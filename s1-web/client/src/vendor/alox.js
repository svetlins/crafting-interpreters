(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal.Opal class (helpers etc.)
  var _Opal;

  // The Kernel module
  var Kernel;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    experimental_features_severity: 'warning',// warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $has_own   = Object.hasOwnProperty;
  var $bind      = Function.prototype.bind;
  var $set_proto = Object.setPrototypeOf;
  var $slice     = Array.prototype.slice;
  var $splice    = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id != null) {
      return obj.$$id;
    }
    $prop(obj, '$$id', Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    var exception = Opal.exceptions.pop();
    if (exception) {
      Opal.gvars["!"] = exception;
      Opal.gvars["@"] = exception.$backtrace();
    }
    else {
      Opal.gvars["!"] = Opal.gvars["@"] = nil;
    }
  };

  function $prop(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.prop = $prop;

  // @deprecated
  Opal.defineProperty = Opal.prop;

  Opal.slice = $slice;


  // Helpers
  // -----

  var $truthy = Opal.truthy = function(val) {
    return false !== val && nil !== val && undefined !== val && null !== val && (!(val instanceof Boolean) || true === val.valueOf());
  };

  Opal.falsy = function(val) {
    return !$truthy(val);
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      return Opal.TypeError.$new(
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      return Opal.TypeError.$new(
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    if (type['$==='](object)) return object;

    if (!object['$respond_to?'](method)) {
      throw Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
      if (!obj['$respond_to_missing?'].$$pristine) {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }

  // TracePoint support
  // ------------------
  //
  // Support for `TracePoint.trace(:class) do ... end`
  Opal.trace_class = false;
  Opal.tracers_for_class = [];

  function invoke_tracers_for_class(klass_or_module) {
    var i, ii, tracer;

    for(i = 0, ii = Opal.tracers_for_class.length; i < ii; i++) {
      tracer = Opal.tracers_for_class[i];
      tracer.trace_object = klass_or_module;
      tracer.block.$call(tracer);
    }
  }

  function handle_autoload(cref, name) {
    if (!cref.$$autoload[name].loaded) {
      cref.$$autoload[name].loaded = true;
      try {
        Opal.Kernel.$require(cref.$$autoload[name].path);
      } catch (e) {
        cref.$$autoload[name].exception = e;
        throw e;
      }
      cref.$$autoload[name].required = true;
      if (cref.$$const[name] != null) {
        cref.$$autoload[name].success = true;
        return cref.$$const[name];
      }
    } else if (cref.$$autoload[name].loaded && !cref.$$autoload[name].required) {
      if (cref.$$autoload[name].exception) { throw cref.$$autoload[name].exception; }
    }
  }

  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) {
      if (cref.$$const[name] != null) { return cref.$$const[name]; }
      if (cref.$$autoload && cref.$$autoload[name]) {
        return handle_autoload(cref, name);
      }
    }
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) {
        return constant;
      } else if (nesting[i].$$autoload && nesting[i].$$autoload[name]) {
        return handle_autoload(nesting[i], name);
      }
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      } else if (ancestors[i].$$autoload && ancestors[i].$$autoload[name]) {
        return handle_autoload(ancestors[i], name);
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (name == null) {
      // A shortpath for calls like ::String => $$$("String")
      result = const_get_name(_Object, cref);

      if (result != null) return result;
      return Opal.const_get_qualified(_Object, cref, skip_missing);
    }

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $prop(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $prop(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  function $const_set(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $prop(cref, name, value);

    return value;
  };

  Opal.const_set = $const_set;

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
      if (module.$$autoload) {
        for (constant in module.$$autoload) {
          constants[constant] = true;
        }
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload && cref.$$autoload[name]) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Generates a function that is a curried const_get_relative.
  Opal.const_get_relative_factory = function(nesting) {
    return function(name, skip_missing) {
      return Opal.$$(nesting, name, skip_missing);
    }
  }

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;
  Opal.$r = Opal.const_get_relative_factory;

  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass   [Class,null] superclass of the new class (may be null)
  // @param singleton    [Boolean,null] a true value denotes we want to allocate
  //                                    a singleton
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function(name, superclass, singleton) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      constructor = function(){};
    }

    if (name && name !== nil) {
      $prop(constructor, 'displayName', '::'+name);
    }

    klass = constructor;

    $prop(klass, '$$name', name);
    $prop(klass, '$$constructor', constructor);
    $prop(klass, '$$prototype', constructor.prototype);
    $prop(klass, '$$const', {});
    $prop(klass, '$$is_class', true);
    $prop(klass, '$$is_a_module', true);
    $prop(klass, '$$super', superclass);
    $prop(klass, '$$cvars', {});
    $prop(klass, '$$own_included_modules', []);
    $prop(klass, '$$own_prepended_modules', []);
    $prop(klass, '$$ancestors', []);
    $prop(klass, '$$ancestors_cache_version', null);
    $prop(klass, '$$subclasses', []);

    $prop(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (singleton !== true) {
        // Let's not forbid GC from cleaning up our
        // subclasses.
        if (typeof WeakRef !== 'undefined') {
          // First, let's clean up our array from empty objects.
          var i, subclass, rebuilt_subclasses = [];
          for (i = 0; i < superclass.$$subclasses.length; i++) {
            subclass = superclass.$$subclasses[i];
            if (subclass.deref() !== undefined) {
              rebuilt_subclasses.push(subclass);
            }
          }
          // Now, let's add our class.
          rebuilt_subclasses.push(new WeakRef(klass));
          superclass.$$subclasses = rebuilt_subclasses;
        }
        else {
          superclass.$$subclasses.push(klass);
        }
      }

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        throw Opal.TypeError.$new("superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }

      if (Opal.trace_class) { invoke_tracers_for_class(klass); }

      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    $const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    if (Opal.trace_class) { invoke_tracers_for_class(klass); }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function(name) {
    var constructor = function(){};
    if (name) {
      $prop(constructor, 'displayName', name+'.$$constructor');
    }

    var module = constructor;

    if (name)
      $prop(constructor, 'displayName', name+'.constructor');

    $prop(module, '$$name', name);
    $prop(module, '$$prototype', constructor.prototype);
    $prop(module, '$$const', {});
    $prop(module, '$$is_module', true);
    $prop(module, '$$is_a_module', true);
    $prop(module, '$$cvars', {});
    $prop(module, '$$iclasses', []);
    $prop(module, '$$own_included_modules', []);
    $prop(module, '$$own_prepended_modules', []);
    $prop(module, '$$ancestors', [module]);
    $prop(module, '$$ancestors_cache_version', null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {

      if (Opal.trace_class) { invoke_tracers_for_class(module); }

      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    $const_set(scope, name, module);

    if (Opal.trace_class) { invoke_tracers_for_class(module); }

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', klass);
    $prop(klass, '$$meta', meta);
    $set_proto(klass, meta.$$prototype);
    // Restoring ClassName.class
    $prop(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', mod);
    $prop(mod, '$$meta', meta);
    $set_proto(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $prop(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = Opal.allocate_class(nil, superclass, true);

    $prop(klass, '$$is_singleton', true);
    $prop(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    $prop(object, '$$meta', klass);

    $set_proto(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(obj.$$meta || obj.$$class);
  };

  Opal.own_methods = function(obj) {
    if (obj.$$meta) {
      return Opal.own_instance_methods(obj.$$meta);
    }
    else {
      return [];
    }
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own.call(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = Opal.ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      throw Opal.NameError.$new('uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $prop(dummy_prepender, '$$dummy', true);
      $prop(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $prop(iclass, prop, proto[prop]);
    }

    $prop(iclass, '$$iclass', true);
    $prop(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $prop(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $prop(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $prop(klass, '$$prototype', native_klass.prototype);

    $prop(klass.$$prototype, '$$class', klass);
    $prop(klass, '$$constructor', native_klass);
    $prop(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs("foo,bar,baz=");
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;
    var stub, existing_method;
    stubs = stubs.split(',');

    for (var i = 0, length = stubs.length; i < length; i++) {
      stub = '$'+stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    // Opal.stub_for(stub) is the method_missing_stub
    $prop(prototype, stub, Opal.stub_for(stub));
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {

    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      delete method_missing_stub.$$p;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = '$' + mid, ancestors, super_method;

    if (obj.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_block_super = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super(obj, call_jsid, current_func, defcheck);
  };

  // @deprecated
  Opal.find_super_dispatcher = Opal.find_super;

  // @deprecated
  Opal.find_iter_super_dispatcher = Opal.find_block_super;

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice.call(parameters, parameters.length - 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  function apply_blockopts(block, blockopts) {
    if (typeof(blockopts) === 'number') {
      block.$$arity = blockopts;
    }
    else if (typeof(blockopts) === 'object') {
      Object.assign(block, blockopts);
    }
  }

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @param blockopts [Object, Number] optional properties to set on the block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block, blockopts) {
    var body;

    apply_blockopts(block, blockopts);

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv['$'+method];
    } else {
      throw Opal.NameError.$new("Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block);
  };

  Opal.send2 = function(recv, body, method, args, block, blockopts) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    apply_blockopts(block, blockopts);

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.refined_send = function(refinement_groups, recv, method, args, block, blockopts) {
    var i, j, k, ancestors, ancestor, refinements, refinement, refine_modules, refine_module, body;

    if (recv.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(recv.$$meta);
    } else {
      ancestors = Opal.ancestors(recv.$$class);
    }

    apply_blockopts(block, blockopts);

    // For all ancestors that there are, starting from the closest to the furthest...
    for (i = 0; i < ancestors.length; i++) {
      ancestor = Opal.id(ancestors[i]);
      // For all refinement groups there are, starting from the closest scope to the furthest...
      for (j = 0; j < refinement_groups.length; j++) {
        refinements = refinement_groups[j];
        // For all refinements there are, starting from the last `using` call to the furthest...
        for (k = refinements.length - 1; k >= 0; k--) {
          refinement = refinements[k];
          if (typeof refinement.$$refine_modules === 'undefined') continue;
          // A single module being given as an argument of the `using` call contains multiple
          // refinement modules
          refine_modules = refinement.$$refine_modules;
          // Does this module refine a given call for a given ancestor module?
          if (typeof refine_modules[ancestor] !== 'undefined') {
            refine_module = refine_modules[ancestor];
            // Does this module define a method we want to call?
            if (typeof refine_module.$$prototype['$'+method] !== 'undefined') {
              body = refine_module.$$prototype['$'+method];
              return Opal.send2(recv, body, method, args, block);
            }
          }
        }
      }
    }

    return Opal.send(recv, method, args, block);
  };

  Opal.lambda = function(block, blockopts) {
    block.$$is_lambda = true;

    apply_blockopts(block, blockopts);

    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @param blockopts [Object, Number] optional properties to set on the body
  // @return [null]
  //
  Opal.def = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      return Opal.defn(Opal.Object, jsid, body);
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      return Opal.defn(obj, jsid, body);
    }
    else {
      return Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var name = jsid.substr(1);

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $prop(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $prop(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(name);
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(name);
    }

    return name;
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    return Opal.defn(Opal.get_singleton_class(obj), jsid, body);
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body,
        alias;

    // Aliasing on main means aliasing on Object...
    if (typeof obj.$$prototype === 'undefined') {
      obj = Opal.Object;
    }

    body = obj.$$prototype['$' + old];

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      delete alias.$$p;

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, 'length', { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName       = name;

    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_gvar = function(new_name, old_name) {
    Object.defineProperty(Opal.gvars, new_name, {
      configurable: true,
      enumerable: true,
      get: function() {
        return Opal.gvars[old_name];
      },
      set: function(new_value) {
        Opal.gvars[old_name] = new_value;
      }
    });
    return nil;
  }

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($has_own.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value, key_tmp;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        key_tmp = keys[i];

        if (key_tmp.$$is_string && typeof key_tmp !== "string") {
          key_tmp = key_tmp.valueOf();
        }

        if (key_tmp === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($has_own.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({uplevel: 1})
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      var retval = module(Opal);
      if (typeof Promise !== 'undefined' && retval instanceof Promise) {
        // A special case of require having an async top:
        // We will need to await it.
        return retval.then(function() { return true; });
      }
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) throw Opal.ArgumentError.$new("unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }

  Opal.last_promise = null;
  Opal.promise_unhandled_exception = false;

  // Run a block of code, but if it returns a Promise, don't run the next
  // one, but queue it.
  Opal.queue = function(proc) {
    if (Opal.last_promise) {
      // The async path is taken only if anything before returned a
      // Promise(V2).
      Opal.last_promise = Opal.last_promise.then(function() {
        if (!Opal.promise_unhandled_exception) return proc(Opal);
      })['catch'](function(error) {
        if (Opal.respond_to(error, '$full_message')) {
          error = error.$full_message();
        }
        console.error(error);
        // Abort further execution
        Opal.promise_unhandled_exception = true;
        Opal.exit(1);
      });
      return Opal.last_promise;
    }
    else {
      var ret = proc(Opal);
      if (typeof Promise === 'function' && typeof ret === 'object' && ret instanceof Promise) {
        Opal.last_promise = ret;
      }
      return ret;
    }
  }

  // Operator helpers
  // ----------------
  Opal.rb_plus   = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l + r : l['$+'](r); }
  Opal.rb_minus  = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l - r : l['$-'](r); }
  Opal.rb_times  = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l * r : l['$*'](r); }
  Opal.rb_divide = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l / r : l['$/'](r); }
  Opal.rb_lt     = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l < r : l['$<'](r); }
  Opal.rb_gt     = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l > r : l['$>'](r); }
  Opal.rb_le     = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l <= r : l['$<='](r); }
  Opal.rb_ge     = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l >= r : l['$>='](r); }

  // Optimized helpers for calls like $truthy((a)['$==='](b)) -> $eqeqeq(a, b)
  Opal.eqeq = function(lhs, rhs) {
    if ((typeof lhs === 'number' && typeof rhs === 'number') ||
        (typeof lhs === 'string' && typeof rhs === 'string')) {
      return lhs === rhs;
    }
    return $truthy((lhs)['$=='](rhs));
  };
  Opal.eqeqeq = function(lhs, rhs) {
    if ((typeof lhs === 'number' && typeof rhs === 'number') ||
        (typeof lhs === 'string' && typeof rhs === 'string')) {
      return lhs === rhs;
    }
    return $truthy((lhs)['$==='](rhs));
  };
  Opal.neqeq = function(lhs, rhs) {
    if ((typeof lhs === 'number' && typeof rhs === 'number') ||
        (typeof lhs === 'string' && typeof rhs === 'string')) {
      return lhs !== rhs;
    }
    return $truthy((lhs)['$!='](rhs));
  };
  Opal.not = function(arg) {
    if (true === arg) return false;
    if (undefined === arg || null === arg || false === arg || nil === arg) return true;
    return $truthy(arg['$!']());
  }



  // Initialization
  // --------------
  Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null);
  Opal.Object      = _Object     = Opal.allocate_class('Object', Opal.BasicObject);
  Opal.Module      = Module      = Opal.allocate_class('Module', Opal.Object);
  Opal.Class       = Class       = Opal.allocate_class('Class', Opal.Module);
  Opal.Opal        = _Opal       = Opal.allocate_module('Opal');
  Opal.Kernel      = Kernel      = Opal.allocate_module('Kernel');

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  $const_set(_Object, "BasicObject",  BasicObject);
  $const_set(_Object, "Object",       _Object);
  $const_set(_Object, "Module",       Module);
  $const_set(_Object, "Class",        Class);
  $const_set(_Object, "Opal",         _Opal);
  $const_set(_Object, "Kernel",       Kernel);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;
  _Opal.$$class       = Module;
  Kernel.$$class      = Module;

  // Forward .toString() to #to_s
  $prop(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $prop(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = function() { return 'main' };
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = Opal.slice.call(arguments);
    var block = top_define_method.$$p;
    delete top_define_method.$$p;
    return Opal.send(_Object, 'define_method', args, block)
  };

  // Nil
  Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object);
  $const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };

  // Errors
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');
  TypeError.$$super = Error;
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
Opal.modules["corelib/helpers"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $Opal = Opal.Opal;

  Opal.add_stubs('===,raise,respond_to?,nil?,__send__,<=>,class,coerce_to!,new,to_s,__id__');
  return (function($base) {
    var self = $module($base, 'Opal');

    
    
    $defs(self, '$bridge', function $$bridge(constructor, klass) {
      
      return Opal.bridge(constructor, klass);
    }, 2);
    $defs(self, '$coerce_to!', function $Opal_coerce_to$excl$1(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3);
      
      args = $post_args;;
      coerced = $coerce_to(object, type, method, args);
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$coerce_to?', function $Opal_coerce_to$ques$2(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3);
      
      args = $post_args;;
      if (!$truthy(object['$respond_to?'](method))) {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil
      };
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$try_convert', function $$try_convert(object, type, method) {
      
      
      if ($eqeqeq(type, object)) {
        return object
      };
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, 3);
    $defs(self, '$compare', function $$compare(a, b) {
      var compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")
      };
      return compare;
    }, 2);
    $defs(self, '$destructure', function $$destructure(args) {
      
      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, 1);
    $defs(self, '$respond_to?', function $Opal_respond_to$ques$3(obj, method, include_all) {
      
      
      
      if (include_all == null) include_all = false;;
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, -3);
    $defs(self, '$instance_variable_name!', function $Opal_instance_variable_name$excl$4(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if (!$truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
        $Kernel.$raise($$$('NameError').$new("'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, 1);
    $defs(self, '$class_variable_name!', function $Opal_class_variable_name$excl$5(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        $Kernel.$raise($$$('NameError').$new("`" + (name) + "' is not allowed as a class variable name", name))
      };
      return name;
    }, 1);
    $defs(self, '$const_name?', function $Opal_const_name$ques$6(const_name) {
      
      
      if (typeof const_name !== 'string') {
        (const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str"))
      }

      return const_name[0] === const_name[0].toUpperCase()
    
    }, 1);
    $defs(self, '$const_name!', function $Opal_const_name$excl$7(const_name) {
      var $a, self = this;

      
      if ($truthy((($a = $$$('::', 'String', 'skip_raise')) ? 'constant' : nil))) {
        const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str")
      };
      
      if (!const_name || const_name[0] != const_name[0].toUpperCase()) {
        self.$raise($$$('NameError'), "wrong constant name " + (const_name))
      }
    ;
      return const_name;
    }, 1);
    $defs(self, '$pristine', function $$pristine(owner_class, $a) {
      var $post_args, method_names;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      method_names = $post_args;;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, -2);
    var inspect_stack = [];
    return $defs(self, '$inspect', function $$inspect(value) {
      var e = nil;

      
      ;
      var pushed = false;
      
      return (function() { try {
      try {
        
        
        if (value === null) {
          // JS null value
          return 'null';
        }
        else if (value === undefined) {
          // JS undefined value
          return 'undefined';
        }
        else if (typeof value.$$class === 'undefined') {
          // JS object / other value that is not bridged
          return Object.prototype.toString.apply(value);
        }
        else if (typeof value.$inspect !== 'function' || value.$inspect.$$stub) {
          // BasicObject and friends
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else if (inspect_stack.indexOf(value.$__id__()) !== -1) {
          // inspect recursing inside inspect to find out about the
          // same object
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else {
          // anything supporting Opal
          inspect_stack.push(value.$__id__());
          pushed = true;
          return value.$inspect();
        }
      ;
        return nil;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {(e = $err)
          try {
            return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, -1);
  })('::')
};

Opal.modules["corelib/module"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $const_set = Opal.const_set, $Object = Opal.Object, $klass = Opal.klass, $defs = Opal.defs, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $Module = Opal.Module, $Kernel = Opal.Kernel, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $to_a = Opal.to_a, $hash2 = Opal.hash2, $Opal = Opal.Opal, $eqeq = Opal.eqeq, $lambda = Opal.lambda, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias;

  Opal.add_stubs('module_eval,to_proc,===,raise,equal?,<,>,nil?,attr_reader,attr_writer,warn,attr_accessor,const_name?,class_variable_name!,const_name!,=~,new,inject,split,const_get,==,start_with?,!~,bind,call,class,append_features,included,name,cover?,size,merge,compile,proc,any?,prepend_features,prepended,to_s,__id__,constants,include?,copy_class_variables,copy_constants,class_exec,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, 0);
    
    $def(self, '$initialize', function $$initialize() {
      var block = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$===', function $Module_$eq_eq_eq$1(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false
      };
      return Opal.is_a(object, self);;
    }, 1);
    
    $def(self, '$<', function $Module_$lt$2(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, 1);
    
    $def(self, '$<=', function $Module_$lt_eq$3(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    }, 1);
    
    $def(self, '$>', function $Module_$gt$4(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, 1);
    
    $def(self, '$>=', function $Module_$gt_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_gt(self, other)
      }
    }, 1);
    
    $def(self, '$<=>', function $Module_$lt_eq_gt$6(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if (!$eqeqeq($Module, other)) {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil
      };
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, 1);
    
    $def(self, '$alias_method', function $$alias_method(newname, oldname) {
      var self = this;

      
      newname = $coerce_to(newname, $$$('String'), 'to_str');
      oldname = $coerce_to(oldname, $$$('String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    }, 2);
    
    $def(self, '$alias_native', function $$alias_native(mid, jsid) {
      var self = this;

      
      
      if (jsid == null) jsid = mid;;
      Opal.alias_native(self, mid, jsid);
      return self;
    }, -2);
    
    $def(self, '$ancestors', function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, 0);
    
    $def(self, '$append_features', function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, 1);
    
    $def(self, '$attr_accessor', function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      $send(self, 'attr_reader', $to_a(names));
      return $send(self, 'attr_writer', $to_a(names));
    }, -1);
    
    $def(self, '$attr', function $$attr($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], {"uplevel": 1}))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', $to_a(args));
    }, -1);
    
    $def(self, '$attr_reader', function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar) {
          return function() {
            if (this[ivar] == null) {
              return nil;
            }
            else {
              return this[ivar];
            }
          };
        })(ivar);

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$attr_writer', function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar){
          return function(value) {
            return this[ivar] = value;
          }
        })(ivar);

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$autoload', function $$autoload(const$, path) {
      var self = this;

      
      if (!$$('Opal')['$const_name?'](const$)) {
        $Kernel.$raise($$$('NameError'), "autoload must be constant name: " + (const$))
      }

      if (path == "") {
        $Kernel.$raise($$$('ArgumentError'), "empty file name")
      }

      if (!self.$$const.hasOwnProperty(const$)) {
        if (!self.$$autoload) {
          self.$$autoload = {};
        }
        Opal.const_cache_version++;
        self.$$autoload[const$] = { path: path, loaded: false, required: false, success: false, exception: false };
      }
      return nil;
    
    }, 2);
    
    $def(self, '$autoload?', function $Module_autoload$ques$7(const$) {
      var self = this;

      
      if (self.$$autoload && self.$$autoload[const$] && !self.$$autoload[const$].required && !self.$$autoload[const$].success) {
        return self.$$autoload[const$].path;
      }

      var ancestors = self.$ancestors();

      for (var i = 0, length = ancestors.length; i < length; i++) {
        if (ancestors[i].$$autoload && ancestors[i].$$autoload[const$] && !ancestors[i].$$autoload[const$].required && !ancestors[i].$$autoload[const$].success) {
          return ancestors[i].$$autoload[const$].path;
        }
      }
      return nil;
    
    }, 1);
    
    $def(self, '$class_variables', function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, 0);
    
    $def(self, '$class_variable_get', function $$class_variable_get(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    }, 1);
    
    $def(self, '$class_variable_set', function $$class_variable_set(name, value) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, 2);
    
    $def(self, '$class_variable_defined?', function $Module_class_variable_defined$ques$8(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, 1);
    
    $def(self, '$remove_class_variable', function $$remove_class_variable(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        $Kernel.$raise($$$('NameError'), "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, 1);
    
    $def(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      
      if (inherit == null) inherit = true;;
      return Opal.constants(self, inherit);;
    }, -1);
    $defs(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat($Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, -1);
    $defs(self, '$nesting', function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, 0);
    
    $def(self, '$const_defined?', function $Module_const_defined$ques$9(name, inherit) {
      var self = this;

      
      
      if (inherit == null) inherit = true;;
      name = $$('Opal')['$const_name!'](name);
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([$Object]).concat(Opal.ancestors($Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) { return true; }
        if (
          module.$$autoload &&
          module.$$autoload[name] &&
          !module.$$autoload[name].required &&
          !module.$$autoload[name].success
        ) {
          return true;
        }
      }

      return false;
    ;
    }, -2);
    
    $def(self, '$const_get', function $$const_get(name, inherit) {
      var self = this;

      
      
      if (inherit == null) inherit = true;;
      name = $$('Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], function $$10(o, c){
          
          
          if (o == null) o = nil;;
          
          if (c == null) c = nil;;
          return o.$const_get(c);}, 2)
      };
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return Opal.$$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, -2);
    
    $def(self, '$const_missing', function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      full_const_name = ($eqeq(self, $Object) ? (name) : ("" + (self) + "::" + (name)));
      return $Kernel.$raise($$$('NameError').$new("uninitialized constant " + (full_const_name), name));
    }, 1);
    
    $def(self, '$const_set', function $$const_set(name, value) {
      var self = this;

      
      name = $Opal['$const_name!'](name);
      if (($truthy(name['$!~']($$$($Opal, 'CONST_NAME_REGEXP'))) || ($truthy(name['$start_with?']("::"))))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      $const_set(self, name, value);
      return value;
    }, 2);
    
    $def(self, '$public_constant', function $$public_constant(const_name) {
      
      return nil
    }, 1);
    
    $def(self, '$define_method', function $$define_method(name, method) {
      var block = $$define_method.$$p || nil, self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      delete $$define_method.$$p;
      
      ;
      ;
      
      if (method === undefined && block === nil)
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
    ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($eqeqeq($$$('Proc'), ($ret_or_2 = method)) ? (method) : ($eqeqeq($$$('Method'), $ret_or_2) ? (method.$to_proc().$$unbound) : ($eqeqeq($$$('UnboundMethod'), $ret_or_2) ? ($lambda(function $$11($a){var $post_args, args, self = $$11.$$s == null ? this : $$11.$$s, bound = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        bound = method.$bind(self);
        return $send(bound, 'call', $to_a(args));}, {$$arity: -1, $$s: self})) : ($Kernel.$raise($$$('TypeError'), "wrong argument type " + (block.$class()) + " (expected Proc/Method)"))))));
      
      var id = '$' + name;

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      return Opal.defn(self, id, block);
    ;
    }, -2);
    
    $def(self, '$remove_method', function $$remove_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$singleton_class?', function $Module_singleton_class$ques$12() {
      var self = this;

      return !!self.$$is_singleton;
    }, 0);
    
    $def(self, '$include', function $$include($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      mods = $post_args;;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$included_modules', function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, 0);
    
    $def(self, '$include?', function $Module_include$ques$13(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$instance_method', function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$$('UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, 1);
    
    $def(self, '$instance_methods', function $$instance_methods(include_super) {
      var self = this;

      
      
      if (include_super == null) include_super = true;;
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$included', function $$included(mod) {
      
      return nil
    }, 1);
    
    $def(self, '$extended', function $$extended(mod) {
      
      return nil
    }, 1);
    
    $def(self, '$extend_object', function $$extend_object(object) {
      
      return nil
    }, 1);
    
    $def(self, '$method_added', function $$method_added($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$method_removed', function $$method_removed($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$method_undefined', function $$method_undefined($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$module_eval', function $$module_eval($a) {
      var block = $$module_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      delete $$module_eval.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$arity: 0, $$s: self});
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "" + ("wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$module_exec', function $$module_exec($a) {
      var block = $$module_exec.$$p || nil, $post_args, args, self = this;

      delete $$module_exec.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      if (block === nil) {
        $Kernel.$raise($$$('LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$method_defined?', function $Module_method_defined$ques$15(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, 1);
    
    $def(self, '$module_function', function $$module_function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = true;
        return nil;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
        return methods.length === 1 ? methods[0] : methods;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$name', function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === $Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, 0);
    
    $def(self, '$prepend', function $$prepend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      mods = $post_args;;
      
      if (mods.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$prepend_features', function $$prepend_features(prepender) {
      var self = this;

      
      
      if (!self.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, 1);
    
    $def(self, '$prepended', function $$prepended(mod) {
      
      return nil
    }, 1);
    
    $def(self, '$remove_const', function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name);
    }, 1);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = Opal.Module.$name.call(self)))) {
        return $ret_or_1
      } else {
        return "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    }, 0);
    
    $def(self, '$undef_method', function $$undef_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this, copy = nil;

      delete $$dup.$$p;
      
      copy = $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, 0);
    
    $def(self, '$copy_class_variables', function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, 1);
    
    $def(self, '$copy_constants', function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        $const_set(self, name, other_constants[name]);
      }
    
    }, 1);
    
    $def(self, '$refine', function $$refine(klass) {
      var block = $$refine.$$p || nil, $a, self = this, refinement_module = nil, m = nil, klass_id = nil;

      delete $$refine.$$p;
      
      ;
      $a = [self, nil, nil], (refinement_module = $a[0]), (m = $a[1]), (klass_id = $a[2]), $a;
      
      klass_id = Opal.id(klass);
      if (typeof self.$$refine_modules === "undefined") {
        self.$$refine_modules = {};
      }
      if (typeof self.$$refine_modules[klass_id] === "undefined") {
        m = self.$$refine_modules[klass_id] = $$$('Refinement').$new();
      }
      else {
        m = self.$$refine_modules[klass_id];
      }
      m.refinement_module = refinement_module
      m.refined_class = klass
    ;
      $send(m, 'class_exec', [], block.$to_proc());
      return m;
    }, 1);
    
    $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("Module#using is not permitted in methods")
    }, 1);
    $alias(self, "class_eval", "module_eval");
    $alias(self, "class_exec", "module_exec");
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Refinement');

    var $proto = self.$$prototype;

    $proto.refinement_module = $proto.refined_class = nil;
    return $def(self, '$inspect', function $$inspect() {
      var $yield = $$inspect.$$p || nil, self = this;

      delete $$inspect.$$p;
      if ($truthy(self.refinement_module)) {
        return "#<refinement:" + (self.refined_class.$inspect()) + "@" + (self.refinement_module.$inspect()) + ">"
      } else {
        return $send2(self, $find_super(self, 'inspect', $$inspect, false, true), 'inspect', [], $yield)
      }
    }, 0)
  })('::', $Module);
};

Opal.modules["corelib/class"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $rb_plus = Opal.rb_plus, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias;

  Opal.add_stubs('require,class_eval,to_proc,+,subclasses,flatten,map,initialize_copy,allocate,name,to_s');
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$new', function $Class_new$1(superclass) {
      var block = $Class_new$1.$$p || nil;

      delete $Class_new$1.$$p;
      
      ;
      
      if (superclass == null) superclass = $$('Object');;
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      ((block !== nil) ? ($send((klass), 'class_eval', [], block.$to_proc())) : nil)
      return klass;
    ;
    }, -1);
    
    $def(self, '$allocate', function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, 0);
    
    $def(self, '$descendants', function $$descendants() {
      var self = this;

      return $rb_plus(self.$subclasses(), $send(self.$subclasses(), 'map', [], "descendants".$to_proc()).$flatten())
    }, 0);
    
    $def(self, '$inherited', function $$inherited(cls) {
      
      return nil
    }, 1);
    
    $def(self, '$initialize_dup', function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, 1);
    
    $def(self, '$new', function $Class_new$2($a) {
      var block = $Class_new$2.$$p || nil, $post_args, args, self = this;

      delete $Class_new$2.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, -1);
    
    $def(self, '$subclasses', function $$subclasses() {
      var self = this;

      
      if (typeof WeakRef !== 'undefined') {
        var i, subclass, out = [];
        for (i = 0; i < self.$$subclasses.length; i++) {
          subclass = self.$$subclasses[i].deref();
          if (subclass !== undefined) {
            out.push(subclass);
          }
        }
        return out;
      }
      else {
        return self.$$subclasses;
      }
    
    }, 0);
    
    $def(self, '$superclass', function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var $yield = $$to_s.$$p || nil, self = this;

      delete $$to_s.$$p;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, $find_super(self, 'to_s', $$to_s, false, true), 'to_s', [], null);
    
    }, 0);
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
};

Opal.modules["corelib/basic_object"] = function(Opal) {/* Generated by Opal 1.4.1 */
  "use strict";
  var nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def, $alias = Opal.alias, $truthy = Opal.truthy, $range = Opal.range, $Kernel = Opal.Kernel, $to_a = Opal.to_a, $hash2 = Opal.hash2, $Opal = Opal.Opal, $send = Opal.send, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge;

  Opal.add_stubs('==,raise,inspect,!,nil?,cover?,size,merge,compile,proc,[],first,>=,length,instance_variable_get,any?,new,caller,pristine');
  return (function($base, $super) {
    var self = $klass($base, $super, 'BasicObject');

    
    
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$==', function $BasicObject_$eq_eq$1(other) {
      var self = this;

      return self === other;
    }, 1);
    
    $def(self, '$eql?', function $BasicObject_eql$ques$2(other) {
      var self = this;

      return self['$=='](other)
    }, 1);
    $alias(self, "equal?", "==");
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.prop(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, 0);
    
    $def(self, '$__send__', function $$__send__(symbol, $a) {
      var block = $$__send__.$$p || nil, $post_args, args, self = this;

      delete $$__send__.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      
      if (!symbol.$$is_string) {
        self.$raise($$$('TypeError'), "" + (self.$inspect()) + " is not a symbol nor a string")
      }

      var func = self['$' + symbol];

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, -2);
    
    $def(self, '$!', function $BasicObject_$excl$3() {
      
      return false
    }, 0);
    
    $def(self, '$!=', function $BasicObject_$not_eq$4(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, 1);
    
    $def(self, '$instance_eval', function $$instance_eval($a) {
      var block = $$instance_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      delete $$instance_eval.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$arity: 0, $$s: self});
      } else if ((($truthy(block['$nil?']()) && ($truthy($rb_ge(args.$length(), 1)))) && ($eqeq(args.$first()['$[]'](0), "@")))) {
        return self.$instance_variable_get(args.$first())
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$size()) + " for 0)")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$instance_exec', function $$instance_exec($a) {
      var block = $$instance_exec.$$p || nil, $post_args, args, self = this;

      delete $$instance_exec.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$singleton_method_added', function $$singleton_method_added($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_removed', function $$singleton_method_removed($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_undefined', function $$singleton_method_undefined($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(symbol, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this, inspect_result = nil;

      delete $$method_missing.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      inspect_result = $Opal.$inspect(self);
      return $Kernel.$raise($$$('NoMethodError').$new("undefined method `" + (symbol) + "' for " + (inspect_result), symbol, args), nil, $Kernel.$caller(1));
    }, -2);
    $Opal.$pristine(self, "method_missing");
    return $def(self, '$respond_to_missing?', function $BasicObject_respond_to_missing$ques$6(method_name, include_all) {
      
      
      
      if (include_all == null) include_all = false;;
      return false;
    }, -2);
  })('::', null)
};

Opal.modules["corelib/kernel"] = function(Opal) {/* Generated by Opal 1.4.1 */
  "use strict";
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $Opal = Opal.Opal, $module = Opal.module, $def = Opal.def, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $Object = Opal.Object, $alias = Opal.alias, $klass = Opal.klass;

  Opal.add_stubs('!,=~,==,object_id,raise,new,class,coerce_to?,<<,allocate,copy_instance_variables,copy_singleton_methods,initialize_clone,initialize_copy,define_method,singleton_class,to_proc,initialize_dup,for,empty?,pop,call,append_features,extend_object,extended,gets,__id__,include?,each,instance_variables,instance_variable_get,inspect,+,to_s,instance_variable_name!,respond_to?,to_int,coerce_to!,Integer,nil?,===,enum_for,result,any?,print,format,puts,<=,length,[],readline,<,first,split,caller,map,to_str,exception,backtrace,rand,respond_to_missing?,pristine,try_convert!,expand_path,join,start_with?,new_seed,srand,tag,value,open,include');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$=~', function $Kernel_$eq_tilde$1(obj) {
      
      return false
    }, 1);
    
    $def(self, '$!~', function $Kernel_$excl_tilde$2(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, 1);
    
    $def(self, '$===', function $Kernel_$eq_eq_eq$3(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    }, 1);
    
    $def(self, '$<=>', function $Kernel_$lt_eq_gt$4(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, 1);
    
    $def(self, '$method', function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$$('Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, 1);
    
    $def(self, '$methods', function $$methods(all) {
      var self = this;

      
      
      if (all == null) all = true;;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$public_methods', function $$public_methods(all) {
      var self = this;

      
      
      if (all == null) all = true;;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$Array', function $$Array(object) {
      
      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, 1);
    
    $def(self, '$at_exit', function $$at_exit() {
      var block = $$at_exit.$$p || nil, $ret_or_1 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      delete $$at_exit.$$p;
      
      ;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      $gvars.__at_exit__['$<<'](block);
      return block;
    }, 0);
    
    $def(self, '$caller', function $$caller(start, length) {
      
      
      
      if (start == null) start = 1;;
      
      if (length == null) length = nil;;
      
      var stack, result;

      stack = new Error().$backtrace();
      result = [];

      for (var i = start + 1, ii = stack.length; i < ii; i++) {
        if (!stack[i].match(/runtime\.js/)) {
          result.push(stack[i]);
        }
      }
      if (length != nil) result = result.slice(0, length);
      return result;
    ;
    }, -1);
    
    $def(self, '$class', function $Kernel_class$5() {
      var self = this;

      return self.$$class;
    }, 0);
    
    $def(self, '$copy_instance_variables', function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, 1);
    
    $def(self, '$copy_singleton_methods', function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, 1);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) freeze = true;
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, -1);
    
    $def(self, '$initialize_clone', function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, 1);
    
    $def(self, '$define_singleton_method', function $$define_singleton_method(name, method) {
      var block = $$define_singleton_method.$$p || nil, self = this;

      delete $$define_singleton_method.$$p;
      
      ;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$initialize_dup', function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, 1);
    
    $def(self, '$enum_for', function $$enum_for($a, $b) {
      var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

      delete $$enum_for.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      if ($post_args.length > 0) method = $post_args.shift();
      if (method == null) method = "each";;
      
      args = $post_args;;
      return $send($$$('Enumerator'), 'for', [self, method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$equal?', function $Kernel_equal$ques$6(other) {
      var self = this;

      return self === other;
    }, 1);
    
    $def(self, '$exit', function $$exit(status) {
      var $a, $ret_or_1 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      
      if (status == null) status = true;;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$$('Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, -1);
    
    $def(self, '$extend', function $$extend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      mods = $post_args;;
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$gets', function $$gets($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send($gvars.stdin, 'gets', $to_a(args));
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.$__id__()
    }, 0);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      
      return nil
    }, 1);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, ivs = nil, id = nil, pushed = nil, e = nil;

      return (function() { try {
      try {
        
        ivs = "";
        id = self.$__id__();
        if ($truthy((inspect_stack)['$include?'](id))) {
          ivs = " ..."
        } else {
          
          (inspect_stack)['$<<'](id);
          pushed = true;
          $send(self.$instance_variables(), 'each', [], function $$7(i){var self = $$7.$$s == null ? this : $$7.$$s, ivar = nil, inspect = nil;

            
            
            if (i == null) i = nil;;
            ivar = self.$instance_variable_get(i);
            inspect = $$('Opal').$inspect(ivar);
            return (ivs = $rb_plus(ivs, " " + (i) + "=" + (inspect)));}, {$$arity: 1, $$s: self});
        };
        return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + (ivs) + ">";
      } catch ($err) {
        if (Opal.rescue($err, [$$('StandardError')])) {(e = $err)
          try {
            return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        ($truthy(pushed) ? ((inspect_stack).$pop()) : nil)
      }; })()
    }, 0);
    
    $def(self, '$instance_of?', function $Kernel_instance_of$ques$8(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, 1);
    
    $def(self, '$instance_variable_defined?', function $Kernel_instance_variable_defined$ques$9(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, 1);
    
    $def(self, '$instance_variable_get', function $$instance_variable_get(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, 1);
    
    $def(self, '$instance_variable_set', function $$instance_variable_set(name, value) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, 2);
    
    $def(self, '$remove_instance_variable', function $$remove_instance_variable(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return $Kernel.$raise($$$('NameError'), "instance variable " + (name) + " not defined");
    }, 1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$Integer', function $$Integer(value, base) {
      
      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          $Kernel.$raise($$$('ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          $Kernel.$raise($$$('TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            $Kernel.$raise($$$('FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $Opal['$coerce_to!'](value, $$$('Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$$('Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
          // no-break
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
          // no-break
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
          // no-break
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
          // no-break
        }
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, -2);
    
    $def(self, '$Float', function $$Float(value) {
      
      
      var str;

      if (value === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return $Kernel.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $Opal['$coerce_to!'](value, $$$('Float'), "to_f");
    
    }, 1);
    
    $def(self, '$Hash', function $$Hash(arg) {
      
      
      if (($truthy(arg['$nil?']()) || ($eqeq(arg, [])))) {
        return $hash2([], {})
      };
      if ($eqeqeq($$$('Hash'), arg)) {
        return arg
      };
      return $Opal['$coerce_to!'](arg, $$$('Hash'), "to_hash");
    }, 1);
    
    $def(self, '$is_a?', function $Kernel_is_a$ques$10(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, 1);
    
    $def(self, '$itself', function $$itself() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$lambda', function $$lambda() {
      var block = $$lambda.$$p || nil;

      delete $$lambda.$$p;
      
      ;
      return Opal.lambda(block);;
    }, 0);
    
    $def(self, '$load', function $$load(file) {
      
      
      file = $Opal['$coerce_to!'](file, $$$('String'), "to_str");
      return Opal.load(file);
    }, 1);
    
    $def(self, '$loop', function $$loop() {
      var $a, $yield = $$loop.$$p || nil, self = this, e = nil;

      delete $$loop.$$p;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["loop"], function $$11(){
          return $$$($$$('Float'), 'INFINITY')}, 0)
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$$('StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };
      };
      return self;
    }, 0);
    
    $def(self, '$nil?', function $Kernel_nil$ques$12() {
      
      return false
    }, 0);
    
    $def(self, '$printf', function $$printf($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', $to_a(args)))
      };
      return nil;
    }, -1);
    
    $def(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil;

      delete $$proc.$$p;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, 0);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'puts', $to_a(strs));
    }, -1);
    
    $def(self, '$p', function $$p($a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      $send(args, 'each', [], function $$13(obj){        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        
        if (obj == null) obj = nil;;
        return $gvars.stdout.$puts(obj.$inspect());}, 1);
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, -1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'print', $to_a(strs));
    }, -1);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send($gvars.stdin, 'readline', $to_a(args));
    }, -1);
    
    $def(self, '$warn', function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $c, $d, self = this, location = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      strs = $post_args;;
      
      uplevel = $kwargs.$$smap["uplevel"];
      if (uplevel == null) uplevel = nil;
      if ($truthy(uplevel)) {
        
        uplevel = $Opal['$coerce_to!'](uplevel, $$$('Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "negative level (" + (uplevel) + ")")
        };
        location = ($d = ($c = self.$caller($rb_plus(uplevel, 1), 1).$first(), ($c === nil || $c == null) ? nil : $send($c, 'split', [":in `"])), ($d === nil || $d == null) ? nil : $send($d, 'first', []));
        if ($truthy(location)) {
          location = "" + (location) + ": "
        };
        strs = $send(strs, 'map', [], function $$14(s){
          
          
          if (s == null) s = nil;;
          return "" + (location) + "warning: " + (s);}, 1);
      };
      if (($truthy($gvars.VERBOSE['$nil?']()) || ($truthy(strs['$empty?']())))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', $to_a(strs))
      };
    }, -1);
    
    $def(self, '$raise', function $$raise(exception, string, backtrace) {
            if ($gvars["!"] == null) $gvars["!"] = nil;
      if ($gvars["@"] == null) $gvars["@"] = nil;

      
      ;
      
      if (string == null) string = nil;;
      
      if (backtrace == null) backtrace = nil;;
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$$('RuntimeError').$new("");
      }
      else if ($respond_to(exception, '$to_str')) {
        exception = $$$('RuntimeError').$new(exception.$to_str());
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && $respond_to(exception, '$exception')) {
        exception = exception.$exception(string);
      }
      else if (exception.$$is_exception) {
        // exception is fine
      }
      else {
        exception = $$$('TypeError').$new("exception class/object expected");
      }

      if (backtrace !== nil) {
        exception.$set_backtrace(backtrace);
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;
      $gvars["@"] = (exception).$backtrace();

      throw exception;
    ;
    }, -1);
    
    $def(self, '$rand', function $$rand(max) {
      
      
      ;
      
      if (max === undefined) {
        return $$$($$$('Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$$('Random'), 'DEFAULT').$rand(max);
    }, -1);
    
    $def(self, '$respond_to?', function $Kernel_respond_to$ques$15(name, include_all) {
      var self = this;

      
      
      if (include_all == null) include_all = false;;
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Kernel_respond_to_missing$ques$16(method_name, include_all) {
      
      
      
      if (include_all == null) include_all = false;;
      return false;
    }, -2);
    $Opal.$pristine(self, "respond_to?", "respond_to_missing?");
    
    $def(self, '$require', function $$require(file) {
      
      
      // As Object.require refers to Kernel.require once Kernel has been loaded the String
      // class may not be available yet, the coercion requires both  String and Array to be loaded.
      if (typeof file !== 'string' && Opal.String && Opal.Array) {
        (file = $Opal['$coerce_to!'](file, $$$('String'), "to_str"))
      }
      return Opal.require(file)
    
    }, 1);
    
    $def(self, '$require_relative', function $$require_relative(file) {
      
      
      $Opal['$try_convert!'](file, $$$('String'), "to_str");
      file = $$$('File').$expand_path($$$('File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, 1);
    
    $def(self, '$require_tree', function $$require_tree(path, $kwargs) {
      var autoload;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      autoload = $kwargs.$$smap["autoload"];
      if (autoload == null) autoload = false;
      
      var result = [];

      path = $$$('File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          if(!autoload) {
            result.push([name, Opal.require(name)]);
          } else {
            result.push([name, true]); // do nothing, delegated to a autoloading
          }
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, 0);
    
    $def(self, '$sleep', function $$sleep(seconds) {
      
      
      
      if (seconds == null) seconds = nil;;
      
      if (seconds === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        $Kernel.$raise($$$('ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, -1);
    
    $def(self, '$srand', function $$srand(seed) {
      
      
      
      if (seed == null) seed = $$('Random').$new_seed();;
      return $$$('Random').$srand(seed);
    }, -1);
    
    $def(self, '$String', function $$String(str) {
      var $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $Opal['$coerce_to?'](str, $$$('String'), "to_str")))) {
        return $ret_or_1
      } else {
        return $Opal['$coerce_to!'](str, $$$('String'), "to_s")
      }
    }, 1);
    
    $def(self, '$tap', function $$tap() {
      var block = $$tap.$$p || nil, self = this;

      delete $$tap.$$p;
      
      ;
      Opal.yield1(block, self);
      return self;
    }, 0);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, 0);
    
    $def(self, '$catch', function $Kernel_catch$17(tag) {
      var $yield = $Kernel_catch$17.$$p || nil, $ret_or_1 = nil, e = nil;

      delete $Kernel_catch$17.$$p;
      
      
      if (tag == null) tag = nil;;
      try {
        
        tag = ($truthy(($ret_or_1 = tag)) ? ($ret_or_1) : ($Object.$new()));
        return Opal.yield1($yield, tag);;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('UncaughtThrowError')])) {(e = $err)
          try {
            
            if ($eqeq(e.$tag(), tag)) {
              return e.$value()
            };
            return $Kernel.$raise();
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };
    }, -1);
    
    $def(self, '$throw', function $Kernel_throw$18(tag, obj) {
      
      
      
      if (obj == null) obj = nil;;
      return $Kernel.$raise($$$('UncaughtThrowError').$new(tag, obj));
    }, -2);
    
    $def(self, '$open', function $$open($a) {
      var block = $$open.$$p || nil, $post_args, args;

      delete $$open.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send($$$('File'), 'open', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$yield_self', function $$yield_self() {
      var $yield = $$yield_self.$$p || nil, self = this;

      delete $$yield_self.$$p;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["yield_self"], function $$19(){
          return 1}, 0)
      };
      return Opal.yield1($yield, self);;
    }, 0);
    $alias(self, "fail", "raise");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "object_id", "__id__");
    $alias(self, "public_send", "__send__");
    $alias(self, "send", "__send__");
    $alias(self, "then", "yield_self");
    return $alias(self, "to_enum", "enum_for");
  })('::', $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    
    delete $Object.$$prototype.$require;
    return self.$include($Kernel);
  })('::', null);
};

Opal.modules["corelib/main"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $def = Opal.def, $Object = Opal.Object, $Kernel = Opal.Kernel;

  Opal.add_stubs('include,raise');
  return (function(self, $parent_nesting) {
    
    
    
    $def(self, '$to_s', function $$to_s() {
      
      return "main"
    }, 0);
    
    $def(self, '$include', function $$include(mod) {
      
      return $Object.$include(mod)
    }, 1);
    
    $def(self, '$autoload', function $$autoload($a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return Opal.Object.$autoload.apply(Opal.Object, args);;
    }, -1);
    return $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("main.using is permitted only at toplevel")
    }, 1);
  })(Opal.get_singleton_class(self), $nesting)
};

Opal.modules["corelib/error/errno"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $klass = Opal.klass;

  Opal.add_stubs('+,errno,class,attr_reader');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting), errors = nil, klass = nil;

    
    errors = [["EINVAL", "Invalid argument", 22], ["EEXIST", "File exists", 17], ["EISDIR", "Is a directory", 21], ["EMFILE", "Too many open files", 24], ["EACCES", "Permission denied", 13], ["EPERM", "Operation not permitted", 1], ["ENOENT", "No such file or directory", 2]];
    klass = nil;
    
    var i;
    for (i = 0; i < errors.length; i++) {
      (function() { // Create a closure
        var class_name = errors[i][0];
        var default_message = errors[i][1];
        var errno = errors[i][2];

        klass = Opal.klass(self, Opal.SystemCallError, class_name);
        klass.errno = errno;

        (function(self, $parent_nesting) {
      
      return $def(self, '$new', function $new$1(name) {
        var $yield = $new$1.$$p || nil, self = this, message = nil;

        delete $new$1.$$p;
        
        
        if (name == null) name = nil;;
        message = default_message;
        if ($truthy(name)) {
          message = $rb_plus(message, " - " + (name))
        };
        return $send2(self, $find_super(self, 'new', $new$1, false, true), 'new', [message], null);
      }, -1)
    })(Opal.get_singleton_class(klass), $nesting)
      })();
    }
  ;
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    
    
    $def(self, '$errno', function $$errno() {
      var self = this;

      return self.$class().$errno()
    }, 0);
    return (function(self, $parent_nesting) {
      
      return self.$attr_reader("errno")
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('StandardError'), $nesting);
};

Opal.modules["corelib/error"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $Kernel = Opal.Kernel, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $Object = Opal.Object, $send2 = Opal.send2, $find_super = Opal.find_super, $module = Opal.module;

  Opal.add_stubs('new,map,backtrace,clone,to_s,merge,tty?,[],include?,raise,dup,empty?,!,caller,shift,+,class,join,cause,full_message,==,reverse,split,autoload,attr_reader,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.message = nil;
    
    Opal.prop(self.$$prototype, '$$is_exception', true);
    var stack_trace_limit;
    $defs(self, '$new', function $Exception_new$1($a) {
      var $post_args, args, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      error.cause   = $gvars["!"];
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, -1);
    stack_trace_limit = self.$new;
    $defs(self, '$exception', function $$exception($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, -1);
    
    // Convert backtrace from any format to Ruby format
    function correct_backtrace(backtrace) {
      var new_bt = [], m;

      for (var i = 0; i < backtrace.length; i++) {
        var loc = backtrace[i];
        if (!loc || !loc.$$is_string) {
          /* Do nothing */
        }
        /* Chromium format */
        else if ((m = loc.match(/^    at (.*?) \((.*?)\)$/))) {
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        }
        else if ((m = loc.match(/^    at (.*?)$/))) {
          new_bt.push(m[1] + ":in `undefined'");
        }
        /* Node format */
        else if ((m = loc.match(/^  from (.*?)$/))) {
          new_bt.push(m[1]);
        }
        /* Mozilla/Apple format */
        else if ((m = loc.match(/^(.*?)@(.*?)$/))) {
          new_bt.push(m[2] + ':in `' + m[1] + "'");
        }
      }

      return new_bt;
    }
  ;
    
    $def(self, '$backtrace', function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) !== 'undefined' && backtrace.$$is_string) {
        return self.backtrace = correct_backtrace(backtrace.split("\n").slice(0, 15));
      }
      else if (backtrace) {
        return self.backtrace = correct_backtrace(backtrace.slice(0, 15));
      }

      return [];
    
    }, 0);
    
    $def(self, '$backtrace_locations', function $$backtrace_locations() {
      var $a, self = this;

      
      if (self.backtrace_locations) return self.backtrace_locations;
      self.backtrace_locations = ($a = self.$backtrace(), ($a === nil || $a == null) ? nil : $send($a, 'map', [], function $$2(loc){
        
        
        if (loc == null) loc = nil;;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);}, 1))
      return self.backtrace_locations;
    
    }, 0);
    
    $def(self, '$cause', function $$cause() {
      var self = this;

      return self.cause || nil;
    }, 0);
    
    $def(self, '$exception', function $$exception(str) {
      var self = this;

      
      
      if (str == null) str = nil;;
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      if (self.backtrace) cloned.backtrace = self.backtrace.$dup();
      cloned.stack = self.stack;
      cloned.cause = self.cause;
      return cloned;
    ;
    }, -1);
    
    $def(self, '$message', function $$message() {
      var self = this;

      return self.$to_s()
    }, 0);
    
    $def(self, '$full_message', function $$full_message(kwargs) {
      var $a, $b, self = this, $ret_or_1 = nil, highlight = nil, order = nil, bold_underline = nil, bold = nil, reset = nil, bt = nil, first = nil, msg = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      if (kwargs == null) kwargs = nil;;
      if (!$truthy((($a = $$('Hash', 'skip_raise')) ? 'constant' : nil))) {
        return "" + (self.message) + "\n" + (self.stack)
      };
      kwargs = $hash2(["highlight", "order"], {"highlight": $gvars.stderr['$tty?'](), "order": "top"}).$merge(($truthy(($ret_or_1 = kwargs)) ? ($ret_or_1) : ($hash2([], {}))));
      $b = [kwargs['$[]']("highlight"), kwargs['$[]']("order")], (highlight = $b[0]), (order = $b[1]), $b;
      if (!$truthy([true, false]['$include?'](highlight))) {
        $Kernel.$raise($$$('ArgumentError'), "expected true or false as highlight: " + (highlight))
      };
      if (!$truthy(["top", "bottom"]['$include?'](order))) {
        $Kernel.$raise($$$('ArgumentError'), "expected :top or :bottom as order: " + (order))
      };
      if ($truthy(highlight)) {
        
        bold_underline = "\u001b[1;4m";
        bold = "\u001b[1m";
        reset = "\u001b[m";
      } else {
        bold_underline = (bold = (reset = ""))
      };
      bt = self.$backtrace().$dup();
      if (($not(bt) || ($truthy(bt['$empty?']())))) {
        bt = self.$caller()
      };
      first = bt.$shift();
      msg = "" + (first) + ": ";
      msg = $rb_plus(msg, "" + (bold) + (self.$to_s()) + " (" + (bold_underline) + (self.$class()) + (reset) + (bold) + ")" + (reset) + "\n");
      msg = $rb_plus(msg, $send(bt, 'map', [], function $$3(loc){
        
        
        if (loc == null) loc = nil;;
        return "\tfrom " + (loc) + "\n";}, 1).$join());
      if ($truthy(self.$cause())) {
        msg = $rb_plus(msg, self.$cause().$full_message($hash2(["highlight"], {"highlight": highlight})))
      };
      if ($eqeq(order, "bottom")) {
        
        msg = msg.$split("\n").$reverse().$join("\n");
        msg = $rb_plus("" + (bold) + "Traceback" + (reset) + " (most recent call last):\n", msg);
      };
      return msg;
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, 0);
    
    $def(self, '$set_backtrace', function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = '  from ' + backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          $Kernel.$raise($$$('TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = $send((backtrace), 'map', [], function $$4(i){
        
        
        if (i == null) i = nil;;
        return $rb_plus("  from ", i);}, 1).join("\n");
      }

      return backtrace;
    
    }, 1);
    return $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.message)) ? (self.message.$to_s()) : ($ret_or_2))))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    }, 0);
  })('::', Error, $nesting);
  $klass('::', $$$('Exception'), 'ScriptError');
  $klass('::', $$$('ScriptError'), 'SyntaxError');
  $klass('::', $$$('ScriptError'), 'LoadError');
  $klass('::', $$$('ScriptError'), 'NotImplementedError');
  $klass('::', $$$('Exception'), 'SystemExit');
  $klass('::', $$$('Exception'), 'NoMemoryError');
  $klass('::', $$$('Exception'), 'SignalException');
  $klass('::', $$$('SignalException'), 'Interrupt');
  $klass('::', $$$('Exception'), 'SecurityError');
  $klass('::', $$$('Exception'), 'SystemStackError');
  $klass('::', $$$('Exception'), 'StandardError');
  $klass('::', $$$('StandardError'), 'EncodingError');
  $klass('::', $$$('StandardError'), 'ZeroDivisionError');
  $klass('::', $$$('StandardError'), 'NameError');
  $klass('::', $$$('NameError'), 'NoMethodError');
  $klass('::', $$$('StandardError'), 'RuntimeError');
  $klass('::', $$$('RuntimeError'), 'FrozenError');
  $klass('::', $$$('StandardError'), 'LocalJumpError');
  $klass('::', $$$('StandardError'), 'TypeError');
  $klass('::', $$$('StandardError'), 'ArgumentError');
  $klass('::', $$$('ArgumentError'), 'UncaughtThrowError');
  $klass('::', $$$('StandardError'), 'IndexError');
  $klass('::', $$$('IndexError'), 'StopIteration');
  $klass('::', $$$('StopIteration'), 'ClosedQueueError');
  $klass('::', $$$('IndexError'), 'KeyError');
  $klass('::', $$$('StandardError'), 'RangeError');
  $klass('::', $$$('RangeError'), 'FloatDomainError');
  $klass('::', $$$('StandardError'), 'IOError');
  $klass('::', $$$('IOError'), 'EOFError');
  $klass('::', $$$('StandardError'), 'SystemCallError');
  $klass('::', $$$('StandardError'), 'RegexpError');
  $klass('::', $$$('StandardError'), 'ThreadError');
  $klass('::', $$$('StandardError'), 'FiberError');
  $Object.$autoload("Errno", "corelib/error/errno");
  (function($base, $super) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $proto = self.$$prototype;

    $proto.tag = nil;
    
    self.$attr_reader("tag", "value");
    return $def(self, '$initialize', function $$initialize(tag, value) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (value == null) value = nil;;
      self.tag = tag;
      self.value = value;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', ["uncaught throw " + (self.tag.$inspect())], null);
    }, -2);
  })('::', $$$('ArgumentError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'NameError');

    
    
    self.$attr_reader("name");
    return $def(self, '$initialize', function $$initialize(message, name) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (name == null) name = nil;;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NoMethodError');

    
    
    self.$attr_reader("args");
    return $def(self, '$initialize', function $$initialize(message, name, args) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (name == null) name = nil;;
      
      if (args == null) args = [];;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'StopIteration');

    
    return self.$attr_reader("result")
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'KeyError');

    var $proto = self.$$prototype;

    $proto.receiver = $proto.key = nil;
    
    
    $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, key, $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      receiver = $kwargs.$$smap["receiver"];
      if (receiver == null) receiver = nil;
      
      key = $kwargs.$$smap["key"];
      if (key == null) key = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, -2);
    
    $def(self, '$receiver', function $$receiver() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.receiver))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no receiver is available")
      }
    }, 0);
    return $def(self, '$key', function $$key() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.key))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no key is available")
      }
    }, 0);
  })('::', null);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    return ($klass($nesting[0], null, 'Error'), nil)
  })('::', $nesting);
};

Opal.modules["corelib/constants"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $const_set = Opal.const_set;

  
  $const_set('::', 'RUBY_PLATFORM', "opal");
  $const_set('::', 'RUBY_ENGINE', "opal");
  $const_set('::', 'RUBY_VERSION', "3.1.0");
  $const_set('::', 'RUBY_ENGINE_VERSION', "1.4.1");
  $const_set('::', 'RUBY_RELEASE_DATE', "2022-01-12");
  $const_set('::', 'RUBY_PATCHLEVEL', 0);
  $const_set('::', 'RUBY_REVISION', "0");
  $const_set('::', 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2021 Adam Beynon and the Opal contributors");
  return $const_set('::', 'RUBY_DESCRIPTION', "opal " + ($$$('RUBY_ENGINE_VERSION')) + " (" + ($$$('RUBY_RELEASE_DATE')) + " revision " + ($$$('RUBY_REVISION')) + ")");
};

Opal.modules["opal/base"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $Object = Opal.Object;

  Opal.add_stubs('require');
  
  $Object.$require("corelib/runtime");
  $Object.$require("corelib/helpers");
  $Object.$require("corelib/module");
  $Object.$require("corelib/class");
  $Object.$require("corelib/basic_object");
  $Object.$require("corelib/kernel");
  $Object.$require("corelib/main");
  $Object.$require("corelib/error");
  return $Object.$require("corelib/constants");
};

Opal.modules["corelib/nil"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $hash2 = Opal.hash2, $NilClass = Opal.NilClass, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $alias = Opal.alias;

  Opal.add_stubs('raise,name,new,>,length,Rational');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$!', function $NilClass_$excl$1() {
      
      return true
    }, 0);
    
    $def(self, '$&', function $NilClass_$$2(other) {
      
      return false
    }, 1);
    
    $def(self, '$|', function $NilClass_$$3(other) {
      
      return other !== false && other !== nil;
    }, 1);
    
    $def(self, '$^', function $NilClass_$$4(other) {
      
      return other !== false && other !== nil;
    }, 1);
    
    $def(self, '$==', function $NilClass_$eq_eq$5(other) {
      
      return other === nil;
    }, 1);
    
    $def(self, '$dup', function $$dup() {
      
      return nil
    }, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) freeze = true;
      return nil;
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      
      return "nil"
    }, 0);
    
    $def(self, '$nil?', function $NilClass_nil$ques$6() {
      
      return true
    }, 0);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      
      return $NilClass
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      
      return []
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      
      return Opal.hash();
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      
      return 0
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      
      return ""
    }, 0);
    
    $def(self, '$to_c', function $$to_c() {
      
      return $$$('Complex').$new(0, 0)
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize($a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 1))) {
        $Kernel.$raise($$$('ArgumentError'))
      };
      return $Kernel.$Rational(0, 1);
    }, -1);
    
    $def(self, '$to_r', function $$to_r() {
      
      return $Kernel.$Rational(0, 1)
    }, 0);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    }, 0);
    return $alias(self, "to_f", "to_i");
  })('::', null, $nesting)
};

Opal.modules["corelib/boolean"] = function(Opal) {/* Generated by Opal 1.4.1 */
  "use strict";
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $alias = Opal.alias;

  Opal.add_stubs('raise,name');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.prop(self.$$prototype, '$$is_boolean', true);
    
    var properties = ['$$class', '$$meta'];

    for (var i = 0; i < properties.length; i++) {
      Object.defineProperty(self.$$prototype, properties[i], {
        configurable: true,
        enumerable: false,
        get: function() {
          return this == true  ? Opal.TrueClass :
                 this == false ? Opal.FalseClass :
                                 Opal.Boolean;
        }
      });
    }

    Object.defineProperty(self.$$prototype, "$$id", {
      configurable: true,
      enumerable: false,
      get: function() {
        return this == true  ? 2 :
               this == false ? 0 :
                               nil;
      }
    });
  ;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, 0);
    
    $def(self, '$!', function $Boolean_$excl$1() {
      var self = this;

      return self != true;
    }, 0);
    
    $def(self, '$&', function $Boolean_$$2(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, 1);
    
    $def(self, '$|', function $Boolean_$$3(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, 1);
    
    $def(self, '$^', function $Boolean_$$4(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, 1);
    
    $def(self, '$==', function $Boolean_$eq_eq$5(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, 1);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return self.$$meta;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(method, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this;

      delete $$method_missing.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      var body = self.$$class.$$prototype['$' + method];
      if (!$truthy(typeof body !== 'undefined' && !body.$$stub)) {
        $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [method].concat($to_a(args)), block)
      };
      return Opal.send(self, body, args, block);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Boolean_respond_to_missing$ques$6(method, _include_all) {
      var self = this;

      
      
      if (_include_all == null) _include_all = false;;
      var body = self.$$class.$$prototype['$' + method];
      return typeof body !== 'undefined' && !body.$$stub;;
    }, -2);
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "==");
    $alias(self, "inspect", "to_s");
    return $alias(self, "object_id", "__id__");
  })('::', Boolean, $nesting);
  $klass('::', $$$('Boolean'), 'TrueClass');
  return ($klass('::', $$$('Boolean'), 'FalseClass'), nil);
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $def = Opal.def;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    }, 1);
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, 1);
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, 1);
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, 1);
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, 1);
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false
      };
      if ($rb_gt(self, max)) {
        return false
      };
      return true;
    }, 2);
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) max = nil;;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/regexp"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $alias = Opal.alias, $send = Opal.send, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $rb_ge = Opal.rb_ge, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus;

  Opal.add_stubs('nil?,[],raise,escape,options,to_str,new,join,coerce_to!,!,match,coerce_to?,begin,uniq,map,scan,source,to_proc,transform_values,group_by,each_with_index,+,last,=~,attr_reader,>=,length,is_a?,include?,names,regexp,named_captures,===,captures,-,inspect,empty?,each,to_a');
  
  $klass('::', $$$('StandardError'), 'RegexpError');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'IGNORECASE', 1);
    $const_set(self, 'EXTENDED', 2);
    $const_set(self, 'MULTILINE', 4);
    Opal.prop(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var $yield = $$allocate.$$p || nil, self = this, allocated = nil;

        delete $$allocate.$$p;
        
        allocated = $send2(self, $find_super(self, 'allocate', $$allocate, false, true), 'allocate', [], $yield);
        allocated.uninitialized = true;
        return allocated;
      }, 0);
      
      $def(self, '$escape', function $$escape(string) {
        
        return Opal.escape_regexp(string);
      }, 1);
      
      $def(self, '$last_match', function $$last_match(n) {
                if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (n == null) n = nil;;
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else if ($truthy($gvars["~"])) {
          return $gvars["~"]['$[]'](n)
        } else {
          return nil
        };
      }, -1);
      
      $def(self, '$union', function $$union($a) {
        var $post_args, parts, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        parts = $post_args;;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              $Kernel.$raise($$$('TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, -1);
      
      $def(self, '$new', function $new$1(regexp, options) {
        
        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $Opal['$coerce_to!'](regexp, $$$('String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          $Kernel.$raise($$$('RegexpError'), "too short escape sequence: /" + (regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$('IGNORECASE') & options) { temp += 'i'; }
          if ($$('MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, -2);
      $alias(self, "compile", "new");
      return $alias(self, "quote", "escape");
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$==', function $Regexp_$eq_eq$2(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, 1);
    
    $def(self, '$===', function $Regexp_$eq_eq_eq$3(string) {
      var self = this;

      return self.$match($Opal['$coerce_to?'](string, $$$('String'), "to_str")) !== nil
    }, 1);
    
    $def(self, '$=~', function $Regexp_$eq_tilde$4(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, 0);
    
    $def(self, '$match', function $$match(string, pos) {
      var block = $$match.$$p || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      delete $$match.$$p;
      
      ;
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$$('String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$$('MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$$('MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, -2);
    
    $def(self, '$match?', function $Regexp_match$ques$5(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$$('String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, -2);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return $send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$uniq()
    }, 0);
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this;

      return $send($send($send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$each_with_index(), 'group_by', [], "first".$to_proc()), 'transform_values', [], function $$6(i){
        
        
        if (i == null) i = nil;;
        return $send(i, 'map', [], function $$7(j){
          
          
          if (j == null) j = nil;;
          return $rb_plus(j.$last(), 1);}, 1);}, 1)
    }, 0);
    
    $def(self, '$~', function $Regexp_$$8() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, 0);
    
    $def(self, '$source', function $$source() {
      var self = this;

      return self.source;
    }, 0);
    
    $def(self, '$options', function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$('MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$('IGNORECASE');
      }
      return result;
    
    }, 0);
    
    $def(self, '$casefold?', function $Regexp_casefold$ques$9() {
      var self = this;

      return self.ignoreCase;
    }, 0);
    $alias(self, "eql?", "==");
    return $alias(self, "to_s", "source");
  })('::', RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    $def(self, '$initialize', function $$initialize(regexp, match_groups, $kwargs) {
      var no_matchdata, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];
      if (no_matchdata == null) no_matchdata = false;
      if (!$truthy(no_matchdata)) {
        $gvars["~"] = self
      };
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, -3);
    
    $def(self, '$match', function $$match(idx) {
      var self = this, match = nil;

      if ($truthy((match = self['$[]'](idx)))) {
        return match
      } else if (($truthy(idx['$is_a?']($$('Integer'))) && ($truthy($rb_ge(idx, self.$length()))))) {
        return $Kernel.$raise($$$('IndexError'), "index " + (idx) + " out of matches")
      } else {
        return nil
      }
    }, 1);
    
    $def(self, '$match_length', function $$match_length(idx) {
      var $a, self = this;

      return ($a = self.$match(idx), ($a === nil || $a == null) ? nil : $send($a, 'length', []))
    }, 1);
    
    $def(self, '$[]', function $MatchData_$$$10($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      if (args[0].$$is_string) {
        if (self.$regexp().$names()['$include?'](args['$[]'](0))['$!']()) {
          $Kernel.$raise($$$('IndexError'), "undefined group name reference: " + (args['$[]'](0)))
        }
        return self.$named_captures()['$[]'](args['$[]'](0))
      }
      else {
        return $send(self.matches, '[]', $to_a(args))
      }
    ;
    }, -1);
    
    $def(self, '$offset', function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, 1);
    
    $def(self, '$==', function $MatchData_$eq_eq$11(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

      
      if (!$eqeqeq($$$('MatchData'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.string == other.string)) ? (self.regexp.toString() == other.regexp.toString()) : ($ret_or_4)))) ? (self.pre_match == other.pre_match) : ($ret_or_3)))) ? (self.post_match == other.post_match) : ($ret_or_2))))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$begin', function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, 1);
    
    $def(self, '$end', function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, 1);
    
    $def(self, '$captures', function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, 0);
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this, matches = nil;

      
      matches = self.$captures();
      return $send(self.$regexp().$named_captures(), 'transform_values', [], function $$12(i){
        
        
        if (i == null) i = nil;;
        return matches['$[]']($rb_minus(i.$last(), 1));}, 1);
    }, 0);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return self.$regexp().$names()
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      if (self.$regexp().$names()['$empty?']()) {
        for (var i = 1, length = self.matches.length; i < length; i++) {
          str += " " + i + ":" + (self.matches[i]).$inspect();
        }
      }
      else {
        $send(self.$named_captures(), 'each', [], function $$13(k, v){
        
        
        if (k == null) k = nil;;
        
        if (v == null) v = nil;;
        return                str += " " + k + ":" + v.$inspect();}, 2)
      }

      return str + ">";
    
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.matches.length
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return self.matches
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.matches[0]
    }, 0);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $Opal['$coerce_to!'](args[i], $$$('Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, -1);
    $alias(self, "eql?", "==");
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/string"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $global_multiline_regexp = Opal.global_multiline_regexp, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $hash2 = Opal.hash2, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $gvars = Opal.gvars, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $const_set = Opal.const_set;

  Opal.add_stubs('require,include,coerce_to?,initialize,===,format,raise,respond_to?,to_s,to_str,<=>,==,=~,new,force_encoding,casecmp,empty?,ljust,ceil,/,+,rjust,floor,coerce_to!,copy_singleton_methods,initialize_clone,initialize_dup,enum_for,chomp,[],to_i,each_line,to_proc,to_a,class,match,match?,captures,proc,succ,escape,include?,upcase,unicode_normalize,pristine');
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    Opal.prop(self.$$prototype, '$$is_string', true);

    Opal.prop(self.$$prototype, '$$cast', function(string) {
      var klass = this.$$class;
      if (klass.$$constructor === String) {
        return string;
      } else {
        return new klass.$$constructor(string);
      }
    });
  ;
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.toString();
    }, 0);
    $defs(self, '$try_convert', function $$try_convert(what) {
      
      return $Opal['$coerce_to?'](what, $$$('String'), "to_str")
    }, 1);
    $defs(self, '$new', function $String_new$1($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$$('String'), 'to_str');
      if (opts && opts.$$is_hash) {
        if (opts.$$smap.encoding) str = str.$force_encoding(opts.$$smap.encoding);
      }
      str = new self.$$constructor(str);
      if (!str.$initialize.$$pristine) $send((str), 'initialize', $to_a(args));
      return str;
    ;
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) str = $post_args.shift();;
      
      encoding = $kwargs.$$smap["encoding"];
      if (encoding == null) encoding = nil;
      
      capacity = $kwargs.$$smap["capacity"];
      if (capacity == null) capacity = nil;
      return nil;
    }, -1);
    
    $def(self, '$%', function $String_$percent$2(data) {
      var self = this;

      if ($eqeqeq($$$('Array'), data)) {
        return $send(self, 'format', [self].concat($to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, 1);
    
    $def(self, '$*', function $String_$$3(count) {
      var self = this;

      
      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return self.$$cast('');
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        $Kernel.$raise($$$('RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return self.$$cast(result);
    
    }, 1);
    
    $def(self, '$+', function $String_$plus$4(other) {
      var self = this;

      
      other = $coerce_to(other, $$$('String'), 'to_str');
      
      if (other == "" && self.$$class === Opal.String) return self;
      if (self == "" && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    }, 1);
    
    $def(self, '$<=>', function $String_$lt_eq_gt$5(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, 1);
    
    $def(self, '$==', function $String_$eq_eq$6(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    }, 1);
    
    $def(self, '$=~', function $String_$eq_tilde$7(other) {
      var self = this;

      
      if (other.$$is_string) {
        $Kernel.$raise($$$('TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, 1);
    
    $def(self, '$[]', function $String_$$$8(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude, range;

      if (index.$$is_range) {
        exclude = index.excl;
        range   = index;
        length  = index.end === nil ? -1 : $coerce_to(index.end, $$$('Integer'), 'to_int');
        index   = index.begin === nil ? 0 : $coerce_to(index.begin, $$$('Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude || range.end === nil) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.$$cast(self.substr(index, length));
      }


      if (index.$$is_string) {
        if (length != null) {
          $Kernel.$raise($$$('TypeError'))
        }
        return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$$('MatchData').$new(index, match))

        if (length == null) {
          return self.$$cast(match[0]);
        }

        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return self.$$cast(match[length += match.length]);
        }

        if (length >= 0 && length < match.length) {
          return self.$$cast(match[length]);
        }

        return nil;
      }


      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.$$cast(self.substr(index, 1));
      }

      length = $coerce_to(length, $$$('Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.$$cast(self.substr(index, length));
    ;
    }, -2);
    
    $def(self, '$b', function $$b() {
      var self = this;

      return (new String(self)).$force_encoding("binary")
    }, 0);
    
    $def(self, '$capitalize', function $$capitalize() {
      var self = this;

      return self.$$cast(self.charAt(0).toUpperCase() + self.substr(1).toLowerCase());
    }, 0);
    
    $def(self, '$casecmp', function $$casecmp(other) {
      var self = this;

      
      if (!$truthy(other['$respond_to?']("to_str"))) {
        return nil
      };
      other = ($coerce_to(other, $$$('String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, 1);
    
    $def(self, '$casecmp?', function $String_casecmp$ques$9(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, 1);
    
    $def(self, '$center', function $$center(width, padstr) {
      var self = this;

      
      
      if (padstr == null) padstr = " ";;
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return self.$$cast(rjustified + ljustified.slice(self.length));
    ;
    }, -2);
    
    $def(self, '$chomp', function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) separator = $gvars["/"];;
      if ($truthy(separator === nil || self.length === 0)) {
        return self
      };
      separator = $Opal['$coerce_to!'](separator, $$$('String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return self.$$cast(result);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$chop', function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return self.$$cast(result);
    
    }, 0);
    
    $def(self, '$chr', function $$chr() {
      var self = this;

      return self.charAt(0);
    }, 0);
    
    $def(self, '$clone', function $$clone() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$count', function $$count($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, -1);
    
    $def(self, '$delete', function $String_delete$10($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp(char_class, 'g'), ''));
    ;
    }, -1);
    
    $def(self, '$delete_prefix', function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$$('String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.$$cast(self.slice(prefix.length));
      } else {
        return self;
      }
    
    }, 1);
    
    $def(self, '$delete_suffix', function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$$('String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.$$cast(self.slice(0, self.length - suffix.length));
      } else {
        return self;
      }
    
    }, 1);
    
    $def(self, '$downcase', function $$downcase() {
      var self = this;

      return self.$$cast(self.toLowerCase());
    }, 0);
    
    $def(self, '$each_line', function $$each_line($a, $b) {
      var block = $$each_line.$$p || nil, $post_args, $kwargs, separator, chomp, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      delete $$each_line.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) separator = $post_args.shift();
      if (separator == null) separator = $gvars["/"];;
      
      chomp = $kwargs.$$smap["chomp"];
      if (chomp == null) chomp = false;
      if (!(block !== nil)) {
        return self.$enum_for("each_line", separator, $hash2(["chomp"], {"chomp": chomp}))
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$$('String'), 'to_str');

      var a, i, n, length, chomped, trailing, splitted, value;

      if (separator.length === 0) {
        for (a = self.split(/((?:\r?\n){2})(?:(?:\r?\n)*)/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            value = (a[i] || "") + (a[i + 1] || "");
            if (chomp) {
              value = (value).$chomp("\n");
            }
            Opal.yield1(block, value);
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        value = splitted[i];
        if (i < length - 1 || trailing) {
          value += separator;
        }
        if (chomp) {
          value = (value).$chomp(separator);
        }
        Opal.yield1(block, value);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$empty?', function $String_empty$ques$11() {
      var self = this;

      return self.length === 0;
    }, 0);
    
    $def(self, '$end_with?', function $String_end_with$ques$12($a) {
      var $post_args, suffixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      suffixes = $post_args;;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$$('String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, -1);
    
    $def(self, '$gsub', function $$gsub(pattern, replacement) {
      var block = $$gsub.$$p || nil, self = this;

      delete $$gsub.$$p;
      
      ;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$$('MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$$('String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return self.$$cast(result);
    ;
    }, -2);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$hex', function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, 0);
    
    $def(self, '$include?', function $String_include$ques$13(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$$('String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    }, 1);
    
    $def(self, '$index', function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = $global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$$('MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, -2);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      /* eslint-disable no-misleading-character-class */
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
              return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
      /* eslint-enable no-misleading-character-class */
    
    }, 0);
    
    $def(self, '$intern', function $$intern() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$lines', function $$lines($a, $b) {
      var block = $$lines.$$p || nil, $post_args, $kwargs, separator, chomp, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      delete $$lines.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) separator = $post_args.shift();
      if (separator == null) separator = $gvars["/"];;
      
      chomp = $kwargs.$$smap["chomp"];
      if (chomp == null) chomp = false;
      e = $send(self, 'each_line', [separator, $hash2(["chomp"], {"chomp": chomp})], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, -1);
    
    $def(self, '$ljust', function $$ljust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) padstr = " ";;
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self.$$cast(self + result.slice(0, width));
    ;
    }, -2);
    
    $def(self, '$lstrip', function $$lstrip() {
      var self = this;

      return self.replace(/^[\u0000\s]*/, '');
    }, 0);
    
    $def(self, '$ascii_only?', function $String_ascii_only$ques$14() {
      var self = this;

      
      if (!self.encoding.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    }, 0);
    
    $def(self, '$match', function $$match(pattern, pos) {
      var block = $$match.$$p || nil, self = this;

      delete $$match.$$p;
      
      ;
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, -2);
    
    $def(self, '$match?', function $String_match$ques$15(pattern, pos) {
      var self = this;

      
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, -2);
    
    $def(self, '$next', function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return self.$$cast('');
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return self.$$cast(result);
    
    }, 0);
    
    $def(self, '$oct', function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, 0);
    
    $def(self, '$ord', function $$ord() {
      var self = this;

      
      if (typeof self.codePointAt === "function") {
        return self.codePointAt(0);
      }
      else {
        return self.charCodeAt(0);
      }
    
    }, 0);
    
    $def(self, '$partition', function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, 1);
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, 0);
    
    $def(self, '$rindex', function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, -2);
    
    $def(self, '$rjust', function $$rjust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) padstr = " ";;
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return self.$$cast(result + padstr.slice(0, remaining) + self);
    ;
    }, -2);
    
    $def(self, '$rpartition', function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, 1);
    
    $def(self, '$rstrip', function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, 0);
    
    $def(self, '$scan', function $$scan(pattern, $kwargs) {
      var block = $$scan.$$p || nil, no_matchdata, self = this;

      delete $$scan.$$p;
      
      ;
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];
      if (no_matchdata == null) no_matchdata = false;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$$('MatchData').$new(pattern, match, $hash2(["no_matchdata"], {"no_matchdata": no_matchdata}));
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? Opal.yield1(block, match[0]) : Opal.yield1(block, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      if (!no_matchdata) ($gvars["~"] = match_data);

      return (block !== nil ? self : result);
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, 0);
    
    $def(self, '$split', function $$split(pattern, limit) {
      var self = this, $ret_or_1 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy(($ret_or_1 = $gvars[";"])) ? ($ret_or_1) : (" "));
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str').$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [self.$$cast(result[0])];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      function castResult() {
        for (i = 0; i < result.length; i++) {
          result[i] = self.$$cast(result[i]);
        }
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        castResult();
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        castResult();
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        castResult();
        return result;
      }

      if (limit >= result.length) {
        castResult();
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      castResult();
      return result;
    ;
    }, -1);
    
    $def(self, '$squeeze', function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        return self.$$cast(self.replace(/(.)\1+/g, '$1'));
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1'));
    ;
    }, -1);
    
    $def(self, '$start_with?', function $String_start_with$ques$16($a) {
      var $post_args, prefixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      prefixes = $post_args;;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$$('MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          var prefix = $coerce_to(prefixes[i], $$$('String'), 'to_str').$to_s();

          if (self.indexOf(prefix) === 0) {
            return true;
          }
        }
      }

      return false;
    ;
    }, -1);
    
    $def(self, '$strip', function $$strip() {
      var self = this;

      return self.replace(/^[\s\u0000]*|[\s\u0000]*$/g, '');
    }, 0);
    
    $def(self, '$sub', function $$sub(pattern, replacement) {
      var block = $$sub.$$p || nil, self = this;

      delete $$sub.$$p;
      
      ;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$$('MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$$('String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return self.$$cast(result);
    ;
    }, -2);
    
    $def(self, '$sum', function $$sum(n) {
      var self = this;

      
      
      if (n == null) n = 16;;
      
      n = $coerce_to(n, $$$('Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, -1);
    
    $def(self, '$swapcase', function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return self.$class().$new(str);
    
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, 0);
    
    $def(self, '$to_i', function $$to_i(base) {
      var self = this;

      
      
      if (base == null) base = 10;;
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$$('Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, -1);
    
    $def(self, '$to_proc', function $$to_proc() {
      var $yield = $$to_proc.$$p || nil, self = this, method_name = nil;

      delete $$to_proc.$$p;
      
      method_name = $rb_plus("$", self.valueOf());
      return $send($Kernel, 'proc', [], function $$17($a){var block = $$17.$$p || nil, $post_args, args;

        delete $$17.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        
        if (args.length === 0) {
          $Kernel.$raise($$$('ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[method_name];

        if (!body) {
          return recv.$method_missing.apply(recv, args);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 1) {
          return body.call(recv);
        } else {
          return body.apply(recv, args.slice(1));
        }
      ;}, -1);
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$tr', function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return self.$$cast(new_str);
    
    }, 2);
    
    $def(self, '$tr_s', function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return self.$$cast(new_str);
    
    }, 2);
    
    $def(self, '$upcase', function $$upcase() {
      var self = this;

      return self.$$cast(self.toUpperCase());
    }, 0);
    
    $def(self, '$upto', function $$upto(stop, excl) {
      var block = $$upto.$$p || nil, self = this;

      delete $$upto.$$p;
      
      ;
      
      if (excl == null) excl = false;;
      if (!(block !== nil)) {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$$('String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$$('String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$$('Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$$('Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    }, 0);
    $defs(self, '$_load', function $$_load($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$unicode_normalize', function $$unicode_normalize(form) {
      var self = this;

      
      
      if (form == null) form = "nfc";;
      if (!$truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
        $Kernel.$raise($$$('ArgumentError'), "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, -1);
    
    $def(self, '$unicode_normalized?', function $String_unicode_normalized$ques$18(form) {
      var self = this;

      
      
      if (form == null) form = "nfc";;
      return self.$unicode_normalize(form)['$=='](self);
    }, -1);
    
    $def(self, '$unpack', function $$unpack(format) {
      
      return $Kernel.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, 1);
    
    $def(self, '$unpack1', function $$unpack1(format) {
      
      return $Kernel.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, 1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') return self;
      self.$$frozen = true;
      return self;
    
    }, 0);
    
    $def(self, '$-@', function $String_$minus$$19() {
      var self = this;

      
      if (typeof self === 'string') return self;
      if (self.$$frozen === true) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    }, 0);
    
    $def(self, '$frozen?', function $String_frozen$ques$20() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    }, 0);
    $alias(self, "+@", "dup");
    $alias(self, "===", "==");
    $alias(self, "byteslice", "[]");
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "===");
    $alias(self, "object_id", "__id__");
    $alias(self, "slice", "[]");
    $alias(self, "succ", "next");
    $alias(self, "to_str", "to_s");
    $alias(self, "to_sym", "intern");
    return $Opal.$pristine(self, "initialize");
  })('::', String, $nesting);
  return $const_set($nesting[0], 'Symbol', $$('String'));
};

Opal.modules["corelib/enumerable"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $module = Opal.module, $send = Opal.send, $to_a = Opal.to_a, $Opal = Opal.Opal, $def = Opal.def, $Kernel = Opal.Kernel, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $rb_le = Opal.rb_le, $hash2 = Opal.hash2, $lambda = Opal.lambda, $not = Opal.not, $alias = Opal.alias;

  Opal.add_stubs('each,public_send,destructure,to_enum,enumerator_size,new,yield,raise,slice_when,!,enum_for,flatten,map,compact,to_a,warn,proc,==,nil?,respond_to?,coerce_to!,>,*,try_convert,<,+,-,ceil,/,size,select,to_proc,__send__,length,<=,[],push,<<,[]=,===,inspect,<=>,first,reverse,sort,take,sort_by,compare,call,dup,sort!,map!,include?,-@,key?,values,transform_values,group_by,fetch,to_h,coerce_to?,class,zip');
  return (function($base) {
    var self = $module($base, 'Enumerable');

    
    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    $def(self, '$all?', function $Enumerable_all$ques$1(pattern) {try {

      var block = $Enumerable_all$ques$1.$$p || nil, self = this;

      delete $Enumerable_all$ques$1.$$p;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$2($a){var $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            return nil
          } else {
            Opal.ret(false)
          };}, -1)
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$3($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          } else {
            Opal.ret(false)
          };}, -1)
      } else {
        $send(self, 'each', [], function $$4($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy($Opal.$destructure(value))) {
            return nil
          } else {
            Opal.ret(false)
          };}, -1)
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$any?', function $Enumerable_any$ques$5(pattern) {try {

      var block = $Enumerable_any$ques$5.$$p || nil, self = this;

      delete $Enumerable_any$ques$5.$$p;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$6($a){var $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            Opal.ret(true)
          } else {
            return nil
          };}, -1)
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$7($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            Opal.ret(true)
          } else {
            return nil
          };}, -1)
      } else {
        $send(self, 'each', [], function $$8($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy($Opal.$destructure(value))) {
            Opal.ret(true)
          } else {
            return nil
          };}, -1)
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$chunk', function $$chunk() {
      var block = $$chunk.$$p || nil, self = this;

      delete $$chunk.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["chunk"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send($$$('Enumerator'), 'new', [], function $$10(yielder){var self = $$10.$$s == null ? this : $$10.$$s;

        
        
        if (yielder == null) yielder = nil;;
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = $yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, {$$arity: 1, $$s: self});
    }, 0);
    
    $def(self, '$chunk_while', function $$chunk_while() {
      var block = $$chunk_while.$$p || nil, self = this;

      delete $$chunk_while.$$p;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], function $$11(before, after){
        
        
        if (before == null) before = nil;;
        
        if (after == null) after = nil;;
        return Opal.yieldX(block, [before, after])['$!']();}, 2);
    }, 0);
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      delete $$collect.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = $yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$collect_concat', function $$collect_concat() {
      var block = $$collect_concat.$$p || nil, self = this;

      delete $$collect_concat.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect_concat"], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send(self, 'map', [], function $$14(item){
        
        
        if (item == null) item = nil;;
        return Opal.yield1(block, item);;}, 1).$flatten(1);
    }, 0);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      return self.$to_a().$compact()
    }, 0);
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this, result = nil;

      delete $$count.$$p;
      
      ;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send($Kernel, 'proc', [], function $$15($a){var $post_args, args;

          
          
          $post_args = Opal.slice.call(arguments);
          
          args = $post_args;;
          return $Opal.$destructure(args)['$=='](object);}, -1)
      } else if ($truthy(block['$nil?']())) {
        block = $send($Kernel, 'proc', [], function $$16(){
          return true}, 0)
      };
      $send(self, 'each', [], function $$17($a){var $post_args, args;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        if ($truthy($yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      delete $$cycle.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$$('Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil
        };
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, -1);
    
    $def(self, '$detect', function $$detect(ifnone) {try {

      var block = $$detect.$$p || nil, self = this;

      delete $$detect.$$p;
      
      ;
      ;
      if (!(block !== nil)) {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], function $$19($a){var $post_args, args, value = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        value = $Opal.$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
        } else {
          return nil
        };}, -1);
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');
      if ($truthy(number < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
      };
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($Opal.$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, 1);
    
    $def(self, '$drop_while', function $$drop_while() {
      var block = $$drop_while.$$p || nil, self = this;

      delete $$drop_while.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        if (dropping) {
          var value = $yield1(block, param);

          if (!$truthy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$each_cons', function $$each_cons(n) {
      var block = $$each_cons.$$p || nil, self = this;

      delete $$each_cons.$$p;
      
      ;
      if ($truthy(arguments.length != 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 1)")
      };
      n = $Opal.$try_convert(n, $$$('Integer'), "to_int");
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_cons", n], function $$20(){var self = $$20.$$s == null ? this : $$20.$$s, enum_size = nil;

          
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if (($eqeq(enum_size, 0) || ($truthy($rb_lt(enum_size, n))))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          $yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return self;
    ;
    }, 1);
    
    $def(self, '$each_entry', function $$each_entry($a) {
      var block = $$each_entry.$$p || nil, $post_args, data, self = this;

      delete $$each_entry.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      data = $post_args;;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["each_entry"].concat($to_a(data)), function $$21(){var self = $$21.$$s == null ? this : $$21.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      self.$each.$$p = function() {
        var item = $Opal.$destructure(arguments);

        $yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, -1);
    
    $def(self, '$each_slice', function $$each_slice(n) {
      var block = $$each_slice.$$p || nil, self = this;

      delete $$each_slice.$$p;
      
      ;
      n = $coerce_to(n, $$$('Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid slice size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_slice", n], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;

          if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, {$$arity: 0, $$s: self})
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          $yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        $yield1(block, slice);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$each_with_index', function $$each_with_index($a) {
      var block = $$each_with_index.$$p || nil, $post_args, args, self = this;

      delete $$each_with_index.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"].concat($to_a(args)), function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, -1);
    
    $def(self, '$each_with_object', function $$each_with_object(object) {
      var block = $$each_with_object.$$p || nil, self = this;

      delete $$each_with_object.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_object", object], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    }, 1);
    
    $def(self, '$entries', function $$entries($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($Opal.$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, -1);
    
    $def(self, '$filter_map', function $$filter_map() {
      var block = $$filter_map.$$p || nil, self = this;

      delete $$filter_map.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["filter_map"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    }, 0);
    
    $def(self, '$find_all', function $$find_all() {
      var block = $$find_all.$$p || nil, self = this;

      delete $$find_all.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["find_all"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$find_index', function $$find_index(object) {try {

      var block = $$find_index.$$p || nil, self = this, index = nil;

      delete $$find_index.$$p;
      
      ;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")
      };
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], function $$27($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($eqeq($Opal.$destructure(value), object)) {
            Opal.ret(index)
          };
          return index += 1;;}, -1)
      } else {
        $send(self, 'each', [], function $$28($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            Opal.ret(index)
          };
          return index += 1;;}, -1)
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$first', function $$first(number) {try {

      var self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], function $$29(value){
          
          
          if (value == null) value = nil;;
          Opal.ret(value);}, 1)
      } else {
        
        result = [];
        number = $coerce_to(number, $$$('Integer'), 'to_int');
        if ($truthy(number < 0)) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        if ($truthy(number == 0)) {
          return []
        };
        current = 0;
        $send(self, 'each', [], function $$30($a){var $post_args, args;

          
          
          $post_args = Opal.slice.call(arguments);
          
          args = $post_args;;
          result.push($Opal.$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
          } else {
            return nil
          };}, -1);
        return result;
      };
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$grep', function $$grep(pattern) {
      var block = $$grep.$$p || nil, self = this, result = nil;

      delete $$grep.$$p;
      
      ;
      result = [];
      $send(self, 'each', [], function $$31($a){var $post_args, value, cmp = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if (!$truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    }, 1);
    
    $def(self, '$grep_v', function $$grep_v(pattern) {
      var block = $$grep_v.$$p || nil, self = this, result = nil;

      delete $$grep_v.$$p;
      
      ;
      result = [];
      $send(self, 'each', [], function $$32($a){var $post_args, value, cmp = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    }, 1);
    
    $def(self, '$group_by', function $$group_by() {
      var block = $$group_by.$$p || nil, self = this, hash = nil, $ret_or_1 = nil, $writer = nil;

      delete $$group_by.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["group_by"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        ($truthy(($ret_or_1 = hash['$[]'](value))) ? ($ret_or_1) : ((($writer = [value, []]), $send(hash, '[]=', $to_a($writer)), $writer[$rb_minus($writer["length"], 1)])))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, 0);
    
    $def(self, '$include?', function $Enumerable_include$ques$34(obj) {try {

      var self = this;

      
      $send(self, 'each', [], function $$35($a){var $post_args, args;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        if ($eqeq($Opal.$destructure(args), obj)) {
          Opal.ret(true)
        } else {
          return nil
        };}, -1);
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, 1);
    
    $def(self, '$inject', function $$inject(object, sym) {
      var block = $$inject.$$p || nil, self = this;

      delete $$inject.$$p;
      
      ;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = $yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$$('Symbol')['$==='](object)) {
            $Kernel.$raise($$$('TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$lazy', function $$lazy() {
      var self = this;

      return $send($$$($$$('Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], function $$36(enum$, $a){var $post_args, args;

        
        
        if (enum$ == null) enum$ = nil;;
        
        $post_args = Opal.slice.call(arguments, 1);
        
        args = $post_args;;
        return $send(enum$, 'yield', $to_a(args));}, -2)
    }, 0);
    
    $def(self, '$enumerator_size', function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, 0);
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      delete $$max.$$p;
      
      ;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = $yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$$('Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, -1);
    
    $def(self, '$max_by', function $$max_by(n) {
      var block = $$max_by.$$p || nil, self = this;

      delete $$max_by.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["max_by", n], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min', function $$min(n) {
      var block = $$min.$$p || nil, self = this;

      delete $$min.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!$truthy(n['$nil?']())) {
        if ((block !== nil)) {
          return $send(self, 'sort', [], function $$38(a, b){
            
            
            if (a == null) a = nil;;
            
            if (b == null) b = nil;;
            return Opal.yieldX(block, [a, b]);;}, 2).$take(n)
        } else {
          return self.$sort().$take(n)
        }
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($Opal.$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min_by', function $$min_by(n) {
      var block = $$min_by.$$p || nil, self = this;

      delete $$min_by.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["min_by", n], function $$39(){var self = $$39.$$s == null ? this : $$39.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$minmax', function $$minmax() {
      var block = $$minmax.$$p || nil, self = this, $ret_or_1 = nil;

      delete $$minmax.$$p;
      
      ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($send($Kernel, 'proc', [], function $$40(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return a['$<=>'](b);}, 2)));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, 0);
    
    $def(self, '$minmax_by', function $$minmax_by() {
      var block = $$minmax_by.$$p || nil, self = this;

      delete $$minmax_by.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["minmax_by"], function $$41(){var self = $$41.$$s == null ? this : $$41.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    }, 0);
    
    $def(self, '$none?', function $Enumerable_none$ques$42(pattern) {try {

      var block = $Enumerable_none$ques$42.$$p || nil, self = this;

      delete $Enumerable_none$ques$42.$$p;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$43($a){var $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$44($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      } else {
        $send(self, 'each', [], function $$45($a){var $post_args, value, item = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          item = $Opal.$destructure(value);
          if ($truthy(item)) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$one?', function $Enumerable_one$ques$46(pattern) {try {

      var block = $Enumerable_one$ques$46.$$p || nil, self = this, count = nil;

      delete $Enumerable_one$ques$46.$$p;
      
      ;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$47($a){var $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, -1)
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$48($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if (!$truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      } else {
        $send(self, 'each', [], function $$49($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if (!$truthy($Opal.$destructure(value))) {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$partition', function $$partition() {
      var block = $$partition.$$p || nil, self = this;

      delete $$partition.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["partition"], function $$50(){var self = $$50.$$s == null ? this : $$50.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, 0);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      delete $$reject.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$51(){var self = $$51.$$s == null ? this : $$51.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (!$truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      delete $$reverse_each.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$52(){var self = $$52.$$s == null ? this : $$52.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        $yieldX(block, result[i]);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$slice_before', function $$slice_before(pattern) {
      var block = $$slice_before.$$p || nil, self = this;

      delete $$slice_before.$$p;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$53(e){var self = $$53.$$s == null ? this : $$53.$$s;

        
        
        if (e == null) e = nil;;
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = $yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $Opal.$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$slice_after', function $$slice_after(pattern) {
      var block = $$slice_after.$$p || nil, self = this;

      delete $$slice_after.$$p;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      if ($truthy(pattern !== undefined)) {
        block = $send($Kernel, 'proc', [], function $$54(e){
          
          
          if (e == null) e = nil;;
          return pattern['$==='](e);}, 1)
      };
      return $send($$$('Enumerator'), 'new', [], function $$55(yielder){var self = $$55.$$s == null ? this : $$55.$$s;

        
        
        if (yielder == null) yielder = nil;;
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $Opal.$destructure(arguments),
              end_chunk = $yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$slice_when', function $$slice_when() {
      var block = $$slice_when.$$p || nil, self = this;

      delete $$slice_when.$$p;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$56(yielder){var self = $$56.$$s == null ? this : $$56.$$s;

        
        
        if (yielder == null) yielder = nil;;
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $Opal.$destructure(arguments),
              before = params[0],
              after = params[1],
              match = $yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, {$$arity: 1, $$s: self});
    }, 0);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this, ary = nil;

      delete $$sort.$$p;
      
      ;
      ary = self.$to_a();
      if (!(block !== nil)) {
        block = $lambda(function $$57(a, b){
          
          
          if (a == null) a = nil;;
          
          if (b == null) b = nil;;
          return a['$<=>'](b);}, 2)
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, 0);
    
    $def(self, '$sort_by', function $$sort_by() {
      var block = $$sort_by.$$p || nil, self = this, dup = nil;

      delete $$sort_by.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by"], function $$58(){var self = $$58.$$s == null ? this : $$58.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      dup = $send(self, 'map', [], function $$59(){var arg = nil;

        
        arg = $Opal.$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, 0);
      $send(dup, 'sort!', [], function $$60(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return (a[0])['$<=>'](b[0]);}, 2);
      return $send(dup, 'map!', [], function $$61(i){
        
        
        if (i == null) i = nil;;
        return i[1];;}, 1);
    }, 0);
    
    $def(self, '$sum', function $$sum(initial) {
      var $yield = $$sum.$$p || nil, self = this, result = nil, compensation = nil;

      delete $$sum.$$p;
      
      
      if (initial == null) initial = 0;;
      result = initial;
      compensation = 0;
      $send(self, 'each', [], function $$62($a){var $post_args, args, item = nil, y = nil, t = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        item = (($yield !== nil) ? (Opal.yieldX($yield, $to_a(args))) : ($Opal.$destructure(args)));
        if (($not([$$$($$$('Float'), 'INFINITY'), $$$($$$('Float'), 'INFINITY')['$-@']()]['$include?'](item)) && ($truthy(item['$respond_to?']("-"))))) {
          
          y = $rb_minus(item, compensation);
          t = $rb_plus(result, y);
          compensation = $rb_minus($rb_minus(t, result), y);
          return (result = t);
        } else {
          return (result = $rb_plus(result, item))
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$take', function $$take(num) {
      var self = this;

      return self.$first(num)
    }, 1);
    
    $def(self, '$take_while', function $$take_while() {try {

      var block = $$take_while.$$p || nil, self = this, result = nil;

      delete $$take_while.$$p;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], function $$63($a){var $post_args, args, value = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        value = $Opal.$destructure(args);
        if (!$truthy(Opal.yield1(block, value))) {
          Opal.ret(result)
        };
        return result.push(value);;}, -1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, 0);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this, hash = nil;

      delete $$uniq.$$p;
      
      ;
      hash = $hash2([], {});
      $send(self, 'each', [], function $$64($a){var $post_args, args, value = nil, produced = nil, $writer = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        value = $Opal.$destructure(args);
        produced = ((block !== nil) ? (Opal.yield1(block, value)) : (value));
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          
          $writer = [produced, value];
          $send(hash, '[]=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };}, -1);
      return hash.$values();
    }, 0);
    
    $def(self, '$tally', function $$tally(hash) {
      var self = this, out = nil;

      
      ;
      out = $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc());
      if ($truthy(hash)) {
        
        $send(out, 'each', [], function $$65(k, v){var $writer = nil;

          
          
          if (k == null) k = nil;;
          
          if (v == null) v = nil;;
          $writer = [k, $rb_plus(hash.$fetch(k, 0), v)];
          $send(hash, '[]=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, 2);
        return hash;
      } else {
        return out
      };
    }, -1);
    
    $def(self, '$to_h', function $$to_h($a) {
      var block = $$to_h.$$p || nil, $post_args, args, self = this;

      delete $$to_h.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(args))
      };
      
      var hash = $hash2([], {});

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);
        var ary = $Opal['$coerce_to?'](param, $$$('Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this;

      delete $$zip.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      return $send(self.$to_a(), 'zip', $to_a(others));
    }, -1);
    $alias(self, "find", "detect");
    $alias(self, "filter", "find_all");
    $alias(self, "flat_map", "collect_concat");
    $alias(self, "map", "collect");
    $alias(self, "member?", "include?");
    $alias(self, "reduce", "inject");
    $alias(self, "select", "find_all");
    return $alias(self, "to_a", "entries");
  })('::')
};

Opal.modules["corelib/enumerator/arithmetic_sequence"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $to_a = Opal.to_a, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $def = Opal.def, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $alias = Opal.alias;

  Opal.add_stubs('is_a?,==,raise,respond_to?,class,attr_reader,begin,end,exclude_end?,>,step,<,<=,>=,-@,_lesser_than_end?,<<,+,-,===,%,_greater_than_begin?,reverse,!,include?,*,to_i,abs,/,hash,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.step_arg2 = $proto.receiver_num = $proto.step_arg1 = $proto.step = $proto.range = $proto.topfx = $proto.bypfx = $proto.creation_method = $proto.skipped_arg = nil;
      
      Opal.prop(self.$$prototype, '$$is_arithmetic_seq', true);
      var inf = Infinity;
      
      $def(self, '$initialize', function $$initialize(range, step, creation_method) {
        var $a, self = this, $ret_or_1 = nil;

        
        ;
        
        if (creation_method == null) creation_method = "step";;
        self.creation_method = creation_method;
        if ($truthy(range['$is_a?']($$$('Array')))) {
          
          $a = [].concat($to_a(range)), (self.step_arg1 = ($a[0] == null ? nil : $a[0])), (self.step_arg2 = ($a[1] == null ? nil : $a[1])), (self.topfx = ($a[2] == null ? nil : $a[2])), (self.bypfx = ($a[3] == null ? nil : $a[3])), $a;
          self.receiver_num = step;
          self.step = 1;
          self.range = ($truthy(self.step_arg2) ? (((self.step = self.step_arg2), Opal.Range.$new(self.receiver_num, self.step_arg1, false))) : ($truthy(self.step_arg1) ? (Opal.Range.$new(self.receiver_num, self.step_arg1, false)) : (Opal.Range.$new(self.receiver_num, nil, false))));
        } else {
          
          if (!$truthy(step)) {
            self.skipped_arg = true
          };
          $a = [range, ($truthy(($ret_or_1 = step)) ? ($ret_or_1) : (1))], (self.range = $a[0]), (self.step = $a[1]), $a;
        };
        self.object = self;
        if ($eqeq(self.step, 0)) {
          $Kernel.$raise($$('ArgumentError'), "step can't be 0")
        };
        if ($truthy(self.step['$respond_to?']("to_int"))) {
          return nil
        } else {
          return $Kernel.$raise($$('ArgumentError'), "" + ("no implicit conversion of " + (self.step.$class()) + " ") + "into Integer")
        };
      }, -2);
      self.$attr_reader("step");
      
      $def(self, '$begin', function $$begin() {
        var self = this;

        return self.range.$begin()
      }, 0);
      
      $def(self, '$end', function $$end() {
        var self = this;

        return self.range.$end()
      }, 0);
      
      $def(self, '$exclude_end?', function $ArithmeticSequence_exclude_end$ques$1() {
        var self = this;

        return self.range['$exclude_end?']()
      }, 0);
      
      $def(self, '$_lesser_than_end?', function $ArithmeticSequence__lesser_than_end$ques$2(val) {
        var self = this, end_ = nil, $ret_or_1 = nil;

        
        end_ = ($truthy(($ret_or_1 = self.$end())) ? ($ret_or_1) : (inf));
        if ($truthy($rb_gt(self.$step(), 0))) {
          if ($truthy(self['$exclude_end?']())) {
            return $rb_lt(val, end_)
          } else {
            return $rb_le(val, end_)
          }
        } else if ($truthy(self['$exclude_end?']())) {
          return $rb_gt(val, end_)
        } else {
          return $rb_ge(val, end_)
        };
      }, 1);
      
      $def(self, '$_greater_than_begin?', function $ArithmeticSequence__greater_than_begin$ques$3(val) {
        var self = this, begin_ = nil, $ret_or_1 = nil;

        
        begin_ = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if ($truthy($rb_gt(self.$step(), 0))) {
          return $rb_gt(val, begin_)
        } else {
          return $rb_lt(val, begin_)
        };
      }, 1);
      
      $def(self, '$first', function $$first(count) {
        var $a, self = this, iter = nil, $ret_or_1 = nil, out = nil;

        
        ;
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if (!$truthy(count)) {
          return ($truthy(self['$_lesser_than_end?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_lesser_than_end?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
          
          out['$<<'](iter);
          iter = $rb_plus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out;
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, $a, self = this, $ret_or_1 = nil, iter = nil;

        delete $$each.$$p;
        
        ;
        if (!(block !== nil)) {
          return self
        };
        if ($eqeqeq(nil, ($ret_or_1 = self.$begin()))) {
          $Kernel.$raise($$('TypeError'), "nil can't be coerced into Integer")
        } else {
          nil
        };
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        while ($truthy(self['$_lesser_than_end?'](iter))) {
          
          Opal.yield1(block, iter);
          iter = $rb_plus(iter, self.$step());
        };
        return self;
      }, 0);
      
      $def(self, '$last', function $$last(count) {
        var $a, self = this, $ret_or_1 = nil, iter = nil, out = nil;

        
        ;
        if (($eqeqeq(inf, ($ret_or_1 = self.$end())) || ($eqeqeq((inf)['$-@'](), $ret_or_1)))) {
          $Kernel.$raise($$$('FloatDomainError'), self.$end())
        } else if ($eqeqeq(nil, $ret_or_1)) {
          $Kernel.$raise($$$('RangeError'), "cannot get the last element of endless arithmetic sequence")
        } else {
          nil
        };
        iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
        if (!$truthy(self['$_lesser_than_end?'](iter))) {
          iter = $rb_minus(iter, self.$step())
        };
        if (!$truthy(count)) {
          return ($truthy(self['$_greater_than_begin?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_greater_than_begin?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
          
          out['$<<'](iter);
          iter = $rb_minus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out.$reverse();
      }, -1);
      
      $def(self, '$size', function $$size() {
        var self = this, step_sign = nil, iter = nil;

        
        step_sign = ($truthy($rb_gt(self.$step(), 0)) ? (1) : (-1));
        if ($not(self['$_lesser_than_end?'](self.$begin()))) {
          return 0
        } else if ($truthy([(inf)['$-@'](), inf]['$include?'](self.$step()))) {
          return 1
        } else if (($truthy([$rb_times((inf)['$-@'](), step_sign), nil]['$include?'](self.$begin())) || ($truthy([$rb_times(inf, step_sign), nil]['$include?'](self.$end()))))) {
          return inf;
        } else {
          
          iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
          if (!$truthy(self['$_lesser_than_end?'](iter))) {
            iter = $rb_minus(iter, self.$step())
          };
          return $rb_plus($rb_divide($rb_minus(iter, self.$begin()), self.$step()).$abs().$to_i(), 1);
        };
      }, 0);
      
      $def(self, '$==', function $ArithmeticSequence_$eq_eq$4(other) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.$class()['$=='](other.$class()))) ? (self.$begin()['$=='](other.$begin())) : ($ret_or_4)))) ? (self.$end()['$=='](other.$end())) : ($ret_or_3)))) ? (self.$step()['$=='](other.$step())) : ($ret_or_2))))) {
          return self['$exclude_end?']()['$=='](other['$exclude_end?']())
        } else {
          return $ret_or_1
        }
      }, 1);
      
      $def(self, '$hash', function $$hash() {
        var self = this;

        return [self.$begin(), self.$end(), self.$step(), self['$exclude_end?']()].$hash()
      }, 0);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this, args = nil;

        if ($truthy(self.receiver_num)) {
          
          args = ($truthy(self.step_arg2) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ", " + (self.bypfx) + (self.step_arg2.$inspect()) + ")") : ($truthy(self.step_arg1) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ")") : nil));
          return "(" + (self.receiver_num.$inspect()) + "." + (self.creation_method) + (args) + ")";
        } else {
          
          args = ($truthy(self.skipped_arg) ? (nil) : ("(" + (self.step) + ")"));
          return "((" + (self.range.$inspect()) + ")." + (self.creation_method) + (args) + ")";
        }
      }, 0);
      $alias(self, "===", "==");
      return $alias(self, "eql?", "==");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/chain"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('to_enum,size,each,<<,to_proc,include?,+,reverse_each,respond_to?,rewind,inspect');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Enumerator');

    
    return (function($base, $super) {
      var self = $klass($base, $super, 'Chain');

      var $proto = self.$$prototype;

      $proto.enums = $proto.iterated = nil;
      
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, enums, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        enums = $post_args;;
        self.enums = enums;
        self.iterated = [];
        return (self.object = self);
      }, -1);
      
      $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this;

        delete $$each.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        if (!(block !== nil)) {
          return $send(self, 'to_enum', ["each"].concat($to_a(args)), function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$size()}, {$$arity: 0, $$s: self})
        };
        $send(self.enums, 'each', [], function $$2(enum$){var self = $$2.$$s == null ? this : $$2.$$s;
          if (self.iterated == null) self.iterated = nil;

          
          
          if (enum$ == null) enum$ = nil;;
          self.iterated['$<<'](enum$);
          return $send(enum$, 'each', $to_a(args), block.$to_proc());}, {$$arity: 1, $$s: self});
        return self;
      }, -1);
      
      $def(self, '$size', function $$size($a) {try {

        var $post_args, args, self = this, accum = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        accum = 0;
        $send(self.enums, 'each', [], function $$3(enum$){var size = nil;

          
          
          if (enum$ == null) enum$ = nil;;
          size = $send(enum$, 'size', $to_a(args));
          if ($truthy([nil, $$$($$$('Float'), 'INFINITY')]['$include?'](size))) {
            Opal.ret(size)
          };
          return (accum = $rb_plus(accum, size));}, 1);
        return accum;
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, -1);
      
      $def(self, '$rewind', function $$rewind() {
        var self = this;

        
        $send(self.iterated, 'reverse_each', [], function $$4(enum$){
          
          
          if (enum$ == null) enum$ = nil;;
          if ($truthy(enum$['$respond_to?']("rewind"))) {
            return enum$.$rewind()
          } else {
            return nil
          };}, 1);
        self.iterated = [];
        return self;
      }, 0);
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<Enumerator::Chain: " + (self.enums.$inspect()) + ">"
      }, 0);
    })(self, self)
  })('::', null)
};

Opal.modules["corelib/enumerator/generator"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $breaker = Opal.breaker, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $send = Opal.send;

  Opal.add_stubs('include,raise,new,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = nil;
      
      self.$include($$$('Enumerable'));
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, 0);
      return $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this, yielder = nil;

        delete $$each.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        yielder = $send($$('Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, -1);
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator/lazy"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $defs = Opal.defs, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $alias = Opal.alias;

  Opal.add_stubs('raise,each,new,enumerator_size,yield,respond_to?,try_convert,<,===,+,for,class,to_proc,destructure,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.enumerator = nil;
      
      $klass(self, $$$('Exception'), 'StopLazyError');
      $defs(self, '$for', function $Lazy_for$1(object, $a) {
        var $post_args, $rest_arg, $yield = $Lazy_for$1.$$p || nil, self = this, lazy = nil;

        delete $Lazy_for$1.$$p;
        
        
        $post_args = Opal.slice.call(arguments, 1);
        
        $rest_arg = $post_args;;
        lazy = $send2(self, $find_super(self, 'for', $Lazy_for$1, false, true), 'for', [object].concat($to_a($rest_arg)), $yield);
        lazy.enumerator = object;
        return lazy;
      }, -2);
      
      $def(self, '$initialize', function $$initialize(object, size) {
        var block = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        ;
        
        if (size == null) size = nil;;
        if (!(block !== nil)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], function $$2(yielder, $a){var $post_args, each_args;

          
          
          if (yielder == null) yielder = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', $to_a(each_args), function $$3($b){var $post_args, args;

              
              
              $post_args = Opal.slice.call(arguments);
              
              args = $post_args;;
              
            args.unshift(yielder);

            $yieldX(block, args);
          ;}, -1)
          } catch ($err) {
            if (Opal.rescue($err, [$$('StopLazyError')])) {
              try {
                return nil
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };}, -2);
      }, -2);
      
      $def(self, '$lazy', function $$lazy() {
        var self = this;

        return self
      }, 0);
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        delete $$collect.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, self.$enumerator_size()], function $$4(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          enum$.$yield(value);
        ;}, -2);
      }, 0);
      
      $def(self, '$collect_concat', function $$collect_concat() {
        var block = $$collect_concat.$$p || nil, self = this;

        delete $$collect_concat.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$5(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], function $$6(v){
            
            
            if (v == null) v = nil;;
            return enum$.$yield(v);}, 1)
          }
          else {
            var array = $Opal.$try_convert(value, $$$('Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], function $$7(v){
            
            
            if (v == null) v = nil;;
            return enum$.$yield(v);}, 1);
            }
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$drop', function $$drop(n) {
        var self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        dropped = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$8(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      }, 1);
      
      $def(self, '$drop_while', function $$drop_while() {
        var block = $$drop_while.$$p || nil, self = this, succeeding = nil;

        delete $$drop_while.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$('Lazy'), 'new', [self, nil], function $$9(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = $yieldX(block, args);

            if (!$truthy(value)) {
              succeeding = false;

              $send(enum$, 'yield', $to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      }, 0);
      
      $def(self, '$enum_for', function $$enum_for($a, $b) {
        var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

        delete $$enum_for.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        if ($post_args.length > 0) method = $post_args.shift();
        if (method == null) method = "each";;
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat($to_a(args)), block.$to_proc());
      }, -1);
      
      $def(self, '$find_all', function $$find_all() {
        var block = $$find_all.$$p || nil, self = this;

        delete $$find_all.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$10(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$grep', function $$grep(pattern) {
        var block = $$grep.$$p || nil, self = this;

        delete $$grep.$$p;
        
        ;
        if ($truthy(block)) {
          return $send($$('Lazy'), 'new', [self, nil], function $$11(enum$, $a){var $post_args, args;

            
            
            if (enum$ == null) enum$ = nil;;
            
            $post_args = Opal.slice.call(arguments, 1);
            
            args = $post_args;;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = $yield1(block, param);

              enum$.$yield($yield1(block, param));
            }
          ;}, -2)
        } else {
          return $send($$('Lazy'), 'new', [self, nil], function $$12(enum$, $a){var $post_args, args;

            
            
            if (enum$ == null) enum$ = nil;;
            
            $post_args = Opal.slice.call(arguments, 1);
            
            args = $post_args;;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, -2)
        };
      }, 1);
      
      $def(self, '$reject', function $$reject() {
        var block = $$reject.$$p || nil, self = this;

        delete $$reject.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$13(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          if (!$truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$take', function $$take(n) {
        var self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        taken = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$14(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', $to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return $Kernel.$raise($$('StopLazyError'))
          };}, -2);
      }, 1);
      
      $def(self, '$take_while', function $$take_while() {
        var block = $$take_while.$$p || nil, self = this;

        delete $$take_while.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$15(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
          else {
            $Kernel.$raise($$('StopLazyError'));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, 0);
      $alias(self, "force", "to_a");
      $alias(self, "filter", "find_all");
      $alias(self, "flat_map", "collect_concat");
      $alias(self, "map", "collect");
      $alias(self, "select", "find_all");
      return $alias(self, "to_enum", "enum_for");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/yielder"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a;

  Opal.add_stubs('yield,proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Yielder');

      var $proto = self.$$prototype;

      $proto.block = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        ;
        self.block = block;
        return self;
      }, 0);
      
      $def(self, '$yield', function $Yielder_yield$1($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, -1);
      
      $def(self, '$<<', function $Yielder_$lt$lt$2(value) {
        var self = this;

        
        self.$yield(value);
        return self;
      }, 1);
      return $def(self, '$to_proc', function $$to_proc() {
        var self = this;

        return $send(self, 'proc', [], function $$3($a){var $post_args, values, self = $$3.$$s == null ? this : $$3.$$s;

          
          
          $post_args = Opal.slice.call(arguments);
          
          values = $post_args;;
          return $send(self, 'yield', $to_a(values));}, {$$arity: -1, $$s: self})
      }, 0);
    })($nesting[0], null)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $slice = Opal.slice, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $def = Opal.def, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $Opal = Opal.Opal, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_ge = Opal.rb_ge, $Kernel = Opal.Kernel, $rb_le = Opal.rb_le, $alias = Opal.alias;

  Opal.add_stubs('require,include,allocate,new,to_proc,!,respond_to?,empty?,nil?,+,class,__send__,call,enum_for,size,destructure,map,>=,length,raise,[],peek_values,<=,next_values,inspect,any?,autoload');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.size = $proto.args = $proto.object = $proto.method = $proto.values = $proto.cursor = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    $defs(self, '$for', function $Enumerator_for$1(object, $a, $b) {
      var block = $Enumerator_for$1.$$p || nil, $post_args, method, args, self = this;

      delete $Enumerator_for$1.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      if ($post_args.length > 0) method = $post_args.shift();
      if (method == null) method = "each";;
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;
      obj.cursor = 0;

      return obj;
    ;
    }, -2);
    
    $def(self, '$initialize', function $$initialize($a) {
      var block = $$initialize.$$p || nil, $post_args, $rest_arg, self = this;

      delete $$initialize.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      self.cursor = 0;
      if ($truthy(block)) {
        
        self.object = $send($$('Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if (($truthy(self.size) && ($not(self.size['$respond_to?']("call"))))) {
          return (self.size = $coerce_to(self.size, $$$('Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, -1);
    
    $def(self, '$each', function $$each($a) {
      var block = $$each.$$p || nil, $post_args, args, self = this;

      delete $$each.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (($truthy(block['$nil?']()) && ($truthy(args['$empty?']())))) {
        return self
      };
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat($to_a(args)))
      };
      return $send(self.object, '__send__', [self.method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$size', function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', $to_a(self.args))
      } else {
        return self.size
      }
    }, 0);
    
    $def(self, '$with_index', function $$with_index(offset) {
      var block = $$with_index.$$p || nil, self = this;

      delete $$with_index.$$p;
      
      ;
      
      if (offset == null) offset = 0;;
      offset = ($truthy(offset) ? ($coerce_to(offset, $$$('Integer'), 'to_int')) : (0));
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["with_index", offset], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, -1);
    
    $def(self, '$each_with_index', function $$each_with_index() {
      var block = $$each_with_index.$$p || nil, self = this;

      delete $$each_with_index.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send2(self, $find_super(self, 'each_with_index', $$each_with_index, false, true), 'each_with_index', [], block);
      return self.object;
    }, 0);
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      
      self.cursor = 0;
      return self;
    }, 0);
    
    $def(self, '$peek_values', function $$peek_values() {
      var self = this, $ret_or_1 = nil;

      
      self.values = ($truthy(($ret_or_1 = self.values)) ? ($ret_or_1) : ($send(self, 'map', [], function $$4($a){var $post_args, i;

        
        
        $post_args = Opal.slice.call(arguments);
        
        i = $post_args;;
        return i;}, -1)));
      if ($truthy($rb_ge(self.cursor, self.values.$length()))) {
        $Kernel.$raise($$$('StopIteration'), "iteration reached an end")
      };
      return self.values['$[]'](self.cursor);
    }, 0);
    
    $def(self, '$peek', function $$peek() {
      var self = this, values = nil;

      
      values = self.$peek_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    }, 0);
    
    $def(self, '$next_values', function $$next_values() {
      var self = this, out = nil;

      
      out = self.$peek_values();
      self.cursor = $rb_plus(self.cursor, 1);
      return out;
    }, 0);
    
    $def(self, '$next', function $$next() {
      var self = this, values = nil;

      
      values = self.$next_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    }, 0);
    
    $def(self, '$feed', function $$feed(arg) {
      var self = this;

      return self.$raise($$('NotImplementedError'), "Opal doesn't support Enumerator#feed")
    }, 1);
    
    $def(self, '$+', function $Enumerator_$plus$5(other) {
      var self = this;

      return $$$($$$('Enumerator'), 'Chain').$new(self, other)
    }, 1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      result = "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "(" + (self.args.$inspect()['$[]']($$$('Range').$new(1, -2))) + ")")
      };
      return $rb_plus(result, ">");
    }, 0);
    $alias(self, "with_object", "each_with_object");
    self.$autoload("ArithmeticSequence", "corelib/enumerator/arithmetic_sequence");
    self.$autoload("Chain", "corelib/enumerator/chain");
    self.$autoload("Generator", "corelib/enumerator/generator");
    self.$autoload("Lazy", "corelib/enumerator/lazy");
    return self.$autoload("Yielder", "corelib/enumerator/yielder");
  })('::', null, $nesting);
};

Opal.modules["corelib/numeric"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $to_ary = Opal.to_ary, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $Opal = Opal.Opal, $hash2 = Opal.hash2, $not = Opal.not, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_le = Opal.rb_le, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $alias = Opal.alias;

  Opal.add_stubs('require,include,instance_of?,class,Float,respond_to?,coerce,__send__,===,raise,equal?,-,*,div,<,-@,ceil,to_f,denominator,to_r,==,floor,/,%,Complex,zero?,numerator,abs,arg,coerce_to!,round,<=>,compare,is_a?,!,new,enum_for,to_proc,negative?,>=,<=,+,to_i,truncate,>');
  
  self.$require("corelib/comparable");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    
    self.$include($$$('Comparable'));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]
      };
      return [$Kernel.$Float(other), $Kernel.$Float(self)];
    }, 1);
    
    $def(self, '$__coerced__', function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil, $ret_or_1 = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = $to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else if (($eqeqeq("+", ($ret_or_1 = method)) || (($eqeqeq("-", $ret_or_1) || (($eqeqeq("*", $ret_or_1) || (($eqeqeq("/", $ret_or_1) || (($eqeqeq("%", $ret_or_1) || (($eqeqeq("&", $ret_or_1) || (($eqeqeq("|", $ret_or_1) || (($eqeqeq("^", $ret_or_1) || ($eqeqeq("**", $ret_or_1)))))))))))))))))) {
        return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")
      } else if (($eqeqeq(">", $ret_or_1) || (($eqeqeq(">=", $ret_or_1) || (($eqeqeq("<", $ret_or_1) || (($eqeqeq("<=", $ret_or_1) || ($eqeqeq("<=>", $ret_or_1)))))))))) {
        return $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      } else {
        return nil
      }
    }, 2);
    
    $def(self, '$<=>', function $Numeric_$lt_eq_gt$1(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0
      };
      return nil;
    }, 1);
    
    $def(self, '$+@', function $Numeric_$plus$$2() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$-@', function $Numeric_$minus$$3() {
      var self = this;

      return $rb_minus(0, self)
    }, 0);
    
    $def(self, '$%', function $Numeric_$percent$4(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, 0);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$$('Math'), 'PI')
      } else {
        return 0
      }
    }, 0);
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      return self.$to_f().$ceil(ndigits);
    }, -1);
    
    $def(self, '$conj', function $$conj() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, 0);
    
    $def(self, '$div', function $$div(other) {
      var self = this;

      
      if ($eqeq(other, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by o")
      };
      return $rb_divide(self, other).$floor();
    }, 1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, 1);
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, 1);
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      return self.$to_f().$floor(ndigits);
    }, -1);
    
    $def(self, '$i', function $$i() {
      var self = this;

      return $Kernel.$Complex(0, self)
    }, 0);
    
    $def(self, '$imag', function $$imag() {
      
      return 0
    }, 0);
    
    $def(self, '$integer?', function $Numeric_integer$ques$5() {
      
      return false
    }, 0);
    
    $def(self, '$nonzero?', function $Numeric_nonzero$ques$6() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, 0);
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, 0);
    
    $def(self, '$quo', function $$quo(other) {
      var self = this;

      return $rb_divide($Opal['$coerce_to!'](self, $$$('Rational'), "to_r"), other)
    }, 1);
    
    $def(self, '$real', function $$real() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$real?', function $Numeric_real$ques$7() {
      
      return true
    }, 0);
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self, 0]
    }, 0);
    
    $def(self, '$round', function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, -1);
    
    $def(self, '$step', function $$step($a, $b, $c) {
      var block = $$step.$$p || nil, $post_args, $kwargs, limit, step, to, by, $d, self = this, counter = nil;

      delete $$step.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) limit = $post_args.shift();;
      
      if ($post_args.length > 0) step = $post_args.shift();;
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          $Kernel.$raise($$$('TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          $Kernel.$raise($$$('ArgumentError'), "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$$('Float'), 'INFINITY') : $$$($$$('Float'), 'INFINITY')['$-@']();
        }

        $Opal.$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$$('Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if (!(block !== nil)) {
        if ((($not(limit) || ($truthy(limit['$is_a?']($$$('Numeric'))))) && (($not(step) || ($truthy(step['$is_a?']($$$('Numeric')))))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new([limit, step, ($truthy(to) ? ("to: ") : nil), ($truthy(by) ? ("by: ") : nil)], self)
        } else {
          return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
        }
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
        
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, -1);
    
    $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $Kernel.$Complex(self, 0)
    }, 0);
    
    $def(self, '$to_int', function $$to_int() {
      var self = this;

      return self.$to_i()
    }, 0);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      return self.$to_f().$truncate(ndigits);
    }, -1);
    
    $def(self, '$zero?', function $Numeric_zero$ques$8() {
      var self = this;

      return self['$=='](0)
    }, 0);
    
    $def(self, '$positive?', function $Numeric_positive$ques$9() {
      var self = this;

      return $rb_gt(self, 0)
    }, 0);
    
    $def(self, '$negative?', function $Numeric_negative$ques$10() {
      var self = this;

      return $rb_lt(self, 0)
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$finite?', function $Numeric_finite$ques$11() {
      
      return true
    }, 0);
    
    $def(self, '$infinite?', function $Numeric_infinite$ques$12() {
      
      return nil
    }, 0);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "phase", "arg");
    return $alias(self, "rectangular", "rect");
  })('::', null);
};

Opal.modules["corelib/array"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $defs = Opal.defs, $Kernel = Opal.Kernel, $def = Opal.def, $Opal = Opal.Opal, $eqeqeq = Opal.eqeqeq, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $to_a = Opal.to_a, $to_ary = Opal.to_ary, $gvars = Opal.gvars, $rb_ge = Opal.rb_ge, $rb_lt = Opal.rb_lt, $neqeq = Opal.neqeq, $alias = Opal.alias;

  Opal.add_stubs('require,include,to_a,warn,raise,replace,respond_to?,to_ary,coerce_to?,===,join,to_str,hash,<=>,==,object_id,inspect,enum_for,class,bsearch_index,to_proc,nil?,coerce_to!,>,*,enumerator_size,empty?,size,map,equal?,dup,each,reduce,-,[],dig,eql?,length,exclude_end?,flatten,__id__,&,!,intersection,to_s,new,item,max,min,>=,**,delete_if,reverse,rotate,rand,at,keep_if,shuffle!,<,sort,sort_by,!=,times,[]=,<<,uniq,|,values,is_a?,end,begin,upto,reject,pristine,singleton_class');
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    Opal.prop(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
  ;
    $defs(self, '$[]', function $Array_$$$1($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      objects = $post_args;;
      return toArraySubclass(objects, self);;
    }, -1);
    
    $def(self, '$initialize', function $$initialize(size, obj) {
      var block = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      ;
      
      if (size == null) size = nil;;
      
      if (obj == null) obj = nil;;
      
      if (obj !== nil && block !== nil) {
        $Kernel.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$$('Integer'), 'MAX')) {
        $Kernel.$raise($$$('ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$$('Integer'), 'to_int');

      if (size < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, -1);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Array'), "to_ary")
    }, 1);
    
    $def(self, '$&', function $Array_$$2(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$|', function $Array_$$3(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, 1);
    
    $def(self, '$*', function $Array_$$4(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())
      };
      other = $coerce_to(other, $$$('Integer'), 'to_int');
      if ($truthy(other < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      };
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$+', function $Array_$plus$5(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      return self.concat(other);;
    }, 1);
    
    $def(self, '$-', function $Array_$minus$6(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(other.length === 0)) {
        return self.slice()
      };
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$<<', function $Array_$lt$lt$7(object) {
      var self = this;

      
      self.push(object);
      return self;
    }, 1);
    
    $def(self, '$<=>', function $Array_$lt_eq_gt$8(other) {
      var self = this;

      
      if ($eqeqeq($$$('Array'), other)) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, 1);
    
    $def(self, '$==', function $Array_$eq_eq$9(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (index.excl_rev && index.begin !== nil) {
        from += 1;
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude || index.end === nil) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_arithmetic_seq(self, index) {
      var array, out = [], i = 0, pseudorange;

      if (index.step < 0) {
        pseudorange = {
          begin: index.range.end,
          end: index.range.begin,
          excl: false,
          excl_rev: index.range.excl
        };
        array = $array_slice_range(self, pseudorange).$reverse();
      }
      else {
        array = $array_slice_range(self, index.range);
      }

      while (i < array.length) {
        out.push(array[i]);
        i += Math.abs(index.step);
      }

      return out;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    $def(self, '$[]', function $Array_$$$10(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else if (index.$$is_arithmetic_seq) {
        return $array_slice_arithmetic_seq(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, -2);
    
    $def(self, '$[]=', function $Array_$$$eq$11(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
            var i, size = self.length;;
      if ($eqeqeq($$$('Range'), index)) {
        
        data = ($eqeqeq($$$('Array'), value) ? (value.$to_a()) : ($truthy(value['$respond_to?']("to_ary")) ? (value.$to_ary().$to_a()) : ([value])));
        
        var exclude = index.excl,
            from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int'),
            to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            $Kernel.$raise($$$('RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude || index.end === nil) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      ;
      } else {
        
        if ($truthy(extra === undefined)) {
          length = 1
        } else {
          
          length = value;
          value = extra;
          data = ($eqeqeq($$$('Array'), value) ? (value.$to_a()) : ($truthy(value['$respond_to?']("to_ary")) ? (value.$to_ary().$to_a()) : ([value])));
        };
        
        var old;

        index  = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          $Kernel.$raise($$$('IndexError'), "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      ;
      };
    }, -3);
    
    $def(self, '$any?', function $Array_any$ques$12(pattern) {
      var block = $Array_any$ques$12.$$p || nil, self = this;

      delete $Array_any$ques$12.$$p;
      
      ;
      ;
      if (self.length === 0) return false;
      return $send2(self, $find_super(self, 'any?', $Array_any$ques$12, false, true), 'any?', [pattern], block);
    }, -1);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$at', function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$$('Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    }, 1);
    
    $def(self, '$bsearch_index', function $$bsearch_index() {
      var block = $$bsearch_index.$$p || nil, self = this;

      delete $$bsearch_index.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, 0);
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this, index = nil;

      delete $$bsearch.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, 0);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      delete $$cycle.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          if ($truthy(n['$nil?']())) {
            return $$$($$$('Float'), 'INFINITY')
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$arity: 0, $$s: self})
      };
      if (($truthy(self['$empty?']()) || ($eqeq(n, 0)))) {
        return nil
      };
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, 0);
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this;

      delete $$count.$$p;
      
      ;
      ;
      if (($truthy(object !== undefined) || ($truthy(block)))) {
        return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [object], block)
      } else {
        return self.$size()
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, 1);
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      delete $$collect.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$collect!', function $Array_collect$excl$15() {
      var block = $Array_collect$excl$15.$$p || nil, self = this;

      delete $Array_collect$excl$15.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect!"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    $def(self, '$combination', function $$combination(n) {
      var $yield = $$combination.$$p || nil, self = this, num = nil;

      delete $$combination.$$p;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["combination", num], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return binomial_coefficient(self.length, num)}, {$$arity: 0, $$s: self})
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$repeated_combination', function $$repeated_combination(n) {
      var $yield = $$repeated_combination.$$p || nil, self = this, num = nil;

      delete $$repeated_combination.$$p;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_combination", num], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return binomial_coefficient(self.length + num - 1, num);}, {$$arity: 0, $$s: self})
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$compact!', function $Array_compact$excl$19() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, 0);
    
    $def(self, '$concat', function $$concat($a) {
      var $post_args, others, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      others = $send(others, 'map', [], function $$20(other){var self = $$20.$$s == null ? this : $$20.$$s;

        
        
        if (other == null) other = nil;;
        other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()
        };
        return other;}, {$$arity: 1, $$s: self});
      $send(others, 'each', [], function $$21(other){var self = $$21.$$s == null ? this : $$21.$$s;

        
        
        if (other == null) other = nil;;
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, {$$arity: 1, $$s: self});
      return self;
    }, -1);
    
    $def(self, '$delete', function $Array_delete$22(object) {
      var $yield = $Array_delete$22.$$p || nil, self = this;

      delete $Array_delete$22.$$p;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, 1);
    
    $def(self, '$delete_at', function $$delete_at(index) {
      var self = this;

      
      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, 1);
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      delete $$delete_if.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["delete_if"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      filterIf(self, $falsy, block);
      return self;
    }, 0);
    
    $def(self, '$difference', function $$difference($a) {
      var $post_args, arrays, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$24(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return $rb_minus(a, b);}, 2);
    }, -1);
    
    $def(self, '$dig', function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      idxs = $post_args;;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(idxs));
    }, -2);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');

      if (number < 0) {
        $Kernel.$raise($$$('ArgumentError'))
      }

      return self.slice(number);
    
    }, 1);
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this;

      delete $$dup.$$p;
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
    }, 0);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      delete $$each.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$each_index', function $$each_index() {
      var block = $$each_index.$$p || nil, self = this;

      delete $$each_index.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_index"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, i);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$empty?', function $Array_empty$ques$27() {
      var self = this;

      return self.length === 0;
    }, 0);
    
    $def(self, '$eql?', function $Array_eql$ques$28(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, 1);
    
    $def(self, '$fetch', function $$fetch(index, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      delete $$fetch.$$p;
      
      ;
      ;
      
      var original = index;

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, -2);
    
    $def(self, '$fill', function $$fill($a) {
      var block = $$fill.$$p || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      delete $$fill.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
            var i, length, value;;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 0..2)")
        };
        $c = args, $b = $to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 1..3)")
        };
        $c = args, $b = $to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($eqeqeq($$$('Range'), one)) {
        
        if ($truthy(two)) {
          $Kernel.$raise($$$('TypeError'), "length invalid with range")
        };
        left = one.begin === nil ? 0 : $coerce_to(one.begin, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          $Kernel.$raise($$$('RangeError'), "" + (one.$inspect()) + " out of range")
        };
        right = one.end === nil ? -1 : $coerce_to(one.end, $$$('Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length
        };
        if (!$truthy(one['$exclude_end?']())) {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self
        };
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          left = 0
        };
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$$('Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self
          };
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      
      };
      if ($truthy(right > this.length)) {
        this.length = right
      };
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, -1);
    
    $def(self, '$first', function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            $Kernel.$raise($$$('TypeError'));
          }

          if (ary === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$$('Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, -1);
    
    $def(self, '$flatten!', function $Array_flatten$excl$29(level) {
      var self = this;

      
      ;
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          $hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if ($hash_ids[hash_id]) {
          return 'self';
        }

        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    }, 0);
    
    $def(self, '$include?', function $Array_include$ques$30(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$index', function $$index(object) {
      var block = $$index.$$p || nil, self = this;

      delete $$index.$$p;
      
      ;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$insert', function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      objects = $post_args;;
      
      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, -2);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var result = [],
      id = self.$__id__(),
      pushed = true;
    ;
      
      return (function() { try {
      
      
        if (inspect_stack.indexOf(id) !== -1) {
          pushed = false;
          return '[...]';
        }
        inspect_stack.push(id)

        for (var i = 0, length = self.length; i < length; i++) {
          var item = self['$[]'](i);

          result.push($$('Opal').$inspect(item));
        }

        return '[' + result.join(', ') + ']';
      ;
      return nil;
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, 0);
    
    $def(self, '$intersection', function $$intersection($a) {
      var $post_args, arrays, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$31(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return a['$&'](b);}, 2);
    }, -1);
    
    $def(self, '$intersect?', function $Array_intersect$ques$32(other) {
      var self = this;

      return self.$intersection(other)['$empty?']()['$!']()
    }, 1);
    
    $def(self, '$join', function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      if (sep == null) sep = nil;;
      if ($truthy(self.length === 0)) {
        return ""
      };
      if ($truthy(sep === nil)) {
        sep = $gvars[","]
      };
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        $Kernel.$raise($$$('NoMethodError').$new("" + ($$('Opal').$inspect(self.$item())) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($Opal['$coerce_to!'](sep, $$$('String'), "to_str").$to_s());
      }
    ;
    }, -1);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      delete $$keep_if.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["keep_if"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      filterIf(self, $truthy, block);
      return self;
    }, 0);
    
    $def(self, '$last', function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    }, 0);
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      delete $$max.$$p;
      
      ;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, -1);
    
    $def(self, '$min', function $$min() {
      var block = $$min.$$p || nil, self = this;

      delete $$min.$$p;
      
      ;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    $def(self, '$permutation', function $$permutation(num) {
      var block = $$permutation.$$p || nil, self = this, perm = nil, used = nil;

      delete $$permutation.$$p;
      
      ;
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["permutation", num], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          return descending_factorial(self.length, num === undefined ? self.length : num);}, {$$arity: 0, $$s: self})
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$$('Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$('Array').$new(num));
        (used = $$('Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$repeated_permutation', function $$repeated_permutation(n) {
      var $yield = $$repeated_permutation.$$p || nil, self = this, num = nil;

      delete $$repeated_permutation.$$p;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_permutation", num], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, {$$arity: 0, $$s: self})
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, 1);
    
    $def(self, '$pop', function $$pop(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return self.pop();
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, -1);
    
    $def(self, '$product', function $$product($a) {
      var block = $$product.$$p || nil, $post_args, args, self = this;

      delete $$product.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$$('Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          $Kernel.$raise($$$('RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, -1);
    
    $def(self, '$push', function $$push($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      objects = $post_args;;
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      delete $$reject.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$36(){var self = $$36.$$s == null ? this : $$36.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, 0);
    
    $def(self, '$reject!', function $Array_reject$excl$37() {
      var block = $Array_reject$excl$37.$$p || nil, self = this, original = nil;

      delete $Array_reject$excl$37.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject!"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$length(), original)) {
        return nil
      } else {
        return self
      };
    }, 0);
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, 1);
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, 0);
    
    $def(self, '$reverse!', function $Array_reverse$excl$39() {
      var self = this;

      return self.reverse();
    }, 0);
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      delete $$reverse_each.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$rindex', function $$rindex(object) {
      var block = $$rindex.$$p || nil, self = this;

      delete $$rindex.$$p;
      
      ;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$rotate', function $$rotate(n) {
      var self = this;

      
      
      if (n == null) n = 1;;
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$$('Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, -1);
    
    $def(self, '$rotate!', function $Array_rotate$excl$41(cnt) {
      var self = this, ary = nil;

      
      
      if (cnt == null) cnt = 1;;
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$$('Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, -1);
    (function($base, $super) {
      var self = $klass($base, $super, 'SampleRandom');

      var $proto = self.$$prototype;

      $proto.rng = nil;
      
      
      $def(self, '$initialize', function $$initialize(rng) {
        var self = this;

        return (self.rng = rng)
      }, 1);
      return $def(self, '$rand', function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$$('Integer'), 'to_int');
        if ($truthy(random < 0)) {
          $Kernel.$raise($$$('RangeError'), "random value must be >= 0")
        };
        if (!$truthy(random < size)) {
          $Kernel.$raise($$$('RangeError'), "random value must be less than Array size")
        };
        return random;
      }, 1);
    })(self, null);
    
    $def(self, '$sample', function $$sample(count, options) {
      var self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($Kernel.$rand(self.length))
      };
      if ($truthy(options === undefined)) {
        if ($truthy((o = $Opal['$coerce_to?'](count, $$$('Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$$('Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$$('Integer'), 'to_int');
        options = $coerce_to(options, $$$('Hash'), 'to_hash');
      };
      if (($truthy(count) && ($truthy(count < 0)))) {
        $Kernel.$raise($$$('ArgumentError'), "count must be greater than 0")
      };
      if ($truthy(options)) {
        rng = options['$[]']("random")
      };
      rng = (($truthy(rng) && ($truthy(rng['$respond_to?']("rand")))) ? ($$('SampleRandom').$new(rng)) : ($Kernel));
      if (!$truthy(count)) {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$('Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, -1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      delete $$select.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select"], function $$42(){var self = $$42.$$s == null ? this : $$42.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$select!', function $Array_select$excl$43() {
      var block = $Array_select$excl$43.$$p || nil, self = this;

      delete $Array_select$excl$43.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select!"], function $$44(){var self = $$44.$$s == null ? this : $$44.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, 0);
    
    $def(self, '$shift', function $$shift(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return shiftNoArg(self);
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      return self.splice(0, count);;
    }, -1);
    
    $def(self, '$shuffle', function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, -1);
    
    $def(self, '$shuffle!', function $Array_shuffle$excl$45(rng) {
      var self = this;

      
      ;
      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $Opal['$coerce_to?'](rng, $$$('Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            $Kernel.$raise($$$('RangeError'), "random number too small " + (j))
          }

          if (j >= i) {
            $Kernel.$raise($$$('RangeError'), "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$slice!', function $Array_slice$excl$46(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      result = nil;
      if ($truthy(length === undefined)) {
        if ($eqeqeq($$$('Range'), index)) {
          
          range = index;
          result = self['$[]'](range);
          range_start = range.begin === nil ? 0 : $coerce_to(range.begin, $$$('Integer'), 'to_int');
          range_end = range.end === nil ? -1 : $coerce_to(range.end, $$$('Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl && range.end !== nil) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, -2);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this;

      delete $$sort.$$p;
      
      ;
      if (!$truthy(self.length > 1)) {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, 0);
    
    $def(self, '$sort!', function $Array_sort$excl$47() {
      var block = $Array_sort$excl$47.$$p || nil, self = this;

      delete $Array_sort$excl$47.$$p;
      
      ;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$sort_by!', function $Array_sort_by$excl$48() {
      var block = $Array_sort_by$excl$48.$$p || nil, self = this;

      delete $Array_sort_by$excl$48.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by!"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, 0);
    
    $def(self, '$take', function $$take(count) {
      var self = this;

      
      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'));
      }

      return self.slice(0, count);
    
    }, 1);
    
    $def(self, '$take_while', function $$take_while() {
      var block = $$take_while.$$p || nil, self = this;

      delete $$take_while.$$p;
      
      ;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    }, 0);
    
    $def(self, '$to_ary', function $$to_ary() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this, array = nil;

      delete $$to_h.$$p;
      
      ;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())
      };
      
      var i, len = array.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $Opal['$coerce_to?'](array[i], $$$('Array'), "to_ary");
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$transpose', function $$transpose() {
      var self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []
      };
      result = [];
      max = nil;
      $send(self, 'each', [], function $$50(row){var $ret_or_1 = nil;

        
        
        if (row == null) row = nil;;
        row = ($eqeqeq($$$('Array'), row) ? (row.$to_a()) : (($coerce_to(row, $$$('Array'), 'to_ary')).$to_a()));
        max = ($truthy(($ret_or_1 = max)) ? ($ret_or_1) : (row.length));
        if ($neqeq(row.length, max)) {
          $Kernel.$raise($$$('IndexError'), "element size differs (" + (row.length) + " should be " + (max) + ")")
        };
        return $send((row.length), 'times', [], function $$51(i){var entry = nil, $writer = nil;

          
          
          if (i == null) i = nil;;
          entry = ($truthy(($ret_or_1 = result['$[]'](i))) ? ($ret_or_1) : ((($writer = [i, []]), $send(result, '[]=', $to_a($writer)), $writer[$rb_minus($writer["length"], 1)])));
          return entry['$<<'](row.$at(i));}, 1);}, 1);
      return result;
    }, 0);
    
    $def(self, '$union', function $$union($a) {
      var $post_args, arrays, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$uniq()], function $$52(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return a['$|'](b);}, 2);
    }, -1);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this;

      delete $$uniq.$$p;
      
      ;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    }, 0);
    
    $def(self, '$uniq!', function $Array_uniq$excl$53() {
      var block = $Array_uniq$excl$53.$$p || nil, self = this;

      delete $Array_uniq$excl$53.$$p;
      
      ;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, 0);
    
    $def(self, '$unshift', function $$unshift($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      objects = $post_args;;
      
      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, -1);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this, out = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      out = [];
      $send(args, 'each', [], function $$54(elem){var self = $$54.$$s == null ? this : $$54.$$s, finish = nil, start = nil, i = nil;

        
        
        if (elem == null) elem = nil;;
        if ($truthy(elem['$is_a?']($$$('Range')))) {
          
          finish = elem.$end() === nil ? -1 : $coerce_to(elem.$end(), $$$('Integer'), 'to_int');
          start = elem.$begin() === nil ? 0 : $coerce_to(elem.$begin(), $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']() && elem.$end() !== nil) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], function $$55(i){var self = $$55.$$s == null ? this : $$55.$$s;

            
            
            if (i == null) i = nil;;
            return out['$<<'](self.$at(i));}, {$$arity: 1, $$s: self});
        } else {
          
          i = $coerce_to(elem, $$$('Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, {$$arity: 1, $$s: self});
      return out;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this, $ret_or_1 = nil;

      delete $$zip.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = ($truthy(($ret_or_1 = $Opal['$coerce_to?'](o, $$$('Array'), "to_ary"))) ? ($ret_or_1) : ($Opal['$coerce_to!'](o, $$$('Enumerator'), "to_enum", "each"))).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          Opal.yield1(block, result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, -1);
    $defs(self, '$inherited', function $$inherited(klass) {
      
      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, 1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var $yield = $$instance_variables.$$p || nil, self = this;

      delete $$instance_variables.$$p;
      return $send($send2(self, $find_super(self, 'instance_variables', $$instance_variables, false, true), 'instance_variables', [], $yield), 'reject', [], function $$56(ivar){var $ret_or_1 = nil;

        
        
        if (ivar == null) ivar = nil;;
        if ($truthy(($ret_or_1 = /^@\d+$/.test(ivar)))) {
          return $ret_or_1
        } else {
          return ivar['$==']("@length")
        };}, 1)
    }, 0);
    
    $def(self, '$pack', function $$pack($a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $Kernel.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, -1);
    $alias(self, "append", "push");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "map", "collect");
    $alias(self, "map!", "collect!");
    $alias(self, "prepend", "unshift");
    $alias(self, "size", "length");
    $alias(self, "slice", "[]");
    $alias(self, "to_s", "inspect");
    $Opal.$pristine(self.$singleton_class(), "allocate");
    return $Opal.$pristine(self, "copy_instance_variables", "initialize_dup");
  })('::', Array, $nesting);
};

Opal.modules["corelib/hash"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $yield1 = Opal.yield1, $hash = Opal.hash, $hash_init = Opal.hash_init, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $hash2 = Opal.hash2, $truthy = Opal.truthy, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, $alias = Opal.alias;

  Opal.add_stubs('require,include,coerce_to?,[],merge!,allocate,raise,coerce_to!,each,fetch,>=,>,==,compare_by_identity,lambda?,abs,arity,enum_for,size,respond_to?,class,dig,except!,dup,delete,new,inspect,map,to_proc,flatten,eql?,default,default_proc,default_proc=,-,default=,to_h,proc');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_hash = true;
    $defs(self, '$[]', function $Hash_$$$1($a) {
      var $post_args, argv, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      argv = $post_args;;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Array'), "to_ary");
        if (argv === nil) {
          $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            $Kernel.$raise($$$('ArgumentError'), "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, -1);
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      $hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, 0);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Hash'), "to_hash")
    }, 1);
    
    $def(self, '$initialize', function $$initialize(defaults) {
      var block = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      ;
      ;
      
      if (defaults !== undefined && block !== nil) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, -1);
    
    $def(self, '$==', function $Hash_$eq_eq$2(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = $hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, 1);
    
    $def(self, '$>=', function $Hash_$gt_eq$3(other) {
      var self = this, result = nil;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], function $$4(other_key, other_val){var self = $$4.$$s == null ? this : $$4.$$s, val = nil;

        
        
        if (other_key == null) other_key = nil;;
        
        if (other_val == null) other_val = nil;;
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, {$$arity: 2, $$s: self});
      return result;
    }, 1);
    
    $def(self, '$>', function $Hash_$gt$5(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, 1);
    
    $def(self, '$<', function $Hash_$lt$6(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_gt(other, self);
    }, 1);
    
    $def(self, '$<=', function $Hash_$lt_eq$7(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_ge(other, self);
    }, 1);
    
    $def(self, '$[]', function $Hash_$$$8(key) {
      var self = this;

      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, 1);
    
    $def(self, '$[]=', function $Hash_$$$eq$9(key, value) {
      var self = this;

      
      $hash_put(self, key, value);
      return value;
    
    }, 2);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $hash_init(self);
      return self;
    
    }, 0);
    
    $def(self, '$clone', function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, 0);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, 0);
    
    $def(self, '$compact!', function $Hash_compact$excl$10() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, 0);
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        $hash_put(identity_hash, key, $hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, 0);
    
    $def(self, '$compare_by_identity?', function $Hash_compare_by_identity$ques$11() {
      var self = this;

      return self.$$by_identity === true;
    }, 0);
    
    $def(self, '$default', function $Hash_default$12(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, -1);
    
    $def(self, '$default=', function $Hash_default$eq$13(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, 1);
    
    $def(self, '$default_proc', function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, 0);
    
    $def(self, '$default_proc=', function $Hash_default_proc$eq$14(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = $Opal['$coerce_to!'](proc, $$$('Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          $Kernel.$raise($$$('TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, 1);
    
    $def(self, '$delete', function $Hash_delete$15(key) {
      var block = $Hash_delete$15.$$p || nil, self = this;

      delete $Hash_delete$15.$$p;
      
      ;
      
      var value = $hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, 1);
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      delete $$delete_if.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["delete_if"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      keys = $post_args;;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      delete $$each.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each"], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $yield1(block, [key, value]);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$each_key', function $$each_key() {
      var block = $$each_key.$$p || nil, self = this;

      delete $$each_key.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_key"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$each_value', function $$each_value() {
      var block = $$each_value.$$p || nil, self = this;

      delete $$each_value.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_value"], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$empty?', function $Hash_empty$ques$20() {
      var self = this;

      return self.$$keys.length === 0;
    }, 0);
    
    $def(self, '$except', function $$except($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      keys = $post_args;;
      return $send(self.$dup(), 'except!', $to_a(keys));
    }, -1);
    
    $def(self, '$except!', function $Hash_except$excl$21($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      keys = $post_args;;
      $send(keys, 'each', [], function $$22(key){var self = $$22.$$s == null ? this : $$22.$$s;

        
        
        if (key == null) key = nil;;
        return self.$delete(key);}, {$$arity: 1, $$s: self});
      return self;
    }, -1);
    
    $def(self, '$fetch', function $$fetch(key, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      delete $$fetch.$$p;
      
      ;
      ;
      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return $Kernel.$raise($$$('KeyError').$new("key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, -2);
    
    $def(self, '$fetch_values', function $$fetch_values($a) {
      var block = $$fetch_values.$$p || nil, $post_args, keys, self = this;

      delete $$fetch_values.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      keys = $post_args;;
      return $send(keys, 'map', [], function $$23(key){var self = $$23.$$s == null ? this : $$23.$$s;

        
        
        if (key == null) key = nil;;
        return $send(self, 'fetch', [key], block.$to_proc());}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      
      if (level == null) level = 1;;
      level = $Opal['$coerce_to!'](level, $$$('Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$has_key?', function $Hash_has_key$ques$24(key) {
      var self = this;

      return $hash_get(self, key) !== undefined;
    }, 1);
    
    $def(self, '$has_value?', function $Hash_has_value$ques$25(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, 0);
    
    $def(self, '$index', function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$indexes', function $$indexes($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = $hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    var inspect_ids;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];
    ;
      
      return (function() { try {
      
      
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          key = $$('Opal').$inspect(key)
          value = $$('Opal').$inspect(value)

          result.push(key + '=>' + value);
        }

        return '{' + result.join(', ') + '}';
      ;
      return nil;
      } finally {
        if (top) inspect_ids = undefined
      }; })();;
    }, 0);
    
    $def(self, '$invert', function $$invert() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $hash_put(hash, value, key);
      }

      return hash;
    
    }, 0);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      delete $$keep_if.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["keep_if"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$$keys.length;
    }, 0);
    
    $def(self, '$merge', function $$merge($a) {
      var block = $$merge.$$p || nil, $post_args, others, self = this;

      delete $$merge.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      return $send(self.$dup(), 'merge!', $to_a(others), block.$to_proc());
    }, -1);
    
    $def(self, '$merge!', function $Hash_merge$excl$27($a) {
      var block = $Hash_merge$excl$27.$$p || nil, $post_args, others, self = this;

      delete $Hash_merge$excl$27.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      
      var i, j, other, other_keys, length, key, value, other_value;
      for (i = 0; i < others.length; ++i) {
        other = $Opal['$coerce_to!'](others[i], $$$('Hash'), "to_hash");
        other_keys = other.$$keys, length = other_keys.length;

        if (block === nil) {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            $hash_put(self, key, other_value);
          }
        } else {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            value = $hash_get(self, key);

            if (value === undefined) {
              $hash_put(self, key, other_value);
              continue;
            }

            $hash_put(self, key, block(key, value, other_value));
          }
        }
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$rehash', function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, 0);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      delete $$reject.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject"], function $$28(){var self = $$28.$$s == null ? this : $$28.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$reject!', function $Hash_reject$excl$29() {
      var block = $Hash_reject$excl$29.$$p || nil, self = this;

      delete $Hash_reject$excl$29.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject!"], function $$30(){var self = $$30.$$s == null ? this : $$30.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, 0);
    
    $def(self, '$replace', function $$replace(other) {
      var self = this, $writer = nil;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      $hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        $hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        
        $writer = [other.$default_proc()];
        $send(self, 'default_proc=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      } else {
        
        $writer = [other.$default()];
        $send(self, 'default=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return self;
    }, 1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      delete $$select.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$select!', function $Hash_select$excl$32() {
      var block = $Hash_select$excl$32.$$p || nil, self = this;

      delete $Hash_select$excl$32.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select!"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$shift', function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, $hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, 0);
    
    $def(self, '$slice', function $$slice($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      keys = $post_args;;
      
      var result = $hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = $hash_get(self, key);

        if (value !== undefined) {
          $hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      delete $$to_h.$$p;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()
      };
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    ;
    }, 0);
    
    $def(self, '$to_hash', function $$to_hash() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return $send(self, 'proc', [], function $$34(key){var self = $$34.$$s == null ? this : $$34.$$s;

        
        ;
        
        if (key == null) {
          $Kernel.$raise($$$('ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, {$$arity: -1, $$s: self})
    }, 0);
    
    $def(self, '$transform_keys', function $$transform_keys() {
      var block = $$transform_keys.$$p || nil, self = this;

      delete $$transform_keys.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = $yield1(block, key);

        $hash_put(result, key, value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$transform_keys!', function $Hash_transform_keys$excl$36() {
      var block = $Hash_transform_keys$excl$36.$$p || nil, self = this;

      delete $Hash_transform_keys$excl$36.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = $yield1(block, key);

        $hash_delete(self, key);
        $hash_put(self, new_key, value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$transform_values', function $$transform_values() {
      var block = $$transform_values.$$p || nil, self = this;

      delete $$transform_values.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(result, key, value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$transform_values!', function $Hash_transform_values$excl$39() {
      var block = $Hash_transform_values$excl$39.$$p || nil, self = this;

      delete $Hash_transform_values$excl$39.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values!"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(self, key, value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$values', function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, 0);
    $alias(self, "dup", "clone");
    $alias(self, "each_pair", "each");
    $alias(self, "eql?", "==");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "include?", "has_key?");
    $alias(self, "indices", "indexes");
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");
    $alias(self, "member?", "has_key?");
    $alias(self, "size", "length");
    $alias(self, "store", "[]=");
    $alias(self, "to_s", "inspect");
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    return $alias(self, "values_at", "indexes");
  })('::', null, $nesting);
};

Opal.modules["corelib/number"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $not = Opal.not, $rb_lt = Opal.rb_lt, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $to_ary = Opal.to_ary, $rb_times = Opal.rb_times, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $alias = Opal.alias, $const_set = Opal.const_set;

  Opal.add_stubs('require,bridge,raise,name,class,Float,respond_to?,coerce_to!,__coerced__,===,>,!,**,new,<,to_f,==,nan?,infinite?,enum_for,+,-,gcd,lcm,%,/,frexp,to_i,ldexp,rationalize,*,<<,to_r,truncate,-@,size,<=,>=,inspect,coerce_to?');
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting);

    
    $Opal.$bridge(Number, self);
    Opal.prop(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [$Kernel.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$Opal['$coerce_to!'](other, $$$('Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
    
    }, 1);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, 0);
    
    $def(self, '$+', function $Number_$plus$1(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, 1);
    
    $def(self, '$-', function $Number_$minus$2(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, 1);
    
    $def(self, '$*', function $Number_$$3(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, 1);
    
    $def(self, '$/', function $Number_$slash$4(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, 1);
    
    $def(self, '$%', function $Number_$percent$5(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, 1);
    
    $def(self, '$&', function $Number_$$6(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, 1);
    
    $def(self, '$|', function $Number_$$7(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, 1);
    
    $def(self, '$^', function $Number_$$8(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, 1);
    
    $def(self, '$<', function $Number_$lt$9(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, 1);
    
    $def(self, '$<=', function $Number_$lt_eq$10(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, 1);
    
    $def(self, '$>', function $Number_$gt$11(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, 1);
    
    $def(self, '$>=', function $Number_$gt_eq$12(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    $def(self, '$<=>', function $Number_$lt_eq_gt$13(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$<<', function $Number_$lt$lt$14(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, 1);
    
    $def(self, '$>>', function $Number_$gt$gt$15(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, 1);
    
    $def(self, '$[]', function $Number_$$$16(bit) {
      var self = this;

      
      bit = $Opal['$coerce_to!'](bit, $$$('Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, 1);
    
    $def(self, '$+@', function $Number_$plus$$17() {
      var self = this;

      return +self;
    }, 0);
    
    $def(self, '$-@', function $Number_$minus$$18() {
      var self = this;

      return -self;
    }, 0);
    
    $def(self, '$~', function $Number_$$19() {
      var self = this;

      return ~self;
    }, 0);
    
    $def(self, '$**', function $Number_$$$20(other) {
      var self = this;

      if ($eqeqeq($$$('Integer'), other)) {
        if (($not($$$('Integer')['$==='](self)) || ($truthy($rb_gt(other, 0))))) {
          return Math.pow(self, other);
        } else {
          return $$$('Rational').$new(self, 1)['$**'](other)
        }
      } else if (($rb_lt(self, 0) && (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))))) {
        return $$$('Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, 1);
    
    $def(self, '$===', function $Number_$eq_eq_eq$21(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, 1);
    
    $def(self, '$==', function $Number_$eq_eq$22(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return Math.abs(self);
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, 0);
    
    $def(self, '$allbits?', function $Number_allbits$ques$23(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == mask;;
    }, 1);
    
    $def(self, '$anybits?', function $Number_anybits$ques$24(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) !== 0;;
    }, 1);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self
      };
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, 0);
    
    $def(self, '$bit_length', function $$bit_length() {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), self)) {
        $Kernel.$raise($$$('NoMethodError').$new("undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$chr', function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCharCode(self), encoding || "BINARY");;
    }, -1);
    
    $def(self, '$denominator', function $$denominator() {
      var $yield = $$denominator.$$p || nil, self = this;

      delete $$denominator.$$p;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return 1
      } else {
        return $send2(self, $find_super(self, 'denominator', $$denominator, false, true), 'denominator', [], $yield)
      }
    }, 0);
    
    $def(self, '$downto', function $$downto(stop) {
      var block = $$downto.$$p || nil, self = this;

      delete $$downto.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["downto", stop], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$equal?', function $Number_equal$ques$26(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$=='](other)))) {
        return $ret_or_1
      } else {
        return isNaN(self) && isNaN(other);
      }
    }, 1);
    
    $def(self, '$even?', function $Number_even$ques$27() {
      var self = this;

      return self % 2 === 0;
    }, 0);
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$gcd', function $$gcd(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, 1);
    
    $def(self, '$gcdlcm', function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    }, 1);
    
    $def(self, '$integer?', function $Number_integer$ques$28() {
      var self = this;

      return self % 1 === 0;
    }, 0);
    
    $def(self, '$is_a?', function $Number_is_a$ques$29(klass) {
      var $yield = $Number_is_a$ques$29.$$p || nil, self = this;

      delete $Number_is_a$ques$29.$$p;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'is_a?', $Number_is_a$ques$29, false, true), 'is_a?', [klass], $yield);
    }, 1);
    
    $def(self, '$instance_of?', function $Number_instance_of$ques$30(klass) {
      var $yield = $Number_instance_of$ques$30.$$p || nil, self = this;

      delete $Number_instance_of$ques$30.$$p;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'instance_of?', $Number_instance_of$ques$30, false, true), 'instance_of?', [klass], $yield);
    }, 1);
    
    $def(self, '$lcm', function $$lcm(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, 1);
    
    $def(self, '$next', function $$next() {
      var self = this;

      return self + 1;
    }, 0);
    
    $def(self, '$nobits?', function $Number_nobits$ques$31(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == 0;;
    }, 1);
    
    $def(self, '$nonzero?', function $Number_nonzero$ques$32() {
      var self = this;

      return self == 0 ? nil : self;
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var $yield = $$numerator.$$p || nil, self = this;

      delete $$numerator.$$p;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return self
      } else {
        return $send2(self, $find_super(self, 'numerator', $$numerator, false, true), 'numerator', [], $yield)
      }
    }, 0);
    
    $def(self, '$odd?', function $Number_odd$ques$33() {
      var self = this;

      return self % 2 !== 0;
    }, 0);
    
    $def(self, '$ord', function $$ord() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$pow', function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$$('Integer')['$==='](b))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$$('Integer')['$==='](m))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, -2);
    
    $def(self, '$pred', function $$pred() {
      var self = this;

      return self - 1;
    }, 0);
    
    $def(self, '$quo', function $$quo(other) {
      var $yield = $$quo.$$p || nil, self = this;

      delete $$quo.$$p;
      if ($eqeqeq($$$('Integer'), self)) {
        return $send2(self, $find_super(self, 'quo', $$quo, false, true), 'quo', [other], $yield)
      } else {
        return $rb_divide(self, other)
      }
    }, 1);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$$('Float'), 'MANT_DIG'));
        return $$$('Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$$('Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, -1);
    
    $def(self, '$remainder', function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, 1);
    
    $def(self, '$round', function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($eqeqeq($$$('Integer'), self)) {
        
        if ($truthy(ndigits == null)) {
          return self
        };
        if (($eqeqeq($$$('Float'), ndigits) && ($truthy(ndigits['$infinite?']())))) {
          $Kernel.$raise($$$('RangeError'), "Infinity")
        };
        ndigits = $Opal['$coerce_to!'](ndigits, $$$('Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$$('Integer'), 'MIN')))) {
          $Kernel.$raise($$$('RangeError'), "out of bounds")
        };
        if ($truthy(ndigits >= 0)) {
          return self
        };
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if (($truthy(self['$nan?']()) && ($truthy(ndigits == null)))) {
          $Kernel.$raise($$$('FloatDomainError'), "NaN")
        };
        ndigits = $Opal['$coerce_to!'](ndigits || 0, $$$('Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            $Kernel.$raise($$$('RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            $Kernel.$raise($$$('FloatDomainError'), "Infinity")
          }
        } else if ($eqeq(ndigits, 0)) {
          return Math.round(self)
        } else if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
          return self
        };
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$$('Float'), 'DIG'), 2), ($truthy($rb_gt(exp, 0)) ? ($rb_divide(exp, 4)) : ($rb_minus($rb_divide(exp, 3), 1))))))) {
          return self
        };
        if ($truthy($rb_lt(ndigits, ($truthy($rb_gt(exp, 0)) ? ($rb_plus($rb_divide(exp, 3), 1)) : ($rb_divide(exp, 4)))['$-@']()))) {
          return 0
        };
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, -1);
    
    $def(self, '$times', function $$times() {
      var block = $$times.$$p || nil, self = this;

      delete $$times.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["times"], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          return self}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    }, 0);
    
    $def(self, '$to_r', function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$$('Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$$('Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, 0);
    
    $def(self, '$to_s', function $$to_s(base) {
      var self = this;

      
      
      if (base == null) base = 10;;
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if (($truthy($rb_lt(base, 2)) || ($truthy($rb_gt(base, 36))))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      if (($eqeq(self, 0) && ($truthy(1/self === -Infinity)))) {
        return "-0.0"
      };
      return self.toString(base);;
    }, -1);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$digits', function $$digits(base) {
      var self = this;

      
      
      if (base == null) base = 10;;
      if ($rb_lt(self, 0)) {
        $Kernel.$raise($$$($$$('Math'), 'DomainError'), "out of domain")
      };
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      
      if (self != parseInt(self)) $Kernel.$raise($$$('NoMethodError'), "undefined method `digits' for " + (self.$inspect()))

      var value = self, result = [];

      if (self == 0) {
        return [0];
      }

      while (value != 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var $yield = $$divmod.$$p || nil, self = this;

      delete $$divmod.$$p;
      if (($truthy(self['$nan?']()) || ($truthy(other['$nan?']())))) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else {
        return $send2(self, $find_super(self, 'divmod', $$divmod, false, true), 'divmod', [other], $yield)
      }
    }, 1);
    
    $def(self, '$upto', function $$upto(stop) {
      var block = $$upto.$$p || nil, self = this;

      delete $$upto.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["upto", stop], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$zero?', function $Number_zero$ques$36() {
      var self = this;

      return self == 0;
    }, 0);
    
    $def(self, '$size', function $$size() {
      
      return 4
    }, 0);
    
    $def(self, '$nan?', function $Number_nan$ques$37() {
      var self = this;

      return isNaN(self);
    }, 0);
    
    $def(self, '$finite?', function $Number_finite$ques$38() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, 0);
    
    $def(self, '$infinite?', function $Number_infinite$ques$39() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, 0);
    
    $def(self, '$positive?', function $Number_positive$ques$40() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, 0);
    
    $def(self, '$negative?', function $Number_negative$ques$41() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, 0);
    $alias(self, "arg", "angle");
    $alias(self, "eql?", "==");
    $alias(self, "fdiv", "/");
    $alias(self, "inspect", "to_s");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "object_id", "__id__");
    $alias(self, "phase", "angle");
    $alias(self, "succ", "next");
    return $alias(self, "to_int", "to_i");
  })('::', $$$('Numeric'), $nesting);
  $const_set('::', 'Fixnum', $$$('Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      Opal.udef(self, '$' + "new");;
      
      $def(self, '$sqrt', function $$sqrt(n) {
        
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        
        if (n < 0) {
          $Kernel.$raise($$$($$$('Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, 1);
      return $def(self, '$try_convert', function $$try_convert(object) {
        var self = this;

        return $$('Opal')['$coerce_to?'](object, self, "to_int")
      }, 1);
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'MAX', Math.pow(2, 30) - 1);
    return $const_set(self, 'MIN', -Math.pow(2, 30));
  })('::', $$$('Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      Opal.udef(self, '$' + "new");;
      return $def(self, '$===', function $eq_eq_eq$42(other) {
        
        return !!other.$$is_number;
      }, 1);
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'INFINITY', Infinity);
    $const_set(self, 'MAX', Number.MAX_VALUE);
    $const_set(self, 'MIN', Number.MIN_VALUE);
    $const_set(self, 'NAN', NaN);
    $const_set(self, 'DIG', 15);
    $const_set(self, 'MANT_DIG', 53);
    $const_set(self, 'RADIX', 2);
    return $const_set(self, 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/range"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $send = Opal.send, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $Opal = Opal.Opal, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $rb_times = Opal.rb_times, $rb_ge = Opal.rb_ge, $alias = Opal.alias;

  Opal.add_stubs('require,include,attr_reader,raise,nil?,<=>,include?,!,<,<=,enum_for,size,upto,to_proc,respond_to?,class,succ,==,===,exclude_end?,eql?,begin,end,last,to_a,>,-@,-,to_i,coerce_to!,ceil,/,is_a?,new,loop,+,*,>=,each_with_index,%,step,bsearch,inspect,[],hash');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.begin = $proto.end = $proto.excl = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    $def(self, '$initialize', function $$initialize(first, last, exclude) {
      var self = this;

      
      
      if (exclude == null) exclude = false;;
      if ($truthy(self.begin)) {
        $Kernel.$raise($$$('NameError'), "'initialize' called twice")
      };
      if (!(($truthy(first['$<=>'](last)) || ($truthy(first['$nil?']()))) || ($truthy(last['$nil?']())))) {
        $Kernel.$raise($$$('ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, -3);
    
    $def(self, '$===', function $Range_$eq_eq_eq$1(value) {
      var self = this;

      return self['$include?'](value)
    }, 1);
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    $def(self, '$count', function $$count() {
      var block = $$count.$$p || nil, self = this;

      delete $$count.$$p;
      
      ;
      if (($not((block !== nil)) && ($truthy(is_infinite(self))))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [], block);
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var $yield = $$to_a.$$p || nil, self = this;

      delete $$to_a.$$p;
      
      if ($truthy(is_infinite(self))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert endless range to an array")
      };
      return $send2(self, $find_super(self, 'to_a', $$to_a, false, true), 'to_a', [], $yield);
    }, 0);
    
    $def(self, '$cover?', function $Range_cover$ques$2(value) {
      var self = this, beg_cmp = nil, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, end_cmp = nil;

      
      beg_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.begin['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (self.begin['$<=>'](value))))) && ($ret_or_1));
      end_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.end['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (value['$<=>'](self.end))))) && ($ret_or_1));
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(self.excl) ? (($truthy(($ret_or_3 = end_cmp)) ? ($rb_lt(end_cmp, 0)) : ($ret_or_3))) : ($truthy(($ret_or_3 = end_cmp)) ? ($rb_le(end_cmp, 0)) : ($ret_or_3))))) ? (beg_cmp) : ($ret_or_2))))) {
        return $rb_le(beg_cmp, 0)
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, $a, self = this, current = nil, last = nil, $ret_or_1 = nil;

      delete $$each.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + ($truthy(self.excl) ? (0) : (1)); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if (!$truthy(current['$respond_to?']("succ"))) {
        $Kernel.$raise($$$('TypeError'), "can't iterate from " + (current.$class()))
      };
      while ($truthy(($truthy(($ret_or_1 = self.end['$nil?']())) ? ($ret_or_1) : ($rb_lt(current['$<=>'](last), 0))))) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if (($not(self.excl) && ($eqeq(current, last)))) {
        Opal.yield1(block, current)
      };
      return self;
    }, 0);
    
    $def(self, '$eql?', function $Range_eql$ques$4(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      if (!$eqeqeq($$$('Range'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.excl['$==='](other['$exclude_end?']()))) ? (self.begin['$eql?'](other.$begin())) : ($ret_or_2))))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$exclude_end?', function $Range_exclude_end$ques$5() {
      var self = this;

      return self.excl
    }, 0);
    
    $def(self, '$first', function $$first(n) {
      var $yield = $$first.$$p || nil, self = this;

      delete $$first.$$p;
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      };
      if ($truthy(n == null)) {
        return self.begin
      };
      return $send2(self, $find_super(self, 'first', $$first, false, true), 'first', [n], $yield);
    }, -1);
    
    $def(self, '$last', function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      };
      if ($truthy(n == null)) {
        return self.end
      };
      return self.$to_a().$last(n);
    }, -1);
    
    $def(self, '$max', function $$max() {
      var $yield = $$max.$$p || nil, self = this;

      delete $$max.$$p;
      if ($truthy(self.end['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'max', $$max, false, true), 'max', [], $yield)
      } else if (($not(self.begin['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, 0);
    
    $def(self, '$min', function $$min() {
      var $yield = $$min.$$p || nil, self = this;

      delete $$min.$$p;
      if ($truthy(self.begin['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'min', $$min, false, true), 'min', [], $yield)
      } else if (($not(self.end['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.begin
      }
    }, 0);
    
    $def(self, '$size', function $$size() {
      var self = this, infinity = nil, range_begin = nil, range_end = nil;

      
      infinity = $$$($$$('Float'), 'INFINITY');
      if ((($eqeq(self.begin, infinity) && ($not(self.end['$nil?']()))) || (($eqeq(self.end, infinity['$-@']()) && ($not(self.begin['$nil?']())))))) {
        return 0
      };
      if ($truthy(is_infinite(self))) {
        return infinity
      };
      if (!($eqeqeq($$$('Numeric'), self.begin) && ($eqeqeq($$$('Numeric'), self.end)))) {
        return nil
      };
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)
      };
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0
      };
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, 0);
    
    $def(self, '$step', function $$step(n) {
      var $yield = $$step.$$p || nil, self = this, $ret_or_1 = nil, i = nil;

      delete $$step.$$p;
      
      ;
      
      function coerceStepSize() {
        if (n == null) {
          n = 1;
        }
        else if (!n.$$is_number) {
          n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int")
        }

        if (n < 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$$('Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (!($yield !== nil)) {
        if (((($truthy(self.begin['$is_a?']($$('Numeric'))) || ($truthy(self.begin['$nil?']()))) && (($truthy(self.end['$is_a?']($$('Numeric'))) || ($truthy(self.end['$nil?']()))))) && ($not(($truthy(($ret_or_1 = self.begin['$nil?']())) ? (self.end['$nil?']()) : ($ret_or_1)))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "step")
        } else {
          return $send(self, 'enum_for', ["step", n], function $$6(){
            
            coerceStepSize();
            return enumeratorSize();
          }, 0)
        }
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

          
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)
            }
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)
          };
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, {$$arity: 0, $$s: self, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], function $$8(value, idx){
          
          
          if (value == null) value = nil;;
          
          if (idx == null) idx = nil;;
          if ($eqeq(idx['$%'](n), 0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, 2);
      };
      return self;
    }, -1);
    
    $def(self, '$%', function $Range_$percent$9(n) {
      var self = this;

      if (($truthy(self.begin['$is_a?']($$('Numeric'))) && ($truthy(self.end['$is_a?']($$('Numeric')))))) {
        return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "%")
      } else {
        return self.$step(n)
      }
    }, 1);
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this;

      delete $$bsearch.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        $Kernel.$raise($$$('NotImplementedError'), "Can't #bsearch an infinite range")
      };
      if (!$truthy(self.begin.$$is_number && self.end.$$is_number)) {
        $Kernel.$raise($$$('TypeError'), "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? ($ret_or_1) : (""))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? ($ret_or_1) : ("")))
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? (self.begin.$inspect()) : ($ret_or_1))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? (self.end.$inspect()) : ($ret_or_1)))
    }, 0);
    
    $def(self, '$marshal_load', function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, 1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, 0);
    $alias(self, "==", "eql?");
    $alias(self, "include?", "cover?");
    return $alias(self, "member?", "cover?");
  })('::', null, $nesting);
};

Opal.modules["corelib/proc"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $Opal = Opal.Opal, $alias = Opal.alias;

  Opal.add_stubs('raise,proc,call,to_proc,new,source_location,coerce_to!');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    Opal.prop(self.$$prototype, '$$is_proc', true);
    Opal.prop(self.$$prototype, '$$is_lambda', false);
    $defs(self, '$new', function $Proc_new$1() {
      var block = $Proc_new$1.$$p || nil;

      delete $Proc_new$1.$$p;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, 0);
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      delete $$call.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$>>', function $Proc_$gt$gt$2(other) {
      var $yield = $Proc_$gt$gt$2.$$p || nil, self = this;

      delete $Proc_$gt$gt$2.$$p;
      return $send($Kernel, 'proc', [], function $$3($a){var block = $$3.$$p || nil, $post_args, args, self = $$3.$$s == null ? this : $$3.$$s, out = nil;

        delete $$3.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        out = $send(self, 'call', $to_a(args), block.$to_proc());
        return other.$call(out);}, {$$arity: -1, $$s: self})
    }, 1);
    
    $def(self, '$<<', function $Proc_$lt$lt$4(other) {
      var $yield = $Proc_$lt$lt$4.$$p || nil, self = this;

      delete $Proc_$lt$lt$4.$$p;
      return $send($Kernel, 'proc', [], function $$5($a){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, out = nil;

        delete $$5.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        out = $send(other, 'call', $to_a(args), block.$to_proc());
        return self.$call(out);}, {$$arity: -1, $$s: self})
    }, 1);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$lambda?', function $Proc_lambda$ques$6() {
      var self = this;

      return !!self.$$is_lambda;
    }, 0);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, 0);
    
    $def(self, '$binding', function $$binding() {
      var $a, self = this;

      
      if (self.$$is_curried) { $Kernel.$raise($$$('ArgumentError'), "Can't create Binding") };
      if ($truthy((($a = $$$('::', 'Binding', 'skip_raise')) ? 'constant' : nil))) {
        return $$$('Binding').$new(nil, [], self.$$s, self.$source_location())
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, 0);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $Opal['$coerce_to!'](arity, $$$('Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, 0);
    $alias(self, "===", "call");
    $alias(self, "clone", "dup");
    $alias(self, "yield", "call");
    return $alias(self, "[]", "call");
  })('::', Function)
};

Opal.modules["corelib/method"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $Kernel = Opal.Kernel, $send = Opal.send, $to_a = Opal.to_a;

  Opal.add_stubs('attr_reader,arity,curry,>>,<<,new,class,join,source_location,raise,call,bind,to_proc');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Method');

    var $proto = self.$$prototype;

    $proto.method = $proto.receiver = $proto.owner = $proto.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    $def(self, '$initialize', function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, 4);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, 0);
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    }, 0);
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      delete $$call.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      return self.method.$curry(arity);
    }, -1);
    
    $def(self, '$>>', function $Method_$gt$gt$1(other) {
      var self = this;

      return self.method['$>>'](other)
    }, 1);
    
    $def(self, '$<<', function $Method_$lt$lt$2(other) {
      var self = this;

      return self.method['$<<'](other)
    }, 1);
    
    $def(self, '$unbind', function $$unbind() {
      var self = this;

      return $$$('UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, 0);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, 0);
    $alias(self, "[]", "call");
    return $alias(self, "===", "call");
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $proto = self.$$prototype;

    $proto.method = $proto.owner = $proto.name = $proto.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    $def(self, '$initialize', function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, 4);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, 0);
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    }, 0);
    
    $def(self, '$bind', function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$$('Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, 1);
    
    $def(self, '$bind_call', function $$bind_call(object, $a) {
      var block = $$bind_call.$$p || nil, $post_args, args, self = this;

      delete $$bind_call.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      return $send(self.$bind(object), 'call', $to_a(args), block.$to_proc());
    }, -2);
    return $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, 0);
  })('::', null);
};

Opal.modules["corelib/variables"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $gvars = Opal.gvars, $const_set = Opal.const_set, $Object = Opal.Object, $hash2 = Opal.hash2;

  Opal.add_stubs('new');
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  $const_set('::', 'ARGV', []);
  $const_set('::', 'ARGF', $Object.$new());
  $const_set('::', 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

Opal.modules["corelib/io"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $const_set = Opal.const_set, $not = Opal.not, $truthy = Opal.truthy, $def = Opal.def, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $range = Opal.range, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $alias = Opal.alias, $rb_minus = Opal.rb_minus, $writer = nil;

  Opal.add_stubs('attr_reader,attr_accessor,!,match?,include?,size,write,String,flatten,puts,sysread_noraise,+,!=,[],ord,getc,readchar,raise,gets,==,to_str,length,split,sub,sysread,>,to_a,each_line,enum_for,getbyte,closed_write?,closed_read?,new,write_proc=,-,read_proc=');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'IO');

    var $proto = self.$$prototype;

    $proto.fd = $proto.read_buffer = $proto.closed = nil;
    
    $const_set(self, 'SEEK_SET', 0);
    $const_set(self, 'SEEK_CUR', 1);
    $const_set(self, 'SEEK_END', 2);
    $const_set(self, 'SEEK_DATA', 3);
    $const_set(self, 'SEEK_HOLE', 4);
    $const_set(self, 'READABLE', 1);
    $const_set(self, 'WRITABLE', 4);
    self.$attr_reader("eof");
    self.$attr_accessor("read_proc", "sync", "tty", "write_proc");
    
    $def(self, '$initialize', function $$initialize(fd, flags) {
      var self = this;

      
      
      if (flags == null) flags = "r";;
      self.fd = fd;
      self.flags = flags;
      self.eof = false;
      if (($truthy(flags['$include?']("r")) && ($not(flags['$match?'](/[wa+]/))))) {
        return (self.closed = "write")
      } else if (($truthy(flags['$match?'](/[wa]/)) && ($not(flags['$match?'](/[r+]/))))) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$fileno', function $$fileno() {
      var self = this;

      return self.fd
    }, 0);
    
    $def(self, '$tty?', function $IO_tty$ques$1() {
      var self = this;

      return self.tty == true;
    }, 0);
    
    $def(self, '$write', function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, 1);
    
    $def(self, '$flush', function $$flush() {
      
      return nil
    }, 0);
    
    $def(self, '$<<', function $IO_$lt$lt$2(string) {
      var self = this;

      
      self.$write(string);
      return self;
    }, 1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, args, self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      for (var i = 0, ii = args.length; i < ii; i++) {
        args[i] = $Kernel.$String(args[i])
      }
      self.$write(args.join($gvars[","]));
    ;
      return nil;
    }, -1);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var line
      if (args.length === 0) {
        self.$write("\n");
        return nil;
      } else {
        for (var i = 0, ii = args.length; i < ii; i++) {
          if (args[i].$$is_array){
            var ary = (args[i]).$flatten()
            if (ary.length > 0) $send(self, 'puts', $to_a((ary)))
          } else {
            if (args[i].$$is_string) {
              line = args[i].valueOf();
            } else {
              line = $Kernel.$String(args[i]);
            }
            if (!line.endsWith("\n")) line += "\n"
            self.$write(line)
          }
        }
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$getc', function $$getc() {
      var $a, self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      do {
        
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if ($neqeq(self.read_buffer, "")) {
          
          ret = self.read_buffer['$[]'](0);
          self.read_buffer = self.read_buffer['$[]']($range(1, -1, false));
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(1))));;
      return nil;
    }, 0);
    
    $def(self, '$getbyte', function $$getbyte() {
      var $a, self = this;

      return ($a = self.$getc(), ($a === nil || $a == null) ? nil : $send($a, 'ord', []))
    }, 0);
    
    $def(self, '$readbyte', function $$readbyte() {
      var self = this;

      return self.$readchar().$ord()
    }, 0);
    
    $def(self, '$readchar', function $$readchar() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$getc()))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      }
    }, 0);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args, self = this, $ret_or_1 = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(($ret_or_1 = $send(self, 'gets', $to_a(args))))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      };
    }, -1);
    
    $def(self, '$gets', function $$gets(sep, limit, opts) {
      var $a, $b, $c, self = this, orig_sep = nil, $ret_or_1 = nil, seplen = nil, data = nil, ret = nil, orig_buffer = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (sep == null) sep = false;;
      
      if (limit == null) limit = nil;;
      
      if (opts == null) opts = $hash2([], {});;
      if (($truthy(sep.$$is_number) && ($not(limit)))) {
        $a = [false, sep, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      if ((($truthy(sep.$$is_hash) && ($not(limit))) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [false, nil, sep], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      } else if (($truthy(limit.$$is_hash) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [sep, nil, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      orig_sep = sep;
      if ($eqeq(sep, false)) {
        sep = $gvars["/"]
      };
      if ($eqeq(sep, "")) {
        sep = /\r?\n\r?\n/
      };
      sep = ($truthy(($ret_or_1 = sep)) ? ($ret_or_1) : (""));
      if (!$eqeq(orig_sep, "")) {
        sep = sep.$to_str()
      };
      seplen = ($eqeq(orig_sep, "") ? (2) : (sep.$length()));
      if ($eqeq(sep, " ")) {
        sep = / /
      };
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      data = "";
      ret = nil;
      do {
        
        self.read_buffer = $rb_plus(self.read_buffer, data);
        if (($neqeq(sep, "") && ($truthy(($truthy(sep.$$is_regexp) ? (self.read_buffer['$match?'](sep)) : (self.read_buffer['$include?'](sep))))))) {
          
          orig_buffer = self.read_buffer;
          $c = self.read_buffer.$split(sep, 2), $b = $to_ary($c), (ret = ($b[0] == null ? nil : $b[0])), (self.read_buffer = ($b[1] == null ? nil : $b[1])), $c;
          if ($neqeq(ret, orig_buffer)) {
            ret = $rb_plus(ret, orig_buffer['$[]'](ret.$length(), seplen))
          };
          break;;
        };
      } while ($truthy((data = self.$sysread_noraise(($eqeq(sep, "") ? (65536) : (1))))));;
      if (!$truthy(ret)) {
        
        $a = [($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : ("")), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
        if ($eqeq(ret, "")) {
          ret = nil
        };
      };
      if ($truthy(ret)) {
        
        if ($truthy(limit)) {
          
          ret = ret['$[]'](Opal.Range.$new(0,limit, true));
          self.read_buffer = $rb_plus(ret['$[]'](Opal.Range.$new(limit, -1, false)), self.read_buffer);
        };
        if ($truthy(opts['$[]']("chomp"))) {
          ret = ret.$sub(/\r?\n$/, "")
        };
        if ($eqeq(orig_sep, "")) {
          ret = ret.$sub(/^[\r\n]+/, "")
        };
      };
      if ($eqeq(orig_sep, false)) {
        $gvars._ = ret
      };
      return ret;
    }, -1);
    
    $def(self, '$sysread', function $$sysread(integer) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.read_proc(integer)))) {
        return $ret_or_1
      } else {
        
        self.eof = true;
        return $Kernel.$raise($$$('EOFError'), "end of file reached");
      }
    }, 1);
    
    $def(self, '$sysread_noraise', function $$sysread_noraise(integer) {
      var self = this;

      try {
        return self.$sysread(integer)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('EOFError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$readpartial', function $$readpartial(integer) {
      var $a, self = this, $ret_or_1 = nil, part = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      part = self.$sysread(integer);
      $a = [$rb_plus(self.read_buffer, ($truthy(($ret_or_1 = part)) ? ($ret_or_1) : (""))), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      if ($eqeq(ret, "")) {
        ret = nil
      };
      return ret;
    }, 1);
    
    $def(self, '$read', function $$read(integer) {
      var $a, $b, self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      
      if (integer == null) integer = nil;;
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      ret = nil;
      do {
        
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if (($truthy(integer) && ($truthy($rb_gt(self.read_buffer.$length(), integer))))) {
          
          $b = [self.read_buffer['$[]'](Opal.Range.$new(0,integer, true)), self.read_buffer['$[]'](Opal.Range.$new(integer, -1, false))], (ret = $b[0]), (self.read_buffer = $b[1]), $b;
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(($truthy(($ret_or_1 = integer)) ? ($ret_or_1) : (65536))))));;
      $a = [self.read_buffer, ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      return ret;
    }, -1);
    
    $def(self, '$readlines', function $$readlines(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) separator = $gvars["/"];;
      return self.$each_line(separator).$to_a();
    }, -1);
    
    $def(self, '$each', function $$each($a, $b) {
      var block = $$each.$$p || nil, $post_args, sep, args, $c, self = this, s = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      delete $$each.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      if ($post_args.length > 0) sep = $post_args.shift();
      if (sep == null) sep = $gvars["/"];;
      
      args = $post_args;;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each", sep].concat($to_a(args)))
      };
      while ($truthy((s = $send(self, 'gets', [sep].concat($to_a(args)))))) {
        Opal.yield1(block, s)
      };
      return self;
    }, -1);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, $a, self = this, s = nil;

      delete $$each_byte.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_byte")
      };
      while ($truthy((s = self.$getbyte()))) {
        Opal.yield1(block, s)
      };
      return self;
    }, 0);
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, $a, self = this, s = nil;

      delete $$each_char.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_char")
      };
      while ($truthy((s = self.$getc()))) {
        Opal.yield1(block, s)
      };
      return self;
    }, 0);
    
    $def(self, '$close', function $$close() {
      var self = this;

      return (self.closed = "both")
    }, 0);
    
    $def(self, '$close_read', function $$close_read() {
      var self = this;

      if ($eqeq(self.closed, "write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    }, 0);
    
    $def(self, '$close_write', function $$close_write() {
      var self = this;

      if ($eqeq(self.closed, "read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    }, 0);
    
    $def(self, '$closed?', function $IO_closed$ques$3() {
      var self = this;

      return self.closed['$==']("both")
    }, 0);
    
    $def(self, '$closed_read?', function $IO_closed_read$ques$4() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("read")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    }, 0);
    
    $def(self, '$closed_write?', function $IO_closed_write$ques$5() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("write")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    }, 0);
    
    $def(self, '$check_writable', function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for writing")
      } else {
        return nil
      }
    }, 0);
    
    $def(self, '$check_readable', function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for reading")
      } else {
        return nil
      }
    }, 0);
    $alias(self, "each_line", "each");
    return $alias(self, "eof?", "eof");
  })('::', null);
  $const_set('::', 'STDIN', ($gvars.stdin = $$$('IO').$new(0, "r")));
  $const_set('::', 'STDOUT', ($gvars.stdout = $$$('IO').$new(1, "w")));
  $const_set('::', 'STDERR', ($gvars.stderr = $$$('IO').$new(2, "w")));
  var console = Opal.global.console;
  
  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];
  $send($$$('STDOUT'), 'write_proc=', $to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];
  $send($$$('STDERR'), 'write_proc=', $to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [function(s) { var p = prompt(); if (p !== null) return p + "\n"; return nil; }];
  $send($$$('STDIN'), 'read_proc=', $to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

Opal.modules["opal/regexp_anchors"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $const_set = Opal.const_set;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'REGEXP_START', "^");
    $const_set(self, 'REGEXP_END', "$");
    $const_set(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'INLINE_IDENTIFIER_REGEXP', $$('Regexp').$new("[^" + ($$$(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$$(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    $const_set(self, 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return $const_set(self, 'CONST_NAME_REGEXP', $$('Regexp').$new("" + ($$$(self, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$$(self, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$$(self, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

Opal.modules["opal/mini"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $Object = Opal.Object;

  Opal.add_stubs('require');
  
  $Object.$require("opal/base");
  $Object.$require("corelib/nil");
  $Object.$require("corelib/boolean");
  $Object.$require("corelib/string");
  $Object.$require("corelib/comparable");
  $Object.$require("corelib/enumerable");
  $Object.$require("corelib/enumerator");
  $Object.$require("corelib/array");
  $Object.$require("corelib/hash");
  $Object.$require("corelib/number");
  $Object.$require("corelib/range");
  $Object.$require("corelib/proc");
  $Object.$require("corelib/method");
  $Object.$require("corelib/regexp");
  $Object.$require("corelib/variables");
  $Object.$require("corelib/io");
  return $Object.$require("opal/regexp_anchors");
};

Opal.modules["corelib/kernel/format"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $def = Opal.def, $alias = Opal.alias;

  Opal.add_stubs('respond_to?,[],==,length,coerce_to?,nil?,to_a,raise,to_int,fetch,Integer,Float,to_ary,to_str,inspect,to_s');
  return (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$format', function $$format(format_string, $a) {
      var $post_args, args, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      if (($eqeq(args.$length(), 1) && ($truthy(args['$[]'](0)['$respond_to?']("to_ary"))))) {
        
        ary = $Opal['$coerce_to?'](args['$[]'](0), $$$('Array'), "to_ary");
        if (!$truthy(ary['$nil?']())) {
          args = ary.$to_a()
        };
      };
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "flag after width") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "width given twice") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { $Kernel.$raise($$$('ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with numbered") // raise
        case -2: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with named") // raise
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          $Kernel.$raise($$$('ArgumentError'), "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              $Kernel.$raise($$$('ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
          // no-break
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                $Kernel.$raise($$$('ArgumentError'), "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                $Kernel.$raise($$$('ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  $Kernel.$raise($$$('ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }
            // raise

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              $Kernel.$raise($$$('ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = $Kernel.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            $Kernel.$raise($$$('NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")
            // raise

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$$('Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              $Kernel.$raise($$$('ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        $Kernel.$raise($$$('ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, -2);
    return $alias(self, "sprintf", "format");
  })('::')
};

Opal.modules["corelib/string/encoding"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $send = Opal.send, $defs = Opal.defs, $eqeq = Opal.eqeq, $def = Opal.def, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $alias = Opal.alias, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, $writer = nil;

  Opal.add_stubs('require,+,[],clone,initialize,new,instance_eval,to_proc,each,const_set,tr,==,default_external,attr_accessor,singleton_class,attr_reader,raise,register,length,bytes,force_encoding,dup,bytesize,enum_for,each_byte,to_a,each_char,each_codepoint,coerce_to!,find,<,default_external=,-');
  
  self.$require("corelib/string");
  (function($base, $super) {
    var self = $klass($base, $super, 'Encoding');

    var $proto = self.$$prototype;

    $proto.ascii = $proto.dummy = $proto.name = nil;
    
    $defs(self, '$register', function $$register(name, options) {
      var block = $$register.$$p || nil, self = this, names = nil, $ret_or_1 = nil, ascii = nil, dummy = nil, encoding = nil, register = nil;

      delete $$register.$$p;
      
      ;
      
      if (options == null) options = $hash2([], {});;
      names = $rb_plus([name], ($truthy(($ret_or_1 = options['$[]']("aliases"))) ? ($ret_or_1) : ([])));
      ascii = ($truthy(($ret_or_1 = options['$[]']("ascii"))) && ($ret_or_1));
      dummy = ($truthy(($ret_or_1 = options['$[]']("dummy"))) && ($ret_or_1));
      if ($truthy(options['$[]']("inherits"))) {
        
        encoding = options['$[]']("inherits").$clone();
        encoding.$initialize(name, names, ascii, dummy);
      } else {
        encoding = self.$new(name, names, ascii, dummy)
      };
      if ((block !== nil)) {
        $send(encoding, 'instance_eval', [], block.$to_proc())
      };
      register = Opal.encodings;
      return $send(names, 'each', [], function $$1(encoding_name){var self = $$1.$$s == null ? this : $$1.$$s;

        
        
        if (encoding_name == null) encoding_name = nil;;
        self.$const_set(encoding_name.$tr("-", "_"), encoding);
        return register[encoding_name] = encoding;}, {$$arity: 1, $$s: self});
    }, -2);
    $defs(self, '$find', function $$find(name) {
      var self = this;

      
      if ($eqeq(name, "default_external")) {
        return self.$default_external()
      };
      return Opal.find_encoding(name);;
    }, 1);
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    $def(self, '$initialize', function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, 4);
    
    $def(self, '$ascii_compatible?', function $Encoding_ascii_compatible$ques$2() {
      var self = this;

      return self.ascii
    }, 0);
    
    $def(self, '$dummy?', function $Encoding_dummy$ques$3() {
      var self = this;

      return self.dummy
    }, 0);
    
    $def(self, '$binary?', function $Encoding_binary$ques$4() {
      
      return false
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.name
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Encoding:" + (self.name) + (($truthy(self.dummy) ? (" (dummy)") : nil)) + ">"
    }, 0);
    
    $def(self, '$charsize', function $$charsize(string) {
      
      
      var len = 0;
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
          len++;
        }
      }
      return len;
    
    }, 1);
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      delete $$each_char.$$p;
      
      ;
      
      var low_surrogate = "";
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        var chr = string.charAt(i);
        if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
          low_surrogate = chr;
          continue;
        }
        else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
          chr = low_surrogate + chr;
        }
        if (string.encoding.name != "UTF-8") {
          chr = new String(chr);
          chr.encoding = string.encoding;
        }
        Opal.yield1(block, chr);
      }
    ;
    }, 1);
    
    $def(self, '$each_byte', function $$each_byte($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    
    $def(self, '$bytesize', function $$bytesize($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    $klass('::', $$$('StandardError'), 'EncodingError');
    return ($klass('::', $$$('EncodingError'), 'CompatibilityError'), nil);
  })('::', null);
  $send($$$('Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            }

            // valid lead
            leadSurrogate = codePoint;

            continue;
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint;
            continue;
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.$bytes().$length()
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16LE"], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 2;
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_16LE')})], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1)}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32LE"], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 4;
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_32LE')})], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1)}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii"], {"aliases": ["BINARY"], "ascii": true})], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;

    
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      delete $$each_char.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var chr = new String(string.charAt(i));
        chr.encoding = string.encoding;
        Opal.yield1(block, chr);
      }
    ;
    }, 1);
    
    $def(self, '$charsize', function $$charsize(string) {
      
      return string.length;
    }, 1);
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1);
    
    $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length;
    }, 1);
    return $def(self, '$binary?', function $binary$ques$11() {
      
      return true
    }, 0);}, {$$arity: 0, $$s: self});
  $$$('Encoding').$register("ISO-8859-1", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ISO8859-1"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  $$$('Encoding').$register("US-ASCII", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ASCII"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    var $proto = self.$$prototype;

    $proto.internal_encoding = $proto.bytes = $proto.encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.prop(String.prototype, 'bytes', nil);
    Opal.prop(String.prototype, 'encoding', $$$($$$('Encoding'), 'UTF_8'));
    Opal.prop(String.prototype, 'internal_encoding', $$$($$$('Encoding'), 'UTF_8'));
    
    $def(self, '$b', function $$b() {
      var self = this;

      return self.$dup().$force_encoding("binary")
    }, 0);
    
    $def(self, '$bytesize', function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, 0);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this;

      delete $$each_byte.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_byte"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;

          return self.$bytesize()}, {$$arity: 0, $$s: self})
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$bytes', function $$bytes() {
      var self = this, $ret_or_1 = nil;

      
      
      if (typeof self === 'string') {
        return (new String(self)).$each_byte().$to_a();
      }
    ;
      self.bytes = ($truthy(($ret_or_1 = self.bytes)) ? ($ret_or_1) : (self.$each_byte().$to_a()));
      return self.bytes.$dup();
    }, 0);
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this;

      delete $$each_char.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_char"], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return self.$length()}, {$$arity: 0, $$s: self})
      };
      $send(self.encoding, 'each_char', [self], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$chars', function $$chars() {
      var block = $$chars.$$p || nil, self = this;

      delete $$chars.$$p;
      
      ;
      if (!$truthy(block)) {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, 0);
    
    $def(self, '$each_codepoint', function $$each_codepoint() {
      var block = $$each_codepoint.$$p || nil, self = this;

      delete $$each_codepoint.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$codepoints', function $$codepoints() {
      var block = $$codepoints.$$p || nil, self = this;

      delete $$codepoints.$$p;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())
      };
      return self.$each_codepoint().$to_a();
    }, 0);
    
    $def(self, '$encode', function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, 1);
    
    $def(self, '$force_encoding', function $$force_encoding(encoding) {
      var self = this;

      
      var str = self;

      if (encoding === str.encoding) { return str; }

      encoding = $Opal['$coerce_to!'](encoding, $$$('String'), "to_s");
      encoding = $$$('Encoding').$find(encoding);

      if (encoding === str.encoding) { return str; }

      str = Opal.set_encoding(str, encoding);

      return str;
    
    }, 1);
    
    $def(self, '$getbyte', function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $Opal['$coerce_to!'](idx, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil
      };
      return string_bytes['$[]'](idx);
    }, 1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      
      return "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    "
    }, 1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    }, 0);
    $alias(self, "size", "length");
    return $def(self, '$valid_encoding?', function $String_valid_encoding$ques$14() {
      
      return true
    }, 0);
  })('::', null);
  
  $writer = [$$$($$('Encoding'), 'UTF_8')];
  $send($$$('Encoding'), 'default_external=', $to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

Opal.modules["corelib/math"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $type_error = Opal.type_error, $module = Opal.module, $const_set = Opal.const_set, $Class = Opal.Class, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_divide = Opal.rb_divide;

  Opal.add_stubs('new,raise,Float,Integer,module_function,checked,float!,===,gamma,-,integer!,/,infinite?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'E', Math.E);
    $const_set(self, 'PI', Math.PI);
    $const_set(self, 'DomainError', $Class.$new($$$('StandardError')));
    $defs(self, '$checked', function $$checked(method, $a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, -2);
    $defs(self, '$float!', function $Math_float$excl$1(value) {
      
      try {
        return $Kernel.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Float')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    $defs(self, '$integer!', function $Math_integer$excl$2(value) {
      
      try {
        return $Kernel.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Integer')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    self.$module_function();
    
    $def(self, '$acos', function $$acos(x) {
      
      return $$$('Math').$checked("acos", $$$('Math')['$float!'](x))
    }, 1);
    if (!$truthy((typeof(Math.acosh) !== "undefined"))) {
      
      Math.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      }
    
    };
    
    $def(self, '$acosh', function $$acosh(x) {
      
      return $$$('Math').$checked("acosh", $$$('Math')['$float!'](x))
    }, 1);
    
    $def(self, '$asin', function $$asin(x) {
      
      return $$$('Math').$checked("asin", $$$('Math')['$float!'](x))
    }, 1);
    if (!$truthy((typeof(Math.asinh) !== "undefined"))) {
      
      Math.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
      }
    
    };
    
    $def(self, '$asinh', function $$asinh(x) {
      
      return $$$('Math').$checked("asinh", $$$('Math')['$float!'](x))
    }, 1);
    
    $def(self, '$atan', function $$atan(x) {
      
      return $$$('Math').$checked("atan", $$$('Math')['$float!'](x))
    }, 1);
    
    $def(self, '$atan2', function $$atan2(y, x) {
      
      return $$$('Math').$checked("atan2", $$$('Math')['$float!'](y), $$$('Math')['$float!'](x))
    }, 2);
    if (!$truthy((typeof(Math.atanh) !== "undefined"))) {
      
      Math.atanh = function(x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      }
    
    };
    
    $def(self, '$atanh', function $$atanh(x) {
      
      return $$$('Math').$checked("atanh", $$$('Math')['$float!'](x))
    }, 1);
    if (!$truthy((typeof(Math.cbrt) !== "undefined"))) {
      
      Math.cbrt = function(x) {
        if (x == 0) {
          return 0;
        }

        if (x < 0) {
          return -Math.cbrt(-x);
        }

        var r  = x,
            ex = 0;

        while (r < 0.125) {
          r *= 8;
          ex--;
        }

        while (r > 1.0) {
          r *= 0.125;
          ex++;
        }

        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;

        while (ex < 0) {
          r *= 0.5;
          ex++;
        }

        while (ex > 0) {
          r *= 2;
          ex--;
        }

        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);

        return r;
      }
    
    };
    
    $def(self, '$cbrt', function $$cbrt(x) {
      
      return $$$('Math').$checked("cbrt", $$$('Math')['$float!'](x))
    }, 1);
    
    $def(self, '$cos', function $$cos(x) {
      
      return $$$('Math').$checked("cos", $$$('Math')['$float!'](x))
    }, 1);
    if (!$truthy((typeof(Math.cosh) !== "undefined"))) {
      
      Math.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      }
    
    };
    
    $def(self, '$cosh', function $$cosh(x) {
      
      return $$$('Math').$checked("cosh", $$$('Math')['$float!'](x))
    }, 1);
    if (!$truthy((typeof(Math.erf) !== "undefined"))) {
      
      Opal.prop(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    
    $def(self, '$erf', function $$erf(x) {
      
      return $$$('Math').$checked("erf", $$$('Math')['$float!'](x))
    }, 1);
    if (!$truthy((typeof(Math.erfc) !== "undefined"))) {
      
      Opal.prop(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    
    $def(self, '$erfc', function $$erfc(x) {
      
      return $$$('Math').$checked("erfc", $$$('Math')['$float!'](x))
    }, 1);
    
    $def(self, '$exp', function $$exp(x) {
      
      return $$$('Math').$checked("exp", $$$('Math')['$float!'](x))
    }, 1);
    
    $def(self, '$frexp', function $$frexp(x) {
      
      
      x = $$('Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, 1);
    
    $def(self, '$gamma', function $$gamma(n) {
      
      
      n = $$('Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$('Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$$('Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, 1);
    if (!$truthy((typeof(Math.hypot) !== "undefined"))) {
      
      Math.hypot = function(x, y) {
        return Math.sqrt(x * x + y * y)
      }
    
    };
    
    $def(self, '$hypot', function $$hypot(x, y) {
      
      return $$$('Math').$checked("hypot", $$$('Math')['$float!'](x), $$$('Math')['$float!'](y))
    }, 2);
    
    $def(self, '$ldexp', function $$ldexp(mantissa, exponent) {
      
      
      mantissa = $$('Math')['$float!'](mantissa);
      exponent = $$('Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        $Kernel.$raise($$$('RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, 2);
    
    $def(self, '$lgamma', function $$lgamma(n) {
      
      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$$('Math').$gamma(n))), $$$('Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, 1);
    
    $def(self, '$log', function $$log(x, base) {
      
      
      ;
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      if ($truthy(base == null)) {
        return $$$('Math').$checked("log", $$$('Math')['$float!'](x))
      } else {
        
        if ($eqeqeq($$$('String'), base)) {
          $Kernel.$raise($type_error(base, $$$('Float')))
        };
        return $rb_divide($$$('Math').$checked("log", $$$('Math')['$float!'](x)), $$$('Math').$checked("log", $$$('Math')['$float!'](base)));
      };
    }, -2);
    if (!$truthy((typeof(Math.log10) !== "undefined"))) {
      
      Math.log10 = function(x) {
        return Math.log(x) / Math.LN10;
      }
    
    };
    
    $def(self, '$log10', function $$log10(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log10", $$$('Math')['$float!'](x));
    }, 1);
    if (!$truthy((typeof(Math.log2) !== "undefined"))) {
      
      Math.log2 = function(x) {
        return Math.log(x) / Math.LN2;
      }
    
    };
    
    $def(self, '$log2', function $$log2(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log2", $$$('Math')['$float!'](x));
    }, 1);
    
    $def(self, '$sin', function $$sin(x) {
      
      return $$$('Math').$checked("sin", $$$('Math')['$float!'](x))
    }, 1);
    if (!$truthy((typeof(Math.sinh) !== "undefined"))) {
      
      Math.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      }
    
    };
    
    $def(self, '$sinh', function $$sinh(x) {
      
      return $$$('Math').$checked("sinh", $$$('Math')['$float!'](x))
    }, 1);
    
    $def(self, '$sqrt', function $$sqrt(x) {
      
      return $$$('Math').$checked("sqrt", $$$('Math')['$float!'](x))
    }, 1);
    
    $def(self, '$tan', function $$tan(x) {
      
      
      x = $$$('Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      return $$$('Math').$checked("tan", $$$('Math')['$float!'](x));
    }, 1);
    if (!$truthy((typeof(Math.tanh) !== "undefined"))) {
      
      Math.tanh = function(x) {
        if (x == Infinity) {
          return 1;
        }
        else if (x == -Infinity) {
          return -1;
        }
        else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      }
    
    };
    return $def(self, '$tanh', function $$tanh(x) {
      
      return $$$('Math').$checked("tanh", $$$('Math')['$float!'](x))
    }, 1);
  })('::', $nesting)
};

Opal.modules["corelib/complex/base"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $klass = Opal.klass;

  Opal.add_stubs('new,from_string');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Complex', function $$Complex(real, imag) {
      
      
      
      if (imag == null) imag = nil;;
      if ($truthy(imag)) {
        return $$('Complex').$new(real, imag)
      } else {
        return $$('Complex').$new(real, 0)
      };
    }, -2)
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $$('Complex').$from_string(self)
    }, 0)
  })('::', null, $nesting);
};

Opal.modules["corelib/complex"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $defs = Opal.defs, $rb_times = Opal.rb_times, $def = Opal.def, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $const_set = Opal.const_set, $alias = Opal.alias;

  Opal.add_stubs('require,real?,===,raise,new,*,cos,sin,attr_reader,class,==,real,imag,Complex,-@,+,__coerced__,-,nan?,/,conj,abs2,quo,polar,exp,log,>,!=,divmod,**,hypot,atan2,lcm,denominator,finite?,infinite?,numerator,abs,arg,rationalize,to_f,to_i,to_r,inspect,zero?,positive?,Rational');
  
  self.$require("corelib/numeric");
  self.$require("corelib/complex/base");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.real = $proto.imag = nil;
    
    $defs(self, '$rect', function $$rect(real, imag) {
      var self = this;

      
      
      if (imag == null) imag = 0;;
      if (!((($eqeqeq($$$('Numeric'), real) && ($truthy(real['$real?']()))) && ($eqeqeq($$$('Numeric'), imag))) && ($truthy(imag['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, -2);
    $defs(self, '$polar', function $$polar(r, theta) {
      var self = this;

      
      
      if (theta == null) theta = 0;;
      if (!((($eqeqeq($$$('Numeric'), r) && ($truthy(r['$real?']()))) && ($eqeqeq($$$('Numeric'), theta))) && ($truthy(theta['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$$('Math').$cos(theta)), $rb_times(r, $$$('Math').$sin(theta)));
    }, -2);
    self.$attr_reader("real", "imag");
    
    $def(self, '$initialize', function $$initialize(real, imag) {
      var self = this;

      
      
      if (imag == null) imag = 0;;
      self.real = real;
      return (self.imag = imag);
    }, -2);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return [other, self]
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return [$$$('Complex').$new(other, 0), self]
      } else {
        return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, 1);
    
    $def(self, '$==', function $Complex_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Complex'), other)) {
        if ($truthy(($ret_or_1 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_1
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        if ($truthy(($ret_or_1 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_1
        }
      } else {
        return other['$=='](self)
      }
    }, 1);
    
    $def(self, '$-@', function $Complex_$minus$$2() {
      var self = this;

      return $Kernel.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, 0);
    
    $def(self, '$+', function $Complex_$plus$3(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, 1);
    
    $def(self, '$-', function $Complex_$minus$4(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, 1);
    
    $def(self, '$*', function $Complex_$$5(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, 1);
    
    $def(self, '$/', function $Complex_$slash$6(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        if ((((($eqeqeq($$$('Number'), self.real) && ($truthy(self.real['$nan?']()))) || (($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$real()) && ($truthy(other.$real()['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$imag()) && ($truthy(other.$imag()['$nan?']())))))) {
          return $$$('Complex').$new($$$($$$('Float'), 'NAN'), $$$($$$('Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, 1);
    
    $def(self, '$**', function $Complex_$$$7(other) {
      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if ($eqeq(other, 0)) {
        return $$$('Complex').$new(1, 0)
      };
      if ($eqeqeq($$$('Complex'), other)) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$$('Math').$exp($rb_minus($rb_times(ore, $$$('Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$$('Math').$log(r)));
        return $$$('Complex').$polar(nr, ntheta);
      } else if ($eqeqeq($$$('Integer'), other)) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($neqeq(n, 0)) {
            
            $c = n.$divmod(2), $b = $to_ary($c), (div = ($b[0] == null ? nil : $b[0])), (mod = ($b[1] == null ? nil : $b[1])), $c;
            while ($eqeq(mod, 0)) {
              
              x = $Kernel.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $d = n.$divmod(2), $c = $to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$$('Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$$('Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $$$('Math').$hypot(self.real, self.imag)
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, 0);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      return $$$('Math').$atan2(self.imag, self.real)
    }, 0);
    
    $def(self, '$conj', function $$conj() {
      var self = this;

      return $Kernel.$Complex(self.real, self.imag['$-@']())
    }, 0);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, 0);
    
    $def(self, '$eql?', function $Complex_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $$('Complex')['$==='](other))) ? (self.real.$class()['$=='](self.imag.$class())) : ($ret_or_2))))) {
        return self['$=='](other)
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Numeric'), other)) {
        $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, 1);
    
    $def(self, '$finite?', function $Complex_finite$ques$9() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_1
      }
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Complex:" + (self.real) + ":" + (self.imag)
    }, 0);
    
    $def(self, '$infinite?', function $Complex_infinite$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$infinite?']()))) {
        return $ret_or_1
      } else {
        return self.imag['$infinite?']()
      }
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return $Kernel.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, 0);
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($neqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.$real().$rationalize(eps);
    }, -1);
    
    $def(self, '$real?', function $Complex_real$ques$11() {
      
      return false
    }, 0);
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, 0);
    
    $def(self, '$to_r', function $$to_r() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, result = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (((($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))) || ($truthy(self.imag['$positive?']()))) || ($truthy(self.imag['$zero?']()))) ? ("+") : ("-")));
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if (($eqeqeq($$$('Number'), self.imag) && (($truthy(self.imag['$nan?']()) || ($truthy(self.imag['$infinite?']())))))) {
        result = $rb_plus(result, "*")
      };
      return $rb_plus(result, "i");
    }, 0);
    $const_set($nesting[0], 'I', self.$new(0, 1));
    $defs(self, '$from_string', function $$from_string(str) {
      
      
      var re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return $Kernel.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return $Kernel.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return $Kernel.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return $Kernel.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return $Kernel.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return $Kernel.$Complex(real, imag);
      }
    
    }, 1);
    (function(self, $parent_nesting) {
      
      return $alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "divide", "/");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "phase", "arg");
    $alias(self, "quo", "/");
    $alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.udef(self, '$' + "positive?");;
    
    
    Opal.udef(self, '$' + "step");;
    return nil;;
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/rational/base"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $def = Opal.def, $klass = Opal.klass;

  Opal.add_stubs('convert,from_string');
  
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$Rational', function $$Rational(numerator, denominator) {
      
      
      
      if (denominator == null) denominator = 1;;
      return $$$('Rational').$convert(numerator, denominator);
    }, -2)
  })('::');
  return (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_r', function $$to_r() {
      var self = this;

      return $$$('Rational').$from_string(self)
    }, 0)
  })('::', null);
};

Opal.modules["corelib/rational"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_divide = Opal.rb_divide, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $Opal = Opal.Opal, $def = Opal.def, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le, $alias = Opal.alias;

  Opal.add_stubs('require,to_i,==,raise,<,-@,new,gcd,/,nil?,===,reduce,to_r,!,equal?,coerce_to!,to_f,numerator,denominator,<=>,-,*,__coerced__,+,Rational,>,**,abs,ceil,with_precision,floor,<=,truncate,send');
  
  self.$require("corelib/numeric");
  self.$require("corelib/rational/base");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Rational');

    var $proto = self.$$prototype;

    $proto.num = $proto.den = nil;
    
    $defs(self, '$reduce', function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if ($eqeq(den, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if ($eqeq(den, 1)) {
        return self.$new(num, den)
      };
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, 2);
    $defs(self, '$convert', function $$convert(num, den) {
      var self = this;

      
      if (($truthy(num['$nil?']()) || ($truthy(den['$nil?']())))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert nil into Rational")
      };
      if (($eqeqeq($$$('Integer'), num) && ($eqeqeq($$$('Integer'), den)))) {
        return self.$reduce(num, den)
      };
      if ((($eqeqeq($$$('Float'), num) || ($eqeqeq($$$('String'), num))) || ($eqeqeq($$$('Complex'), num)))) {
        num = num.$to_r()
      };
      if ((($eqeqeq($$$('Float'), den) || ($eqeqeq($$$('String'), den))) || ($eqeqeq($$$('Complex'), den)))) {
        den = den.$to_r()
      };
      if (($truthy(den['$equal?'](1)) && ($not($$$('Integer')['$==='](num))))) {
        return $Opal['$coerce_to!'](num, $$$('Rational'), "to_r")
      } else if (($eqeqeq($$$('Numeric'), num) && ($eqeqeq($$$('Numeric'), den)))) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, 2);
    
    $def(self, '$initialize', function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      return (self.den = den);
    }, 2);
    
    $def(self, '$numerator', function $$numerator() {
      var self = this;

      return self.num
    }, 0);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.den
    }, 0);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return [other, self]
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return [other.$to_r(), self]
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return [other, self.$to_f()]
      } else {
        return nil
      }
    }, 1);
    
    $def(self, '$==', function $Rational_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        if ($truthy(($ret_or_2 = self.num['$=='](other.$numerator())))) {
          return self.den['$=='](other.$denominator())
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($truthy(($ret_or_2 = self.num['$=='](other)))) {
          return self.den['$=='](1)
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$=='](other)
      } else {
        return other['$=='](self)
      }
    }, 1);
    
    $def(self, '$<=>', function $Rational_$lt_eq_gt$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$<=>'](other)
      } else {
        return self.$__coerced__("<=>", other)
      }
    }, 1);
    
    $def(self, '$+', function $Rational_$plus$3(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_plus(self.$to_f(), other)
      } else {
        return self.$__coerced__("+", other)
      }
    }, 1);
    
    $def(self, '$-', function $Rational_$minus$4(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_minus(self.$to_f(), other)
      } else {
        return self.$__coerced__("-", other)
      }
    }, 1);
    
    $def(self, '$*', function $Rational_$$5(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$numerator());
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_times(self.num, other), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_times(self.$to_f(), other)
      } else {
        return self.$__coerced__("*", other)
      }
    }, 1);
    
    $def(self, '$/', function $Rational_$slash$6(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$denominator());
        den = $rb_times(self.den, other.$numerator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $rb_divide(self.$to_f(), 0.0)
        } else {
          return $Kernel.$Rational(self.num, $rb_times(self.den, other))
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_divide(self.$to_f(), other)
      } else {
        return self.$__coerced__("/", other)
      }
    }, 1);
    
    $def(self, '$**', function $Rational_$$$7(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Integer'), ($ret_or_1 = other))) {
        if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $$$($$$('Float'), 'INFINITY')
        } else if ($truthy($rb_gt(other, 0))) {
          return $Kernel.$Rational(self.num['$**'](other), self.den['$**'](other))
        } else if ($truthy($rb_lt(other, 0))) {
          return $Kernel.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
        } else {
          return $Kernel.$Rational(1, 1)
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$**'](other)
      } else if ($eqeqeq($$$('Rational'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $Kernel.$Rational(1, 1)
        } else if ($eqeq(other.$denominator(), 1)) {
          if ($truthy($rb_lt(other, 0))) {
            return $Kernel.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
          } else {
            return $Kernel.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
          }
        } else if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        } else {
          return self.$to_f()['$**'](other)
        }
      } else {
        return self.$__coerced__("**", other)
      }
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $Kernel.$Rational(self.num.$abs(), self.den.$abs())
    }, 0);
    
    $def(self, '$ceil', function $$ceil(precision) {
      var self = this;

      
      
      if (precision == null) precision = 0;;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, -1);
    
    $def(self, '$floor', function $$floor(precision) {
      var self = this;

      
      
      if (precision == null) precision = 0;;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Rational:" + (self.num) + ":" + (self.den)
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return $Kernel.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, -1);
    
    $def(self, '$round', function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      
      if (precision == null) precision = 0;;
      if (!$eqeq(precision, 0)) {
        return self.$with_precision("round", precision)
      };
      if ($eqeq(self.num, 0)) {
        return 0
      };
      if ($eqeq(self.den, 1)) {
        return self.num
      };
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, -1);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self.$truncate()
    }, 0);
    
    $def(self, '$to_r', function $$to_r() {
      var self = this;

      return self
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, 0);
    
    $def(self, '$truncate', function $$truncate(precision) {
      var self = this;

      
      
      if (precision == null) precision = 0;;
      if ($eqeq(precision, 0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, -1);
    
    $def(self, '$with_precision', function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if (!$eqeqeq($$$('Integer'), precision)) {
        $Kernel.$raise($$$('TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return $Kernel.$Rational(s.$send(method), p)
      };
    }, 2);
    $defs(self, '$from_string', function $$from_string(string) {
      
      
      var str = string.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return $Kernel.$Rational(numerator, denominator);
          } else {
            return $Kernel.$Rational(numerator, 1);
          }
        } else {
          return $Kernel.$Rational(numerator, 1);
        }
      } else {
        return $Kernel.$Rational(0, 1);
      }
    
    }, 1);
    $alias(self, "divide", "/");
    return $alias(self, "quo", "/");
  })('::', $$$('Numeric'));
};

Opal.modules["corelib/time"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $slice = Opal.slice, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $rb_plus = Opal.rb_plus, $rb_divide = Opal.rb_divide, $rb_minus = Opal.rb_minus, $range = Opal.range, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $eqeq = Opal.eqeq, $alias = Opal.alias;

  Opal.add_stubs('require,include,===,raise,coerce_to!,respond_to?,to_str,to_i,new,<=>,to_f,nil?,>,<,strftime,year,month,day,+,round,/,-,copy_instance_variables,initialize_dup,is_a?,zero?,wday,utc?,mon,yday,hour,min,sec,rjust,ljust,zone,to_s,[],cweek_cyear,isdst,!=,<=,==,ceil');
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    $defs(self, '$at', function $$at(seconds, frac) {
      
      
      ;
      
      var result;

      if ($$$('Time')['$==='](seconds)) {
        if (frac !== undefined) {
          $Kernel.$raise($$$('TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.is_utc = seconds.is_utc;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $Opal['$coerce_to!'](seconds, $$$('Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $Opal['$coerce_to!'](frac, $$$('Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $Opal['$coerce_to!'](year, $$$('Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $Opal['$coerce_to!'](month, $$$('Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        $Kernel.$raise($$$('ArgumentError'), "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $Opal['$coerce_to!'](day, $$$('Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        $Kernel.$raise($$$('ArgumentError'), "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $Opal['$coerce_to!'](hour, $$$('Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        $Kernel.$raise($$$('ArgumentError'), "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $Opal['$coerce_to!'](min, $$$('Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        $Kernel.$raise($$$('ArgumentError'), "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $Opal['$coerce_to!'](sec, $$$('Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        $Kernel.$raise($$$('ArgumentError'), "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    $defs(self, '$new', function $Time_new$1(year, month, day, hour, min, sec, utc_offset) {
      
      
      ;
      
      if (month == null) month = nil;;
      
      if (day == null) day = nil;;
      
      if (hour == null) hour = nil;;
      
      if (min == null) min = nil;;
      
      if (sec == null) sec = nil;;
      
      if (utc_offset == null) utc_offset = nil;;
      
      var args, result;

      if (year === undefined) {
        return new Date();
      }

      if (utc_offset !== nil) {
        $Kernel.$raise($$$('ArgumentError'), "Opal does not support explicitly specifying UTC offset for Time")
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, -1);
    $defs(self, '$local', function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      
      if (month == null) month = nil;;
      
      if (day == null) day = nil;;
      
      if (hour == null) hour = nil;;
      
      if (min == null) min = nil;;
      
      if (sec == null) sec = nil;;
      
      if (millisecond == null) millisecond = nil;;
      
      if (_dummy1 == null) _dummy1 = nil;;
      
      if (_dummy2 == null) _dummy2 = nil;;
      
      if (_dummy3 == null) _dummy3 = nil;;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, -2);
    $defs(self, '$gm', function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      
      if (month == null) month = nil;;
      
      if (day == null) day = nil;;
      
      if (hour == null) hour = nil;;
      
      if (min == null) min = nil;;
      
      if (sec == null) sec = nil;;
      
      if (millisecond == null) millisecond = nil;;
      
      if (_dummy1 == null) _dummy1 = nil;;
      
      if (_dummy2 == null) _dummy2 = nil;;
      
      if (_dummy3 == null) _dummy3 = nil;;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.is_utc = true;
      return result;
    ;
    }, -2);
    $defs(self, '$now', function $$now() {
      var self = this;

      return self.$new()
    }, 0);
    
    $def(self, '$+', function $Time_$plus$2(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        $Kernel.$raise($$$('TypeError'), "time + time?")
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, 1);
    
    $def(self, '$-', function $Time_$minus$3(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        return (self.getTime() - other.getTime()) / 1000
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, 1);
    
    $def(self, '$<=>', function $Time_$lt_eq_gt$4(other) {
      var self = this, r = nil;

      if ($eqeqeq($$$('Time'), other)) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, 1);
    
    $def(self, '$==', function $Time_$eq_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$$('Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$asctime', function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, 0);
    
    $def(self, '$day', function $$day() {
      var self = this;

      return self.is_utc ? self.getUTCDate() : self.getDate();
    }, 0);
    
    $def(self, '$yday', function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$('Time').$new(self.$year()).$to_i();
      start_of_day = $$('Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, 0);
    
    $def(self, '$isdst', function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$eql?', function $Time_eql$ques$6(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = other['$is_a?']($$$('Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$friday?', function $Time_friday$ques$7() {
      var self = this;

      return self.$wday() == 5
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, 0);
    
    $def(self, '$hour', function $$hour() {
      var self = this;

      return self.is_utc ? self.getUTCHours() : self.getHours();
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, 0);
    
    $def(self, '$min', function $$min() {
      var self = this;

      return self.is_utc ? self.getUTCMinutes() : self.getMinutes();
    }, 0);
    
    $def(self, '$mon', function $$mon() {
      var self = this;

      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;
    }, 0);
    
    $def(self, '$monday?', function $Time_monday$ques$8() {
      var self = this;

      return self.$wday() == 1
    }, 0);
    
    $def(self, '$saturday?', function $Time_saturday$ques$9() {
      var self = this;

      return self.$wday() == 6
    }, 0);
    
    $def(self, '$sec', function $$sec() {
      var self = this;

      return self.is_utc ? self.getUTCSeconds() : self.getSeconds();
    }, 0);
    
    $def(self, '$succ', function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.is_utc = self.is_utc;
      return result;
    
    }, 0);
    
    $def(self, '$usec', function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, 0);
    
    $def(self, '$zone', function $$zone() {
      var self = this;

      
      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, 0);
    
    $def(self, '$getgm', function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.is_utc = true;
      return result;
    
    }, 0);
    
    $def(self, '$gmtime', function $$gmtime() {
      var self = this;

      
      self.is_utc = true;
      return self;
    
    }, 0);
    
    $def(self, '$gmt?', function $Time_gmt$ques$10() {
      var self = this;

      return self.is_utc === true;
    }, 0);
    
    $def(self, '$gmt_offset', function $$gmt_offset() {
      var self = this;

      return self.is_utc ? 0 : -self.getTimezoneOffset() * 60;
    }, 0);
    
    $def(self, '$strftime', function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "",
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = self.getTimezoneOffset(),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, 1);
    
    $def(self, '$sunday?', function $Time_sunday$ques$11() {
      var self = this;

      return self.$wday() == 0
    }, 0);
    
    $def(self, '$thursday?', function $Time_thursday$ques$12() {
      var self = this;

      return self.$wday() == 4
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, 0);
    
    $def(self, '$tuesday?', function $Time_tuesday$ques$13() {
      var self = this;

      return self.$wday() == 2
    }, 0);
    
    $def(self, '$wday', function $$wday() {
      var self = this;

      return self.is_utc ? self.getUTCDay() : self.getDay();
    }, 0);
    
    $def(self, '$wednesday?', function $Time_wednesday$ques$14() {
      var self = this;

      return self.$wday() == 3
    }, 0);
    
    $def(self, '$year', function $$year() {
      var self = this;

      return self.is_utc ? self.getUTCFullYear() : self.getFullYear();
    }, 0);
    
    $def(self, '$cweek_cyear', function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = $$$('Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if (($truthy($rb_le(jan01_wday, 4)) && ($neqeq(jan01_wday, 0)))) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if ($eqeq(offset, -8)) {
          offset = -1
        };
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$$('Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if ($eqeq(week, 53)) {
        
        dec31 = $$$('Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if (($truthy($rb_le(dec31_wday, 3)) && ($neqeq(dec31_wday, 0)))) {
          
          week = 1;
          year = $rb_plus(year, 1);
        };
      };
      return [week, year];
    }, 0);
    (function(self, $parent_nesting) {
      
      
      $alias(self, "mktime", "local");
      return $alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "ctime", "asctime");
    $alias(self, "dst?", "isdst");
    $alias(self, "getutc", "getgm");
    $alias(self, "gmtoff", "gmt_offset");
    $alias(self, "mday", "day");
    $alias(self, "month", "mon");
    $alias(self, "to_s", "inspect");
    $alias(self, "tv_sec", "to_i");
    $alias(self, "tv_usec", "usec");
    $alias(self, "utc", "gmtime");
    $alias(self, "utc?", "gmt?");
    return $alias(self, "utc_offset", "gmt_offset");
  })('::', Date, $nesting);
};

Opal.modules["corelib/struct"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $send = Opal.send, $Class = Opal.Class, $to_a = Opal.to_a, $def = Opal.def, $defs = Opal.defs, $Kernel = Opal.Kernel, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $alias = Opal.alias;

  Opal.add_stubs('require,include,!=,upcase,[],==,class,unshift,const_name!,map,coerce_to!,new,each,define_struct_attribute,allocate,initialize,alias_method,module_eval,to_proc,const_set,raise,<<,members,define_method,instance_eval,last,>,length,-,keys,any?,join,[]=,each_with_index,hash,===,<,-@,size,>=,include?,to_sym,instance_of?,__id__,eql?,enum_for,+,name,each_pair,inspect,to_h,args,each_with_object,flatten,to_a,respond_to?,dig');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    $defs(self, '$new', function $Struct_new$1(const_name, $a, $b) {
      var block = $Struct_new$1.$$p || nil, $post_args, $kwargs, args, keyword_init, self = this, klass = nil;

      delete $Struct_new$1.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      args = $post_args;;
      
      keyword_init = $kwargs.$$smap["keyword_init"];
      if (keyword_init == null) keyword_init = false;
      if ($truthy(const_name)) {
        if (($eqeq(const_name.$class(), $$$('String')) && ($neqeq(const_name['$[]'](0).$upcase(), const_name['$[]'](0))))) {
          
          args.$unshift(const_name);
          const_name = nil;
        } else {
          
          try {
            const_name = $Opal['$const_name!'](const_name)
          } catch ($err) {
            if (Opal.rescue($err, [$$$('TypeError'), $$$('NameError')])) {
              try {
                
                args.$unshift(const_name);
                const_name = nil;
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };
        }
      };
      $send(args, 'map', [], function $$2(arg){
        
        
        if (arg == null) arg = nil;;
        return $Opal['$coerce_to!'](arg, $$$('String'), "to_str");}, 1);
      klass = $send($Class, 'new', [self], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

        
        $send(args, 'each', [], function $$4(arg){var self = $$4.$$s == null ? this : $$4.$$s;

          
          
          if (arg == null) arg = nil;;
          return self.$define_struct_attribute(arg);}, {$$arity: 1, $$s: self});
        return (function(self, $parent_nesting) {
          
          
          
          $def(self, '$new', function $new$5($a) {
            var $post_args, args, self = this, instance = nil;

            
            
            $post_args = Opal.slice.call(arguments);
            
            args = $post_args;;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', $to_a(args));
            return instance;
          }, -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, {$$arity: 0, $$s: self});
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())
      };
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$$('Struct').$const_set(const_name, klass)
      };
      return klass;
    }, -2);
    $defs(self, '$define_struct_attribute', function $$define_struct_attribute(name) {
      var self = this;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "you cannot define attributes to the Struct class")
      };
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$$data[name];}, {$$arity: 0, $$s: self});
      return $send(self, 'define_method', ["" + (name) + "="], function $$7(value){var self = $$7.$$s == null ? this : $$7.$$s;

        
        
        if (value == null) value = nil;;
        return self.$$data[name] = value;;}, {$$arity: 1, $$s: self});
    }, 1);
    $defs(self, '$members', function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "the Struct class has no members")
      };
      return (self.members = ($truthy(($ret_or_1 = self.members)) ? ($ret_or_1) : ([])));
    }, 0);
    $defs(self, '$inherited', function $$inherited(klass) {
      var self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

        return (self.members = members)}, {$$arity: 0, $$s: self});
    }, 1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this, kwargs = nil, $ret_or_1 = nil, extra = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy(($ret_or_1 = args.$last())) ? ($ret_or_1) : ($hash2([], {})));
        if (($truthy($rb_gt(args.$length(), 1)) || ($truthy((args.length === 1 && !kwargs.$$is_hash))))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given " + (args.$length()) + ", expected 0)")
        };
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          $Kernel.$raise($$$('ArgumentError'), "unknown keywords: " + (extra.$join(", ")))
        };
        return $send(self.$class().$members(), 'each', [], function $$9(name){var self = $$9.$$s == null ? this : $$9.$$s, $writer = nil;

          
          
          if (name == null) name = nil;;
          $writer = [name, kwargs['$[]'](name)];
          $send(self, '[]=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, {$$arity: 1, $$s: self});
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          $Kernel.$raise($$$('ArgumentError'), "struct size differs")
        };
        return $send(self.$class().$members(), 'each_with_index', [], function $$10(name, index){var self = $$10.$$s == null ? this : $$10.$$s, $writer = nil;

          
          
          if (name == null) name = nil;;
          
          if (index == null) index = nil;;
          $writer = [name, args['$[]'](index)];
          $send(self, '[]=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, {$$arity: 2, $$s: self});
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    }, 1);
    $defs(self, '$keyword_init?', function $Struct_keyword_init$ques$11() {
      var self = this;

      return self.$$keyword_init;
    }, 0);
    
    $def(self, '$members', function $$members() {
      var self = this;

      return self.$class().$members()
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return $$('Hash').$new(self.$$data).$hash()
    }, 0);
    
    $def(self, '$[]', function $Struct_$$$12(name) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name];;
    }, 1);
    
    $def(self, '$[]=', function $Struct_$$$eq$13(name, value) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        if (!$truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name] = value;;
    }, 2);
    
    $def(self, '$==', function $Struct_$eq_eq$14(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, 1);
    
    $def(self, '$eql?', function $Struct_eql$ques$15(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, 1);
    
    $def(self, '$each', function $$each() {
      var $yield = $$each.$$p || nil, self = this;

      delete $$each.$$p;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$17(name){var self = $$17.$$s == null ? this : $$17.$$s;

        
        
        if (name == null) name = nil;;
        return Opal.yield1($yield, self['$[]'](name));;}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      delete $$each_pair.$$p;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each_pair"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$19(name){var self = $$19.$$s == null ? this : $$19.$$s;

        
        
        if (name == null) name = nil;;
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return $send(self.$class().$members(), 'map', [], function $$20(name){var self = $$20.$$s == null ? this : $$20.$$s;

        
        
        if (name == null) name = nil;;
        return self['$[]'](name);}, {$$arity: 1, $$s: self})
    }, 0);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, pushed = nil;

      return (function() { try {
      
      result = "#<struct ";
      if ($truthy((inspect_stack)['$include?'](self.$__id__()))) {
        return $rb_plus(result, ":...>")
      } else {
        
        (inspect_stack)['$<<'](self.$__id__());
        pushed = true;
        if (($eqeqeq($$$('Struct'), self) && ($truthy(self.$class().$name())))) {
          result = $rb_plus(result, "" + (self.$class()) + " ")
        };
        result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$21(name, value){
          
          
          if (name == null) name = nil;;
          
          if (value == null) value = nil;;
          return "" + (name) + "=" + ($$('Opal').$inspect(value));}, 2).$join(", "));
        result = $rb_plus(result, ">");
        return result;
      };
      } finally {
        ($truthy(pushed) ? (inspect_stack.pop()) : nil)
      }; })()
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      delete $$to_h.$$p;
      
      ;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(self.$args()))
      };
      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], function $$22(name, h){var self = $$22.$$s == null ? this : $$22.$$s, $writer = nil;

        
        
        if (name == null) name = nil;;
        
        if (h == null) h = nil;;
        $writer = [name, self['$[]'](name)];
        $send(h, '[]=', $to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, {$$arity: 2, $$s: self});
    }, 0);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      args = $send(args, 'map', [], function $$23(arg){
        
        
        if (arg == null) arg = nil;;
        return arg.$$is_range ? arg.$to_a() : arg;}, 1).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, -1);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      keys = $post_args;;
      item = ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key)) ? (self.$$data[key] || nil) : nil);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    $alias(self, "size", "length");
    $alias(self, "to_s", "inspect");
    return $alias(self, "values", "to_a");
  })('::', null, $nesting);
};

Opal.modules["corelib/dir"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias;

  Opal.add_stubs('[]');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      
      
      
      $def(self, '$chdir', function $$chdir(dir) {
        var $yield = $$chdir.$$p || nil, prev_cwd = nil;

        delete $$chdir.$$p;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, 1);
      
      $def(self, '$pwd', function $$pwd() {
        
        return Opal.current_dir || '.';
      }, 0);
      
      $def(self, '$home', function $$home() {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$$('ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      }, 0);
      return $alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/file"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $klass = Opal.klass, $const_set = Opal.const_set, $Opal = Opal.Opal, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $def = Opal.def, $Kernel = Opal.Kernel, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_minus = Opal.rb_minus, $range = Opal.range, $send = Opal.send, $alias = Opal.alias;

  Opal.add_stubs('respond_to?,to_path,coerce_to!,pwd,split,sub,+,unshift,join,home,raise,start_with?,absolute_path,==,<,dirname,-,basename,empty?,rindex,[],length,nil?,gsub,find,=~,map,each_with_index,flatten,reject,to_proc,end_with?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    $const_set($nesting[0], 'Separator', $const_set($nesting[0], 'SEPARATOR', "/"));
    $const_set($nesting[0], 'ALT_SEPARATOR', nil);
    $const_set($nesting[0], 'PATH_SEPARATOR', ":");
    $const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$absolute_path', function $$absolute_path(path, basedir) {
        var sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) basedir = nil;;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = ($truthy(path['$respond_to?']("to_path")) ? (path.$to_path()) : (path));
        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");
        basedir = ($truthy(($ret_or_1 = basedir)) ? ($ret_or_1) : ($$$('Dir').$pwd()));
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split($regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split($regexp(["[", sep_chars, "]"])), path.$split($regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)
        };
        return new_path;
      }, -2);
      
      $def(self, '$expand_path', function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) basedir = nil;;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$('Dir').$home();
          if (!$truthy(home)) {
            $Kernel.$raise($$$('ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if (!$truthy(home['$start_with?'](leading_sep))) {
            $Kernel.$raise($$$('ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = $regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)
          };
        };
        return self.$absolute_path(path, basedir);
      }, -2);
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$('ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$('SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$('SEPARATOR'), $$('ALT_SEPARATOR')));
        }
      }
    ;
      
      $def(self, '$dirname', function $$dirname(path, level) {
        var self = this, sep_chars = nil;

        
        
        if (level == null) level = 1;;
        if ($eqeq(level, 0)) {
          return path
        };
        if ($truthy($rb_lt(level, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "level can't be negative")
        };
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("^[" + (sep_chars) + "]")), out;

        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          out = absolute ? '/' : '.';
        }
        else {
          out = path;
        }

        if (level == 1) {
          return out;
        }
        else {
          return self.$dirname(out, $rb_minus(level, 1))
        }
      ;
      }, -2);
      
      $def(self, '$basename', function $$basename(name, suffix) {
        var sep_chars = nil;

        
        
        if (suffix == null) suffix = nil;;
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $Opal['$coerce_to!'](suffix, $$$('String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, -2);
      
      $def(self, '$extname', function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""
        };
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if (($truthy(last_dot_idx['$nil?']()) || ($eqeq($rb_plus(last_dot_idx, 1), $rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, 1);
      
      $def(self, '$exist?', function $exist$ques$1(path) {
        
        return Opal.modules[path] != null
      }, 1);
      
      $def(self, '$directory?', function $directory$ques$2(path) {
        var files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub($regexp(["(^.", $$('SEPARATOR'), "+|", $$('SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], function $$3(f){
          
          
          if (f == null) f = nil;;
          return f['$=~']($regexp(["^", path]));}, 1);
        return file;
      }, 1);
      
      $def(self, '$join', function $$join($a) {
        var $post_args, paths, result = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""
        };
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], function $$4(item, index){
          
          
          if (item == null) item = nil;;
          
          if (index == null) index = nil;;
          if (($eqeq(index, 0) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else if (($eqeq(paths.$length(), $rb_plus(index, 1)) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else {
            return item
          };}, 2);
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], function $$5(item, index){var next_item = nil;

          
          
          if (item == null) item = nil;;
          
          if (index == null) index = nil;;
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if (($truthy(item['$end_with?']($$('SEPARATOR'))) && ($truthy(next_item['$start_with?']($$('SEPARATOR')))))) {
              item = item.$sub($regexp([$$('SEPARATOR'), "+$"]), "")
            };
            return (result = (($truthy(item['$end_with?']($$('SEPARATOR'))) || ($truthy(next_item['$start_with?']($$('SEPARATOR'))))) ? ("" + (result) + (item)) : ("" + (result) + (item) + ($$('SEPARATOR')))));
          };}, 2);
        return result;
      }, -1);
      
      $def(self, '$split', function $$split(path) {
        
        return path.$split($$('SEPARATOR'))
      }, 1);
      $alias(self, "realpath", "expand_path");
      return $alias(self, "exists?", "exist?");
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('IO'), $nesting)
};

Opal.modules["corelib/process/base"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $klass = Opal.klass, $defs = Opal.defs;

  
  (function($base, $super) {
    var self = $klass($base, $super, 'Signal');

    
    return $defs(self, '$trap', function $$trap($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1)
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'GC');

    
    return $defs(self, '$start', function $$start() {
      
      return nil
    }, 0)
  })('::', null);
};

Opal.modules["corelib/process"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $defs = Opal.defs, $truthy = Opal.truthy, $Kernel = Opal.Kernel;

  Opal.add_stubs('const_set,size,<<,__register_clock__,to_f,now,new,[],raise');
  return (function($base) {
    var self = $module($base, 'Process');

    var monotonic = nil;

    
    self.__clocks__ = [];
    $defs(self, '$__register_clock__', function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)
    };
    $defs(self, '$pid', function $$pid() {
      
      return 0
    }, 0);
    $defs(self, '$times', function $$times() {
      var t = nil;

      
      t = $$$('Time').$now().$to_f();
      return $$$($$$('Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, 0);
    return $defs(self, '$clock_gettime', function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      
      if (unit == null) unit = "float_second";;
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        $Kernel.$raise($$$($$$('Errno'), 'EINVAL'), "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: $Kernel.$raise($$$('ArgumentError'), "unexpected unit: " + (unit))
      }
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/random/formatter"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $module = Opal.module, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, $range = Opal.range, $rb_divide = Opal.rb_divide, $Kernel = Opal.Kernel, $Opal = Opal.Opal;

  Opal.add_stubs('_verify_count,bytes,encode,strict_encode64,random_bytes,urlsafe_encode64,split,hex,[]=,-,[],map,to_proc,join,times,<<,|,ord,/,abs,random_float,raise,coerce_to!,flatten,new,random_number,length,include,extend');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$hex', function $$hex(count) {
        var self = this;

        
        
        if (count == null) count = nil;;
        count = $$$('Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, -1);
      
      $def(self, '$random_bytes', function $$random_bytes(count) {
        var self = this;

        
        
        if (count == null) count = nil;;
        return self.$bytes(count);
      }, -1);
      
      $def(self, '$base64', function $$base64(count) {
        var self = this;

        
        
        if (count == null) count = nil;;
        return $$$('Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$urlsafe_base64', function $$urlsafe_base64(count, padding) {
        var self = this;

        
        
        if (count == null) count = nil;;
        
        if (padding == null) padding = false;;
        return $$$('Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$uuid', function $$uuid() {
        var self = this, str = nil, $writer = nil;

        
        str = self.$hex(16).$split("");
        
        $writer = [12, "4"];
        $send(str, '[]=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16)];
        $send(str, '[]=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      }, 0);
      
      $def(self, '$random_float', function $$random_float() {
        var self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], function $$1(i){
          
          
          if (i == null) i = nil;;
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));}, 1);
        return $rb_divide(num.$abs(), 2147483647);
      }, 0);
      
      $def(self, '$random_number', function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");

          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          return randomInt(limit);
        }
      ;
      }, -1);
      return $def(self, '$alphanumeric', function $$alphanumeric(count) {
        var self = this, map = nil;

        
        
        if (count == null) count = nil;;
        count = $$('Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$$('Array'), 'new', [count], function $$2(i){var self = $$2.$$s == null ? this : $$2.$$s;

          
          
          if (i == null) i = nil;;
          return map['$[]'](self.$random_number(map.$length()));}, {$$arity: 1, $$s: self}).$join();
      }, -1);
    })(self, $nesting);
    self.$include($$$($$$('Random'), 'Formatter'));
    return self.$extend($$$($$$('Random'), 'Formatter'));
  })('::', null, $nesting)
};

Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, mersenne_twister = nil;

  Opal.add_stubs('generator=,-');
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    var $writer = nil;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    $const_set(self, 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    
    $writer = [$$$(self, 'MERSENNE_TWISTER_GENERATOR')];
    $send(self, 'generator=', $to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];;
  })('::', null);
};

Opal.modules["corelib/random"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $klass = Opal.klass, $Kernel = Opal.Kernel, $defs = Opal.defs, $Opal = Opal.Opal, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $send = Opal.send;

  Opal.add_stubs('require,attr_reader,to_int,raise,new_seed,coerce_to!,reseed,rand,seed,bytes,===,==,state,_verify_count,encode,join,new,chr,random_number,random_float,const_defined?,const_set');
  
  self.$require("corelib/random/formatter");
  (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    
    
    self.$attr_reader("seed", "state");
    $defs(self, '$_verify_count', function $$_verify_count(count) {
      
      
      if (!$truthy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) $Kernel.$raise($$$('ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    }, 1);
    
    $def(self, '$initialize', function $$initialize(seed) {
      var self = this;

      
      
      if (seed == null) seed = $$$('Random').$new_seed();;
      seed = $Opal['$coerce_to!'](seed, $$$('Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, -1);
    
    $def(self, '$reseed', function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, 1);
    $defs(self, '$new_seed', function $$new_seed() {
      
      return Opal.$$rand.new_seed();
    }, 0);
    $defs(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return $$$(self, 'DEFAULT').$rand(limit);
    }, -1);
    $defs(self, '$srand', function $$srand(n) {
      var self = this, previous_seed = nil;

      
      
      if (n == null) n = $$$('Random').$new_seed();;
      n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      previous_seed = $$$(self, 'DEFAULT').$seed();
      $$$(self, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, -1);
    $defs(self, '$urandom', function $$urandom(size) {
      
      return $$$('SecureRandom').$bytes(size)
    }, 1);
    
    $def(self, '$==', function $Random_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      
      if (!$eqeqeq($$$('Random'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$bytes', function $$bytes(length) {
      var self = this;

      
      length = $$$('Random').$_verify_count(length);
      return $send($$$('Array'), 'new', [length], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        return self.$rand(255).$chr()}, {$$arity: 0, $$s: self}).$join().$encode("ASCII-8BIT");
    }, 1);
    $defs(self, '$bytes', function $$bytes(length) {
      var self = this;

      return $$$(self, 'DEFAULT').$bytes(length)
    }, 1);
    
    $def(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, -1);
    
    $def(self, '$random_float', function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    }, 0);
    $defs(self, '$random_float', function $$random_float() {
      var self = this;

      return $$$(self, 'DEFAULT').$random_float()
    }, 0);
    return $defs(self, '$generator=', function $Random_generator$eq$3(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$$(self, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, 1);
  })('::', null);
  return self.$require("corelib/random/mersenne_twister");
};

Opal.modules["corelib/unsupported"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $Kernel = Opal.Kernel, $klass = Opal.klass, $send = Opal.send, $module = Opal.module, $def = Opal.def, $alias = Opal.alias, $defs = Opal.defs;

  Opal.add_stubs('raise,warn,each,define_method,%');
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $Kernel.$raise($$$('NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    return $send(["<<", "capitalize!", "chomp!", "chop!", "downcase!", "gsub!", "lstrip!", "next!", "reverse!", "slice!", "squeeze!", "strip!", "sub!", "succ!", "swapcase!", "tr!", "tr_s!", "upcase!", "prepend", "[]=", "clear", "encode!", "unicode_normalize!"], 'each', [], function $String$1(method_name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      
      if (method_name == null) method_name = nil;;
      return $send(self, 'define_method', [method_name], function $$2($a){var $post_args, $rest_arg;

        
        
        $post_args = Opal.slice.call(arguments);
        
        $rest_arg = $post_args;;
        return $Kernel.$raise($$$('NotImplementedError'), (ERROR)['$%'](method_name));}, -1);}, {$$arity: 1, $$s: self});
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    var ERROR = "Object freezing is not supported by Opal";
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    return $def(self, '$frozen?', function $Kernel_frozen$ques$3() {
      
      
      handle_unsupported_feature(ERROR);
      return false;
    }, 0);
  })('::');
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    var ERROR = "Object tainting is not supported by Opal";
    
    $def(self, '$taint', function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    
    $def(self, '$untaint', function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    return $def(self, '$tainted?', function $Kernel_tainted$ques$4() {
      
      
      handle_unsupported_feature(ERROR);
      return false;
    }, 0);
  })('::');
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    
    
    $def(self, '$public', function $Module_public$5($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = false;
        return nil;
      }
      return (methods.length === 1) ? methods[0] : methods;
    ;
    }, -1);
    
    $def(self, '$private_class_method', function $$private_class_method($a) {
      var $post_args, methods;

      
      
      $post_args = Opal.slice.call(arguments);
      
      methods = $post_args;;
      return (methods.length === 1) ? methods[0] : methods;;
    }, -1);
    
    $def(self, '$private_method_defined?', function $Module_private_method_defined$ques$6(obj) {
      
      return false
    }, 1);
    
    $def(self, '$private_constant', function $$private_constant($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    $alias(self, "nesting", "public");
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_class_method", "private_class_method");
    $alias(self, "public_instance_method", "instance_method");
    $alias(self, "public_instance_methods", "instance_methods");
    return $alias(self, "public_method_defined?", "method_defined?");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$private_methods', function $$private_methods($a) {
      var $post_args, methods;

      
      
      $post_args = Opal.slice.call(arguments);
      
      methods = $post_args;;
      return [];
    }, -1);
    return $alias(self, "private_instance_methods", "private_methods");
  })('::');
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$eval', function $Kernel_eval$7($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return $Kernel.$raise($$$('NotImplementedError'), "To use Kernel#eval, you must first require 'opal-parser'. " + ("See https://github.com/opal/opal/blob/" + ($$('RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, -1)
  })('::', $nesting);
  $defs(self, '$public', function $public$8($a) {
    var $post_args, methods;

    
    
    $post_args = Opal.slice.call(arguments);
    
    methods = $post_args;;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
  return $defs(self, '$private', function $private$9($a) {
    var $post_args, methods;

    
    
    $post_args = Opal.slice.call(arguments);
    
    methods = $post_args;;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
};

Opal.queue(function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $Object = Opal.Object;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$require("corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  return $Object.$require("corelib/unsupported");
});

Opal.modules["corelib/pack_unpack/format_string_parser"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $Kernel = Opal.Kernel;

  Opal.add_stubs('raise');
  return (function($base) {
    var self = $module($base, 'PackUnpack');

    
    
    var directives = [
      // Integer
      'C',
      'S',
      'L',
      'Q',
      'J',

      'c',
      's',
      'l',
      'q',
      'j',

      'n',
      'N',
      'v',
      'V',

      'U',
      'w',

      // Float
      'D',
      'd',
      'F',
      'f',
      'E',
      'e',
      'G',
      'g',

      // String
      'A',
      'a',
      'Z',
      'B',
      'b',
      'H',
      'h',
      'u',
      'M',
      'm',

      'P',
      'p',

      // Misc
      '@',
      'X',
      'x'
    ];

    var modifiers = [
      '!', // ignored
      '_', // ignored
      '>', // big endian
      '<'  // little endian
    ];

    self.eachDirectiveAndCount = function(format, callback) {
      var currentDirective,
          currentCount,
          currentModifiers,
          countSpecified;

      function reset() {
        currentDirective = null;
        currentCount = 0;
        currentModifiers = [];
        countSpecified = false;
      }

      reset();

      function yieldAndReset() {
        if (currentDirective == null) {
          reset();
          return;
        }

        var directiveSupportsModifiers = /[sSiIlLqQjJ]/.test(currentDirective);

        if (!directiveSupportsModifiers && currentModifiers.length > 0) {
          $Kernel.$raise($$$('ArgumentError'), "'" + (currentModifiers[0]) + "' allowed only after types sSiIlLqQjJ")
        }

        if (currentModifiers.indexOf('<') !== -1 && currentModifiers.indexOf('>') !== -1) {
          $Kernel.$raise($$$('RangeError'), "Can't use both '<' and '>'")
        }

        if (!countSpecified) {
          currentCount = 1;
        }

        if (currentModifiers.indexOf('>') !== -1) {
          currentDirective = currentDirective + '>';
        }

        callback(currentDirective, currentCount);

        reset();
      }

      for (var i = 0; i < format.length; i++) {
        var currentChar = format[i];

        if (directives.indexOf(currentChar) !== -1) {
          // Directive char always resets current state
          yieldAndReset();
          currentDirective = currentChar;
        } else if (currentDirective) {
          if (/\d/.test(currentChar)) {
            // Count can be represented as a sequence of digits
            currentCount = currentCount * 10 + parseInt(currentChar, 10);
            countSpecified = true;
          } else if (currentChar === '*' && countSpecified === false) {
            // Count can be represented by a star character
            currentCount = Infinity;
            countSpecified = true;
          } else if (modifiers.indexOf(currentChar) !== -1 && countSpecified === false) {
            // Directives can be specified only after directive and before count
            currentModifiers.push(currentChar);
          } else {
            yieldAndReset();
          }
        }
      }

      yieldAndReset();
    }
  
  })('::')
};

Opal.modules["corelib/array/pack"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $def = Opal.def;

  Opal.add_stubs('require,raise,delete,gsub,coerce_to!,inspect');
  
  self.$require("corelib/pack_unpack/format_string_parser");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    
    
    // Format Parser
    var eachDirectiveAndCount = Opal.PackUnpack.eachDirectiveAndCount;

    function identityFunction(value) { return value; }

    function utf8BytesToUtf16LEString(bytes) {
      var str = String.fromCharCode.apply(null, bytes), out = "", i = 0, len = str.length, c, char2, char3;
      while (i < len) {
        c = str.charCodeAt(i++);
        switch (c >> 4) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            // 0xxxxxxx
            out += str.charAt(i - 1);
            break;
          case 12:
          case 13:
            // 110x xxxx 10xx xxxx
            char2 = str.charCodeAt(i++);
            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
            break;
          case 14:
            // 1110 xxxx10xx xxxx10xx xxxx
            char2 = str.charCodeAt(i++);
            char3 = str.charCodeAt(i++);
            out += String.fromCharCode(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
            break;
        }
      }
      return out;
    }

    function asciiBytesToUtf16LEString(bytes) {
      return String.fromCharCode.apply(null, bytes);
    }

    function asciiStringFromUnsignedInt(bytes, callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          var result = [];

          for (var i = 0; i < bytes; i++) {
            var bit = item & 255;
            result.push(bit);
            item = item >> 8;
          };

          return asciiBytesToUtf16LEString(result);
        });
      }
    }

    function asciiStringFromSignedInt(bytes, callback) {
      return function(data) {
        var buffer = callback(data),
            bits = bytes * 8,
            limit = Math.pow(2, bits);

        return buffer.map(function(item) {
          if (item < 0) {
            item += limit;
          }

          var result = [];

          for (var i = 0; i < bytes; i++) {
            var bit = item & 255;
            result.push(bit);
            item = item >> 8;
          };

          return asciiBytesToUtf16LEString(result);
        });
      }
    }

    function toInt(callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          return $coerce_to(item, $$$('Integer'), 'to_int')
        });
      }
    }

    function ToStr(callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          return $coerce_to(item, $$$('String'), 'to_str')
        });
      }
    }

    function fromCodePoint(callback) {
      return function(data) {
        var buffer = callback(data);
        return buffer.map(function(item) {
          try {
            return String.fromCodePoint(item);
          } catch (error) {
            if (error instanceof RangeError) {
              $Kernel.$raise($$$('RangeError'), "value out of range");
            }
            throw error;
          }
        });
      }
    }

    function joinChars(callback) {
      return function(data) {
        var buffer = callback(data);
        return buffer.join('');
      }
    }

    var handlers = {
      // Integer
      'C': joinChars(asciiStringFromUnsignedInt(1, toInt(identityFunction))),
      'S': joinChars(asciiStringFromUnsignedInt(2, toInt(identityFunction))),
      'L': joinChars(asciiStringFromUnsignedInt(4, toInt(identityFunction))),
      'Q': joinChars(asciiStringFromUnsignedInt(8, toInt(identityFunction))),
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': joinChars(asciiStringFromSignedInt(1, toInt(identityFunction))),
      's': joinChars(asciiStringFromSignedInt(2, toInt(identityFunction))),
      'l': joinChars(asciiStringFromSignedInt(4, toInt(identityFunction))),
      'q': joinChars(asciiStringFromSignedInt(8, toInt(identityFunction))),
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': joinChars(fromCodePoint(toInt(identityFunction))),
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': joinChars(identityFunction),
      'a': joinChars(identityFunction),
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': null,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };

    function readNTimesFromBufferAndMerge(callback) {
      return function(buffer, count) {
        var chunk = [], chunkData;

        if (count === Infinity) {
          while (buffer.length > 0) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        } else {
          if (buffer.length < count) {
            $Kernel.$raise($$$('ArgumentError'), "too few arguments");
          }
          for (var i = 0; i < count; i++) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    function readItem(buffer) {
      var chunk = buffer.slice(0, 1);
      buffer = buffer.slice(1, buffer.length);
      return { chunk: chunk, rest: buffer };
    }

    function readNCharsFromTheFirstItemAndMergeWithFallback(fallback, callback) {
      return function(buffer, count) {
        var chunk = [], source = buffer[0];

        if (source === nil) {
          source = '';
        } else if (source === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "too few arguments");
        } else {
          source = $coerce_to(source, $$$('String'), 'to_str');
        }

        buffer = buffer.slice(1, buffer.length);

        function infiniteReeder() {
          var chunkData = callback(source);
          source = chunkData.rest;
          var subChunk = chunkData.chunk;

          if (subChunk.length === 1 && subChunk[0] === nil) {
            subChunk = []
          }

          chunk = chunk.concat(subChunk);
        }

        function finiteReeder() {
          var chunkData = callback(source);
          source = chunkData.rest;
          var subChunk = chunkData.chunk;

          if (subChunk.length === 0) {
            subChunk = [fallback];
          }

          if (subChunk.length === 1 && subChunk[0] === nil) {
            subChunk = [fallback];
          }

          chunk = chunk.concat(subChunk);
        }

        if (count === Infinity) {
          while (source.length > 0) {
            infiniteReeder();
          }
        } else {
          for (var i = 0; i < count; i++) {
            finiteReeder();
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    var readChunk = {
      // Integer
      'C': readNTimesFromBufferAndMerge(readItem),
      'S': readNTimesFromBufferAndMerge(readItem),
      'L': readNTimesFromBufferAndMerge(readItem),
      'Q': readNTimesFromBufferAndMerge(readItem),
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': readNTimesFromBufferAndMerge(readItem),
      's': readNTimesFromBufferAndMerge(readItem),
      'l': readNTimesFromBufferAndMerge(readItem),
      'q': readNTimesFromBufferAndMerge(readItem),
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': readNTimesFromBufferAndMerge(readItem),
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': readNCharsFromTheFirstItemAndMergeWithFallback(" ", readItem),
      'a': readNCharsFromTheFirstItemAndMergeWithFallback("\x00", readItem),
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': null,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };

    var autocompletion = {
      // Integer
      'C': false,
      'S': false,
      'L': false,
      'Q': false,
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': false,
      's': false,
      'l': false,
      'q': false,
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': false,
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': false,
      'a': false,
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': false,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };
  ;
    return $def(self, '$pack', function $$pack(format) {
      var self = this;

      
      format = $Opal['$coerce_to!'](format, $$$('String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      
      var output = '';

      var buffer = self.slice();

      function autocomplete(array, size) {
        while (array.length < size) {
          array.push(nil);
        }

        return array;
      }

      function processChunk(directive, count) {
        var chunk,
            chunkReader = readChunk[directive];

        if (chunkReader == null) {
          $Kernel.$raise("Unsupported pack directive " + ((directive).$inspect()) + " (no chunk reader defined)")
        }

        var chunkData = chunkReader(buffer, count);
        chunk = chunkData.chunk;
        buffer = chunkData.rest;

        var handler = handlers[directive];

        if (handler == null) {
          $Kernel.$raise("Unsupported pack directive " + ((directive).$inspect()) + " (no handler defined)")
        }

        return handler(chunk);
      }

      eachDirectiveAndCount(format, function(directive, count) {
        var part = processChunk(directive, count);

        if (count !== Infinity) {
          var shouldAutocomplete = autocompletion[directive]

          if (shouldAutocomplete == null) {
            $Kernel.$raise("Unsupported pack directive " + ((directive).$inspect()) + " (no autocompletion rule defined)")
          }

          if (shouldAutocomplete) {
            autocomplete(part, count);
          }
        }

        output = output.concat(part);
      });

      if (format.match(/^(U\*?)+$/)) {
        return output;
      }
      else {
        return Opal.enc(output, "binary");
      }
    ;
    }, 1);
  })('::', null);
};

Opal.modules["base64"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $defs = Opal.defs, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs('raise,delete');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Base64');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var encode, decode;

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    encode = function (input) {
      var str = String(input);
      /* eslint-disable */
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars, output = '';
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3/4);
        if (charCode > 0xFF) {
          self.$raise($$('ArgumentError'), "invalid character (failed: The string to be encoded contains characters outside of the Latin1 range.)");
        }
        block = block << 8 | charCode;
      }
      return output;
      /* eslint-enable */
    };

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    decode = function (input) {
      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        self.$raise($$('ArgumentError'), "invalid base64 (failed: The string to be decoded is not correctly encoded.)");
      }
      /* eslint-disable */
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
      /* eslint-enable */
    };
  ;
    $defs(self, '$decode64', function $$decode64(string) {
      
      return decode(string.replace(/\r?\n/g, ''));
    }, 1);
    $defs(self, '$encode64', function $$encode64(string) {
      
      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    }, 1);
    $defs(self, '$strict_decode64', function $$strict_decode64(string) {
      
      return decode(string);
    }, 1);
    $defs(self, '$strict_encode64', function $$strict_encode64(string) {
      
      return encode(string);
    }, 1);
    $defs(self, '$urlsafe_decode64', function $$urlsafe_decode64(string) {
      
      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    }, 1);
    return $defs(self, '$urlsafe_encode64', function $$urlsafe_encode64(string, $kwargs) {
      var padding, str = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      padding = $kwargs.$$smap["padding"];
      if (padding == null) padding = true;
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if (!$truthy(padding)) {
        str = str.$delete("=")
      };
      return str;
    }, -2);
  })($nesting[0], $nesting)
};

Opal.modules["corelib/string/unpack"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $Kernel = Opal.Kernel, $hash2 = Opal.hash2, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $Opal = Opal.Opal, $rb_gt = Opal.rb_gt, $def = Opal.def;

  Opal.add_stubs('require,flatten,decode64,raise,<,delete,gsub,coerce_to!,>,length,inspect,[],unpack');
  
  self.$require("base64");
  self.$require("corelib/pack_unpack/format_string_parser");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), expected = nil, given = nil;

    
    
    // Format Parser
    var eachDirectiveAndCount = Opal.PackUnpack.eachDirectiveAndCount;

    function flattenArray(callback) {
      return function(data) {
        var array = callback(data);
        return (array).$flatten();
      }
    }

    function mapChunksToWords(callback) {
      return function(data) {
        var chunks = callback(data);

        return chunks.map(function(chunk) {
          return chunk.reverse().reduce(function(result, singleByte) {
            return result * 256 + singleByte;
          }, 0);
        });
      }
    }

    function chunkBy(chunkSize, callback) {
      return function(data) {
        var array = callback(data),
            chunks = [],
            chunksCount = (array.length / chunkSize);

        for (var i = 0; i < chunksCount; i++) {
          var chunk = array.splice(0, chunkSize);
          if (chunk.length === chunkSize) {
            chunks.push(chunk);
          }
        }

        return chunks;
      }
    }

    function toNByteSigned(bytesCount, callback) {
      return function(data) {
        var unsignedBits = callback(data),
            bitsCount = bytesCount * 8,
            limit = Math.pow(2, bitsCount);

        return unsignedBits.map(function(n) {
          if (n >= limit / 2) {
            n -= limit;
          }

          return n;
        });
      }
    }

    function bytesToAsciiChars(callback) {
      return function(data) {
        var bytes = callback(data);

        return bytes.map(function(singleByte) {
          return String.fromCharCode(singleByte);
        });
      }
    }

    function joinChars(callback) {
      return function(data) {
        var chars = callback(data);
        return chars.join('');
      }
    }

    function wrapIntoArray(callback) {
      return function(data) {
        var object = callback(data);
        return [object];
      }
    }

    function filterTrailingChars(chars) {
      var charCodesToFilter = chars.map(function(s) { return s.charCodeAt(0); });

      return function(callback) {
        return function(data) {
          var charCodes = callback(data);

          while (charCodesToFilter.indexOf(charCodes[charCodes.length - 1]) !== -1) {
            charCodes = charCodes.slice(0, charCodes.length - 1);
          }

          return charCodes;
        }
      }
    }

    var filterTrailingZerosAndSpaces = filterTrailingChars(["\u0000", " "]);

    function invertChunks(callback) {
      return function(data) {
        var chunks = callback(data);

        return chunks.map(function(chunk) {
          return chunk.reverse();
        });
      }
    }

    function uudecode(callback) {
      return function(data) {
        var bytes = callback(data);

        var stop = false;
        var i = 0, length = 0;

        var result = [];

        do {
          if (i < bytes.length) {
            var n = bytes[i] - 32 & 0x3F;

            ++i;

            if (bytes[i] === 10) {
              continue;
            }

            if (n > 45) {
              return '';
            }

            length += n;

            while (n > 0) {
              var c1 = bytes[i];
              var c2 = bytes[i + 1];
              var c3 = bytes[i + 2];
              var c4 = bytes[i + 3];

              var b1 = (c1 - 32 & 0x3F) << 2 | (c2 - 32 & 0x3F) >> 4;
              var b2 = (c2 - 32 & 0x3F) << 4 | (c3 - 32 & 0x3F) >> 2;
              var b3 = (c3 - 32 & 0x3F) << 6 | c4 - 32 & 0x3F;

              result.push(b1 & 0xFF);
              result.push(b2 & 0xFF);
              result.push(b3 & 0xFF);

              i += 4;
              n -= 3;
            }

            ++i;
          } else {
            break;
          }
        } while (true);

        return result.slice(0, length);
      }
    }

    function toBits(callback) {
      return function(data) {
        var bytes = callback(data);

        var bits = bytes.map(function(singleByte) {
          return singleByte.toString(2);
        });

        return bits;
      }
    }

    function decodeBERCompressedIntegers(callback) {
      return function(data) {
        var bytes = callback(data), result = [], buffer = '';

        for (var i = 0; i < bytes.length; i++) {
          var singleByte = bytes[i],
              bits = singleByte.toString(2);

          bits = Array(8 - bits.length + 1).join('0').concat(bits);

          var firstBit = bits[0];
          bits = bits.slice(1, bits.length);

          buffer = buffer.concat(bits);

          if (firstBit === '0') {
            var decoded = parseInt(buffer, 2);
            result.push(decoded);
            buffer = ''
          }
        }

        return result;
      }
    }

    function base64Decode(callback) {
      return function(data) {
        return $$('Base64').$decode64(callback(data));
      }
    }

    // quoted-printable decode
    function qpdecode(callback) {
      return function(data) {
        var string = callback(data);

        return string
          .replace(/[\t\x20]$/gm, '')
          .replace(/=(?:\r\n?|\n|$)/g, '')
          .replace(/=([a-fA-F0-9]{2})/g, function($0, $1) {
            var codePoint = parseInt($1, 16);
            return String.fromCharCode(codePoint);
          });
      }
    }

    function identityFunction(value) { return value; }

    var handlers = {
      // Integer
      'C': identityFunction,
      'S': mapChunksToWords(chunkBy(2, identityFunction)),
      'L': mapChunksToWords(chunkBy(4, identityFunction)),
      'Q': mapChunksToWords(chunkBy(8, identityFunction)),
      'J': null,

      'S>': mapChunksToWords(invertChunks(chunkBy(2, identityFunction))),
      'L>': mapChunksToWords(invertChunks(chunkBy(4, identityFunction))),
      'Q>': mapChunksToWords(invertChunks(chunkBy(8, identityFunction))),

      'c': toNByteSigned(1, identityFunction),
      's': toNByteSigned(2, mapChunksToWords(chunkBy(2, identityFunction))),
      'l': toNByteSigned(4, mapChunksToWords(chunkBy(4, identityFunction))),
      'q': toNByteSigned(8, mapChunksToWords(chunkBy(8, identityFunction))),
      'j': null,

      's>': toNByteSigned(2, mapChunksToWords(invertChunks(chunkBy(2, identityFunction)))),
      'l>': toNByteSigned(4, mapChunksToWords(invertChunks(chunkBy(4, identityFunction)))),
      'q>': toNByteSigned(8, mapChunksToWords(invertChunks(chunkBy(8, identityFunction)))),

      'n': null, // aliased later
      'N': null, // aliased later
      'v': null, // aliased later
      'V': null, // aliased later

      'U': identityFunction,
      'w': decodeBERCompressedIntegers(identityFunction),

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': wrapIntoArray(joinChars(bytesToAsciiChars(filterTrailingZerosAndSpaces(identityFunction)))),
      'a': wrapIntoArray(joinChars(bytesToAsciiChars(identityFunction))),
      'Z': joinChars(bytesToAsciiChars(identityFunction)),
      'B': joinChars(identityFunction),
      'b': joinChars(identityFunction),
      'H': joinChars(identityFunction),
      'h': joinChars(identityFunction),
      'u': joinChars(bytesToAsciiChars(uudecode(identityFunction))),
      'M': qpdecode(joinChars(bytesToAsciiChars(identityFunction))),
      'm': base64Decode(joinChars(bytesToAsciiChars(identityFunction))),

      'P': null,
      'p': null
    };

    function readBytes(n) {
      return function(bytes) {
        var chunk = bytes.slice(0, n);
        bytes = bytes.slice(n, bytes.length);
        return { chunk: chunk, rest: bytes };
      }
    }

    function readUnicodeCharChunk(bytes) {
      var currentByteIndex = 0;
      var bytesLength = bytes.length;
      function readByte() {
        var result = bytes[currentByteIndex++];
        bytesLength = bytes.length - currentByteIndex;
        return result;
      }

      var c = readByte(), extraLength;

      if (c >> 7 == 0) {
        // 0xxx xxxx
        return { chunk: [c], rest: bytes.slice(currentByteIndex) };
      }

      if (c >> 6 == 0x02) {
        $Kernel.$raise($$$('ArgumentError'), "malformed UTF-8 character")
      }

      if (c >> 5 == 0x06) {
        // 110x xxxx (two bytes)
        extraLength = 1;
      } else if (c >> 4 == 0x0e) {
        // 1110 xxxx (three bytes)
        extraLength = 2;
      } else if (c >> 3 == 0x1e) {
        // 1111 0xxx (four bytes)
        extraLength = 3;
      } else if (c >> 2 == 0x3e) {
        // 1111 10xx (five bytes)
        extraLength = 4;
      } else if (c >> 1 == 0x7e) {
        // 1111 110x (six bytes)
        extraLength = 5;
      } else {
        $Kernel.$raise("malformed UTF-8 character")
      }

      if (extraLength > bytesLength) {
        ((expected = extraLength + 1), (given = bytesLength + 1), $Kernel.$raise($$$('ArgumentError'), "malformed UTF-8 character (expected " + (expected) + " bytes, given " + (given) + " bytes)"))
      }

      // Remove the UTF-8 prefix from the char
      var mask = (1 << (8 - extraLength - 1)) - 1,
          result = c & mask;

      for (var i = 0; i < extraLength; i++) {
        c = readByte();

        if (c >> 6 != 0x02) {
          $Kernel.$raise("Invalid multibyte sequence")
        }

        result = (result << 6) | (c & 0x3f);
      }

      if (result <= 0xffff) {
        return { chunk: [result], rest: bytes.slice(currentByteIndex) };
      } else {
        result -= 0x10000;
        var high = ((result >> 10) & 0x3ff) + 0xd800,
            low = (result & 0x3ff) + 0xdc00;
        return { chunk: [high, low], rest: bytes.slice(currentByteIndex) };
      }
    }

    function readUuencodingChunk(buffer) {
      var length = buffer.indexOf(32); // 32 = space

      if (length === -1) {
        return { chunk: buffer, rest: [] };
      } else {
        return { chunk: buffer.slice(0, length), rest: buffer.slice(length, buffer.length) };
      }
    }

    function readNBitsLSBFirst(buffer, count) {
      var result = '';

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            bitsToTake = Math.min(count, 8),
            bytesToTake = Math.ceil(bitsToTake / 8);

        buffer = buffer.slice(1, buffer.length);

        if (singleByte != null) {
          var bits = singleByte.toString(2);
          bits = Array(8 - bits.length + 1).join('0').concat(bits).split('').reverse().join('');

          for (var j = 0; j < bitsToTake; j++) {
            result += bits[j] || '0';
            count--;
          }
        }
      }

      return { chunk: [result], rest: buffer };
    }

    function readNBitsMSBFirst(buffer, count) {
      var result = '';

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            bitsToTake = Math.min(count, 8),
            bytesToTake = Math.ceil(bitsToTake / 8);

        buffer = buffer.slice(1, buffer.length);

        if (singleByte != null) {
          var bits = singleByte.toString(2);
          bits = Array(8 - bits.length + 1).join('0').concat(bits);

          for (var j = 0; j < bitsToTake; j++) {
            result += bits[j] || '0';
            count--;
          }
        }
      }

      return { chunk: [result], rest: buffer };
    }

    function readWhileFirstBitIsOne(buffer) {
      var result = [];

      for (var i = 0; i < buffer.length; i++) {
        var singleByte = buffer[i];

        result.push(singleByte);

        if ((singleByte & 128) === 0) {
          break;
        }
      }

      return { chunk: result, rest: buffer.slice(result.length, buffer.length) };
    }

    function readTillNullCharacter(buffer, count) {
      var result = [];

      for (var i = 0; i < count && i < buffer.length; i++) {
        var singleByte = buffer[i];

        if (singleByte === 0) {
          break;
        } else {
          result.push(singleByte);
        }
      }

      if (count === Infinity) {
        count = result.length;
      }

      if (buffer[count] === 0) {
        count++;
      }

      buffer = buffer.slice(count, buffer.length);

      return { chunk: result, rest: buffer };
    }

    function readHexCharsHighNibbleFirst(buffer, count) {
      var result = [];

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            hex = singleByte.toString(16);

        buffer = buffer.slice(1, buffer.length);
        hex = Array(2 - hex.length + 1).join('0').concat(hex);

        if (count === 1) {
          result.push(hex[0]);
          count--;
        } else {
          result.push(hex[0], hex[1]);
          count -= 2;
        }
      }

      return { chunk: result, rest: buffer };
    }

    function readHexCharsLowNibbleFirst(buffer, count) {
      var result = [];

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            hex = singleByte.toString(16);

        buffer = buffer.slice(1, buffer.length);
        hex = Array(2 - hex.length + 1).join('0').concat(hex);

        if (count === 1) {
          result.push(hex[1]);
          count--;
        } else {
          result.push(hex[1], hex[0]);
          count -= 2;
        }
      }

      return { chunk: result, rest: buffer };
    }

    function readNTimesAndMerge(callback) {
      return function(buffer, count) {
        var chunk = [], chunkData;

        if (count === Infinity) {
          while (buffer.length > 0) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        } else {
          for (var i = 0; i < count; i++) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    function readAll(buffer, count) {
      return { chunk: buffer, rest: [] };
    }

    var readChunk = {
      // Integer
      'C': readNTimesAndMerge(readBytes(1)),
      'S': readNTimesAndMerge(readBytes(2)),
      'L': readNTimesAndMerge(readBytes(4)),
      'Q': readNTimesAndMerge(readBytes(8)),
      'J': null,

      'S>': readNTimesAndMerge(readBytes(2)),
      'L>': readNTimesAndMerge(readBytes(4)),
      'Q>': readNTimesAndMerge(readBytes(8)),

      'c': readNTimesAndMerge(readBytes(1)),
      's': readNTimesAndMerge(readBytes(2)),
      'l': readNTimesAndMerge(readBytes(4)),
      'q': readNTimesAndMerge(readBytes(8)),
      'j': null,

      's>': readNTimesAndMerge(readBytes(2)),
      'l>': readNTimesAndMerge(readBytes(4)),
      'q>': readNTimesAndMerge(readBytes(8)),

      'n': null, // aliased later
      'N': null, // aliased later
      'v': null, // aliased later
      'V': null, // aliased later

      'U': readNTimesAndMerge(readUnicodeCharChunk),
      'w': readNTimesAndMerge(readWhileFirstBitIsOne),

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': readNTimesAndMerge(readBytes(1)),
      'a': readNTimesAndMerge(readBytes(1)),
      'Z': readTillNullCharacter,
      'B': readNBitsMSBFirst,
      'b': readNBitsLSBFirst,
      'H': readHexCharsHighNibbleFirst,
      'h': readHexCharsLowNibbleFirst,
      'u': readNTimesAndMerge(readUuencodingChunk),
      'M': readAll,
      'm': readAll,

      'P': null,
      'p': null
    }

    var autocompletion = {
      // Integer
      'C': true,
      'S': true,
      'L': true,
      'Q': true,
      'J': null,

      'S>': true,
      'L>': true,
      'Q>': true,

      'c': true,
      's': true,
      'l': true,
      'q': true,
      'j': null,

      's>': true,
      'l>': true,
      'q>': true,

      'n': null, // aliased later
      'N': null, // aliased later
      'v': null, // aliased later
      'V': null, // aliased later

      'U': false,
      'w': false,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': false,
      'a': false,
      'Z': false,
      'B': false,
      'b': false,
      'H': false,
      'h': false,
      'u': false,
      'M': false,
      'm': false,

      'P': null,
      'p': null
    }

    var optimized = {
      'C*': handlers['C'],
      'c*': handlers['c'],
      'A*': handlers['A'],
      'a*': handlers['a'],
      'M*': wrapIntoArray(handlers['M']),
      'm*': wrapIntoArray(handlers['m']),
      'S*': handlers['S'],
      's*': handlers['s'],
      'L*': handlers['L'],
      'l*': handlers['l'],
      'Q*': handlers['Q'],
      'q*': handlers['q'],
      'S>*': handlers['S>'],
      's>*': handlers['s>'],
      'L>*': handlers['L>'],
      'l>*': handlers['l>'],
      'Q>*': handlers['Q>'],
      'q>*': handlers['q>']
    }

    function alias(existingDirective, newDirective) {
      readChunk[newDirective] = readChunk[existingDirective];
      handlers[newDirective] = handlers[existingDirective];
      autocompletion[newDirective] = autocompletion[existingDirective];
    }

    alias('S>', 'n');
    alias('L>', 'N');

    alias('S', 'v');
    alias('L', 'V');
  ;
    
    $def(self, '$unpack', function $$unpack(format, $kwargs) {
      var offset, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      offset = $kwargs.$$smap["offset"];
      if (offset == null) offset = 0;
      if ($truthy($rb_lt(offset, 0))) {
        $Kernel.$raise($$$('ArgumentError'), "offset can't be negative")
      };
      format = $Opal['$coerce_to!'](format, $$$('String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      
      var output = [];

      // A very optimized handler for U*.
      if (format == "U*" &&
          self.internal_encoding.name === "UTF-8" &&
          typeof self.codePointAt === "function") {

        var cp, j = 0;

        output = new Array(self.length);
        for (var i = offset; i < self.length; i++) {
          cp = output[j++] = self.codePointAt(i);
          if (cp > 0xffff) i++;
        }
        return output.slice(0, j);
      }

      var buffer = self.$bytes();

      ($truthy($rb_gt(offset, (buffer).$length())) ? ($Kernel.$raise($$$('ArgumentError'), "offset outside of string")) : nil)

      buffer = buffer.slice(offset);


      // optimization
      var optimizedHandler = optimized[format];
      if (optimizedHandler) {
        return optimizedHandler(buffer);
      }

      function autocomplete(array, size) {
        while (array.length < size) {
          array.push(nil);
        }

        return array;
      }

      function processChunk(directive, count) {
        var chunk,
            chunkReader = readChunk[directive];

        if (chunkReader == null) {
          $Kernel.$raise("Unsupported unpack directive " + ((directive).$inspect()) + " (no chunk reader defined)")
        }

        var chunkData = chunkReader(buffer, count);
        chunk = chunkData.chunk;
        buffer = chunkData.rest;

        var handler = handlers[directive];

        if (handler == null) {
          $Kernel.$raise("Unsupported unpack directive " + ((directive).$inspect()) + " (no handler defined)")
        }

        return handler(chunk);
      }

      eachDirectiveAndCount(format, function(directive, count) {
        var part = processChunk(directive, count);

        if (count !== Infinity) {
          var shouldAutocomplete = autocompletion[directive];

          if (shouldAutocomplete == null) {
            $Kernel.$raise("Unsupported unpack directive " + ((directive).$inspect()) + " (no autocompletion rule defined)")
          }

          if (shouldAutocomplete) {
            autocomplete(part, count);
          }
        }

        output = output.concat(part);
      });

      return output;
    ;
    }, -2);
    return $def(self, '$unpack1', function $$unpack1(format, $kwargs) {
      var offset, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      offset = $kwargs.$$smap["offset"];
      if (offset == null) offset = 0;
      format = $Opal['$coerce_to!'](format, $$$('String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      return self.$unpack(format['$[]'](0), $hash2(["offset"], {"offset": offset}))['$[]'](0);
    }, -2);
  })('::', null, $nesting);
};

Opal.modules["json"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, $Object = Opal.Object, $hash2 = Opal.hash2, $eqeqeq = Opal.eqeqeq, $defs = Opal.defs, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('raise,new,push,[]=,-,[],create_id,json_create,const_get,attr_accessor,create_id=,===,parse,generate,from_object,merge,to_json,responds_to?,to_io,write,to_s,to_a,strftime');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'JSON');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $writer = nil;

    
    $klass($nesting[0], $$('StandardError'), 'JSONError');
    $klass($nesting[0], $$('JSONError'), 'ParserError');
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise($$$($$('JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'undefined':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                (($writer = [k, to_opal(value[k], options)]), $send((hash), '[]=', $to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]']($$('JSON').$create_id())) != nil) {
              return $Object.$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    
    $writer = ["json_class"];
    $send(self, 'create_id=', $to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    $defs(self, '$[]', function $JSON_$$$1(value, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      if ($eqeqeq($$('String'), value)) {
        return self.$parse(value, options)
      } else {
        return self.$generate(value, options)
      };
    }, -2);
    $defs(self, '$parse', function $$parse(source, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})));
    }, -2);
    $defs(self, '$parse!', function $JSON_parse$excl$2(source, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      return self.$parse(source, options);
    }, -2);
    $defs(self, '$load', function $$load(source, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      return self.$from_object($parse(source), options);
    }, -2);
    $defs(self, '$from_object', function $$from_object(js_object, options) {
      var $ret_or_1 = nil, $writer = nil;

      
      
      if (options == null) options = $hash2([], {});;
      if ($truthy(($ret_or_1 = options['$[]']("object_class")))) {
        $ret_or_1
      } else {
        
        $writer = ["object_class", $$('Hash')];
        $send(options, '[]=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      if ($truthy(($ret_or_1 = options['$[]']("array_class")))) {
        $ret_or_1
      } else {
        
        $writer = ["array_class", $$('Array')];
        $send(options, '[]=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return to_opal(js_object, options.$$smap);;
    }, -2);
    $defs(self, '$generate', function $$generate(obj, options) {
      
      
      
      if (options == null) options = $hash2([], {});;
      return obj.$to_json(options);
    }, -2);
    return $defs(self, '$dump', function $$dump(obj, io, limit) {
      var self = this, string = nil;

      
      
      if (io == null) io = nil;;
      
      if (limit == null) limit = nil;;
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()
        };
        io.$write(string);
        return io;
      } else {
        return string
      };
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, 0)
  })($nesting[0], null);
  (function($base) {
    var self = $module($base, 'Enumerable');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, 0)
  })($nesting[0]);
  (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(',') + ']';
    
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Hash');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(',') + '}';
    
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_json', function $$to_json() {
      
      return "null"
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.toString();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return JSON.stringify(self);
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, 0)
  })($nesting[0], null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Date');

    
    
    
    $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, 0);
    return $def(self, '$as_json', function $$as_json() {
      var self = this;

      return self.$to_s()
    }, 0);
  })($nesting[0], null);
};

Opal.modules["lib/a_lox/version"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return $const_set($nesting[0], 'VERSION', "0.1.0")
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/printers/pretty_printer"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $def = Opal.def, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('extend,accept,+,left,lexeme,operator,right,expression,to_s,value');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base) {
      var self = $module($base, 'PrettyPrinter');

      
      
      self.$extend(self);
      
      $def(self, '$print', function $$print(expression) {
        var self = this;

        return expression.$accept(self)
      }, 1);
      
      $def(self, '$visit_binary', function $$visit_binary(binary) {
        var self = this;

        return $rb_plus($rb_plus(binary.$left().$accept(self), binary.$operator().$lexeme()), binary.$right().$accept(self))
      }, 1);
      
      $def(self, '$visit_grouping', function $$visit_grouping(grouping) {
        var self = this;

        return $rb_plus($rb_plus("(", grouping.$expression().$accept(self)), ")")
      }, 1);
      
      $def(self, '$visit_literal', function $$visit_literal(literal) {
        
        return literal.$value().$to_s()
      }, 1);
      return $def(self, '$visit_unary', function $$visit_unary(unary) {
        var self = this;

        return $rb_plus(unary.$operator().$lexeme(), unary.$right().$accept(self))
      }, 1);
    })($nesting[0])
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/printers/react_tree_printer"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus;

  Opal.add_stubs('is_a?,map,accept,statement?,expression?,raise,expression,lexeme,name,join,parameters,to_proc,body,value,merge,scope_attributes,compact,adorn,initializer,statements,condition,then_branch,else_branch,operator,left,right,inspect,+,callee,arguments,private,tap,[]=,[],-,global?,allocation,local?,slot,upvalue?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Printers');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ReactTreePrinter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.statements = nil;
        
        
        $def(self, '$initialize', function $$initialize(statements) {
          var self = this;

          return (self.statements = statements)
        }, 1);
        
        $def(self, '$print', function $$print() {
          var self = this, regular_tree = nil;

          
          regular_tree = ($truthy(self.statements['$is_a?']($$('Array'))) ? ($send(self.statements, 'map', [], function $$1(resolvable_element){var self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (resolvable_element == null) resolvable_element = nil;;
            return resolvable_element.$accept(self);}, {$$arity: 1, $$s: self})) : ($truthy(self.statements['$statement?']()) ? (self.statements.$accept(self)) : ($truthy(self.statements['$expression?']()) ? (self.statements.$accept(self)) : (self.$raise("Malformed tree")))));
          return $hash2(["name", "children"], {"name": "PROGRAM", "children": regular_tree});
        }, 0);
        
        $def(self, '$visit_expression_statement', function $$visit_expression_statement(expression_statement) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "EXP-STMT", "attributes": $hash2([], {}), "children": [expression_statement.$expression().$accept(self)]})
        }, 1);
        
        $def(self, '$visit_function_statement', function $$visit_function_statement(function_statement) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "FUN-DEF", "attributes": $hash2(["name"], {"name": "" + (function_statement.$name().$lexeme()) + "(" + ($send(function_statement.$parameters(), 'map', [], "lexeme".$to_proc()).$join(", ")) + ")"}), "children": $send(function_statement.$body(), 'map', [], function $$2(statement){var self = $$2.$$s == null ? this : $$2.$$s;

            
            
            if (statement == null) statement = nil;;
            return statement.$accept(self);}, {$$arity: 1, $$s: self})})
        }, 1);
        
        $def(self, '$visit_return_statement', function $$visit_return_statement(return_statement) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "RETURN", "attributes": $hash2([], {}), "children": [return_statement.$value().$accept(self)]})
        }, 1);
        
        $def(self, '$visit_print_statement', function $$visit_print_statement(print_statement) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "PRINT PRINT PRINT PRINT PRINT", "attributes": $hash2([], {}), "children": [print_statement.$expression().$accept(self)]})
        }, 1);
        
        $def(self, '$visit_var_statement', function $$visit_var_statement(variable_statement) {
          var $a, self = this;

          return $hash2(["name", "attributes", "children"], {"name": "VAR-DEF", "attributes": $hash2(["name"], {"name": variable_statement.$name().$lexeme()}).$merge(self.$scope_attributes(variable_statement)), "children": [self.$adorn(($a = variable_statement.$initializer(), ($a === nil || $a == null) ? nil : $send($a, 'accept', [self])), "INITIALIZER")].$compact()})
        }, 1);
        
        $def(self, '$visit_block_statement', function $$visit_block_statement(block_statement) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "BLOCK", "attributes": $hash2([], {}), "children": $send(block_statement.$statements(), 'map', [], function $$3(statement){var self = $$3.$$s == null ? this : $$3.$$s;

            
            
            if (statement == null) statement = nil;;
            return statement.$accept(self);}, {$$arity: 1, $$s: self})})
        }, 1);
        
        $def(self, '$visit_if_statement', function $$visit_if_statement(if_statement) {
          var $a, self = this;

          return $hash2(["name", "attributes", "children"], {"name": "IF", "attributes": $hash2([], {}), "children": [self.$adorn(if_statement.$condition().$accept(self), "CONDITION"), self.$adorn(if_statement.$then_branch().$accept(self), "THEN"), self.$adorn(($a = if_statement.$else_branch(), ($a === nil || $a == null) ? nil : $send($a, 'accept', [self])), "ELSE")].$compact()})
        }, 1);
        
        $def(self, '$visit_while_statement', function $$visit_while_statement(while_statement) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "WHILE", "attributes": $hash2([], {}), "children": [self.$adorn(while_statement.$condition().$accept(self), "CONDITION"), self.$adorn(while_statement.$body().$accept(self), "BODY")]})
        }, 1);
        
        $def(self, '$visit_assign', function $$visit_assign(assign_expression) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "ASSIGN", "attributes": $hash2(["name"], {"name": assign_expression.$name().$lexeme()}).$merge(self.$scope_attributes(assign_expression)), "children": [assign_expression.$value().$accept(self)]})
        }, 1);
        
        $def(self, '$visit_binary', function $$visit_binary(binary_expression) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "BINARY", "attributes": $hash2(["operator"], {"operator": binary_expression.$operator().$lexeme()}), "children": [binary_expression.$left().$accept(self), binary_expression.$right().$accept(self)]})
        }, 1);
        
        $def(self, '$visit_grouping', function $$visit_grouping(grouping_expression) {
          var self = this;

          return $hash2(["name", "children"], {"name": "GROUP", "children": [grouping_expression.$expression().$accept(self)]})
        }, 1);
        
        $def(self, '$visit_literal', function $$visit_literal(literal_expression) {
          
          return $hash2(["name", "attributes"], {"name": "LITERAL", "attributes": $hash2(["value"], {"value": literal_expression.$value().$inspect()})})
        }, 1);
        
        $def(self, '$visit_logical', function $$visit_logical(logical_expression) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "LOGICAL", "attributes": $hash2(["value"], {"value": logical_expression.$operator().$lexeme()}), "children": [logical_expression.$left().$accept(self), logical_expression.$right().$accept(self)]})
        }, 1);
        
        $def(self, '$visit_unary', function $$visit_unary(unary_expression) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "UNARY", "attributes": $hash2(["operator"], {"operator": unary_expression.$operator().$lexeme()}), "children": [unary_expression.$right().$accept(self)]})
        }, 1);
        
        $def(self, '$visit_variable', function $$visit_variable(variable_expression) {
          var self = this;

          return $hash2(["name", "attributes"], {"name": "VAR-LOOKUP", "attributes": $hash2(["name"], {"name": variable_expression.$name().$lexeme()}).$merge(self.$scope_attributes(variable_expression))})
        }, 1);
        
        $def(self, '$visit_call', function $$visit_call(call_expression) {
          var self = this;

          return $hash2(["name", "attributes", "children"], {"name": "CALL", "attributes": $hash2([], {}), "children": $rb_plus([self.$adorn(call_expression.$callee().$accept(self), "CALLEE")], $send(call_expression.$arguments(), 'map', [], function $$4(argument){var self = $$4.$$s == null ? this : $$4.$$s;

            
            
            if (argument == null) argument = nil;;
            return self.$adorn(argument.$accept(self), "ARG");}, {$$arity: 1, $$s: self}))})
        }, 1);
        self.$private();
        
        $def(self, '$adorn', function $$adorn(node, role) {
          
          
          if (!$truthy(node)) {
            return nil
          };
          return $send(node, 'tap', [], function $$5(){var $writer = nil;

            
            $writer = ["role", role];
            $send(node['$[]']("attributes"), '[]=', $to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, 0);
        }, 2);
        return $def(self, '$scope_attributes', function $$scope_attributes(node) {
          
          if ($truthy(node.$allocation()['$global?']())) {
            return $hash2(["allocation"], {"allocation": "GLOBAL"})
          } else if ($truthy(node.$allocation()['$local?']())) {
            return $hash2(["allocation", "stack slot"], {"allocation": "STACK", "stack slot": node.$allocation().$slot()})
          } else if ($truthy(node.$allocation()['$upvalue?']())) {
            return $hash2(["allocation", "heap slot"], {"allocation": "HEAP", "heap slot": node.$allocation().$slot()})
          } else {
            return nil
          }
        }, 1);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/scanner"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set, $send = Opal.send, $hash2 = Opal.hash2, $def = Opal.def, $klass = Opal.klass, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $rb_ge = Opal.rb_ge, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $rb_le = Opal.rb_le;

  Opal.add_stubs('new,merge,to_h,include,has_more?,scan_token,add_token,advance,===,match?,!=,peek,+,noop,consume_string,consume_number,consume_identifier,report_scanner_error,>=,size,!,at_end?,[],==,-,digit?,peek_next,to_f,=~,<=,<<');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'TokenTypes');

      var $nesting = [self].concat($parent_nesting);

      
      $const_set($nesting[0], 'LEFT_PAREN', "LEFT_PAREN");
      $const_set($nesting[0], 'RIGHT_PAREN', "RIGHT_PAREN");
      $const_set($nesting[0], 'LEFT_BRACE', "LEFT_BRACE");
      $const_set($nesting[0], 'RIGHT_BRACE', "RIGHT_BRACE");
      $const_set($nesting[0], 'COMMA', "COMMA");
      $const_set($nesting[0], 'DOT', "DOT");
      $const_set($nesting[0], 'MINUS', "MINUS");
      $const_set($nesting[0], 'PLUS', "PLUS");
      $const_set($nesting[0], 'SEMICOLON', "SEMICOLON");
      $const_set($nesting[0], 'SLASH', "SLASH");
      $const_set($nesting[0], 'STAR', "STAR");
      $const_set($nesting[0], 'BANG', "BANG");
      $const_set($nesting[0], 'BANG_EQUAL', "BANG_EQUAL");
      $const_set($nesting[0], 'EQUAL', "EQUAL");
      $const_set($nesting[0], 'EQUAL_EQUAL', "EQUAL_EQUAL");
      $const_set($nesting[0], 'GREATER', "GREATER");
      $const_set($nesting[0], 'GREATER_EQUAL', "GREATER_EQUAL");
      $const_set($nesting[0], 'LESS', "LESS");
      $const_set($nesting[0], 'LESS_EQUAL', "LESS_EQUAL");
      $const_set($nesting[0], 'IDENTIFIER', "IDENTIFIER");
      $const_set($nesting[0], 'STRING', "STRING");
      $const_set($nesting[0], 'NUMBER', "NUMBER");
      $const_set($nesting[0], 'AND', "AND");
      $const_set($nesting[0], 'OR', "OR");
      $const_set($nesting[0], 'IF', "IF");
      $const_set($nesting[0], 'ELSE', "ELSE");
      $const_set($nesting[0], 'TRUE_TOKEN', "TRUE");
      $const_set($nesting[0], 'FALSE_TOKEN', "FALSE");
      $const_set($nesting[0], 'WHILE', "WHILE");
      $const_set($nesting[0], 'FOR', "FOR");
      $const_set($nesting[0], 'NIL_TOKEN', "NIL");
      $const_set($nesting[0], 'FUN', "FUN");
      $const_set($nesting[0], 'PRINT', "PRINT");
      $const_set($nesting[0], 'RETURN', "RETURN");
      $const_set($nesting[0], 'VAR', "VAR");
      return $const_set($nesting[0], 'EOF', "EOF");
    })($nesting[0], $nesting);
    $const_set($nesting[0], 'Token', $send($$('Struct'), 'new', ["type", "lexeme", "literal", "line"], function $ALox$1(){var self = $ALox$1.$$s == null ? this : $ALox$1.$$s;

      return $def(self, '$serialize', function $$serialize() {
        var self = this;

        return self.$to_h().$merge($hash2(["name"], {"name": "TOKEN"}))
      }, 0)}, {$$arity: 0, $$s: self}));
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Scanner');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.current = $proto.tokens = $proto.line = $proto.error_reporter = $proto.source = $proto.start = nil;
      
      self.$include($$('TokenTypes'));
      $const_set($nesting[0], 'KEY_WORDS', $hash2(["and", "else", "for", "fun", "if", "nil", "or", "print", "return", "true", "false", "var", "while"], {"and": $$('AND'), "else": $$('ELSE'), "for": $$('FOR'), "fun": $$('FUN'), "if": $$('IF'), "nil": $$('NIL_TOKEN'), "or": $$('OR'), "print": $$('PRINT'), "return": $$('RETURN'), "true": $$('TRUE_TOKEN'), "false": $$('FALSE_TOKEN'), "var": $$('VAR'), "while": $$('WHILE')}));
      
      $def(self, '$initialize', function $$initialize(source, $kwargs) {
        var error_reporter, self = this;

        
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        error_reporter = $kwargs.$$smap["error_reporter"];
        if (error_reporter == null) error_reporter = nil;
        self.source = source;
        self.tokens = [];
        self.start = 0;
        self.current = 0;
        self.line = 1;
        return (self.error_reporter = error_reporter);
      }, -2);
      
      $def(self, '$scan', function $$scan() {
        var $a, self = this;

        
        while ($truthy(self['$has_more?']())) {
          
          self.start = self.current;
          self.$scan_token();
        };
        self.start = self.current;
        self.$add_token($$('EOF'));
        return self.tokens;
      }, 0);
      
      $def(self, '$scan_token', function $$scan_token() {
        var $a, self = this, current_char = nil, $ret_or_1 = nil, $ret_or_2 = nil;

        
        current_char = self.$advance();
        if ($eqeqeq("(", ($ret_or_1 = current_char))) {
          return self.$add_token($$('LEFT_PAREN'))
        } else if ($eqeqeq(")", $ret_or_1)) {
          return self.$add_token($$('RIGHT_PAREN'))
        } else if ($eqeqeq("{", $ret_or_1)) {
          return self.$add_token($$('LEFT_BRACE'))
        } else if ($eqeqeq("}", $ret_or_1)) {
          return self.$add_token($$('RIGHT_BRACE'))
        } else if ($eqeqeq(",", $ret_or_1)) {
          return self.$add_token($$('COMMA'))
        } else if ($eqeqeq(".", $ret_or_1)) {
          return self.$add_token($$('DOT'))
        } else if ($eqeqeq("-", $ret_or_1)) {
          return self.$add_token($$('MINUS'))
        } else if ($eqeqeq("+", $ret_or_1)) {
          return self.$add_token($$('PLUS'))
        } else if ($eqeqeq(";", $ret_or_1)) {
          return self.$add_token($$('SEMICOLON'))
        } else if ($eqeqeq("*", $ret_or_1)) {
          return self.$add_token($$('STAR'))
        } else if ($eqeqeq("!", $ret_or_1)) {
          return self.$add_token(($truthy(self['$match?']("=")) ? ($$('BANG_EQUAL')) : ($$('BANG'))))
        } else if ($eqeqeq("=", $ret_or_1)) {
          return self.$add_token(($truthy(self['$match?']("=")) ? ($$('EQUAL_EQUAL')) : ($$('EQUAL'))))
        } else if ($eqeqeq("<", $ret_or_1)) {
          return self.$add_token(($truthy(self['$match?']("=")) ? ($$('LESS_EQUAL')) : ($$('LESS'))))
        } else if ($eqeqeq(">", $ret_or_1)) {
          return self.$add_token(($truthy(self['$match?']("=")) ? ($$('GREATER_EQUAL')) : ($$('GREATER'))))
        } else if ($eqeqeq("/", $ret_or_1)) {
          if ($truthy(self['$match?']("/"))) {
            while ($truthy(($truthy(($ret_or_2 = self.$peek()['$!=']("\n"))) ? (self['$has_more?']()) : ($ret_or_2)))) {
              self.$advance()
            }
          } else {
            return self.$add_token($$('SLASH'))
          }
        } else if ($eqeqeq("\n", $ret_or_1)) {
          return (self.line = $rb_plus(self.line, 1))
        } else if ($eqeqeq(/\s/, $ret_or_1)) {
          return self.$noop()
        } else if ($eqeqeq("\"", $ret_or_1)) {
          return self.$consume_string()
        } else if ($eqeqeq(/\d/, $ret_or_1)) {
          return self.$consume_number()
        } else if ($eqeqeq(/\w/, $ret_or_1)) {
          return self.$consume_identifier()
        } else {
          return self.error_reporter.$report_scanner_error(self.line, "invalid token")
        };
      }, 0);
      
      $def(self, '$noop', function $$noop() {
        
        return nil
      }, 0);
      
      $def(self, '$at_end?', function $Scanner_at_end$ques$2() {
        var self = this;

        return $rb_ge(self.current, self.source.$size())
      }, 0);
      
      $def(self, '$has_more?', function $Scanner_has_more$ques$3() {
        var self = this;

        return self['$at_end?']()['$!']()
      }, 0);
      
      $def(self, '$advance', function $$advance() {
        var self = this, char$ = nil;

        
        char$ = self.source['$[]'](self.current);
        self.current = $rb_plus(self.current, 1);
        return char$;
      }, 0);
      
      $def(self, '$peek', function $$peek() {
        var self = this;

        
        if ($truthy(self['$at_end?']())) {
          return "\u0000"
        };
        return self.source['$[]'](self.current);
      }, 0);
      
      $def(self, '$peek_next', function $$peek_next() {
        var self = this;

        
        if ($truthy(self['$at_end?']())) {
          return "\u0000"
        };
        return self.source['$[]']($rb_plus(self.current, 1));
      }, 0);
      
      $def(self, '$match?', function $Scanner_match$ques$4(expected) {
        var self = this;

        
        if ($truthy(self['$at_end?']())) {
          return false
        };
        if ($neqeq(self.source['$[]'](self.current), expected)) {
          return false
        };
        self.current = $rb_plus(self.current, 1);
        return true;
      }, 1);
      
      $def(self, '$consume_string', function $$consume_string() {
        var $a, self = this, $ret_or_1 = nil;

        
        while ($truthy(($truthy(($ret_or_1 = self.$peek()['$!=']("\""))) ? (self['$has_more?']()) : ($ret_or_1)))) {
          
          if ($eqeq(self.$peek(), "\n")) {
            self.line = $rb_plus(self.line, 1)
          };
          self.$advance();
        };
        if ($truthy(self['$at_end?']())) {
          self.error_reporter.$report_scanner_error(self.line, "unterminated string")
        };
        self.$advance();
        return self.$add_token($$('STRING'), self.source['$[]'](Opal.Range.$new($rb_plus(self.start, 1),$rb_minus(self.current, 1), true)));
      }, 0);
      
      $def(self, '$consume_number', function $$consume_number() {
        var $a, self = this;

        
        while ($truthy(self['$digit?'](self.$peek()))) {
          self.$advance()
        };
        if (($eqeq(self.$peek(), ".") && ($truthy(self['$digit?'](self.$peek_next()))))) {
          
          self.$advance();
          while ($truthy(self['$digit?'](self.$peek()))) {
            self.$advance()
          };
        };
        return self.$add_token($$('NUMBER'), self.source['$[]'](Opal.Range.$new(self.start,self.current, true)).$to_f());
      }, 0);
      
      $def(self, '$consume_identifier', function $$consume_identifier() {
        var $a, self = this, lexeme = nil, $ret_or_1 = nil;

        
        while ($truthy(self.$peek()['$=~'](/\w/))) {
          self.$advance()
        };
        lexeme = self.source['$[]'](Opal.Range.$new(self.start,self.current, true));
        return self.$add_token(($truthy(($ret_or_1 = $$('KEY_WORDS')['$[]'](lexeme))) ? ($ret_or_1) : ($$('IDENTIFIER'))));
      }, 0);
      
      $def(self, '$digit?', function $Scanner_digit$ques$5(char$) {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $rb_ge(char$, "0")))) {
          return $rb_le(char$, "9")
        } else {
          return $ret_or_1
        }
      }, 1);
      return $def(self, '$add_token', function $$add_token(type, literal) {
        var self = this, lexeme = nil;

        
        
        if (literal == null) literal = nil;;
        lexeme = self.source['$[]'](Opal.Range.$new(self.start,self.current, true));
        return self.tokens['$<<']($$('Token').$new(type, lexeme, literal, self.line));
      }, -2);
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/ast_node_dsl"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $defs = Opal.defs, $klass = Opal.klass, $def = Opal.def, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $to_a = Opal.to_a, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $range = Opal.range, $gvars = Opal.gvars;

  Opal.add_stubs('extend,attr_reader,include?,fail,<<,each,new,instance_eval,to_proc,primary_fields,attr_accessor,additional_fields,define_method,!=,size,present_fields_list,each_with_index,instance_variable_set,[],public_send,underscore,name,class,private,empty?,==,first,+,join,map,last,split,gsub,tr,downcase');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'AstNodeDSL');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$included', function $$included(base) {
        var self = this;

        return base.$extend(self)
      }, 1);
      (function($base, $super) {
        var self = $klass($base, $super, 'DSLEnvironment');

        var $proto = self.$$prototype;

        $proto.primary_fields = nil;
        
        self.$attr_reader("primary_fields", "additional_fields");
        
        $def(self, '$initialize', function $$initialize() {
          var self = this;

          
          self.primary_fields = [];
          return (self.additional_fields = []);
        }, 0);
        
        $def(self, '$method_missing', function $$method_missing(name, $a, $b) {
          var $post_args, $kwargs, args, kwargs, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 1);
          
          $kwargs = Opal.extract_kwargs($post_args);
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          args = $post_args;;
          
          kwargs = Opal.kwrestargs($kwargs, {});;
          if ($truthy(self.primary_fields['$include?'](name))) {
            self.$fail()
          };
          return self.primary_fields['$<<'](name);
        }, -2);
        
        $def(self, '$respond_to_missing?', function $DSLEnvironment_respond_to_missing$ques$1($a) {
          var $post_args, $rest_arg;

          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          return true;
        }, -1);
        return $def(self, '$additional', function $$additional($a) {
          var $post_args, names, self = this;

          
          
          $post_args = Opal.slice.call(arguments);
          
          names = $post_args;;
          return $send(names, 'each', [], function $$2(name){var self = $$2.$$s == null ? this : $$2.$$s;
            if (self.additional_fields == null) self.additional_fields = nil;

            
            
            if (name == null) name = nil;;
            if ($truthy(self.additional_fields['$include?'](name))) {
              self.$fail()
            };
            return self.additional_fields['$<<'](name);}, {$$arity: 1, $$s: self});
        }, -1);
      })($nesting[0], null);
      return $def(self, '$define_node', function $$define_node() {
        var block = $$define_node.$$p || nil, self = this, env = nil;

        delete $$define_node.$$p;
        
        ;
        env = $$('DSLEnvironment').$new();
        $send(env, 'instance_eval', [], block.$to_proc());
        return $send($$('Class'), 'new', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          
          $send(self, 'attr_reader', $to_a(env.$primary_fields()));
          $send(self, 'attr_accessor', $to_a(env.$additional_fields()));
          $send(self, 'define_method', ["initialize"], function $$4($a){var $post_args, args, self = $$4.$$s == null ? this : $$4.$$s;

            
            
            $post_args = Opal.slice.call(arguments);
            
            args = $post_args;;
            if ($neqeq(args.$size(), env.$primary_fields().$size())) {
              self.$fail($$('ArgumentError'), "exactly " + (self.$present_fields_list(env.$primary_fields())) + " needed")
            };
            $send(env.$primary_fields(), 'each_with_index', [], function $$5(primary_field_name, i){var self = $$5.$$s == null ? this : $$5.$$s;

              
              
              if (primary_field_name == null) primary_field_name = nil;;
              
              if (i == null) i = nil;;
              return self.$instance_variable_set("@" + (primary_field_name), args['$[]'](i));}, {$$arity: 2, $$s: self});
            return $send(env.$additional_fields(), 'each', [], function $$6(f){var self = $$6.$$s == null ? this : $$6.$$s;

              
              
              if (f == null) f = nil;;
              return self.$instance_variable_set("@" + (f), nil);}, {$$arity: 1, $$s: self});}, {$$arity: -1, $$s: self});
          $send(self, 'define_method', ["accept"], function $$7(visitor){var self = $$7.$$s == null ? this : $$7.$$s;

            
            
            if (visitor == null) visitor = nil;;
            return visitor.$public_send("visit_" + (self.$underscore(self.$class().$name())), self);}, {$$arity: 1, $$s: self});
          self.$private();
          
          $def(self, '$present_fields_list', function $$present_fields_list(fields) {
            
            
            if ($truthy(fields['$empty?']())) {
              return "no fields"
            };
            if ($eqeq(fields.$size(), 1)) {
              return "`" + (fields.$first()) + "`"
            };
            return $rb_plus($send(fields['$[]']($range(0, -2, false)), 'map', [], function $$8(f){
              
              
              if (f == null) f = nil;;
              return "`" + (f) + "`";}, 1).$join(", "), " and `" + (fields['$[]'](-1)) + "`");
          }, 1);
          return $def(self, '$underscore', function $$underscore(camel_cased_word) {
            var word = nil;

            
            word = camel_cased_word.$split("::").$last();
            word = $send(word, 'gsub', [/([A-Z]+)(?=[A-Z][a-z])|([a-z\d])(?=[A-Z])/], function $$9(){var $a, $ret_or_1 = nil;

              return $rb_plus(($truthy(($ret_or_1 = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) ? ($ret_or_1) : ((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))), "_")}, 0);
            word = word.$tr("-", "_");
            word = word.$downcase();
            return word;
          }, 1);}, {$$arity: 0, $$s: self});
      }, 0);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/expression"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set, $send = Opal.send;

  Opal.add_stubs('include,define_node,name,value,additional,left,operator,right,expression,callee,paren,arguments');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Expression');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$include($$('AstNodeDSL'));
      $const_set($nesting[0], 'Assign', $send(self, 'define_node', [], function $Expression$1(){var self = $Expression$1.$$s == null ? this : $Expression$1.$$s;

        
        self.$name();
        self.$value();
        return self.$additional("allocation");}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'Variable', $send(self, 'define_node', [], function $Expression$2(){var self = $Expression$2.$$s == null ? this : $Expression$2.$$s;

        
        self.$name();
        return self.$additional("allocation");}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'Binary', $send(self, 'define_node', [], function $Expression$3(){var self = $Expression$3.$$s == null ? this : $Expression$3.$$s;

        
        self.$left();
        self.$operator();
        return self.$right();}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'Logical', $send(self, 'define_node', [], function $Expression$4(){var self = $Expression$4.$$s == null ? this : $Expression$4.$$s;

        
        self.$left();
        self.$operator();
        return self.$right();}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'Unary', $send(self, 'define_node', [], function $Expression$5(){var self = $Expression$5.$$s == null ? this : $Expression$5.$$s;

        
        self.$operator();
        return self.$right();}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'Grouping', $send(self, 'define_node', [], function $Expression$6(){var self = $Expression$6.$$s == null ? this : $Expression$6.$$s;

        return self.$expression()}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'Literal', $send(self, 'define_node', [], function $Expression$7(){var self = $Expression$7.$$s == null ? this : $Expression$7.$$s;

        return self.$value()}, {$$arity: 0, $$s: self}));
      return $const_set($nesting[0], 'Call', $send(self, 'define_node', [], function $Expression$8(){var self = $Expression$8.$$s == null ? this : $Expression$8.$$s;

        
        self.$callee();
        self.$paren();
        return self.$arguments();}, {$$arity: 0, $$s: self}));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/statement"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set, $send = Opal.send;

  Opal.add_stubs('include,define_node,expression,name,parameters,body,additional,keyword,value,initializer,statements,condition,then_branch,else_branch');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Statement');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$include($$('AstNodeDSL'));
      $const_set($nesting[0], 'ExpressionStatement', $send(self, 'define_node', [], function $Statement$1(){var self = $Statement$1.$$s == null ? this : $Statement$1.$$s;

        return self.$expression()}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'FunctionStatement', $send(self, 'define_node', [], function $Statement$2(){var self = $Statement$2.$$s == null ? this : $Statement$2.$$s;

        
        self.$name();
        self.$parameters();
        self.$body();
        return self.$additional("allocation", "full_name", "upvalues");}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'ReturnStatement', $send(self, 'define_node', [], function $Statement$3(){var self = $Statement$3.$$s == null ? this : $Statement$3.$$s;

        
        self.$keyword();
        return self.$value();}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'PrintStatement', $send(self, 'define_node', [], function $Statement$4(){var self = $Statement$4.$$s == null ? this : $Statement$4.$$s;

        return self.$expression()}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'VarStatement', $send(self, 'define_node', [], function $Statement$5(){var self = $Statement$5.$$s == null ? this : $Statement$5.$$s;

        
        self.$name();
        self.$initializer();
        return self.$additional("allocation");}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'BlockStatement', $send(self, 'define_node', [], function $Statement$6(){var self = $Statement$6.$$s == null ? this : $Statement$6.$$s;

        
        self.$statements();
        return self.$additional("locals");}, {$$arity: 0, $$s: self}));
      $const_set($nesting[0], 'IfStatement', $send(self, 'define_node', [], function $Statement$7(){var self = $Statement$7.$$s == null ? this : $Statement$7.$$s;

        
        self.$condition();
        self.$then_branch();
        return self.$else_branch();}, {$$arity: 0, $$s: self}));
      return $const_set($nesting[0], 'WhileStatement', $send(self, 'define_node', [], function $Statement$8(){var self = $Statement$8.$$s == null ? this : $Statement$8.$$s;

        
        self.$condition();
        return self.$body();}, {$$arity: 0, $$s: self}));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/parser"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $def = Opal.def, $truthy = Opal.truthy, $not = Opal.not, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq;

  Opal.add_stubs('include,has_more?,<<,parse_toplevel_statement,match_any?,parse_variable_declaration,parse_function_declaration,parse_statement,synchronize,consume,parse_expression,new,!,check,loop,>,size,error,peek,parse_block_statement,parse_print_statement,parse_if,parse_while,parse_for,parse_return,parse_expression_statement,nil?,previous,parse_assignment,parse_or,is_a?,name,parse_and,parse_equality,parse_comparison,parse_term,parse_factor,parse_unary,parse_call,parse_primary,parse_finish_call,count,literal,raise,each,advance,at_end?,==,type,[],-,+,report_parser_error,include?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Parser');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.tokens = $proto.current = $proto.error_reporter = nil;
      
      self.$include($$('TokenTypes'));
      self.$include($$('Expression'));
      self.$include($$('Statement'));
      $klass($nesting[0], $$('RuntimeError'), 'ParserError');
      
      $def(self, '$initialize', function $$initialize(tokens, $kwargs) {
        var error_reporter, self = this;

        
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        error_reporter = $kwargs.$$smap["error_reporter"];
        if (error_reporter == null) error_reporter = nil;
        self.tokens = tokens;
        self.current = 0;
        return (self.error_reporter = error_reporter);
      }, -2);
      
      $def(self, '$parse', function $$parse() {
        var $a, self = this, statements = nil;

        
        statements = [];
        while ($truthy(self['$has_more?']())) {
          statements['$<<'](self.$parse_toplevel_statement())
        };
        return statements;
      }, 0);
      
      $def(self, '$parse_toplevel_statement', function $$parse_toplevel_statement() {
        var self = this;

        try {
          if ($truthy(self['$match_any?']($$('VAR')))) {
            return self.$parse_variable_declaration()
          } else if ($truthy(self['$match_any?']($$('FUN')))) {
            return self.$parse_function_declaration("function")
          } else {
            return self.$parse_statement()
          }
        } catch ($err) {
          if (Opal.rescue($err, [$$('ParserError')])) {
            try {
              
              self.$synchronize();
              return nil;
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }
      }, 0);
      
      $def(self, '$parse_variable_declaration', function $$parse_variable_declaration() {
        var self = this, name = nil, initializer = nil;

        
        name = self.$consume($$('IDENTIFIER'), "Expected variable name");
        if ($truthy(self['$match_any?']($$('EQUAL')))) {
          initializer = self.$parse_expression()
        };
        self.$consume($$('SEMICOLON'), "Expected ; after variable declaration");
        return $$('VarStatement').$new(name, initializer);
      }, 0);
      
      $def(self, '$parse_function_declaration', function $$parse_function_declaration(kind) {
        var self = this, name = nil, parameters = nil, body = nil;

        
        name = self.$consume($$('IDENTIFIER'), "Expected " + (kind) + " name");
        self.$consume($$('LEFT_PAREN'), "Expected ( after " + (kind) + " name");
        parameters = [];
        if ($not(self.$check($$('RIGHT_PAREN')))) {
          (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            
            if ($truthy($rb_gt(parameters.$size(), 255))) {
              self.$error(self.$peek(), "Expected function to have fewer than 255 parameters")
            };
            parameters['$<<'](self.$consume($$('IDENTIFIER'), "Expected parameter name"));
            if ($truthy(self['$match_any?']($$('COMMA')))) {
              return nil
            } else {
              
              Opal.brk(nil, $brk)
            };}, {$$arity: 0, $$s: self, $$brk: $brk})
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()
        };
        self.$consume($$('RIGHT_PAREN'), "Expected ) after " + (kind) + " parameter list");
        self.$consume($$('LEFT_BRACE'), "Expected { before " + (kind) + " body");
        body = self.$parse_block_statement();
        return $$('FunctionStatement').$new(name, parameters, body);
      }, 1);
      
      $def(self, '$parse_statement', function $$parse_statement() {
        var self = this;

        if ($truthy(self['$match_any?']($$('PRINT')))) {
          return self.$parse_print_statement()
        } else if ($truthy(self['$match_any?']($$('LEFT_BRACE')))) {
          return $$('BlockStatement').$new(self.$parse_block_statement())
        } else if ($truthy(self['$match_any?']($$('IF')))) {
          return self.$parse_if()
        } else if ($truthy(self['$match_any?']($$('WHILE')))) {
          return self.$parse_while()
        } else if ($truthy(self['$match_any?']($$('FOR')))) {
          return self.$parse_for()
        } else if ($truthy(self['$match_any?']($$('RETURN')))) {
          return self.$parse_return()
        } else {
          return self.$parse_expression_statement()
        }
      }, 0);
      
      $def(self, '$parse_if', function $$parse_if() {
        var self = this, condition = nil, then_branch = nil, else_branch = nil;

        
        self.$consume($$('LEFT_PAREN'), "Expected ( before if condition");
        condition = self.$parse_expression();
        self.$consume($$('RIGHT_PAREN'), "Expected ) after if condition");
        then_branch = self.$parse_statement();
        if ($truthy(self['$match_any?']($$('ELSE')))) {
          else_branch = self.$parse_statement()
        };
        return $$('IfStatement').$new(condition, then_branch, else_branch);
      }, 0);
      
      $def(self, '$parse_while', function $$parse_while() {
        var self = this, condition = nil, body = nil;

        
        self.$consume($$('LEFT_PAREN'), "Expected ( before while condition");
        condition = self.$parse_expression();
        self.$consume($$('RIGHT_PAREN'), "Expected ) after while condition");
        body = self.$parse_statement();
        return $$('WhileStatement').$new(condition, body);
      }, 0);
      
      $def(self, '$parse_for', function $$parse_for() {
        var self = this, initializer = nil, condition = nil, increment = nil, body = nil, $ret_or_1 = nil;

        
        self.$consume($$('LEFT_PAREN'), "Expected ( after for");
        initializer = ($truthy(self['$match_any?']($$('SEMICOLON'))) ? (nil) : ($truthy(self['$match_any?']($$('VAR'))) ? (self.$parse_variable_declaration()) : (self.$parse_expression_statement())));
        if ($not(self.$check($$('SEMICOLON')))) {
          condition = self.$parse_expression()
        };
        self.$consume($$('SEMICOLON'), "Expected ; after for condition");
        if ($not(self.$check($$('RIGHT_PAREN')))) {
          increment = $$('ExpressionStatement').$new(self.$parse_expression())
        };
        self.$consume($$('RIGHT_PAREN'), "Expected ) after for clauses");
        body = self.$parse_statement();
        if ($not(increment['$nil?']())) {
          body = $$('BlockStatement').$new([body, increment])
        };
        body = $$('WhileStatement').$new(($truthy(($ret_or_1 = condition)) ? ($ret_or_1) : ($$('Literal').$new(true))), body);
        if ($truthy(initializer)) {
          body = $$('BlockStatement').$new([initializer, body])
        };
        return body;
      }, 0);
      
      $def(self, '$parse_return', function $$parse_return() {
        var self = this, keyword = nil, value = nil;

        
        keyword = self.$previous();
        value = ($not(self.$check($$('SEMICOLON'))) ? (self.$parse_expression()) : nil);
        self.$consume($$('SEMICOLON'), "Expected semicolon after return");
        return $$('ReturnStatement').$new(keyword, value);
      }, 0);
      
      $def(self, '$parse_print_statement', function $$parse_print_statement() {
        var self = this, expression = nil;

        
        expression = self.$parse_expression();
        self.$consume($$('SEMICOLON'), "Expected ; after expression");
        return $$('PrintStatement').$new(expression);
      }, 0);
      
      $def(self, '$parse_block_statement', function $$parse_block_statement() {
        var $a, self = this, statements = nil, $ret_or_1 = nil;

        
        statements = [];
        while ($truthy(($truthy(($ret_or_1 = self.$check($$('RIGHT_BRACE'))['$!']())) ? (self['$has_more?']()) : ($ret_or_1)))) {
          statements['$<<'](self.$parse_toplevel_statement())
        };
        self.$consume($$('RIGHT_BRACE'), "Expected } at end of block");
        return statements;
      }, 0);
      
      $def(self, '$parse_expression_statement', function $$parse_expression_statement() {
        var self = this, expression = nil;

        
        expression = self.$parse_expression();
        self.$consume($$('SEMICOLON'), "Expected ; after expression");
        return $$('ExpressionStatement').$new(expression);
      }, 0);
      
      $def(self, '$parse_expression', function $$parse_expression() {
        var self = this;

        return self.$parse_assignment()
      }, 0);
      
      $def(self, '$parse_assignment', function $$parse_assignment() {
        var self = this, expression = nil, equal = nil, name = nil, value = nil;

        
        expression = self.$parse_or();
        if ($truthy(self['$match_any?']($$('EQUAL')))) {
          
          equal = self.$previous();
          if ($truthy(expression['$is_a?']($$('Variable')))) {
            
            name = expression.$name();
            value = self.$parse_expression();
            return $$('Assign').$new(name, value);
          } else {
            self.$error(equal, "Expected variable name on left side of assignment")
          };
        };
        return expression;
      }, 0);
      
      $def(self, '$parse_or', function $$parse_or() {
        var $a, self = this, expression = nil, operator = nil, right = nil;

        
        expression = self.$parse_and();
        while ($truthy(self['$match_any?']($$('OR')))) {
          
          operator = self.$previous();
          right = self.$parse_and();
          expression = $$('Logical').$new(expression, operator, right);
        };
        return expression;
      }, 0);
      
      $def(self, '$parse_and', function $$parse_and() {
        var $a, self = this, expression = nil, operator = nil, right = nil;

        
        expression = self.$parse_equality();
        while ($truthy(self['$match_any?']($$('AND')))) {
          
          operator = self.$previous();
          right = self.$parse_equality();
          expression = $$('Logical').$new(expression, operator, right);
        };
        return expression;
      }, 0);
      
      $def(self, '$parse_equality', function $$parse_equality() {
        var $a, self = this, expression = nil, operator = nil, right_expression = nil;

        
        expression = self.$parse_comparison();
        while ($truthy(self['$match_any?']($$('BANG_EQUAL'), $$('EQUAL_EQUAL')))) {
          
          operator = self.$previous();
          right_expression = self.$parse_comparison();
          expression = $$('Binary').$new(expression, operator, right_expression);
        };
        return expression;
      }, 0);
      
      $def(self, '$parse_comparison', function $$parse_comparison() {
        var $a, self = this, expression = nil, operator = nil, right_expression = nil;

        
        expression = self.$parse_term();
        while ($truthy(self['$match_any?']($$('GREATER'), $$('GREATER_EQUAL'), $$('LESS'), $$('LESS_EQUAL')))) {
          
          operator = self.$previous();
          right_expression = self.$parse_term();
          expression = $$('Binary').$new(expression, operator, right_expression);
        };
        return expression;
      }, 0);
      
      $def(self, '$parse_term', function $$parse_term() {
        var $a, self = this, expression = nil, operator = nil, right_expression = nil;

        
        expression = self.$parse_factor();
        while ($truthy(self['$match_any?']($$('PLUS'), $$('MINUS')))) {
          
          operator = self.$previous();
          right_expression = self.$parse_factor();
          expression = $$('Binary').$new(expression, operator, right_expression);
        };
        return expression;
      }, 0);
      
      $def(self, '$parse_factor', function $$parse_factor() {
        var $a, self = this, expression = nil, operator = nil, right_expression = nil;

        
        expression = self.$parse_unary();
        while ($truthy(self['$match_any?']($$('STAR'), $$('SLASH')))) {
          
          operator = self.$previous();
          right_expression = self.$parse_unary();
          expression = $$('Binary').$new(expression, operator, right_expression);
        };
        return expression;
      }, 0);
      
      $def(self, '$parse_unary', function $$parse_unary() {
        var self = this, operator = nil, right = nil;

        
        if ($truthy(self['$match_any?']($$('BANG'), $$('MINUS')))) {
          
          operator = self.$previous();
          right = self.$parse_unary();
          return $$('Unary').$new(operator, right);
        };
        return self.$parse_call();
      }, 0);
      
      $def(self, '$parse_call', function $$parse_call() {
        var self = this, expression = nil;

        
        expression = self.$parse_primary();
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s, name = nil;

          if ($truthy(self['$match_any?']($$('LEFT_PAREN')))) {
            return (expression = self.$parse_finish_call(expression))
          } else if ($truthy(self['$match_any?']($$('DOT')))) {
            
            name = self.$consume($$('IDENTIFIER'), "Expected identifier after .");
            return (expression = $$('GetExpression').$new(expression, name));
          } else {
            
            Opal.brk(nil, $brk)
          }}, {$$arity: 0, $$s: self, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        return expression;
      }, 0);
      
      $def(self, '$parse_finish_call', function $$parse_finish_call(callee) {
        var self = this, arguments$ = nil, close_paren = nil;

        
        arguments$ = [];
        if ($not(self.$check($$('RIGHT_PAREN')))) {
          (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

            
            if ($truthy($rb_gt(arguments$.$count(), 255))) {
              self.$error(self.$peek(), "Can't have more than 255 arguments")
            };
            arguments$['$<<'](self.$parse_expression());
            if ($truthy(self['$match_any?']($$('COMMA')))) {
              return nil
            } else {
              
              Opal.brk(nil, $brk)
            };}, {$$arity: 0, $$s: self, $$brk: $brk})
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()
        };
        close_paren = self.$consume($$('RIGHT_PAREN'), "Expected ) after argument list");
        return $$('Call').$new(callee, close_paren, arguments$);
      }, 1);
      
      $def(self, '$parse_primary', function $$parse_primary() {
        var self = this, expression = nil;

        
        if ($truthy(self['$match_any?']($$('NUMBER'), $$('STRING')))) {
          return $$('Literal').$new(self.$previous().$literal())
        };
        if ($truthy(self['$match_any?']($$('FALSE_TOKEN')))) {
          return $$('Literal').$new(false)
        };
        if ($truthy(self['$match_any?']($$('TRUE_TOKEN')))) {
          return $$('Literal').$new(true)
        };
        if ($truthy(self['$match_any?']($$('NIL_TOKEN')))) {
          return $$('Literal').$new(nil)
        };
        if ($truthy(self['$match_any?']($$('IDENTIFIER')))) {
          return $$('Variable').$new(self.$previous())
        };
        if ($truthy(self['$match_any?']($$('LEFT_PAREN')))) {
          
          expression = self.$parse_expression();
          self.$consume($$('RIGHT_PAREN'), "Expected ')' after expression");
          return $$('Grouping').$new(expression);
        };
        return self.$raise(self.$error(self.$peek(), "Expected expression"));
      }, 0);
      
      $def(self, '$match_any?', function $Parser_match_any$ques$4($a) {try {

        var $post_args, token_types, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        token_types = $post_args;;
        $send(token_types, 'each', [], function $$5(token_type){var self = $$5.$$s == null ? this : $$5.$$s;

          
          
          if (token_type == null) token_type = nil;;
          if ($truthy(self.$check(token_type))) {
            
            self.$advance();
            Opal.ret(true);
          } else {
            return nil
          };}, {$$arity: 1, $$s: self});
        return false;
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, -1);
      
      $def(self, '$check', function $$check(token_type) {
        var self = this;

        
        if ($truthy(self['$at_end?']())) {
          return false
        };
        return self.$peek().$type()['$=='](token_type);
      }, 1);
      
      $def(self, '$peek', function $$peek() {
        var self = this;

        return self.tokens['$[]'](self.current)
      }, 0);
      
      $def(self, '$previous', function $$previous() {
        var self = this;

        return self.tokens['$[]']($rb_minus(self.current, 1))
      }, 0);
      
      $def(self, '$advance', function $$advance() {
        var self = this;

        
        if ($truthy(self['$has_more?']())) {
          self.current = $rb_plus(self.current, 1)
        };
        return self.$previous();
      }, 0);
      
      $def(self, '$consume', function $$consume(token_type, message) {
        var self = this;

        if ($truthy(self.$check(token_type))) {
          return self.$advance()
        } else {
          return self.$raise(self.$error(self.$peek(), message))
        }
      }, 2);
      
      $def(self, '$error', function $$error(token, message) {
        var $a, self = this;

        
        ($a = self.error_reporter, ($a === nil || $a == null) ? nil : $send($a, 'report_parser_error', [token, message]));
        return $$('ParserError').$new();
      }, 2);
      
      $def(self, '$synchronize', function $$synchronize() {
        var $a, self = this;

        
        self.$advance();
        while ($truthy(self['$has_more?']())) {
          
          if ($eqeq(self.$previous().$type(), $$('SEMICOLON'))) {
            return nil
          };
          if ($truthy([$$('FOR'), $$('FUN'), $$('IF'), $$('PRINT'), $$('RETURN'), $$('VAR'), $$('WHILE')]['$include?'](self.$peek().$type()))) {
            return nil
          };
          self.$advance();
        };
      }, 0);
      
      $def(self, '$at_end?', function $Parser_at_end$ques$6() {
        var self = this;

        return self.$peek().$type()['$==']($$('EOF'))
      }, 0);
      return $def(self, '$has_more?', function $Parser_has_more$ques$7() {
        var self = this;

        return self['$at_end?']()['$!']()
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/static_resolver/upvalues"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $defs = Opal.defs, $hash2 = Opal.hash2, $def = Opal.def, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_gt = Opal.rb_gt, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $to_ary = Opal.to_ary, $to_a = Opal.to_a;

  Opal.add_stubs('new,attr_accessor,==,kind,attr_reader,nil?,+,-,select,>,depth,reject!,top_level?,global,local,count,<<,find_local,find_upvalue,add_upvalue,upvalue,detect,name,captured=,slot,each_with_index,is_a?,each,resolve,accept,report_static_analysis_error,begin_block,last,statements,end_block,locals=,add_variable,lexeme,allocation=,initializer,resolve_variable,value,map,parameters,body,upvalues,upvalues=,join,to_proc,full_name=,pop,expression,condition,then_branch,else_branch,error,keyword,left,right,callee,arguments');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'StaticResolver');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Upvalues');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.error_reporter = $proto.function_scopes = nil;
        
        $const_set($nesting[0], 'Variable', $send($$('Struct'), 'new', ["name", "kind", "slot", "depth"], function $Upvalues$1(){var self = $Upvalues$1.$$s == null ? this : $Upvalues$1.$$s;

          
          self.$attr_accessor("captured");
          $defs(self, '$global', function $$global() {
            var self = this;

            return self.$new(nil, "global", nil)
          }, 0);
          $defs(self, '$local', function $$local($kwargs) {
            var name, slot, depth, self = this;

            
            
            if ($kwargs == null) {
              $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
              throw Opal.ArgumentError.$new('expected kwargs');
            };
            
            if (!Opal.hasOwnProperty.call($kwargs.$$smap, 'name')) {
              throw Opal.ArgumentError.$new('missing keyword: name');
            }
            name = $kwargs.$$smap["name"];;
            
            if (!Opal.hasOwnProperty.call($kwargs.$$smap, 'slot')) {
              throw Opal.ArgumentError.$new('missing keyword: slot');
            }
            slot = $kwargs.$$smap["slot"];;
            
            if (!Opal.hasOwnProperty.call($kwargs.$$smap, 'depth')) {
              throw Opal.ArgumentError.$new('missing keyword: depth');
            }
            depth = $kwargs.$$smap["depth"];;
            return self.$new(name, "local", slot, depth);
          }, 1);
          $defs(self, '$upvalue', function $$upvalue($kwargs) {
            var name, slot, self = this;

            
            
            if ($kwargs == null) {
              $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
              throw Opal.ArgumentError.$new('expected kwargs');
            };
            
            if (!Opal.hasOwnProperty.call($kwargs.$$smap, 'name')) {
              throw Opal.ArgumentError.$new('missing keyword: name');
            }
            name = $kwargs.$$smap["name"];;
            
            if (!Opal.hasOwnProperty.call($kwargs.$$smap, 'slot')) {
              throw Opal.ArgumentError.$new('missing keyword: slot');
            }
            slot = $kwargs.$$smap["slot"];;
            return self.$new(name, "upvalue", slot, nil);
          }, 1);
          
          $def(self, '$global?', function $global$ques$2() {
            var self = this;

            return self.$kind()['$==']("global")
          }, 0);
          
          $def(self, '$local?', function $local$ques$3() {
            var self = this;

            return self.$kind()['$==']("local")
          }, 0);
          return $def(self, '$upvalue?', function $upvalue$ques$4() {
            var self = this;

            return self.$kind()['$==']("upvalue")
          }, 0);}, {$$arity: 0, $$s: self}));
        $const_set($nesting[0], 'Upvalue', $$('Struct').$new("slot", "local"));
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'FunctionScope');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.enclosing = $proto.current_depth = $proto.locals = $proto.upvalues = nil;
          
          self.$attr_reader("upvalues", "name");
          
          $def(self, '$initialize', function $$initialize(name, $kwargs) {
            var enclosing, self = this;

            
            
            if ($kwargs == null) {
              $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
              throw Opal.ArgumentError.$new('expected kwargs');
            };
            
            enclosing = $kwargs.$$smap["enclosing"];
            if (enclosing == null) enclosing = nil;
            self.name = name;
            self.enclosing = enclosing;
            self.locals = [];
            self.current_depth = 0;
            return (self.upvalues = []);
          }, -2);
          
          $def(self, '$top_level?', function $FunctionScope_top_level$ques$5() {
            var self = this;

            return self.enclosing['$nil?']()
          }, 0);
          
          $def(self, '$begin_block', function $$begin_block() {
            var self = this;

            return (self.current_depth = $rb_plus(self.current_depth, 1))
          }, 0);
          
          $def(self, '$end_block', function $$end_block() {
            var self = this, block_variables = nil;

            
            self.current_depth = $rb_minus(self.current_depth, 1);
            block_variables = $send(self.locals, 'select', [], function $$6(_1){var self = $$6.$$s == null ? this : $$6.$$s;
              if (self.current_depth == null) self.current_depth = nil;

              
              
              if (_1 == null) _1 = nil;;
              return $rb_gt(_1.$depth(), self.current_depth);}, {$$arity: 1, $$s: self});
            $send(self.locals, 'reject!', [], function $$7(_1){var self = $$7.$$s == null ? this : $$7.$$s;
              if (self.current_depth == null) self.current_depth = nil;

              
              
              if (_1 == null) _1 = nil;;
              return $rb_gt(_1.$depth(), self.current_depth);}, {$$arity: 1, $$s: self});
            return block_variables;
          }, 0);
          
          $def(self, '$add_variable', function $$add_variable(name) {
            var self = this, variable = nil;

            
            if (($truthy(self['$top_level?']()) && ($eqeq(self.current_depth, 0)))) {
              return $$('Variable').$global()
            };
            variable = $$('Variable').$local($hash2(["name", "slot", "depth"], {"name": name, "slot": self.locals.$count(), "depth": self.current_depth}));
            self.locals['$<<'](variable);
            return variable;
          }, 1);
          
          $def(self, '$resolve_variable', function $$resolve_variable(name) {
            var $a, $b, self = this, local = nil, upvalue_slot = nil, is_local = nil, upvalue_index = nil;

            
            local = self.$find_local(name);
            if ($truthy(local)) {
              return local
            };
            if ($truthy(self.enclosing)) {
              
              $b = self.enclosing.$find_upvalue(name), $a = $to_ary($b), (upvalue_slot = ($a[0] == null ? nil : $a[0])), (is_local = ($a[1] == null ? nil : $a[1])), $b;
              if ($truthy(upvalue_slot)) {
                
                upvalue_index = self.$add_upvalue(upvalue_slot, $hash2(["local"], {"local": is_local}));
                return $$('Variable').$upvalue($hash2(["name", "slot"], {"name": name, "slot": upvalue_index}));
              };
            };
            return $$('Variable').$global();
          }, 1);
          
          $def(self, '$find_local', function $$find_local(name) {
            var self = this;

            return $send(self.locals, 'detect', [], function $$8(local){
              
              
              if (local == null) local = nil;;
              return local.$name()['$=='](name);}, 1)
          }, 1);
          
          $def(self, '$find_upvalue', function $$find_upvalue(name) {
            var $a, $b, self = this, local = nil, $writer = nil, up_upvalue_slot = nil, is_local = nil, xxx_slot = nil;

            
            local = self.$find_local(name);
            if ($truthy(local)) {
              
              
              $writer = [true];
              $send(local, 'captured=', $to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              return [local.$slot(), true];
            };
            if ($truthy(self.enclosing)) {
              
              $b = self.enclosing.$find_upvalue(name), $a = $to_ary($b), (up_upvalue_slot = ($a[0] == null ? nil : $a[0])), (is_local = ($a[1] == null ? nil : $a[1])), $b;
              if ($truthy(up_upvalue_slot)) {
                
                xxx_slot = self.$add_upvalue(up_upvalue_slot, $hash2(["local"], {"local": is_local}));
                return [xxx_slot, false];
              };
            };
            return [nil, false];
          }, 1);
          return $def(self, '$add_upvalue', function $$add_upvalue(upvalue, $kwargs) {try {

            var local, self = this, new_upvalue = nil;

            
            
            if ($kwargs == null) {
              $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
              throw Opal.ArgumentError.$new('expected kwargs');
            };
            
            if (!Opal.hasOwnProperty.call($kwargs.$$smap, 'local')) {
              throw Opal.ArgumentError.$new('missing keyword: local');
            }
            local = $kwargs.$$smap["local"];;
            new_upvalue = $$('Upvalue').$new(upvalue, local);
            $send(self.upvalues, 'each_with_index', [], function $$9(upvalue, index){
              
              
              if (upvalue == null) upvalue = nil;;
              
              if (index == null) index = nil;;
              if ($eqeq(upvalue, new_upvalue)) {
                Opal.ret(index)
              } else {
                return nil
              };}, 2);
            self.upvalues['$<<'](new_upvalue);
            return $rb_minus(self.upvalues.$count(), 1);
            } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
          }, 2);
        })($nesting[0], null, $nesting);
        
        $def(self, '$initialize', function $$initialize($kwargs) {
          var error_reporter, self = this;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          error_reporter = $kwargs.$$smap["error_reporter"];
          if (error_reporter == null) error_reporter = nil;
          self.function_scopes = [$$('FunctionScope').$new("global")];
          return (self.error_reporter = error_reporter);
        }, -1);
        
        $def(self, '$resolve', function $$resolve(resolvable) {
          var self = this;

          if ($truthy(resolvable['$is_a?']($$('Array')))) {
            return $send(resolvable, 'each', [], function $$10(resolvable_element){var self = $$10.$$s == null ? this : $$10.$$s;

              
              
              if (resolvable_element == null) resolvable_element = nil;;
              return self.$resolve(resolvable_element);}, {$$arity: 1, $$s: self})
          } else {
            return resolvable.$accept(self)
          }
        }, 1);
        
        $def(self, '$error', function $$error(token, message) {
          var $a, self = this;

          return ($a = self.error_reporter, ($a === nil || $a == null) ? nil : $send($a, 'report_static_analysis_error', [token, message]))
        }, 2);
        
        $def(self, '$visit_block_statement', function $$visit_block_statement(block_statement) {
          var self = this, $writer = nil;

          
          self.function_scopes.$last().$begin_block();
          self.$resolve(block_statement.$statements());
          
          $writer = [self.function_scopes.$last().$end_block()];
          $send(block_statement, 'locals=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }, 1);
        
        $def(self, '$visit_var_statement', function $$visit_var_statement(var_statement) {
          var self = this, $writer = nil;

          
          
          $writer = [self.function_scopes.$last().$add_variable(var_statement.$name().$lexeme())];
          $send(var_statement, 'allocation=', $to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(var_statement.$initializer())) {
            return self.$resolve(var_statement.$initializer())
          } else {
            return nil
          };
        }, 1);
        
        $def(self, '$visit_variable', function $$visit_variable(variable_expression) {
          var self = this, $writer = nil;

          
          $writer = [self.function_scopes.$last().$resolve_variable(variable_expression.$name().$lexeme())];
          $send(variable_expression, 'allocation=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, 1);
        
        $def(self, '$visit_assign', function $$visit_assign(assign_expression) {
          var self = this, $writer = nil;

          
          self.$resolve(assign_expression.$value());
          
          $writer = [self.function_scopes.$last().$resolve_variable(assign_expression.$name().$lexeme())];
          $send(assign_expression, 'allocation=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }, 1);
        
        $def(self, '$visit_function_statement', function $$visit_function_statement(function_statement) {
          var self = this, $writer = nil;

          
          
          $writer = [self.function_scopes.$last().$add_variable(function_statement.$name().$lexeme())];
          $send(function_statement, 'allocation=', $to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          self.function_scopes['$<<']($$('FunctionScope').$new(function_statement.$name().$lexeme(), $hash2(["enclosing"], {"enclosing": self.function_scopes.$last()})));
          $send(function_statement.$parameters(), 'map', [], function $$11(parameter){var self = $$11.$$s == null ? this : $$11.$$s;
            if (self.function_scopes == null) self.function_scopes = nil;

            
            
            if (parameter == null) parameter = nil;;
            return self.function_scopes.$last().$add_variable(parameter.$lexeme());}, {$$arity: 1, $$s: self});
          self.$resolve(function_statement.$body());
          
          $writer = [self.function_scopes.$last().$upvalues()];
          $send(function_statement, 'upvalues=', $to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [$rb_plus($rb_plus("__", $send(self.function_scopes, 'map', [], "name".$to_proc()).$join("__")), "__")];
          $send(function_statement, 'full_name=', $to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return self.function_scopes.$pop();
        }, 1);
        
        $def(self, '$visit_expression_statement', function $$visit_expression_statement(expression_statement) {
          var self = this;

          return self.$resolve(expression_statement.$expression())
        }, 1);
        
        $def(self, '$visit_if_statement', function $$visit_if_statement(if_statement) {
          var self = this;

          
          self.$resolve(if_statement.$condition());
          self.$resolve(if_statement.$then_branch());
          if ($truthy(if_statement.$else_branch())) {
            return self.$resolve(if_statement.$else_branch())
          } else {
            return nil
          };
        }, 1);
        
        $def(self, '$visit_print_statement', function $$visit_print_statement(print_statement) {
          var self = this;

          return self.$resolve(print_statement.$expression())
        }, 1);
        
        $def(self, '$visit_return_statement', function $$visit_return_statement(return_statement) {
          var self = this;

          
          if ($truthy(self.function_scopes.$last()['$top_level?']())) {
            self.$error(return_statement.$keyword(), "Can't return outside of function")
          };
          if ($truthy(return_statement.$value())) {
            return self.$resolve(return_statement.$value())
          } else {
            return nil
          };
        }, 1);
        
        $def(self, '$visit_while_statement', function $$visit_while_statement(while_statement) {
          var self = this;

          
          self.$resolve(while_statement.$condition());
          return self.$resolve(while_statement.$body());
        }, 1);
        
        $def(self, '$visit_binary', function $$visit_binary(binary_expression) {
          var self = this;

          
          self.$resolve(binary_expression.$left());
          return self.$resolve(binary_expression.$right());
        }, 1);
        
        $def(self, '$visit_call', function $$visit_call(call_expression) {
          var self = this;

          
          self.$resolve(call_expression.$callee());
          return $send(call_expression.$arguments(), 'each', [], function $$12(argument){var self = $$12.$$s == null ? this : $$12.$$s;

            
            
            if (argument == null) argument = nil;;
            return self.$resolve(argument);}, {$$arity: 1, $$s: self});
        }, 1);
        
        $def(self, '$visit_grouping', function $$visit_grouping(grouping_expression) {
          var self = this;

          return self.$resolve(grouping_expression.$expression())
        }, 1);
        
        $def(self, '$visit_logical', function $$visit_logical(logical_expression) {
          var self = this;

          
          self.$resolve(logical_expression.$left());
          return self.$resolve(logical_expression.$right());
        }, 1);
        
        $def(self, '$visit_unary', function $$visit_unary(unary_expression) {
          var self = this;

          return self.$resolve(unary_expression.$right())
        }, 1);
        return $def(self, '$visit_literal', function $$visit_literal(literal_expression) {
          
          return nil
        }, 1);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/executable_container"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $hash2 = Opal.hash2, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy;

  Opal.add_stubs('attr_reader,[]=,-,<<,[],size,pack_short,+,include?,index,map,respond_to?,serialize');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ExecutableContainer');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.functions = $proto.constants = nil;
      
      $const_set($nesting[0], 'PLACEHOLDER', "PLACEHOLDER");
      self.$attr_reader("functions", "constants");
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self.functions = $hash2([], {});
        return (self.constants = []);
      }, 0);
      
      $def(self, '$reset_function', function $$reset_function(function$) {
        var self = this, $writer = nil;

        
        $writer = [function$, []];
        $send(self.functions, '[]=', $to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, 1);
      
      $def(self, '$write', function $$write(function$, opcode) {
        var self = this;

        
        self.functions['$[]'](function$)['$<<'](opcode);
        return self.functions['$[]'](function$).$size();
      }, 2);
      
      $def(self, '$patch_jump', function $$patch_jump(function$, jump_offset) {
        var $a, $b, self = this, jump = nil, first_byte = nil, second_byte = nil, $writer = nil;

        
        jump = $rb_minus($rb_minus(self.functions['$[]'](function$).$size(), jump_offset), 2);
        $b = $$('BinaryUtils').$pack_short(jump), $a = $to_ary($b), (first_byte = ($a[0] == null ? nil : $a[0])), (second_byte = ($a[1] == null ? nil : $a[1])), $b;
        
        $writer = [jump_offset, first_byte];
        $send(self.functions['$[]'](function$), '[]=', $to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [$rb_plus(jump_offset, 1), second_byte];
        $send(self.functions['$[]'](function$), '[]=', $to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, 2);
      
      $def(self, '$add_constant', function $$add_constant(constant) {
        var self = this;

        if ($truthy(self.constants['$include?'](constant))) {
          return self.constants.$index(constant)
        } else {
          
          self.constants['$<<'](constant);
          return $rb_minus(self.constants.$size(), 1);
        }
      }, 1);
      
      $def(self, '$size', function $$size(function$) {
        var self = this;

        return self.functions['$[]'](function$).$size()
      }, 1);
      return $def(self, '$serialize', function $$serialize() {
        var self = this;

        return $hash2(["functions", "constants"], {"functions": self.functions, "constants": $send(self.constants, 'map', [], function $$1(constant){
          
          
          if (constant == null) constant = nil;;
          if ($truthy(constant['$respond_to?']("serialize"))) {
            return constant.$serialize()
          } else {
            return constant
          };}, 1)})
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/compiler"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, $eqeq = Opal.eqeq;

  Opal.add_stubs('attr_reader,count,upvalue_count,new,reset_function,each,accept,emit_return,add_constant,expression,emit,compile,body,full_name,parameters,upvalues,emit_two,local,slot,global?,allocation,lexeme,name,local?,value,initializer,fail,statements,locals,captured,condition,emit_jump,then_branch,patch_jump,else_branch,size,[],functions,pack_short,-,upvalue?,left,right,fetch,operator,==,nil?,type,callee,arguments,write');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Compiler');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.statements = $proto["function"] = $proto.executable = $proto.name = nil;
      
      (function($base, $super) {
        var self = $klass($base, $super, 'FunctionDescriptor');

        var $proto = self.$$prototype;

        $proto.upvalues = $proto.arity = $proto.name = nil;
        
        self.$attr_reader("arity", "name");
        
        $def(self, '$initialize', function $$initialize(name, arity, upvalues) {
          var self = this;

          
          self.arity = arity;
          self.name = name;
          return (self.upvalues = upvalues);
        }, 3);
        
        $def(self, '$upvalue_count', function $$upvalue_count() {
          var self = this;

          return self.upvalues.$count()
        }, 0);
        return $def(self, '$serialize', function $$serialize() {
          var self = this;

          return $hash2(["type", "arity", "name", "upvalue_count"], {"type": "function", "arity": self.arity, "name": self.name, "upvalue_count": self.$upvalue_count()})
        }, 0);
      })($nesting[0], null);
      
      $def(self, '$initialize', function $$initialize(statements, executable, $a, $b, $c, $d) {
        var $post_args, $kwargs, name, arity, upvalues, error_reporter, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 2);
        
        $kwargs = Opal.extract_kwargs($post_args);
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        if ($post_args.length > 0) name = $post_args.shift();
        if (name == null) name = "__toplevel__";;
        
        if ($post_args.length > 0) arity = $post_args.shift();
        if (arity == null) arity = 0;;
        
        if ($post_args.length > 0) upvalues = $post_args.shift();
        if (upvalues == null) upvalues = [];;
        
        error_reporter = $kwargs.$$smap["error_reporter"];
        if (error_reporter == null) error_reporter = nil;
        self.statements = statements;
        self.executable = executable;
        self.name = name;
        self["function"] = $$('FunctionDescriptor').$new(name, arity, upvalues);
        self.error_reporter = error_reporter;
        return executable.$reset_function(name);
      }, -3);
      
      $def(self, '$compile', function $$compile() {
        var self = this;

        
        $send(self.statements, 'each', [], function $$1(statement){var self = $$1.$$s == null ? this : $$1.$$s;

          
          
          if (statement == null) statement = nil;;
          return statement.$accept(self);}, {$$arity: 1, $$s: self});
        self.$emit_return();
        return self["function"];
      }, 0);
      
      $def(self, '$add_constant', function $$add_constant(constant) {
        var self = this;

        return self.executable.$add_constant(constant)
      }, 1);
      
      $def(self, '$visit_expression_statement', function $$visit_expression_statement(expression_statement) {
        var self = this;

        
        expression_statement.$expression().$accept(self);
        return self.$emit($$$($$('Opcodes'), 'POP'));
      }, 1);
      
      $def(self, '$visit_function_statement', function $$visit_function_statement(function_statement) {
        var self = this, function$ = nil, constant_index = nil;

        
        function$ = $$('Compiler').$new(function_statement.$body(), self.executable, function_statement.$full_name(), function_statement.$parameters().$count(), function_statement.$upvalues()).$compile();
        self.$emit_two($$$($$('Opcodes'), 'LOAD_CLOSURE'), self.$add_constant(function$));
        $send(function_statement.$upvalues(), 'each', [], function $$2(upvalue){var self = $$2.$$s == null ? this : $$2.$$s;

          
          
          if (upvalue == null) upvalue = nil;;
          return self.$emit_two(($truthy(upvalue.$local()) ? (1) : (0)), upvalue.$slot());}, {$$arity: 1, $$s: self});
        if ($truthy(function_statement.$allocation()['$global?']())) {
          
          constant_index = self.$add_constant(function_statement.$name().$lexeme());
          return self.$emit_two($$$($$('Opcodes'), 'DEFINE_GLOBAL'), constant_index);
        } else if ($truthy(function_statement.$allocation()['$local?']())) {
          return nil
        } else {
          return nil
        };
      }, 1);
      
      $def(self, '$visit_return_statement', function $$visit_return_statement(return_statement) {
        var self = this;

        
        if ($truthy(return_statement.$value())) {
          return_statement.$value().$accept(self)
        } else {
          self.$emit($$$($$('Opcodes'), 'NIL_OP'))
        };
        return self.$emit($$$($$('Opcodes'), 'RETURN'));
      }, 1);
      
      $def(self, '$visit_print_statement', function $$visit_print_statement(print_statement) {
        var self = this;

        
        print_statement.$expression().$accept(self);
        return self.$emit($$$($$('Opcodes'), 'PRINT'));
      }, 1);
      
      $def(self, '$visit_var_statement', function $$visit_var_statement(var_statement) {
        var self = this;

        
        if ($truthy(var_statement.$initializer())) {
          var_statement.$initializer().$accept(self)
        } else {
          self.$emit($$$($$('Opcodes'), 'NIL_OP'))
        };
        if ($truthy(var_statement.$allocation()['$global?']())) {
          return self.$emit_two($$$($$('Opcodes'), 'DEFINE_GLOBAL'), self.$add_constant(var_statement.$name().$lexeme()))
        } else if ($truthy(var_statement.$allocation()['$local?']())) {
          return nil
        } else {
          return self.$fail()
        };
      }, 1);
      
      $def(self, '$visit_block_statement', function $$visit_block_statement(block_statement) {
        var self = this;

        
        $send(block_statement.$statements(), 'each', [], function $$3(statement){var self = $$3.$$s == null ? this : $$3.$$s;

          
          
          if (statement == null) statement = nil;;
          return statement.$accept(self);}, {$$arity: 1, $$s: self});
        return $send(block_statement.$locals(), 'each', [], function $$4(local){var self = $$4.$$s == null ? this : $$4.$$s;

          
          
          if (local == null) local = nil;;
          if ($truthy(local.$captured())) {
            return self.$emit($$$($$('Opcodes'), 'CLOSE_UPVALUE'))
          } else {
            return self.$emit($$$($$('Opcodes'), 'POP'))
          };}, {$$arity: 1, $$s: self});
      }, 1);
      
      $def(self, '$visit_if_statement', function $$visit_if_statement(if_statement) {
        var $a, self = this, else_jump_offset = nil, exit_jump = nil;

        
        if_statement.$condition().$accept(self);
        else_jump_offset = self.$emit_jump($$$($$('Opcodes'), 'JUMP_ON_FALSE'));
        self.$emit($$$($$('Opcodes'), 'POP'));
        if_statement.$then_branch().$accept(self);
        exit_jump = self.$emit_jump($$$($$('Opcodes'), 'JUMP'));
        self.executable.$patch_jump(self.name, else_jump_offset);
        self.$emit($$$($$('Opcodes'), 'POP'));
        ($a = if_statement.$else_branch(), ($a === nil || $a == null) ? nil : $send($a, 'accept', [self]));
        return self.executable.$patch_jump(self.name, exit_jump);
      }, 1);
      
      $def(self, '$visit_while_statement', function $$visit_while_statement(while_statement) {
        var self = this, begin_loop_offset = nil, exit_loop_offset = nil;

        
        begin_loop_offset = self.executable.$functions()['$[]'](self.name).$size();
        while_statement.$condition().$accept(self);
        exit_loop_offset = self.$emit_jump($$$($$('Opcodes'), 'JUMP_ON_FALSE'));
        self.$emit($$$($$('Opcodes'), 'POP'));
        while_statement.$body().$accept(self);
        self.$emit($$$($$('Opcodes'), 'JUMP'));
        $send(self, 'emit_two', $to_a($$('BinaryUtils').$pack_short($rb_minus($rb_minus(begin_loop_offset, 2), self.executable.$functions()['$[]'](self.name).$size()))));
        self.executable.$patch_jump(self.name, exit_loop_offset);
        return self.$emit($$$($$('Opcodes'), 'POP'));
      }, 1);
      
      $def(self, '$visit_class_statement', function $$visit_class_statement() {
        
        return nil
      }, 0);
      
      $def(self, '$visit_assign', function $$visit_assign(assign_expression) {
        var self = this, constant_index = nil;

        
        assign_expression.$value().$accept(self);
        if ($truthy(assign_expression.$allocation()['$global?']())) {
          
          constant_index = self.$add_constant(assign_expression.$name().$lexeme());
          return self.$emit_two($$$($$('Opcodes'), 'SET_GLOBAL'), constant_index);
        } else if ($truthy(assign_expression.$allocation()['$local?']())) {
          return self.$emit_two($$$($$('Opcodes'), 'SET_LOCAL'), assign_expression.$allocation().$slot())
        } else if ($truthy(assign_expression.$allocation()['$upvalue?']())) {
          return self.$emit_two($$$($$('Opcodes'), 'SET_UPVALUE'), assign_expression.$allocation().$slot())
        } else {
          return self.$fail()
        };
      }, 1);
      
      $def(self, '$visit_variable', function $$visit_variable(variable_expression) {
        var self = this, constant_index = nil;

        if ($truthy(variable_expression.$allocation()['$global?']())) {
          
          constant_index = self.$add_constant(variable_expression.$name().$lexeme());
          return self.$emit_two($$$($$('Opcodes'), 'GET_GLOBAL'), constant_index);
        } else if ($truthy(variable_expression.$allocation()['$local?']())) {
          return self.$emit_two($$$($$('Opcodes'), 'GET_LOCAL'), variable_expression.$allocation().$slot())
        } else if ($truthy(variable_expression.$allocation()['$upvalue?']())) {
          return self.$emit_two($$$($$('Opcodes'), 'GET_UPVALUE'), variable_expression.$allocation().$slot())
        } else {
          return self.$fail()
        }
      }, 1);
      
      $def(self, '$visit_binary', function $$visit_binary(binary_expression) {
        var self = this;

        
        binary_expression.$left().$accept(self);
        binary_expression.$right().$accept(self);
        return $send($hash2(["+", "-", "*", "/", "==", "!=", ">", "<", ">=", "<="], {"+": [$$$($$('Opcodes'), 'ADD')], "-": [$$$($$('Opcodes'), 'SUBTRACT')], "*": [$$$($$('Opcodes'), 'MULTIPLY')], "/": [$$$($$('Opcodes'), 'DIVIDE')], "==": [$$$($$('Opcodes'), 'EQUAL')], "!=": [$$$($$('Opcodes'), 'EQUAL'), $$$($$('Opcodes'), 'NOT')], ">": [$$$($$('Opcodes'), 'GREATER')], "<": [$$$($$('Opcodes'), 'LESSER')], ">=": [$$$($$('Opcodes'), 'LESSER'), $$$($$('Opcodes'), 'NOT')], "<=": [$$$($$('Opcodes'), 'GREATER'), $$$($$('Opcodes'), 'NOT')]}).$fetch(binary_expression.$operator().$lexeme()), 'each', [], function $$5(op){var self = $$5.$$s == null ? this : $$5.$$s;

          
          
          if (op == null) op = nil;;
          return self.$emit(op);}, {$$arity: 1, $$s: self});
      }, 1);
      
      $def(self, '$visit_grouping', function $$visit_grouping(grouping_expression) {
        var self = this;

        return grouping_expression.$expression().$accept(self)
      }, 1);
      
      $def(self, '$visit_literal', function $$visit_literal(literal_expression) {
        var self = this, constant_index = nil;

        if ($eqeq(literal_expression.$value(), true)) {
          return self.$emit($$$($$('Opcodes'), 'TRUE_OP'))
        } else if ($eqeq(literal_expression.$value(), false)) {
          return self.$emit($$$($$('Opcodes'), 'FALSE_OP'))
        } else if ($truthy(literal_expression.$value()['$nil?']())) {
          return self.$emit($$$($$('Opcodes'), 'NIL_OP'))
        } else {
          
          constant_index = self.$add_constant(literal_expression.$value());
          return self.$emit_two($$$($$('Opcodes'), 'LOAD_CONSTANT'), constant_index);
        }
      }, 1);
      
      $def(self, '$visit_logical', function $$visit_logical(logical_expression) {
        var self = this, short_circuit_exit = nil, else_jump = nil, end_jump = nil;

        if ($eqeq(logical_expression.$operator().$type(), $$$($$('TokenTypes'), 'AND'))) {
          
          logical_expression.$left().$accept(self);
          short_circuit_exit = self.$emit_jump($$$($$('Opcodes'), 'JUMP_ON_FALSE'));
          self.$emit($$$($$('Opcodes'), 'POP'));
          logical_expression.$right().$accept(self);
          return self.executable.$patch_jump(self.name, short_circuit_exit);
        } else if ($eqeq(logical_expression.$operator().$type(), $$$($$('TokenTypes'), 'OR'))) {
          
          logical_expression.$left().$accept(self);
          else_jump = self.$emit_jump($$$($$('Opcodes'), 'JUMP_ON_FALSE'));
          end_jump = self.$emit_jump($$$($$('Opcodes'), 'JUMP'));
          self.executable.$patch_jump(self.name, else_jump);
          self.$emit($$$($$('Opcodes'), 'POP'));
          logical_expression.$right().$accept(self);
          return self.executable.$patch_jump(self.name, end_jump);
        } else {
          return self.$fail()
        }
      }, 1);
      
      $def(self, '$visit_unary', function $$visit_unary(unary_expression) {
        var self = this;

        
        unary_expression.$right().$accept(self);
        return $send($hash2(["-", "!"], {"-": [$$$($$('Opcodes'), 'NEGATE')], "!": [$$$($$('Opcodes'), 'NOT')]}).$fetch(unary_expression.$operator().$lexeme()), 'each', [], function $$6(op){var self = $$6.$$s == null ? this : $$6.$$s;

          
          
          if (op == null) op = nil;;
          return self.$emit(op);}, {$$arity: 1, $$s: self});
      }, 1);
      
      $def(self, '$visit_call', function $$visit_call(call_expression) {
        var self = this;

        
        call_expression.$callee().$accept(self);
        $send(call_expression.$arguments(), 'each', [], function $$7(arg){var self = $$7.$$s == null ? this : $$7.$$s;

          
          
          if (arg == null) arg = nil;;
          return arg.$accept(self);}, {$$arity: 1, $$s: self});
        return self.$emit_two($$$($$('Opcodes'), 'CALL'), call_expression.$arguments().$count());
      }, 1);
      
      $def(self, '$emit', function $$emit(opcode) {
        var self = this;

        return self.executable.$write(self.name, opcode)
      }, 1);
      
      $def(self, '$emit_two', function $$emit_two(opcode, operand) {
        var self = this;

        
        self.$emit(opcode);
        return self.$emit(operand);
      }, 2);
      
      $def(self, '$emit_jump', function $$emit_jump(jump_opcode) {
        var self = this;

        
        self.$emit(jump_opcode);
        self.$emit("PLACEHOLDER");
        self.$emit("PLACEHOLDER");
        return $rb_minus(self.executable.$size(self.name), 2);
      }, 1);
      return $def(self, '$emit_return', function $$emit_return() {
        var self = this;

        
        self.$emit($$$($$('Opcodes'), 'NIL_OP'));
        return self.$emit($$$($$('Opcodes'), 'RETURN'));
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox/opcodes"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Opcodes');

      var $nesting = [self].concat($parent_nesting);

      
      $const_set($nesting[0], 'LOAD_CONSTANT', "LOAD-CONSTANT");
      $const_set($nesting[0], 'LOAD_CLOSURE', "LOAD-CLOSURE");
      $const_set($nesting[0], 'RETURN', "RETURN");
      $const_set($nesting[0], 'ADD', "ADD");
      $const_set($nesting[0], 'SUBTRACT', "SUBTRACT");
      $const_set($nesting[0], 'MULTIPLY', "MULTIPLY");
      $const_set($nesting[0], 'DIVIDE', "DIVIDE");
      $const_set($nesting[0], 'EQUAL', "EQUAL");
      $const_set($nesting[0], 'GREATER', "GREATER");
      $const_set($nesting[0], 'LESSER', "LESSER");
      $const_set($nesting[0], 'NOT', "NOT");
      $const_set($nesting[0], 'NEGATE', "NEGATE");
      $const_set($nesting[0], 'POP', "POP");
      $const_set($nesting[0], 'TRUE_OP', "TRUE");
      $const_set($nesting[0], 'FALSE_OP', "FALSE");
      $const_set($nesting[0], 'NIL_OP', "NIL");
      $const_set($nesting[0], 'PRINT', "PRINT");
      $const_set($nesting[0], 'DEFINE_GLOBAL', "DEFINE-GLOBAL");
      $const_set($nesting[0], 'GET_GLOBAL', "GET-GLOBAL");
      $const_set($nesting[0], 'SET_GLOBAL', "SET-GLOBAL");
      $const_set($nesting[0], 'GET_LOCAL', "GET-LOCAL");
      $const_set($nesting[0], 'SET_LOCAL', "SET-LOCAL");
      $const_set($nesting[0], 'GET_UPVALUE', "GET-UPVALUE");
      $const_set($nesting[0], 'SET_UPVALUE', "SET-UPVALUE");
      $const_set($nesting[0], 'CLOSE_UPVALUE', "CLOSE-UPVALUE");
      $const_set($nesting[0], 'JUMP_ON_FALSE', "JUMP-ON-FALSE");
      $const_set($nesting[0], 'JUMP', "JUMP");
      return $const_set($nesting[0], 'CALL', "CALL");
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["ostruct"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $to_a = Opal.to_a, $rb_minus = Opal.rb_minus, $def = Opal.def, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_plus = Opal.rb_plus, $alias = Opal.alias;

  Opal.add_stubs('each_pair,new_ostruct_member,[]=,-,[],to_sym,>,length,raise,new,end_with?,!=,chomp,to_s,key?,enum_for,is_a?,==,instance_variable_get,===,eql?,dup,to_n,hash,attr_reader,__send__,singleton_class,delete,respond_to?,define_singleton_method,__id__,class,any?,+,join,map,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'OpenStruct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.table = nil;
    
    
    $def(self, '$initialize', function $$initialize(hash) {
      var self = this;

      
      
      if (hash == null) hash = nil;;
      self.table = $hash2([], {});
      if ($truthy(hash)) {
        return $send(hash, 'each_pair', [], function $$1(key, value){var self = $$1.$$s == null ? this : $$1.$$s, $writer = nil;
          if (self.table == null) self.table = nil;

          
          
          if (key == null) key = nil;;
          
          if (value == null) value = nil;;
          $writer = [self.$new_ostruct_member(key), value];
          $send(self.table, '[]=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, {$$arity: 2, $$s: self})
      } else {
        return nil
      };
    }, -1);
    
    $def(self, '$[]', function $OpenStruct_$$$2(name) {
      var self = this;

      return self.table['$[]'](name.$to_sym())
    }, 1);
    
    $def(self, '$[]=', function $OpenStruct_$$$eq$3(name, value) {
      var self = this, $writer = nil;

      
      $writer = [self.$new_ostruct_member(name), value];
      $send(self.table, '[]=', $to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, 2);
    
    $def(self, '$method_missing', function $$method_missing(name, $a) {
      var $post_args, args, self = this, $writer = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 2))) {
        self.$raise($$('NoMethodError').$new("undefined method `" + (name) + "' for #<OpenStruct>", name))
      };
      if ($truthy(name['$end_with?']("="))) {
        
        if ($neqeq(args.$length(), 1)) {
          self.$raise($$('ArgumentError'), "wrong number of arguments (0 for 1)")
        };
        
        $writer = [self.$new_ostruct_member(name['$[]']($range(0, -2, false))), args['$[]'](0)];
        $send(self.table, '[]=', $to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      } else {
        return self.table['$[]'](name.$to_sym())
      };
    }, -2);
    
    $def(self, '$respond_to_missing?', function $OpenStruct_respond_to_missing$ques$4(mid, include_private) {
      var $a, $yield = $OpenStruct_respond_to_missing$ques$4.$$p || nil, self = this, mname = nil, $ret_or_1 = nil;

      delete $OpenStruct_respond_to_missing$ques$4.$$p;
      
      
      if (include_private == null) include_private = false;;
      mname = mid.$to_s().$chomp("=").$to_sym();
      if ($truthy(($ret_or_1 = ($a = self.table, ($a === nil || $a == null) ? nil : $send($a, 'key?', [mname]))))) {
        return $ret_or_1
      } else {
        return $send2(self, $find_super(self, 'respond_to_missing?', $OpenStruct_respond_to_missing$ques$4, false, true), 'respond_to_missing?', [mid, include_private], $yield)
      };
    }, -2);
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      delete $$each_pair.$$p;
      
      if (!($yield !== nil)) {
        return self.$enum_for("each_pair")
      };
      return $send(self.table, 'each_pair', [], function $$5(pair){
        
        
        if (pair == null) pair = nil;;
        return Opal.yield1($yield, pair);;}, 1);
    }, 0);
    
    $def(self, '$==', function $OpenStruct_$eq_eq$6(other) {
      var self = this;

      
      if (!$truthy(other['$is_a?']($$('OpenStruct')))) {
        return false
      };
      return self.table['$=='](other.$instance_variable_get("@table"));
    }, 1);
    
    $def(self, '$===', function $OpenStruct_$eq_eq_eq$7(other) {
      var self = this;

      
      if (!$truthy(other['$is_a?']($$('OpenStruct')))) {
        return false
      };
      return self.table['$==='](other.$instance_variable_get("@table"));
    }, 1);
    
    $def(self, '$eql?', function $OpenStruct_eql$ques$8(other) {
      var self = this;

      
      if (!$truthy(other['$is_a?']($$('OpenStruct')))) {
        return false
      };
      return self.table['$eql?'](other.$instance_variable_get("@table"));
    }, 1);
    
    $def(self, '$to_h', function $$to_h() {
      var self = this;

      return self.table.$dup()
    }, 0);
    
    $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.table.$to_n()
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.table.$hash()
    }, 0);
    self.$attr_reader("table");
    
    $def(self, '$delete_field', function $$delete_field(name) {
      var self = this, sym = nil;

      
      sym = name.$to_sym();
      
      try {
        self.$singleton_class().$__send__("remove_method", sym, "" + (sym) + "=")
      } catch ($err) {
        if (Opal.rescue($err, [$$('NameError')])) {
          try {
            nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };;
      return self.table.$delete(sym);
    }, 1);
    
    $def(self, '$new_ostruct_member', function $$new_ostruct_member(name) {
      var self = this;

      
      name = name.$to_sym();
      if (!$truthy(self['$respond_to?'](name))) {
        
        $send(self, 'define_singleton_method', [name], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;
          if (self.table == null) self.table = nil;

          return self.table['$[]'](name)}, {$$arity: 0, $$s: self});
        $send(self, 'define_singleton_method', ["" + (name) + "="], function $$10(x){var self = $$10.$$s == null ? this : $$10.$$s, $writer = nil;
          if (self.table == null) self.table = nil;

          
          
          if (x == null) x = nil;;
          $writer = [name, x];
          $send(self.table, '[]=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, {$$arity: 1, $$s: self});
      };
      return name;
    }, 1);
    var ostruct_ids;;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      
      var top = (ostruct_ids === undefined),
          ostruct_id = self.$__id__();
    ;
      
      return (function() { try {
      
      result = "#<" + (self.$class());
      
        if (top) {
          ostruct_ids = {};
        }
        if (ostruct_ids.hasOwnProperty(ostruct_id)) {
          return result + ' ...>';
        }
        ostruct_ids[ostruct_id] = true;
      ;
      if ($truthy(self.table['$any?']())) {
        result = $rb_plus(result, " ")
      };
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$11(name, value){
        
        
        if (name == null) name = nil;;
        
        if (value == null) value = nil;;
        return "" + (name) + "=" + (value.$inspect());}, 2).$join(", "));
      result = $rb_plus(result, ">");
      return result;
      } finally {
        
        if (top) {
          ostruct_ids = undefined;
        }
      
      }; })();;
    }, 0);
    return $alias(self, "to_s", "inspect");
  })($nesting[0], null, $nesting)
};

Opal.modules["lib/a_lox/vm"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $defs = Opal.defs, $def = Opal.def, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $gvars = Opal.gvars, $eqeqeq = Opal.eqeqeq, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $rb_times = Opal.rb_times, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $rb_ge = Opal.rb_ge, $range = Opal.range;

  Opal.add_stubs('require,new,attr_reader,name,arity,+,[],functions,function_name,-,unpack_short,read_code,constants,[]=,pointer,execute,top_level_script,loop,last,nil?,===,push,read_constant,map,times,upvalue_count,==,detect,stack_top,<<,sort_by!,-@,upvalues,callable,pop,has_key?,error,set_stack_slot,get_stack_slot,value,set_value,falsey?,empty?,fail,/,*,equal?,>,<,is_a?,size,lox_object_to_string,count,>=,first,shift,close!,puts,read_short,jump,inspect,print_debug_info,any?,private,!,to_s,report_runtime_error,local_variable_get,print_stack,join');
  
  self.$require("ostruct");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'VM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.stack = $proto.error_reporter = nil;
      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Callable');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.function_descriptor = nil;
        
        $defs(self, '$top_level_script', function $$top_level_script() {
          
          return $$('OpenStruct').$new($hash2(["function_name", "upvalues"], {"function_name": "__toplevel__", "upvalues": []}))
        }, 0);
        self.$attr_reader("upvalues");
        
        $def(self, '$initialize', function $$initialize(function_descriptor, upvalues) {
          var self = this;

          
          self.function_descriptor = function_descriptor;
          return (self.upvalues = upvalues);
        }, 2);
        
        $def(self, '$function_name', function $$function_name() {
          var self = this;

          return self.function_descriptor.$name()
        }, 0);
        return $def(self, '$arity', function $$arity() {
          var self = this;

          return self.function_descriptor.$arity()
        }, 0);
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'CallFrame');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.ip = $proto.executable = $proto.callable = $proto.stack = $proto.stack_top = nil;
        
        self.$attr_reader("callable", "stack_top");
        
        $def(self, '$initialize', function $$initialize(executable, stack, callable, stack_top) {
          var self = this;

          
          
          if (stack_top == null) stack_top = 0;;
          self.executable = executable;
          self.stack = stack;
          self.callable = callable;
          self.ip = 0;
          return (self.stack_top = stack_top);
        }, -4);
        
        $def(self, '$read_code', function $$read_code() {
          var self = this;

          
          self.ip = $rb_plus(self.ip, 1);
          return self.executable.$functions()['$[]'](self.callable.$function_name())['$[]']($rb_minus(self.ip, 1));
        }, 0);
        
        $def(self, '$read_short', function $$read_short() {
          var self = this;

          return $$('BinaryUtils').$unpack_short(self.$read_code(), self.$read_code())
        }, 0);
        
        $def(self, '$read_constant', function $$read_constant(constant_index) {
          var self = this;

          return self.executable.$constants()['$[]'](constant_index)
        }, 1);
        
        $def(self, '$get_stack_slot', function $$get_stack_slot(offset) {
          var self = this;

          return self.stack['$[]']($rb_plus(self.stack_top, offset))
        }, 1);
        
        $def(self, '$set_stack_slot', function $$set_stack_slot(offset, value) {
          var self = this, $writer = nil;

          
          $writer = [$rb_plus(self.stack_top, offset), value];
          $send(self.stack, '[]=', $to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, 2);
        return $def(self, '$jump', function $$jump(location) {
          var self = this;

          return (self.ip = $rb_plus(self.ip, location))
        }, 1);
      })($nesting[0], null, $nesting);
      (function($base, $super) {
        var self = $klass($base, $super, 'Upvalue');

        var $proto = self.$$prototype;

        $proto.stack = $proto.value = nil;
        
        self.$attr_reader("pointer");
        
        $def(self, '$initialize', function $$initialize(pointer, stack) {
          var self = this;

          
          self.pointer = pointer;
          return (self.stack = stack);
        }, 2);
        
        $def(self, '$close!', function $Upvalue_close$excl$1() {
          var self = this;

          return (self.value = self.stack['$[]'](self.$pointer()))
        }, 0);
        
        $def(self, '$value', function $$value() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.value))) {
            return $ret_or_1
          } else {
            return self.stack['$[]'](self.$pointer())
          }
        }, 0);
        return $def(self, '$set_value', function $$set_value(new_value) {
          var $a, self = this, $writer = nil;

          if ($truthy((($a = self['value'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
            return (self.value = new_value)
          } else {
            
            $writer = [self.$pointer(), new_value];
            $send(self.stack, '[]=', $to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }
        }, 1);
      })($nesting[0], null);
      $defs(self, '$execute', function $$execute(executable, $kwargs) {
        var out, debug, self = this;
        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        out = $kwargs.$$smap["out"];
        if (out == null) out = $gvars.stdout;
        
        debug = $kwargs.$$smap["debug"];
        if (debug == null) debug = false;
        return self.$new().$execute(executable, $hash2(["out", "debug"], {"out": out, "debug": debug}));
      }, -2);
      
      $def(self, '$initialize', function $$initialize($kwargs) {
        var error_reporter, self = this;

        
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        error_reporter = $kwargs.$$smap["error_reporter"];
        if (error_reporter == null) error_reporter = nil;
        self.stack = [];
        self.globals = $hash2([], {});
        return (self.error_reporter = error_reporter);
      }, -1);
      
      $def(self, '$execute', function $$execute(executable, $kwargs) {
        var out, debug, self = this, call_frames = nil, open_upvalues = nil;
        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        out = $kwargs.$$smap["out"];
        if (out == null) out = $gvars.stdout;
        
        debug = $kwargs.$$smap["debug"];
        if (debug == null) debug = false;
        call_frames = [$$('CallFrame').$new(executable, self.stack, $$('Callable').$top_level_script())];
        open_upvalues = [];
        self.had_error = false;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$2(){var $a, self = $$2.$$s == null ? this : $$2.$$s, call_frame = nil, op = nil, $ret_or_1 = nil, function_descriptor = nil, upvalues = nil, $writer = nil, global_name = nil, b = nil, a = nil, argument_count = nil, callable = nil, result = nil, $ret_or_2 = nil, upvalue = nil, location = nil;
          if (self.had_error == null) self.had_error = nil;
          if (self.stack == null) self.stack = nil;
          if (self.globals == null) self.globals = nil;

          
          call_frame = call_frames.$last();
          if ($truthy(call_frame['$nil?']())) {
            
            Opal.brk(nil, $brk)
          };
          if ($truthy(self.had_error)) {
            
            Opal.brk(nil, $brk)
          };
          op = call_frame.$read_code();
          if ($eqeqeq($$$($$('Opcodes'), 'LOAD_CONSTANT'), ($ret_or_1 = op))) {
            self.stack.$push(call_frame.$read_constant(call_frame.$read_code()))
          } else if ($eqeqeq($$$($$('Opcodes'), 'LOAD_CLOSURE'), $ret_or_1)) {
            
            function_descriptor = call_frame.$read_constant(call_frame.$read_code());
            upvalues = $send(function_descriptor.$upvalue_count().$times(), 'map', [], function $$3(upvalue_description){var $a, self = $$3.$$s == null ? this : $$3.$$s, is_local = nil, slot = nil, new_upvalue = nil, $ret_or_2 = nil;
              if (self.stack == null) self.stack = nil;

              
              
              if (upvalue_description == null) upvalue_description = nil;;
              $a = [call_frame.$read_code(), call_frame.$read_code()], (is_local = $a[0]), (slot = $a[1]), $a;
              if ($eqeq(is_local, 1)) {
                
                new_upvalue = ($truthy(($ret_or_2 = $send(open_upvalues, 'detect', [], function $$4(_1){
                  
                  
                  if (_1 == null) _1 = nil;;
                  return _1.$pointer()['$==']($rb_plus(call_frame.$stack_top(), slot));}, 1))) ? ($ret_or_2) : ($$('Upvalue').$new($rb_plus(call_frame.$stack_top(), slot), self.stack)));
                open_upvalues['$<<'](new_upvalue);
                $send(open_upvalues, 'sort_by!', [], function $$5(_1){
                  
                  
                  if (_1 == null) _1 = nil;;
                  return _1.$pointer()['$-@']();}, 1);
                return new_upvalue;
              } else {
                return call_frame.$callable().$upvalues()['$[]'](slot)
              };}, {$$arity: 1, $$s: self});
            self.stack.$push($$('Callable').$new(function_descriptor, upvalues));
          } else if ($eqeqeq($$$($$('Opcodes'), 'SET_GLOBAL'), $ret_or_1)) {
            
            $writer = [call_frame.$read_constant(call_frame.$read_code()), self.stack.$last()];
            $send(self.globals, '[]=', $to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else if ($eqeqeq($$$($$('Opcodes'), 'DEFINE_GLOBAL'), $ret_or_1)) {
            
            $writer = [call_frame.$read_constant(call_frame.$read_code()), self.stack.$pop()];
            $send(self.globals, '[]=', $to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else if ($eqeqeq($$$($$('Opcodes'), 'GET_GLOBAL'), $ret_or_1)) {
            
            global_name = call_frame.$read_constant(call_frame.$read_code());
            if (!$truthy(self.globals['$has_key?'](global_name))) {
              self.$error("Undefined global " + (global_name))
            };
            self.stack.$push(self.globals['$[]'](global_name));
          } else if ($eqeqeq($$$($$('Opcodes'), 'SET_LOCAL'), $ret_or_1)) {
            call_frame.$set_stack_slot(call_frame.$read_code(), self.stack.$last())
          } else if ($eqeqeq($$$($$('Opcodes'), 'GET_LOCAL'), $ret_or_1)) {
            self.stack.$push(call_frame.$get_stack_slot(call_frame.$read_code()))
          } else if ($eqeqeq($$$($$('Opcodes'), 'GET_UPVALUE'), $ret_or_1)) {
            self.stack.$push(call_frame.$callable().$upvalues()['$[]'](call_frame.$read_code()).$value())
          } else if ($eqeqeq($$$($$('Opcodes'), 'SET_UPVALUE'), $ret_or_1)) {
            call_frame.$callable().$upvalues()['$[]'](call_frame.$read_code()).$set_value(self.stack.$last())
          } else if ($eqeqeq($$$($$('Opcodes'), 'NIL_OP'), $ret_or_1)) {
            self.stack.$push(nil)
          } else if ($eqeqeq($$$($$('Opcodes'), 'TRUE_OP'), $ret_or_1)) {
            self.stack.$push(true)
          } else if ($eqeqeq($$$($$('Opcodes'), 'FALSE_OP'), $ret_or_1)) {
            self.stack.$push(false)
          } else if ($eqeqeq($$$($$('Opcodes'), 'NOT'), $ret_or_1)) {
            self.stack.$push(self['$falsey?'](self.stack.$pop()))
          } else if ($eqeqeq($$$($$('Opcodes'), 'NEGATE'), $ret_or_1)) {
            self.stack.$push(self.stack.$pop()['$-@']())
          } else if ($eqeqeq($$$($$('Opcodes'), 'POP'), $ret_or_1)) {
            
            if ($truthy(self.stack['$empty?']())) {
              self.$fail("corrupted stack")
            };
            self.stack.$pop();
          } else if ($eqeqeq($$$($$('Opcodes'), 'ADD'), $ret_or_1)) {
            
            $a = [self.stack.$pop(), self.stack.$pop()], (b = $a[0]), (a = $a[1]), $a;
            self.stack.$push($rb_plus(a, b));
          } else if ($eqeqeq($$$($$('Opcodes'), 'SUBTRACT'), $ret_or_1)) {
            
            $a = [self.stack.$pop(), self.stack.$pop()], (b = $a[0]), (a = $a[1]), $a;
            self.stack.$push($rb_minus(a, b));
          } else if ($eqeqeq($$$($$('Opcodes'), 'DIVIDE'), $ret_or_1)) {
            
            $a = [self.stack.$pop(), self.stack.$pop()], (b = $a[0]), (a = $a[1]), $a;
            self.stack.$push($rb_divide(a, b));
          } else if ($eqeqeq($$$($$('Opcodes'), 'MULTIPLY'), $ret_or_1)) {
            
            $a = [self.stack.$pop(), self.stack.$pop()], (b = $a[0]), (a = $a[1]), $a;
            self.stack.$push($rb_times(a, b));
          } else if ($eqeqeq($$$($$('Opcodes'), 'EQUAL'), $ret_or_1)) {
            self.stack.$push(self['$equal?'](self.stack.$pop(), self.stack.$pop()))
          } else if ($eqeqeq($$$($$('Opcodes'), 'GREATER'), $ret_or_1)) {
            
            $a = [self.stack.$pop(), self.stack.$pop()], (b = $a[0]), (a = $a[1]), $a;
            self.stack.$push($rb_gt(a, b));
          } else if ($eqeqeq($$$($$('Opcodes'), 'LESSER'), $ret_or_1)) {
            
            $a = [self.stack.$pop(), self.stack.$pop()], (b = $a[0]), (a = $a[1]), $a;
            self.stack.$push($rb_lt(a, b));
          } else if ($eqeqeq($$$($$('Opcodes'), 'CALL'), $ret_or_1)) {
            
            argument_count = call_frame.$read_code();
            callable = self.stack['$[]']($rb_minus(argument_count['$-@'](), 1));
            if ($truthy(callable['$is_a?']($$('Callable')))) {
              if ($eqeq(callable.$arity(), argument_count)) {
                call_frames['$<<']($$('CallFrame').$new(executable, self.stack, callable, $rb_minus(self.stack.$size(), argument_count)))
              } else {
                self.$error("function " + (callable.$function_name()) + " takes " + (callable.$arity()) + " arguments but " + (argument_count) + " provided")
              }
            } else {
              self.$error("" + (self.$lox_object_to_string(callable)) + " is not callable")
            };
          } else if ($eqeqeq($$$($$('Opcodes'), 'RETURN'), $ret_or_1)) {
            
            result = self.stack.$pop();
            while ($truthy(($truthy(($ret_or_2 = $rb_gt(open_upvalues.$count(), 0))) ? ($rb_ge(open_upvalues.$first().$pointer(), call_frame.$stack_top())) : ($ret_or_2)))) {
              
              upvalue = open_upvalues.$shift();
              upvalue['$close!']();
            };
            call_frames.$pop();
            
            $writer = [$range(0, -1, false), self.stack['$[]'](Opal.Range.$new(0,$rb_minus(call_frame.$stack_top(), 1), true))];
            $send(self.stack, '[]=', $to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            self.stack.$push(result);
          } else if ($eqeqeq($$$($$('Opcodes'), 'CLOSE_UPVALUE'), $ret_or_1)) {
            
            if ($truthy(open_upvalues['$empty?']())) {
              self.$fail("corrupted upvalues")
            };
            open_upvalues.$shift()['$close!']();
            if ($truthy(self.stack['$empty?']())) {
              self.$fail("corrupted stack")
            };
            self.stack.$pop();
          } else if ($eqeqeq($$$($$('Opcodes'), 'PRINT'), $ret_or_1)) {
            out.$puts(self.$lox_object_to_string(self.stack.$pop()))
          } else if ($eqeqeq($$$($$('Opcodes'), 'JUMP_ON_FALSE'), $ret_or_1)) {
            
            location = call_frame.$read_short();
            if ($truthy(self['$falsey?'](self.stack.$last()))) {
              call_frame.$jump(location)
            };
          } else if ($eqeqeq($$$($$('Opcodes'), 'JUMP'), $ret_or_1)) {
            call_frame.$jump(call_frame.$read_short())
          } else {
            self.$fail(op.$inspect())
          };
          if ($truthy(debug)) {
            return self.$print_debug_info(Opal.Binding.$new(  function($code, $value) {    if (typeof $value === 'undefined') {      return eval($code);    }    else {      return eval($code + ' = $value');    }  },  ["call_frame", "op", "function_descriptor", "upvalues", "global_name", "b", "a", "argument_count", "callable", "result", "upvalue", "location", "call_frames", "open_upvalues", "executable"],  self,  ['lib/a_lox/vm.rb', 243]))
          } else {
            return nil
          };}, {$$arity: 0, $$s: self, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        self.stack.$pop();
        if ($truthy(open_upvalues['$any?']())) {
          return self.$fail("corrupted open upvalues")
        } else {
          return nil
        };
      }, -2);
      self.$private();
      
      $def(self, '$falsey?', function $VM_falsey$ques$6(value) {
        
        return value['$!']()
      }, 1);
      
      $def(self, '$equal?', function $VM_equal$ques$7(a, b) {
        
        return a['$=='](b)
      }, 2);
      
      $def(self, '$lox_object_to_string', function $$lox_object_to_string(lox_object) {
        
        if ($truthy(lox_object['$is_a?']($$('Callable')))) {
          return "fun " + (lox_object.$function_name()) + "/" + (lox_object.$arity())
        } else if ($truthy(lox_object['$nil?']())) {
          return "nil"
        } else {
          return lox_object.$to_s()
        }
      }, 1);
      
      $def(self, '$error', function $$error(message) {
        var $a, self = this;

        
        self.had_error = true;
        return ($a = self.error_reporter, ($a === nil || $a == null) ? nil : $send($a, 'report_runtime_error', [message]));
      }, 1);
      
      $def(self, '$print_debug_info', function $$print_debug_info(b) {
        var self = this;

        
        self.$puts(b.$local_variable_get("op"));
        self.$print_stack();
        return self.$puts();
      }, 1);
      return $def(self, '$print_stack', function $$print_stack() {
        var self = this;

        return self.$puts(["["].concat($to_a($send(self.stack, 'map', [], function $$8(value){
          
          
          if (value == null) value = nil;;
          if ($truthy(value['$is_a?']($$('Callable')))) {
            return "<" + (value.$function_name()) + ">"
          } else {
            return value
          };}, 1))).concat(["]"]).$join(" "))
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["lib/a_lox/binary_utils"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $def = Opal.def, $send = Opal.send, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('extend,bytes,pack,unpack1,reduce,map,to_proc,+');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting);

    return (function($base) {
      var self = $module($base, 'BinaryUtils');

      
      
      self.$extend(self);
      
      $def(self, '$pack_short', function $$pack_short(short$) {
        
        return [short$].$pack("s").$bytes()
      }, 1);
      return $def(self, '$unpack_short', function $$unpack_short(byte1, byte2) {
        
        return $send($send([byte1, byte2], 'map', [], "chr".$to_proc()), 'reduce', [], function $$1(a, s){
          
          
          if (a == null) a = nil;;
          
          if (s == null) s = nil;;
          return $rb_plus(a, s);}, 2).$unpack1("s")
      }, 2);
    })($nesting[0])
  })($nesting[0], $nesting)
};

Opal.modules["lib/a_lox"] = function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass;

  
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/version");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/printers/pretty_printer");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/printers/react_tree_printer");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/scanner");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/ast_node_dsl");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/expression");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/statement");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/parser");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/static_resolver/upvalues");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/executable_container");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/compiler");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/opcodes");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/vm");
  self.$require("lib/a_lox.rb"+ '/../' + "a_lox/binary_utils");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return ($klass($nesting[0], $$('StandardError'), 'Error'), nil)
  })($nesting[0], $nesting);
};

Opal.queue(function(Opal) {/* Generated by Opal 1.4.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $defs = Opal.defs, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $def = Opal.def, $eqeq = Opal.eqeq, $module = Opal.module, $to_ary = Opal.to_ary;

  Opal.add_stubs('require,compile,new,catch,scan,any?,throw,parse,resolve,<<,==,type,line,lexeme,to_json,map,to_proc,print,serialize');
  
  nil;
  self.$require("corelib/array/pack");
  self.$require("corelib/string/unpack");
  self.$require("json");
  self.$require("lib/opal_entrypoint.rb"+ '/../' + "a_lox");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'CompilationEnvironment');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.errors = nil;
    
    $defs(self, '$compile', function $$compile(source) {
      var self = this;

      return self.$new().$compile(source)
    }, 1);
    
    $def(self, '$compile', function $$compile(source) {
      var $a, self = this, tokens = nil, ast = nil, executable_container = nil;

      
      self.errors = [];
      $a = [nil, nil, nil], (tokens = $a[0]), (ast = $a[1]), (executable_container = $a[2]), $a;
      $send(self, 'catch', ["error"], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;
        if (self.errors == null) self.errors = nil;

        
        executable_container = $$$($$('ALox'), 'ExecutableContainer').$new();
        tokens = $$$($$('ALox'), 'Scanner').$new(source, $hash2(["error_reporter"], {"error_reporter": self})).$scan();
        if ($truthy(self.errors['$any?']())) {
          self.$throw("error")
        };
        ast = $$$($$('ALox'), 'Parser').$new(tokens, $hash2(["error_reporter"], {"error_reporter": self})).$parse();
        if ($truthy(self.errors['$any?']())) {
          self.$throw("error")
        };
        $$$($$$($$('ALox'), 'StaticResolver'), 'Upvalues').$new($hash2(["error_reporter"], {"error_reporter": self})).$resolve(ast);
        if ($truthy(self.errors['$any?']())) {
          self.$throw("error")
        };
        return $$$($$('ALox'), 'Compiler').$new(ast, executable_container).$compile();}, {$$arity: 0, $$s: self});
      return [tokens, ast, executable_container, self.errors];
    }, 1);
    
    $def(self, '$report_scanner_error', function $$report_scanner_error(line, message) {
      var self = this;

      return self.errors['$<<']("scanner error. line: " + (line) + " - error: " + (message))
    }, 2);
    
    $def(self, '$report_parser_error', function $$report_parser_error(token, message) {
      var self = this;

      if ($eqeq(token.$type(), $$$($$$($$('ALox'), 'TokenTypes'), 'EOF'))) {
        return self.errors['$<<']("parser error. line: " + (token.$line()) + " at end - error: " + (message))
      } else {
        return self.errors['$<<']("parser error. line: " + (token.$line()) + ", token: " + (token.$lexeme()) + " - error: " + (message))
      }
    }, 2);
    
    $def(self, '$report_static_analysis_error', function $$report_static_analysis_error(token, message) {
      var self = this;

      return self.errors['$<<']("static analysis error. line: " + (token.$line()) + " - error: " + (message))
    }, 2);
    return $def(self, '$report_runtime_error', function $$report_runtime_error(message) {
      var self = this;

      return self.errors['$<<']("runtime error: " + (message))
    }, 1);
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'ALox');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $defs(self, '$analyze', function $$analyze(source) {
      var $a, $b, tokens = nil, ast = nil, executable_container = nil, errors = nil;

      
      $b = $$('CompilationEnvironment').$compile(source), $a = $to_ary($b), (tokens = ($a[0] == null ? nil : $a[0])), (ast = ($a[1] == null ? nil : $a[1])), (executable_container = ($a[2] == null ? nil : $a[2])), (errors = ($a[3] == null ? nil : $a[3])), $b;
      return ($truthy(errors['$any?']()) ? ($hash2(["errors"], {"errors": errors})) : ($hash2(["tokens", "tree", "executable"], {"tokens": $send(tokens, 'map', [], "serialize".$to_proc()), "tree": ($truthy(ast) ? ($$$($$('Printers'), 'ReactTreePrinter').$new(ast).$print()) : (nil)), "executable": ($a = executable_container, ($a === nil || $a == null) ? nil : $send($a, 'serialize', []))}))).$to_json();
    }, 1)
  })($nesting[0], $nesting);
});

Opal.queue(function(Opal) {/* Generated by Opal 1.4.1 */
  var nil = Opal.nil, $Kernel = Opal.Kernel;

  Opal.add_stubs('exit');
  return $Kernel.$exit()
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKHR5cGVvZihnbG9iYWxfb2JqZWN0LmNvbnNvbGUpID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnNvbGUgPSBnbG9iYWxfb2JqZWN0LmNvbnNvbGU7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsX29iamVjdC5jb25zb2xlID09IG51bGwpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9O1xuICB9XG5cbiAgaWYgKCEoJ2xvZycgaW4gY29uc29sZSkpIHsgY29uc29sZS5sb2cgPSBmdW5jdGlvbiAoKSB7fTsgfVxuICBpZiAoISgnd2FybicgaW4gY29uc29sZSkpIHsgY29uc29sZS53YXJuID0gY29uc29sZS5sb2c7IH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuT3BhbCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdPcGFsIGFscmVhZHkgbG9hZGVkLiBMb2FkaW5nIHR3aWNlIGNhbiBjYXVzZSB0cm91YmxlcywgcGxlYXNlIGZpeCB5b3VyIHNldHVwLicpO1xuICAgIHJldHVybiBnbG9iYWxfb2JqZWN0Lk9wYWw7XG4gIH1cblxuICB2YXIgbmlsO1xuXG4gIC8vIFRoZSBhY3R1YWwgY2xhc3MgZm9yIEJhc2ljT2JqZWN0XG4gIHZhciBCYXNpY09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE9iamVjdCBjbGFzcy5cbiAgLy8gVGhlIGxlYWRpbmcgdW5kZXJzY29yZSBpcyB0byBhdm9pZCBjb25mdXNpb24gd2l0aCB3aW5kb3cuT2JqZWN0KClcbiAgdmFyIF9PYmplY3Q7XG5cbiAgLy8gVGhlIGFjdHVhbCBNb2R1bGUgY2xhc3NcbiAgdmFyIE1vZHVsZTtcblxuICAvLyBUaGUgYWN0dWFsIENsYXNzIGNsYXNzXG4gIHZhciBDbGFzcztcblxuICAvLyBUaGUgT3BhbC5PcGFsIGNsYXNzIChoZWxwZXJzIGV0Yy4pXG4gIHZhciBfT3BhbDtcblxuICAvLyBUaGUgS2VybmVsIG1vZHVsZVxuICB2YXIgS2VybmVsO1xuXG4gIC8vIFRoZSBPcGFsIG9iamVjdCB0aGF0IGlzIGV4cG9zZWQgZ2xvYmFsbHlcbiAgdmFyIE9wYWwgPSBnbG9iYWxfb2JqZWN0Lk9wYWwgPSB7fTtcblxuICAvLyBUaGlzIGlzIGEgdXNlZnVsIHJlZmVyZW5jZSB0byBnbG9iYWwgb2JqZWN0IGluc2lkZSBydWJ5IGZpbGVzXG4gIE9wYWwuZ2xvYmFsID0gZ2xvYmFsX29iamVjdDtcbiAgZ2xvYmFsX29iamVjdC5PcGFsID0gT3BhbDtcblxuICAvLyBDb25maWd1cmUgcnVudGltZSBiZWhhdmlvciB3aXRoIHJlZ2FyZHMgdG8gcmVxdWlyZSBhbmQgdW5zdXBwb3J0ZWQgZmVhdHVyZXNcbiAgT3BhbC5jb25maWcgPSB7XG4gICAgbWlzc2luZ19yZXF1aXJlX3NldmVyaXR5OiAnZXJyb3InLCAgICAgICAgLy8gZXJyb3IsIHdhcm5pbmcsIGlnbm9yZVxuICAgIHVuc3VwcG9ydGVkX2ZlYXR1cmVzX3NldmVyaXR5OiAnd2FybmluZycsIC8vIGVycm9yLCB3YXJuaW5nLCBpZ25vcmVcbiAgICBleHBlcmltZW50YWxfZmVhdHVyZXNfc2V2ZXJpdHk6ICd3YXJuaW5nJywvLyB3YXJuaW5nLCBpZ25vcmVcbiAgICBlbmFibGVfc3RhY2tfdHJhY2U6IHRydWUgICAgICAgICAgICAgICAgICAvLyB0cnVlLCBmYWxzZVxuICB9O1xuXG4gIC8vIE1pbmlmeSBjb21tb24gZnVuY3Rpb24gY2FsbHNcbiAgdmFyICRoYXNfb3duICAgPSBPYmplY3QuaGFzT3duUHJvcGVydHk7XG4gIHZhciAkYmluZCAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG4gIHZhciAkc2V0X3Byb3RvID0gT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuICB2YXIgJHNsaWNlICAgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgdmFyICRzcGxpY2UgICAgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xuXG4gIC8vIE5pbCBvYmplY3QgaWQgaXMgYWx3YXlzIDRcbiAgdmFyIG5pbF9pZCA9IDQ7XG5cbiAgLy8gR2VuZXJhdGVzIGV2ZW4gc2VxdWVudGlhbCBudW1iZXJzIGdyZWF0ZXIgdGhhbiA0XG4gIC8vIChuaWxfaWQpIHRvIHNlcnZlIGFzIHVuaXF1ZSBpZHMgZm9yIHJ1Ynkgb2JqZWN0c1xuICB2YXIgdW5pcXVlX2lkID0gbmlsX2lkO1xuXG4gIC8vIFJldHVybiBuZXh0IHVuaXF1ZSBpZFxuICBPcGFsLnVpZCA9IGZ1bmN0aW9uKCkge1xuICAgIHVuaXF1ZV9pZCArPSAyO1xuICAgIHJldHVybiB1bmlxdWVfaWQ7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgb3IgYXNzaWduIHRoZSBpZCBvZiBhbiBvYmplY3RcbiAgT3BhbC5pZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouJCRpc19udW1iZXIpIHJldHVybiAob2JqICogMikrMTtcbiAgICBpZiAob2JqLiQkaWQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iai4kJGlkO1xuICAgIH1cbiAgICAkcHJvcChvYmosICckJGlkJywgT3BhbC51aWQoKSk7XG4gICAgcmV0dXJuIG9iai4kJGlkO1xuICB9O1xuXG4gIC8vIEdsb2JhbHMgdGFibGVcbiAgT3BhbC5ndmFycyA9IHt9O1xuXG4gIC8vIEV4aXQgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IHBsYXRmb3JtIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gIC8vIChTZWUgbm9kZWpzIGFuZCBjaHJvbWUgZm9yIGV4YW1wbGVzKVxuICBPcGFsLmV4aXQgPSBmdW5jdGlvbihzdGF0dXMpIHsgaWYgKE9wYWwuZ3ZhcnMuREVCVUcpIGNvbnNvbGUubG9nKCdFeGl0ZWQgd2l0aCBzdGF0dXMgJytzdGF0dXMpOyB9O1xuXG4gIC8vIGtlZXBzIHRyYWNrIG9mIGV4Y2VwdGlvbnMgZm9yICQhXG4gIE9wYWwuZXhjZXB0aW9ucyA9IFtdO1xuXG4gIC8vIEBwcml2YXRlXG4gIC8vIFBvcHMgYW4gZXhjZXB0aW9uIGZyb20gdGhlIHN0YWNrIGFuZCB1cGRhdGVzIGAkIWAuXG4gIE9wYWwucG9wX2V4Y2VwdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleGNlcHRpb24gPSBPcGFsLmV4Y2VwdGlvbnMucG9wKCk7XG4gICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgT3BhbC5ndmFyc1tcIiFcIl0gPSBleGNlcHRpb247XG4gICAgICBPcGFsLmd2YXJzW1wiQFwiXSA9IGV4Y2VwdGlvbi4kYmFja3RyYWNlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgT3BhbC5ndmFyc1tcIiFcIl0gPSBPcGFsLmd2YXJzW1wiQFwiXSA9IG5pbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gJHByb3Aob2JqZWN0LCBuYW1lLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mKG9iamVjdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3I6XG4gICAgICAvLyAgIHMgPSBcInN0cmluZ1wiXG4gICAgICAvLyAgIGRlZiBzLm07IGVuZFxuICAgICAgLy8gU3RyaW5nIGNsYXNzIGlzIHRoZSBvbmx5IGNsYXNzIHRoYXQ6XG4gICAgICAvLyArIGNvbXBpbGVzIHRvIEpTIHByaW1pdGl2ZVxuICAgICAgLy8gKyBhbGxvd3MgbWV0aG9kIGRlZmluaXRpb24gZGlyZWN0bHkgb24gaW5zdGFuY2VzXG4gICAgICAvLyBudW1iZXJzLCB0cnVlLCBmYWxzZSBhbmQgbnVsbCBkbyBub3Qgc3VwcG9ydCBpdC5cbiAgICAgIG9iamVjdFtuYW1lXSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5wcm9wID0gJHByb3A7XG5cbiAgLy8gQGRlcHJlY2F0ZWRcbiAgT3BhbC5kZWZpbmVQcm9wZXJ0eSA9IE9wYWwucHJvcDtcblxuICBPcGFsLnNsaWNlID0gJHNsaWNlO1xuXG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLVxuXG4gIHZhciAkdHJ1dGh5ID0gT3BhbC50cnV0aHkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gZmFsc2UgIT09IHZhbCAmJiBuaWwgIT09IHZhbCAmJiB1bmRlZmluZWQgIT09IHZhbCAmJiBudWxsICE9PSB2YWwgJiYgKCEodmFsIGluc3RhbmNlb2YgQm9vbGVhbikgfHwgdHJ1ZSA9PT0gdmFsLnZhbHVlT2YoKSk7XG4gIH07XG5cbiAgT3BhbC5mYWxzeSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAhJHRydXRoeSh2YWwpO1xuICB9O1xuXG4gIE9wYWwudHlwZV9lcnJvciA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0LiQkY2xhc3M7XG5cbiAgICBpZiAoY29lcmNlZCAmJiBtZXRob2QpIHtcbiAgICAgIGNvZXJjZWQgPSBjb2VyY2VkLiQkY2xhc3M7XG4gICAgICByZXR1cm4gT3BhbC5UeXBlRXJyb3IuJG5ldyhcbiAgICAgICAgXCJjYW4ndCBjb252ZXJ0IFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGUgK1xuICAgICAgICBcIiAoXCIgKyBvYmplY3QgKyBcIiNcIiArIG1ldGhvZCArIFwiIGdpdmVzIFwiICsgY29lcmNlZCArIFwiKVwiXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLlR5cGVFcnJvci4kbmV3KFxuICAgICAgICBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyBvYmplY3QgKyBcIiBpbnRvIFwiICsgdHlwZVxuICAgICAgKVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmNvZXJjZV90byA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVbJyQ9PT0nXShvYmplY3QpKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgaWYgKCFvYmplY3RbJyRyZXNwb25kX3RvPyddKG1ldGhvZCkpIHtcbiAgICAgIHRocm93IE9wYWwudHlwZV9lcnJvcihvYmplY3QsIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChhcmdzID09IG51bGwpIGFyZ3MgPSBbXTtcbiAgICByZXR1cm4gT3BhbC5zZW5kKG9iamVjdCwgbWV0aG9kLCBhcmdzKTtcbiAgfVxuXG4gIE9wYWwucmVzcG9uZF90byA9IGZ1bmN0aW9uKG9iaiwganNpZCwgaW5jbHVkZV9hbGwpIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgIW9iai4kJGNsYXNzKSByZXR1cm4gZmFsc2U7XG4gICAgaW5jbHVkZV9hbGwgPSAhIWluY2x1ZGVfYWxsO1xuICAgIHZhciBib2R5ID0gb2JqW2pzaWRdO1xuXG4gICAgaWYgKG9ialsnJHJlc3BvbmRfdG8/J10uJCRwcmlzdGluZSkge1xuICAgICAgaWYgKHR5cGVvZihib2R5KSA9PT0gXCJmdW5jdGlvblwiICYmICFib2R5LiQkc3R1Yikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghb2JqWyckcmVzcG9uZF90b19taXNzaW5nPyddLiQkcHJpc3RpbmUpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuc2VuZChvYmosIG9ialsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXSwgW2pzaWQuc3Vic3RyKDEpLCBpbmNsdWRlX2FsbF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90bz8nXSwgW2pzaWQuc3Vic3RyKDEpLCBpbmNsdWRlX2FsbF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyYWNlUG9pbnQgc3VwcG9ydFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gU3VwcG9ydCBmb3IgYFRyYWNlUG9pbnQudHJhY2UoOmNsYXNzKSBkbyAuLi4gZW5kYFxuICBPcGFsLnRyYWNlX2NsYXNzID0gZmFsc2U7XG4gIE9wYWwudHJhY2Vyc19mb3JfY2xhc3MgPSBbXTtcblxuICBmdW5jdGlvbiBpbnZva2VfdHJhY2Vyc19mb3JfY2xhc3Moa2xhc3Nfb3JfbW9kdWxlKSB7XG4gICAgdmFyIGksIGlpLCB0cmFjZXI7XG5cbiAgICBmb3IoaSA9IDAsIGlpID0gT3BhbC50cmFjZXJzX2Zvcl9jbGFzcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB0cmFjZXIgPSBPcGFsLnRyYWNlcnNfZm9yX2NsYXNzW2ldO1xuICAgICAgdHJhY2VyLnRyYWNlX29iamVjdCA9IGtsYXNzX29yX21vZHVsZTtcbiAgICAgIHRyYWNlci5ibG9jay4kY2FsbCh0cmFjZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZV9hdXRvbG9hZChjcmVmLCBuYW1lKSB7XG4gICAgaWYgKCFjcmVmLiQkYXV0b2xvYWRbbmFtZV0ubG9hZGVkKSB7XG4gICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0ubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIE9wYWwuS2VybmVsLiRyZXF1aXJlKGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5wYXRoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY3JlZi4kJGF1dG9sb2FkW25hbWVdLmV4Y2VwdGlvbiA9IGU7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0ucmVxdWlyZWQgPSB0cnVlO1xuICAgICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5zdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5sb2FkZWQgJiYgIWNyZWYuJCRhdXRvbG9hZFtuYW1lXS5yZXF1aXJlZCkge1xuICAgICAgaWYgKGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5leGNlcHRpb24pIHsgdGhyb3cgY3JlZi4kJGF1dG9sb2FkW25hbWVdLmV4Y2VwdGlvbjsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbnN0YW50c1xuICAvLyAtLS0tLS0tLS1cbiAgLy9cbiAgLy8gRm9yIGZ1dHVyZSByZWZlcmVuY2U6XG4gIC8vIC0gVGhlIFJhaWxzIGF1dG9sb2FkaW5nIGd1aWRlIChodHRwOi8vZ3VpZGVzLnJ1YnlvbnJhaWxzLm9yZy92NS4wL2F1dG9sb2FkaW5nX2FuZF9yZWxvYWRpbmdfY29uc3RhbnRzLmh0bWwpXG4gIC8vIC0gQENvbnJhZElyd2luJ3MgMjAxMiBwb3N0IG9uIOKAnEV2ZXJ5dGhpbmcgeW91IGV2ZXIgd2FudGVkIHRvIGtub3cgYWJvdXQgY29uc3RhbnQgbG9va3VwIGluIFJ1YnnigJ0gKGh0dHA6Ly9jaXJ3LmluL2Jsb2cvY29uc3RhbnQtbG9va3VwLmh0bWwpXG4gIC8vXG4gIC8vIExlZ2VuZCBvZiBNUkkgY29uY2VwdHMvbmFtZXM6XG4gIC8vIC0gY29uc3RhbnQgcmVmZXJlbmNlIChjcmVmKTogdGhlIG1vZHVsZS9jbGFzcyB0aGF0IGFjdHMgYXMgYSBuYW1lc3BhY2VcbiAgLy8gLSBuZXN0aW5nOiB0aGUgbmFtZXNwYWNlcyB3cmFwcGluZyB0aGUgY3VycmVudCBzY29wZSwgZS5nLiBuZXN0aW5nIGluc2lkZVxuICAvLyAgICAgICAgICAgIGBtb2R1bGUgQTsgbW9kdWxlIEI6OkM7IGVuZDsgZW5kYCBpcyBgW0I6OkMsIEFdYFxuXG4gIC8vIEdldCB0aGUgY29uc3RhbnQgaW4gdGhlIHNjb3BlIG9mIHRoZSBjdXJyZW50IGNyZWZcbiAgZnVuY3Rpb24gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSkge1xuICAgIGlmIChjcmVmKSB7XG4gICAgICBpZiAoY3JlZi4kJGNvbnN0W25hbWVdICE9IG51bGwpIHsgcmV0dXJuIGNyZWYuJCRjb25zdFtuYW1lXTsgfVxuICAgICAgaWYgKGNyZWYuJCRhdXRvbG9hZCAmJiBjcmVmLiQkYXV0b2xvYWRbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZV9hdXRvbG9hZChjcmVmLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSBuZXN0aW5nIGFycmF5IGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudFxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfbmVzdGluZyhuZXN0aW5nLCBuYW1lKSB7XG4gICAgdmFyIGksIGlpLCBjb25zdGFudDtcblxuICAgIGlmIChuZXN0aW5nLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgLy8gSWYgdGhlIG5lc3RpbmcgaXMgbm90IGVtcHR5IHRoZSBjb25zdGFudCBpcyBsb29rZWQgdXAgaW4gaXRzIGVsZW1lbnRzXG4gICAgLy8gYW5kIGluIG9yZGVyLiBUaGUgYW5jZXN0b3JzIG9mIHRob3NlIGVsZW1lbnRzIGFyZSBpZ25vcmVkLlxuICAgIGZvciAoaSA9IDAsIGlpID0gbmVzdGluZy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdGFudCA9IG5lc3RpbmdbaV0uJCRjb25zdFtuYW1lXTtcbiAgICAgIGlmIChjb25zdGFudCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICAgIH0gZWxzZSBpZiAobmVzdGluZ1tpXS4kJGF1dG9sb2FkICYmIG5lc3RpbmdbaV0uJCRhdXRvbG9hZFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlX2F1dG9sb2FkKG5lc3RpbmdbaV0sIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIGFuY2VzdG9ycyBjaGFpbiBsb29raW5nIGZvciB0aGUgY29uc3RhbnRcbiAgZnVuY3Rpb24gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSB7XG4gICAgdmFyIGksIGlpLCBhbmNlc3RvcnM7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhjcmVmKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmIChhbmNlc3RvcnNbaV0uJCRjb25zdCAmJiAkaGFzX293bi5jYWxsKGFuY2VzdG9yc1tpXS4kJGNvbnN0LCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3JzW2ldLiQkY29uc3RbbmFtZV07XG4gICAgICB9IGVsc2UgaWYgKGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkICYmIGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVfYXV0b2xvYWQoYW5jZXN0b3JzW2ldLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBXYWxrIHVwIE9iamVjdCdzIGFuY2VzdG9ycyBjaGFpbiBsb29raW5nIGZvciB0aGUgY29uc3RhbnQsXG4gIC8vIGJ1dCBvbmx5IGlmIGNyZWYgaXMgbWlzc2luZyBvciBhIG1vZHVsZS5cbiAgZnVuY3Rpb24gY29uc3RfbG9va3VwX09iamVjdChjcmVmLCBuYW1lKSB7XG4gICAgaWYgKGNyZWYgPT0gbnVsbCB8fCBjcmVmLiQkaXNfbW9kdWxlKSB7XG4gICAgICByZXR1cm4gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhfT2JqZWN0LCBuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsIGNvbnN0X21pc3NpbmcgaWYgbm90aGluZyBlbHNlIHdvcmtlZFxuICBmdW5jdGlvbiBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIGlmICghc2tpcF9taXNzaW5nKSB7XG4gICAgICByZXR1cm4gKGNyZWYgfHwgX09iamVjdCkuJGNvbnN0X21pc3NpbmcobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGp1c3QgaW4gdGhlIGN1cnJlbnQgY3JlZiBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2BcbiAgT3BhbC5jb25zdF9nZXRfbG9jYWwgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBPcGFsLlR5cGVFcnJvcihjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSk7ICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgcmVzdWx0ID0gY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpOyBpZiAocmVzdWx0ICE9IG51bGwpIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IHJlbGF0aXZlIHRvIGEgY3JlZiBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2AgKHdoZW4gdGhlXG4gIC8vIGNvbnN0YW50IGlzIHByZWZpeGVkIGJ5IGA6OmApLlxuICBPcGFsLmNvbnN0X2dldF9xdWFsaWZpZWQgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgcmVzdWx0LCBjYWNoZSwgY2FjaGVkLCBjdXJyZW50X3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb247XG5cbiAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAvLyBBIHNob3J0cGF0aCBmb3IgY2FsbHMgbGlrZSA6OlN0cmluZyA9PiAkJCQoXCJTdHJpbmdcIilcbiAgICAgIHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKF9PYmplY3QsIGNyZWYpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkKF9PYmplY3QsIGNyZWYsIHNraXBfbWlzc2luZyk7XG4gICAgfVxuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBPcGFsLlR5cGVFcnJvcihjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XG4gICAgfVxuXG4gICAgaWYgKChjYWNoZSA9IGNyZWYuJCRjb25zdF9jYWNoZSkgPT0gbnVsbCkge1xuICAgICAgJHByb3AoY3JlZiwgJyQkY29uc3RfY2FjaGUnLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgIGNhY2hlID0gY3JlZi4kJGNvbnN0X2NhY2hlO1xuICAgIH1cbiAgICBjYWNoZWQgPSBjYWNoZVtuYW1lXTtcblxuICAgIGlmIChjYWNoZWQgPT0gbnVsbCB8fCBjYWNoZWRbMF0gIT09IGN1cnJlbnRfdmVyc2lvbikge1xuICAgICAgKChyZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKSkgICAgICAgICAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkpICAgICAgIT0gbnVsbCk7XG4gICAgICBjYWNoZVtuYW1lXSA9IFtjdXJyZW50X3ZlcnNpb24sIHJlc3VsdF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNhY2hlZFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICE9IG51bGwgPyByZXN1bHQgOiBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZyk7XG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgdG9wIGxldmVsIGNvbnN0YW50IGNhY2hlIGdlbmVyYXRpb24gY291bnRlclxuICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24gPSAxO1xuXG4gIC8vIExvb2sgZm9yIHRoZSBjb25zdGFudCBpbiB0aGUgb3BlbiB1c2luZyB0aGUgY3VycmVudCBuZXN0aW5nIGFuZCB0aGUgbmVhcmVzdFxuICAvLyBjcmVmIGFuY2VzdG9ycyBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2AgKHdoZW4gdGhlIGNvbnN0YW50IGhhcyBubyA6OiBwcmVmaXgpLlxuICBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZSA9IGZ1bmN0aW9uKG5lc3RpbmcsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciBjcmVmID0gbmVzdGluZ1swXSwgcmVzdWx0LCBjdXJyZW50X3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24sIGNhY2hlLCBjYWNoZWQ7XG5cbiAgICBpZiAoKGNhY2hlID0gbmVzdGluZy4kJGNvbnN0X2NhY2hlKSA9PSBudWxsKSB7XG4gICAgICAkcHJvcChuZXN0aW5nLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkpICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkpICAgICAgICAgIT0gbnVsbCk7XG5cbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgY29uc3RhbnQgb24gYSBjcmVmIGFuZCBvcHBvcnR1bmlzdGljYWxseSBzZXQgdGhlIG5hbWUgb2ZcbiAgLy8gdW5uYW1lZCBjbGFzc2VzL21vZHVsZXMuXG4gIGZ1bmN0aW9uICRjb25zdF9zZXQoY3JlZiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKHZhbHVlLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGlmICh2YWx1ZS4kJG5hbWUgPT0gbnVsbCB8fCB2YWx1ZS4kJG5hbWUgPT09IG5pbCkgdmFsdWUuJCRuYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZS4kJGJhc2VfbW9kdWxlID09IG51bGwpIHZhbHVlLiQkYmFzZV9tb2R1bGUgPSBjcmVmO1xuICAgIH1cblxuICAgIGNyZWYuJCRjb25zdCA9IChjcmVmLiQkY29uc3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY3JlZi4kJGNvbnN0W25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAgIC8vIEBleGFtcGxlXG4gICAgLy8gICBPcGFsLiQkLlJlZ2V4cC4kJC5JR05PUkVDQVNFXG4gICAgY3JlZi4kJCA9IGNyZWYuJCRjb25zdDtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgLy8gRXhwb3NlIHRvcCBsZXZlbCBjb25zdGFudHMgb250byB0aGUgT3BhbCBvYmplY3RcbiAgICBpZiAoY3JlZiA9PT0gX09iamVjdCkgT3BhbFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gTmFtZSBuZXcgY2xhc3MgZGlyZWN0bHkgb250byBjdXJyZW50IHNjb3BlIChPcGFsLkZvby5CYXogPSBrbGFzcylcbiAgICAkcHJvcChjcmVmLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgT3BhbC5jb25zdF9zZXQgPSAkY29uc3Rfc2V0O1xuXG4gIC8vIEdldCBhbGwgdGhlIGNvbnN0YW50cyByZWFjaGFibGUgZnJvbSBhIGdpdmVuIGNyZWYsIGJ5IGRlZmF1bHQgd2lsbCBpbmNsdWRlXG4gIC8vIGluaGVyaXRlZCBjb25zdGFudHMuXG4gIE9wYWwuY29uc3RhbnRzID0gZnVuY3Rpb24oY3JlZiwgaW5oZXJpdCkge1xuICAgIGlmIChpbmhlcml0ID09IG51bGwpIGluaGVyaXQgPSB0cnVlO1xuXG4gICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtjcmVmXSwgaSwgaWksIGNvbnN0YW50cyA9IHt9LCBjb25zdGFudDtcblxuICAgIGlmIChpbmhlcml0KSBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoT3BhbC5hbmNlc3RvcnMoT3BhbC5PYmplY3QpKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuXG4gICAgICAvLyBEbyBub3Qgc2hvdyBPYmplY3RzIGNvbnN0YW50cyB1bmxlc3Mgd2UncmUgcXVlcnlpbmcgT2JqZWN0IGl0c2VsZlxuICAgICAgaWYgKGNyZWYgIT09IF9PYmplY3QgJiYgbW9kdWxlID09IF9PYmplY3QpIGJyZWFrO1xuXG4gICAgICBmb3IgKGNvbnN0YW50IGluIG1vZHVsZS4kJGNvbnN0KSB7XG4gICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1vZHVsZS4kJGF1dG9sb2FkKSB7XG4gICAgICAgIGZvciAoY29uc3RhbnQgaW4gbW9kdWxlLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgICBjb25zdGFudHNbY29uc3RhbnRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBhIGNvbnN0YW50IGZyb20gYSBjcmVmLlxuICBPcGFsLmNvbnN0X3JlbW92ZSA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUpIHtcbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcblxuICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgdmFyIG9sZCA9IGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICByZXR1cm4gb2xkO1xuICAgIH1cblxuICAgIGlmIChjcmVmLiQkYXV0b2xvYWQgJiYgY3JlZi4kJGF1dG9sb2FkW25hbWVdKSB7XG4gICAgICBkZWxldGUgY3JlZi4kJGF1dG9sb2FkW25hbWVdO1xuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG5cbiAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwiY29uc3RhbnQgXCIrY3JlZitcIjo6XCIrY3JlZi4kbmFtZSgpK1wiIG5vdCBkZWZpbmVkXCIpO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgYSBjdXJyaWVkIGNvbnN0X2dldF9yZWxhdGl2ZS5cbiAgT3BhbC5jb25zdF9nZXRfcmVsYXRpdmVfZmFjdG9yeSA9IGZ1bmN0aW9uKG5lc3RpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgICByZXR1cm4gT3BhbC4kJChuZXN0aW5nLCBuYW1lLCBza2lwX21pc3NpbmcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldHVwIHNvbWUgc2hvcnRjdXRzIHRvIHJlZHVjZSBjb21waWxlZCBzaXplXG4gIE9wYWwuJCQgPSBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZTtcbiAgT3BhbC4kJCQgPSBPcGFsLmNvbnN0X2dldF9xdWFsaWZpZWQ7XG4gIE9wYWwuJHIgPSBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZV9mYWN0b3J5O1xuXG4gIC8vIE1vZHVsZXMgJiBDbGFzc2VzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBgY2xhc3MgRm9vOyBlbmRgIGV4cHJlc3Npb24gaW4gcnVieSBpcyBjb21waWxlZCB0byBjYWxsIHRoaXMgcnVudGltZVxuICAvLyBtZXRob2Qgd2hpY2ggZWl0aGVyIHJldHVybnMgYW4gZXhpc3RpbmcgY2xhc3Mgb2YgdGhlIGdpdmVuIG5hbWUsIG9yIGNyZWF0ZXNcbiAgLy8gYSBuZXcgY2xhc3MgaW4gdGhlIGdpdmVuIGBiYXNlYCBzY29wZS5cbiAgLy9cbiAgLy8gSWYgYSBjb25zdGFudCB3aXRoIHRoZSBnaXZlbiBuYW1lIGV4aXN0cywgdGhlbiB3ZSBjaGVjayB0byBtYWtlIHN1cmUgdGhhdFxuICAvLyBpdCBpcyBhIGNsYXNzIGFuZCBhbHNvIHRoYXQgdGhlIHN1cGVyY2xhc3NlcyBtYXRjaC4gSWYgZWl0aGVyIG9mIHRoZXNlXG4gIC8vIGZhaWwsIHRoZW4gd2UgcmFpc2UgYSBgVHlwZUVycm9yYC4gTm90ZSwgYHN1cGVyY2xhc3NgIG1heSBiZSBudWxsIGlmIG9uZVxuICAvLyB3YXMgbm90IHNwZWNpZmllZCBpbiB0aGUgcnVieSBjb2RlLlxuICAvL1xuICAvLyBXZSBwYXNzIGEgY29uc3RydWN0b3IgdG8gdGhpcyBtZXRob2Qgb2YgdGhlIGZvcm0gYGZ1bmN0aW9uIENsYXNzTmFtZSgpIHt9YFxuICAvLyBzaW1wbHkgc28gdGhhdCBjbGFzc2VzIHNob3cgdXAgd2l0aCBuaWNlbHkgZm9ybWF0dGVkIG5hbWVzIGluc2lkZSBkZWJ1Z2dlcnNcbiAgLy8gaW4gdGhlIHdlYiBicm93c2VyIChvciBub2RlL3Nwcm9ja2V0cykuXG4gIC8vXG4gIC8vIFRoZSBgc2NvcGVgIGlzIHRoZSBjdXJyZW50IGBzZWxmYCB2YWx1ZSB3aGVyZSB0aGUgY2xhc3MgaXMgYmVpbmcgY3JlYXRlZFxuICAvLyBmcm9tLiBXZSB1c2UgdGhpcyB0byBnZXQgdGhlIHNjb3BlIGZvciB3aGVyZSB0aGUgY2xhc3Mgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gIC8vIElmIGBzY29wZWAgaXMgYW4gb2JqZWN0IChub3QgYSBjbGFzcy9tb2R1bGUpLCB3ZSBzaW1wbGUgZ2V0IGl0cyBjbGFzcyBhbmRcbiAgLy8gdXNlIHRoYXQgYXMgdGhlIHNjb3BlIGluc3RlYWQuXG4gIC8vXG4gIC8vIEBwYXJhbSBzY29wZSAgICAgICAgW09iamVjdF0gd2hlcmUgdGhlIGNsYXNzIGlzIGJlaW5nIGNyZWF0ZWRcbiAgLy8gQHBhcmFtIHN1cGVyY2xhc3MgICBbQ2xhc3MsbnVsbF0gc3VwZXJjbGFzcyBvZiB0aGUgbmV3IGNsYXNzIChtYXkgYmUgbnVsbClcbiAgLy8gQHBhcmFtIHNpbmdsZXRvbiAgICBbQm9vbGVhbixudWxsXSBhIHRydWUgdmFsdWUgZGVub3RlcyB3ZSB3YW50IHRvIGFsbG9jYXRlXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBzaW5nbGV0b25cbiAgLy9cbiAgLy8gQHJldHVybiBuZXcgW0NsYXNzXSAgb3IgZXhpc3RpbmcgcnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmFsbG9jYXRlX2NsYXNzID0gZnVuY3Rpb24obmFtZSwgc3VwZXJjbGFzcywgc2luZ2xldG9uKSB7XG4gICAgdmFyIGtsYXNzLCBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzdXBlcmNsYXNzICE9IG51bGwgJiYgc3VwZXJjbGFzcy4kJGJyaWRnZSkge1xuICAgICAgLy8gSW5oZXJpdGFuY2UgZnJvbSBicmlkZ2VkIGNsYXNzZXMgcmVxdWlyZXNcbiAgICAgIC8vIGNhbGxpbmcgb3JpZ2luYWwgSlMgY29uc3RydWN0b3JzXG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBzZWxmID0gbmV3ICgkYmluZC5hcHBseShzdXBlcmNsYXNzLiQkY29uc3RydWN0b3IsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xuXG4gICAgICAgIC8vIGFuZCByZXBsYWNpbmcgYSBfX3Byb3RvX18gbWFudWFsbHlcbiAgICAgICAgJHNldF9wcm90byhzZWxmLCBrbGFzcy4kJHByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSAmJiBuYW1lICE9PSBuaWwpIHtcbiAgICAgICRwcm9wKGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCAnOjonK25hbWUpO1xuICAgIH1cblxuICAgIGtsYXNzID0gY29uc3RydWN0b3I7XG5cbiAgICAkcHJvcChrbGFzcywgJyQkbmFtZScsIG5hbWUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRjb25zdHJ1Y3RvcicsIGNvbnN0cnVjdG9yKTtcbiAgICAkcHJvcChrbGFzcywgJyQkcHJvdG90eXBlJywgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3QnLCB7fSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGlzX2NsYXNzJywgdHJ1ZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJHN1cGVyJywgc3VwZXJjbGFzcyk7XG4gICAgJHByb3Aoa2xhc3MsICckJGN2YXJzJywge30pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkcHJvcChrbGFzcywgJyQkb3duX3ByZXBlbmRlZF9tb2R1bGVzJywgW10pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRhbmNlc3RvcnMnLCBbXSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG4gICAgJHByb3Aoa2xhc3MsICckJHN1YmNsYXNzZXMnLCBbXSk7XG5cbiAgICAkcHJvcChrbGFzcy4kJHByb3RvdHlwZSwgJyQkY2xhc3MnLCBrbGFzcyk7XG5cbiAgICAvLyBCeSBkZWZhdWx0IGlmIHRoZXJlIGFyZSBubyBzaW5nbGV0b24gY2xhc3MgbWV0aG9kc1xuICAgIC8vIF9fcHJvdG9fXyBpcyBDbGFzcy5wcm90b3R5cGVcbiAgICAvLyBMYXRlciBzaW5nbGV0b24gbWV0aG9kcyBnZW5lcmF0ZSBhIHNpbmdsZXRvbl9jbGFzc1xuICAgIC8vIGFuZCBpbmplY3QgaXQgaW50byBhbmNlc3RvcnMgY2hhaW5cbiAgICBpZiAoT3BhbC5DbGFzcykge1xuICAgICAgJHNldF9wcm90byhrbGFzcywgT3BhbC5DbGFzcy5wcm90b3R5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdXBlcmNsYXNzICE9IG51bGwpIHtcbiAgICAgICRzZXRfcHJvdG8oa2xhc3MuJCRwcm90b3R5cGUsIHN1cGVyY2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gICAgICBpZiAoc2luZ2xldG9uICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIExldCdzIG5vdCBmb3JiaWQgR0MgZnJvbSBjbGVhbmluZyB1cCBvdXJcbiAgICAgICAgLy8gc3ViY2xhc3Nlcy5cbiAgICAgICAgaWYgKHR5cGVvZiBXZWFrUmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIEZpcnN0LCBsZXQncyBjbGVhbiB1cCBvdXIgYXJyYXkgZnJvbSBlbXB0eSBvYmplY3RzLlxuICAgICAgICAgIHZhciBpLCBzdWJjbGFzcywgcmVidWlsdF9zdWJjbGFzc2VzID0gW107XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdWJjbGFzcyA9IHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzW2ldO1xuICAgICAgICAgICAgaWYgKHN1YmNsYXNzLmRlcmVmKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZWJ1aWx0X3N1YmNsYXNzZXMucHVzaChzdWJjbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdywgbGV0J3MgYWRkIG91ciBjbGFzcy5cbiAgICAgICAgICByZWJ1aWx0X3N1YmNsYXNzZXMucHVzaChuZXcgV2Vha1JlZihrbGFzcykpO1xuICAgICAgICAgIHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzID0gcmVidWlsdF9zdWJjbGFzc2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzLnB1c2goa2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBlcmNsYXNzLiQkbWV0YSkge1xuICAgICAgICAvLyBJZiBzdXBlcmNsYXNzIGhhcyBtZXRhY2xhc3MgdGhlbiB3ZSBoYXZlIGV4cGxpY2l0ZWx5IGluaGVyaXQgaXQuXG4gICAgICAgIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzKGtsYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cblxuICBmdW5jdGlvbiBmaW5kX2V4aXN0aW5nX2NsYXNzKHNjb3BlLCBuYW1lKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGNsYXNzIGluIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgdmFyIGtsYXNzID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuXG4gICAgLy8gSWYgdGhlIGNsYXNzIGV4aXN0cyBpbiB0aGUgc2NvcGUsIHRoZW4gd2UgbXVzdCB1c2UgdGhhdFxuICAgIGlmIChrbGFzcykge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBleGlzdGluZyBjb25zdGFudCBpcyBhIGNsYXNzLCBvciByYWlzZSBlcnJvclxuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcobmFtZSArIFwiIGlzIG5vdCBhIGNsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU3VwZXJjbGFzc01hdGNoKGtsYXNzLCBzdXBlcmNsYXNzKSB7XG4gICAgaWYgKGtsYXNzLiQkc3VwZXIgIT09IHN1cGVyY2xhc3MpIHtcbiAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG1pc21hdGNoIGZvciBjbGFzcyBcIiArIGtsYXNzLiQkbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5rbGFzcyA9IGZ1bmN0aW9uKHNjb3BlLCBzdXBlcmNsYXNzLCBuYW1lKSB7XG4gICAgdmFyIGJyaWRnZWQ7XG5cbiAgICBpZiAoc2NvcGUgPT0gbnVsbCB8fCBzY29wZSA9PSAnOjonKSB7XG4gICAgICAvLyBHbG9iYWwgc2NvcGVcbiAgICAgIHNjb3BlID0gX09iamVjdDtcbiAgICB9IGVsc2UgaWYgKCFzY29wZS4kJGlzX2NsYXNzICYmICFzY29wZS4kJGlzX21vZHVsZSkge1xuICAgICAgLy8gU2NvcGUgaXMgYW4gb2JqZWN0LCB1c2UgaXRzIGNsYXNzXG4gICAgICBzY29wZSA9IHNjb3BlLiQkY2xhc3M7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHN1cGVyY2xhc3MgaXMgbm90IGFuIE9wYWwtZ2VuZXJhdGVkIGNsYXNzIHRoZW4gd2UncmUgYnJpZGdpbmcgYSBuYXRpdmUgSlMgY2xhc3NcbiAgICBpZiAoXG4gICAgICBzdXBlcmNsYXNzICE9IG51bGwgJiYgKCFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5IHx8IChcbiAgICAgICAgc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSAmJiAhc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRpc19jbGFzcycpXG4gICAgICApKVxuICAgICkge1xuICAgICAgaWYgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IgJiYgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5uYW1lID09IFwiRnVuY3Rpb25cIikge1xuICAgICAgICBicmlkZ2VkID0gc3VwZXJjbGFzcztcbiAgICAgICAgc3VwZXJjbGFzcyA9IF9PYmplY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwic3VwZXJjbGFzcyBtdXN0IGJlIGEgQ2xhc3MgKFwiICsgKFxuICAgICAgICAgIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yICYmIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLm5hbWUgfHwgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci4kJG5hbWUpKSB8fFxuICAgICAgICAgIHR5cGVvZihzdXBlcmNsYXNzKVxuICAgICAgICApICsgXCIgZ2l2ZW4pXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrbGFzcyA9IGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpO1xuXG4gICAgaWYgKGtsYXNzKSB7XG4gICAgICBpZiAoc3VwZXJjbGFzcykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgZXhpc3RpbmcgY2xhc3MgaGFzIHNhbWUgc3VwZXJjbGFzc1xuICAgICAgICBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT3BhbC50cmFjZV9jbGFzcykgeyBpbnZva2VfdHJhY2Vyc19mb3JfY2xhc3Moa2xhc3MpOyB9XG5cbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG5cbiAgICAvLyBDbGFzcyBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgYSBuZXcgb25lIHdpdGggZ2l2ZW4gc3VwZXJjbGFzcy4uLlxuXG4gICAgLy8gTm90IHNwZWNpZnlpbmcgYSBzdXBlcmNsYXNzIG1lYW5zIHdlIGNhbiBhc3N1bWUgaXQgdG8gYmUgT2JqZWN0XG4gICAgaWYgKHN1cGVyY2xhc3MgPT0gbnVsbCkge1xuICAgICAgc3VwZXJjbGFzcyA9IF9PYmplY3Q7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSBjbGFzcyBvYmplY3QgKGluc3RhbmNlIG9mIENsYXNzKVxuICAgIGtsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhuYW1lLCBzdXBlcmNsYXNzKTtcbiAgICAkY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBrbGFzcyk7XG5cbiAgICAvLyBDYWxsIC5pbmhlcml0ZWQoKSBob29rIHdpdGggbmV3IGNsYXNzIG9uIHRoZSBzdXBlcmNsYXNzXG4gICAgaWYgKHN1cGVyY2xhc3MuJGluaGVyaXRlZCkge1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoYnJpZGdlZCkge1xuICAgICAgT3BhbC5icmlkZ2UoYnJpZGdlZCwga2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhrbGFzcyk7IH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuICAvLyBEZWZpbmUgbmV3IG1vZHVsZSAob3IgcmV0dXJuIGV4aXN0aW5nIG1vZHVsZSkuIFRoZSBnaXZlbiBgc2NvcGVgIGlzIGJhc2ljYWxseVxuICAvLyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgdGhlIGBtb2R1bGVgIHN0YXRlbWVudCB3YXMgZGVmaW5lZCBpbi4gSWYgdGhpcyBpc1xuICAvLyBhIHJ1YnkgbW9kdWxlIG9yIGNsYXNzLCB0aGVuIGl0IGlzIHVzZWQsIG90aGVyd2lzZSBpZiB0aGUgc2NvcGUgaXMgYSBydWJ5XG4gIC8vIG9iamVjdCB0aGVuIHRoYXQgb2JqZWN0cyByZWFsIHJ1YnkgY2xhc3MgaXMgdXNlZCAoZS5nLiBpZiB0aGUgc2NvcGUgaXMgdGhlXG4gIC8vIG1haW4gb2JqZWN0LCB0aGVuIHRoZSB0b3AgbGV2ZWwgYE9iamVjdGAgY2xhc3MgaXMgdXNlZCBhcyB0aGUgc2NvcGUpLlxuICAvL1xuICAvLyBJZiBhIG1vZHVsZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIHNjb3BlLCB0aGVuIHRoYXRcbiAgLy8gaW5zdGFuY2UgaXMganVzdCByZXR1cm5lZC5cbiAgLy9cbiAgLy8gSWYgdGhlcmUgaXMgYSBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgc2NvcGUsIHRoZW4gYW4gZXJyb3IgaXNcbiAgLy8gZ2VuZXJhdGVkIGluc3RlYWQgKGNhbm5vdCBoYXZlIGEgY2xhc3MgYW5kIG1vZHVsZSBvZiBzYW1lIG5hbWUgaW4gc2FtZSBzY29wZSkuXG4gIC8vXG4gIC8vIE90aGVyd2lzZSwgYSBuZXcgbW9kdWxlIGlzIGNyZWF0ZWQgaW4gdGhlIHNjb3BlIHdpdGggdGhlIGdpdmVuIG5hbWUsIGFuZCB0aGF0XG4gIC8vIG5ldyBpbnN0YW5jZSBpcyByZXR1cm5lZCBiYWNrICh0byBiZSByZWZlcmVuY2VkIGF0IHJ1bnRpbWUpLlxuICAvL1xuICAvLyBAcGFyYW0gIHNjb3BlIFtNb2R1bGUsIENsYXNzXSBjbGFzcyBvciBtb2R1bGUgdGhpcyBkZWZpbml0aW9uIGlzIGluc2lkZVxuICAvLyBAcGFyYW0gIGlkICAgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG5ldyAob3IgZXhpc3RpbmcpIG1vZHVsZVxuICAvL1xuICAvLyBAcmV0dXJuIFtNb2R1bGVdXG4gIE9wYWwuYWxsb2NhdGVfbW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgJHByb3AoY29uc3RydWN0b3IsICdkaXNwbGF5TmFtZScsIG5hbWUrJy4kJGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKG5hbWUpXG4gICAgICAkcHJvcChjb25zdHJ1Y3RvciwgJ2Rpc3BsYXlOYW1lJywgbmFtZSsnLmNvbnN0cnVjdG9yJyk7XG5cbiAgICAkcHJvcChtb2R1bGUsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkcHJvcChtb2R1bGUsICckJHByb3RvdHlwZScsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRjb25zdCcsIHt9KTtcbiAgICAkcHJvcChtb2R1bGUsICckJGlzX21vZHVsZScsIHRydWUpO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkaXNfYV9tb2R1bGUnLCB0cnVlKTtcbiAgICAkcHJvcChtb2R1bGUsICckJGN2YXJzJywge30pO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkaWNsYXNzZXMnLCBbXSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkcHJvcChtb2R1bGUsICckJG93bl9wcmVwZW5kZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkcHJvcChtb2R1bGUsICckJGFuY2VzdG9ycycsIFttb2R1bGVdKTtcbiAgICAkcHJvcChtb2R1bGUsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG5cbiAgICAkc2V0X3Byb3RvKG1vZHVsZSwgT3BhbC5Nb2R1bGUucHJvdG90eXBlKTtcblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZF9leGlzdGluZ19tb2R1bGUoc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuICAgIGlmIChtb2R1bGUgPT0gbnVsbCAmJiBzY29wZSA9PT0gX09iamVjdCkgbW9kdWxlID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhfT2JqZWN0LCBuYW1lKTtcblxuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgIGlmICghbW9kdWxlLiQkaXNfbW9kdWxlICYmIG1vZHVsZSAhPT0gX09iamVjdCkge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KG5hbWUgKyBcIiBpcyBub3QgYSBtb2R1bGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfVxuXG4gIE9wYWwubW9kdWxlID0gZnVuY3Rpb24oc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlO1xuXG4gICAgaWYgKHNjb3BlID09IG51bGwgfHwgc2NvcGUgPT0gJzo6Jykge1xuICAgICAgLy8gR2xvYmFsIHNjb3BlXG4gICAgICBzY29wZSA9IF9PYmplY3Q7XG4gICAgfSBlbHNlIGlmICghc2NvcGUuJCRpc19jbGFzcyAmJiAhc2NvcGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIC8vIFNjb3BlIGlzIGFuIG9iamVjdCwgdXNlIGl0cyBjbGFzc1xuICAgICAgc2NvcGUgPSBzY29wZS4kJGNsYXNzO1xuICAgIH1cblxuICAgIG1vZHVsZSA9IGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKTtcblxuICAgIGlmIChtb2R1bGUpIHtcblxuICAgICAgaWYgKE9wYWwudHJhY2VfY2xhc3MpIHsgaW52b2tlX3RyYWNlcnNfZm9yX2NsYXNzKG1vZHVsZSk7IH1cblxuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG5cbiAgICAvLyBNb2R1bGUgZG9lc250IGV4aXN0LCBjcmVhdGUgYSBuZXcgb25lLi4uXG4gICAgbW9kdWxlID0gT3BhbC5hbGxvY2F0ZV9tb2R1bGUobmFtZSk7XG4gICAgJGNvbnN0X3NldChzY29wZSwgbmFtZSwgbW9kdWxlKTtcblxuICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhtb2R1bGUpOyB9XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciB0aGUgcGFzc2VkIG9iamVjdC5cbiAgLy9cbiAgLy8gSWYgdGhlIGdpdmVuIG9iamVjdCBhbHJlZHkgaGFzIGEgc2luZ2xldG9uIGNsYXNzLCB0aGVuIGl0IHdpbGwgYmUgc3RvcmVkIG9uXG4gIC8vIHRoZSBvYmplY3QgYXMgdGhlIGAkJG1ldGFgIHByb3BlcnR5LiBJZiB0aGlzIGV4aXN0cywgdGhlbiBpdCBpcyBzaW1wbHlcbiAgLy8gcmV0dXJuZWQgYmFjay5cbiAgLy9cbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBzaW5nbGV0b24gb2JqZWN0IGZvciB0aGUgY2xhc3Mgb3Igb2JqZWN0IGlzIGNyZWF0ZWQsIHNldCBvblxuICAvLyB0aGUgb2JqZWN0IGF0IGAkJG1ldGFgIGZvciBmdXR1cmUgdXNlLCBhbmQgdGhlbiByZXR1cm5lZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSB0aGUgcnVieSBvYmplY3RcbiAgLy8gQHJldHVybiBbQ2xhc3NdIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIG9iamVjdFxuICBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0LiQkbWV0YSkge1xuICAgICAgcmV0dXJuIG9iamVjdC4kJG1ldGE7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnJCRpc19jbGFzcycpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9IGVsc2UgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnJCRpc19tb2R1bGUnKSkge1xuICAgICAgcmV0dXJuIE9wYWwuYnVpbGRfbW9kdWxlX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9vYmplY3Rfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEJ1aWxkIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIGFuIGV4aXN0aW5nIGNsYXNzLiBDbGFzcyBvYmplY3QgYXJlIGJ1aWx0XG4gIC8vIHdpdGggdGhlaXIgc2luZ2xldG9uIGNsYXNzIGFscmVhZHkgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgaW5oZXJpdGluZ1xuICAvLyBmcm9tIHRoZWlyIHN1cGVyY2xhc3Mgb2JqZWN0ICh1cCB0byBgQ2xhc3NgIGl0c2VsZikuXG4gIC8vXG4gIC8vIE5PVEU6IEFjdHVhbGx5IGluIE1SSSBhIGNsYXNzJyBzaW5nbGV0b24gY2xhc3MgaW5oZXJpdHMgZnJvbSBpdHNcbiAgLy8gc3VwZXJjbGFzcycgc2luZ2xldG9uIGNsYXNzIHdoaWNoIGluIHR1cm4gaW5oZXJpdHMgZnJvbSBDbGFzcy5cbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzIFtDbGFzc11cbiAgLy8gQHJldHVybiBbQ2xhc3NdXG4gIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24oa2xhc3MpIHtcbiAgICB2YXIgc3VwZXJjbGFzcywgbWV0YTtcblxuICAgIGlmIChrbGFzcy4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBrbGFzcy4kJG1ldGE7XG4gICAgfVxuXG4gICAgLy8gVGhlIHNpbmdsZXRvbl9jbGFzcyBzdXBlcmNsYXNzIGlzIHRoZSBzaW5nbGV0b25fY2xhc3Mgb2YgaXRzIHN1cGVyY2xhc3M7XG4gICAgLy8gYnV0IEJhc2ljT2JqZWN0IGhhcyBubyBzdXBlcmNsYXNzIChpdHMgYCQkc3VwZXJgIGlzIG51bGwpLCB0aHVzIHdlXG4gICAgLy8gZmFsbGJhY2sgb24gYENsYXNzYC5cbiAgICBzdXBlcmNsYXNzID0ga2xhc3MgPT09IEJhc2ljT2JqZWN0ID8gQ2xhc3MgOiBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moa2xhc3MuJCRzdXBlcik7XG5cbiAgICBtZXRhID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhudWxsLCBzdXBlcmNsYXNzLCB0cnVlKTtcblxuICAgICRwcm9wKG1ldGEsICckJGlzX3NpbmdsZXRvbicsIHRydWUpO1xuICAgICRwcm9wKG1ldGEsICckJHNpbmdsZXRvbl9vZicsIGtsYXNzKTtcbiAgICAkcHJvcChrbGFzcywgJyQkbWV0YScsIG1ldGEpO1xuICAgICRzZXRfcHJvdG8oa2xhc3MsIG1ldGEuJCRwcm90b3R5cGUpO1xuICAgIC8vIFJlc3RvcmluZyBDbGFzc05hbWUuY2xhc3NcbiAgICAkcHJvcChrbGFzcywgJyQkY2xhc3MnLCBPcGFsLkNsYXNzKTtcblxuICAgIHJldHVybiBtZXRhO1xuICB9O1xuXG4gIE9wYWwuYnVpbGRfbW9kdWxlX3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgIGlmIChtb2QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gbW9kLiQkbWV0YTtcbiAgICB9XG5cbiAgICB2YXIgbWV0YSA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobnVsbCwgT3BhbC5Nb2R1bGUsIHRydWUpO1xuXG4gICAgJHByb3AobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJHByb3AobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcbiAgICAkcHJvcChtb2QsICckJG1ldGEnLCBtZXRhKTtcbiAgICAkc2V0X3Byb3RvKG1vZCwgbWV0YS4kJHByb3RvdHlwZSk7XG4gICAgLy8gUmVzdG9yaW5nIE1vZHVsZU5hbWUuY2xhc3NcbiAgICAkcHJvcChtb2QsICckJGNsYXNzJywgT3BhbC5Nb2R1bGUpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYSBSdWJ5IChub24gY2xhc3MpIE9iamVjdC5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9vYmplY3Rfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIHN1cGVyY2xhc3MgPSBvYmplY3QuJCRjbGFzcyxcbiAgICAgICAga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5pbCwgc3VwZXJjbGFzcywgdHJ1ZSk7XG5cbiAgICAkcHJvcChrbGFzcywgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJHNpbmdsZXRvbl9vZicsIG9iamVjdCk7XG5cbiAgICBkZWxldGUga2xhc3MuJCRwcm90b3R5cGUuJCRjbGFzcztcblxuICAgICRwcm9wKG9iamVjdCwgJyQkbWV0YScsIGtsYXNzKTtcblxuICAgICRzZXRfcHJvdG8ob2JqZWN0LCBvYmplY3QuJCRtZXRhLiQkcHJvdG90eXBlKTtcblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuICBPcGFsLmlzX21ldGhvZCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gKHByb3BbMF0gPT09ICckJyAmJiBwcm9wWzFdICE9PSAnJCcpO1xuICB9O1xuXG4gIE9wYWwuaW5zdGFuY2VfbWV0aG9kcyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgIHZhciBleGNsdWRlID0gW10sIHJlc3VsdHMgPSBbXSwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldLFxuICAgICAgICAgIHByb3RvID0gYW5jZXN0b3IuJCRwcm90b3R5cGU7XG5cbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgbGwgPSBwcm9wcy5sZW5ndGg7IGogPCBsbDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG5cbiAgICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKHByb3ApKSB7XG4gICAgICAgICAgdmFyIG1ldGhvZF9uYW1lID0gcHJvcC5zbGljZSgxKSxcbiAgICAgICAgICAgICAgbWV0aG9kID0gcHJvdG9bcHJvcF07XG5cbiAgICAgICAgICBpZiAobWV0aG9kLiQkc3R1YiAmJiBleGNsdWRlLmluZGV4T2YobWV0aG9kX25hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgZXhjbHVkZS5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW1ldGhvZC4kJHN0dWIgJiYgcmVzdWx0cy5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgIHZhciByZXN1bHRzID0gW10sXG4gICAgICAgIHByb3RvID0gbW9kLiQkcHJvdG90eXBlO1xuXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcHJvcHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG5cbiAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gcHJvdG9bcHJvcF07XG5cbiAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViKSB7XG4gICAgICAgICAgdmFyIG1ldGhvZF9uYW1lID0gcHJvcC5zbGljZSgxKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgT3BhbC5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIE9wYWwuaW5zdGFuY2VfbWV0aG9kcyhvYmouJCRtZXRhIHx8IG9iai4kJGNsYXNzKTtcbiAgfTtcblxuICBPcGFsLm93bl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG9iai4kJG1ldGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5yZWNlaXZlcl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG1vZCA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopO1xuICAgIHZhciBzaW5nbGV0b25fbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kKTtcbiAgICB2YXIgaW5zdGFuY2VfbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kLiQkc3VwZXIpO1xuICAgIHJldHVybiBzaW5nbGV0b25fbWV0aG9kcy5jb25jYXQoaW5zdGFuY2VfbWV0aG9kcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgcGFpcnMgb2YgbmFtZXMvdmFsdWVzXG4gIC8vIGZvciBhbGwgY2xhc3MgdmFyaWFibGVzIGRlZmluZWQgaW4gcHJvdmlkZWQgK21vZHVsZStcbiAgLy8gYW5kIGl0cyBhbmNlc3RvcnMuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHJldHVybiBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGFuY2VzdG9yLiQkY3ZhcnMsIG5hbWUpKSB7XG4gICAgICAgIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS4kJGN2YXJzW25hbWVdID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gR2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgZnJvbSBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0ID0gZnVuY3Rpb24obW9kdWxlLCBuYW1lLCB0b2xlcmFudCkge1xuICAgIGlmICgkaGFzX293bi5jYWxsKG1vZHVsZS4kJGN2YXJzLCBuYW1lKSlcbiAgICAgIHJldHVybiBtb2R1bGUuJCRjdmFyc1tuYW1lXTtcblxuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXG4gICAgICBpZiAoJGhhc19vd24uY2FsbChhbmNlc3Rvci4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3IuJCRjdmFyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRvbGVyYW50KVxuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldygndW5pbml0aWFsaXplZCBjbGFzcyB2YXJpYWJsZSAnK25hbWUrJyBpbiAnK21vZHVsZS4kbmFtZSgpKTtcblxuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jvb3QocHJvdG8pIHtcbiAgICByZXR1cm4gcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX2luY2x1ZGVkX21vZHVsZXMobW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XG5cbiAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICAgIC8vIHN1cGVyY2xhc3NcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcbiAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgIH1cbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX3ByZXBlbmRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgICAgaWYgKHByb3RvID09PSBtb2R1bGUuJCRwcm90b3R5cGUuJCRkZWZpbmVfbWV0aG9kc19vbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8vIFRoZSBhY3R1YWwgaW5jbHVzaW9uIG9mIGEgbW9kdWxlIGludG8gYSBjbGFzcy5cbiAgLy9cbiAgLy8gIyMgQ2xhc3MgYCQkcGFyZW50YCBhbmQgYGljbGFzc2BcbiAgLy9cbiAgLy8gVG8gaGFuZGxlIGBzdXBlcmAgY2FsbHMsIGV2ZXJ5IGNsYXNzIGhhcyBhIGAkJHBhcmVudGAuIFRoaXMgcGFyZW50IGlzXG4gIC8vIHVzZWQgdG8gcmVzb2x2ZSB0aGUgbmV4dCBjbGFzcyBmb3IgYSBzdXBlciBjYWxsLiBBIG5vcm1hbCBjbGFzcyB3b3VsZFxuICAvLyBoYXZlIHRoaXMgcG9pbnQgdG8gaXRzIHN1cGVyY2xhc3MuIEhvd2V2ZXIsIGlmIGEgY2xhc3MgaW5jbHVkZXMgYSBtb2R1bGVcbiAgLy8gdGhlbiB0aGlzIHdvdWxkIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG1vZHVsZS4gVGhlIG1vZHVsZSB3b3VsZFxuICAvLyBhbHNvIGhhdmUgdG8gdGhlbiBwb2ludCBpdHMgYCQkcGFyZW50YCB0byB0aGUgYWN0dWFsIHN1cGVyY2xhc3MuIFdlXG4gIC8vIGNhbm5vdCBtb2RpZnkgbW9kdWxlcyBsaWtlIHRoaXMsIGJlY2F1c2UgaXQgbWlnaHQgYmUgaW5jbHVkZWQgaW4gbW9yZVxuICAvLyB0aGVuIG9uZSBjbGFzcy4gVG8gZml4IHRoaXMsIHdlIGFjdHVhbGx5IGluc2VydCBhbiBgaWNsYXNzYCBhcyB0aGUgY2xhc3MnXG4gIC8vIGAkJHBhcmVudGAgd2hpY2ggY2FuIHRoZW4gcG9pbnQgdG8gdGhlIHN1cGVyY2xhc3MuIFRoZSBgaWNsYXNzYCBhY3RzIGFzXG4gIC8vIGEgcHJveHkgdG8gdGhlIGFjdHVhbCBtb2R1bGUsIHNvIHRoZSBgc3VwZXJgIGNoYWluIGNhbiB0aGVuIHNlYXJjaCBpdCBmb3JcbiAgLy8gdGhlIHJlcXVpcmVkIG1ldGhvZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXSB0aGUgbW9kdWxlIHRvIGluY2x1ZGVcbiAgLy8gQHBhcmFtIGluY2x1ZGVyIFtNb2R1bGVdIHRoZSB0YXJnZXQgY2xhc3MgdG8gaW5jbHVkZSBtb2R1bGUgaW50b1xuICAvLyBAcmV0dXJuIFtudWxsXVxuICBPcGFsLmFwcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgaW5jbHVkZXIpIHtcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRwcm9wKGljbGFzcywgJyQkaW5jbHVkZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG4gICAgdmFyIGluY2x1ZGVyX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKGluY2x1ZGVyKSxcbiAgICAgICAgY2hhaW4gPSBjaGFpbl9pY2xhc3NlcyhpY2xhc3NlcyksXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyLFxuICAgICAgICBlbmRfY2hhaW5fb247XG5cbiAgICBpZiAoaW5jbHVkZXJfYW5jZXN0b3JzLmluZGV4T2YobW9kdWxlKSA9PT0gLTEpIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgaW5jbHVkZVxuXG4gICAgICAvLyBpbmNsdWRlciAtPiBjaGFpbi5maXJzdCAtPiAuLi5jaGFpbi4uLiAtPiBjaGFpbi5sYXN0IC0+IGluY2x1ZGVyLnBhcmVudFxuICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBpbmNsdWRlci4kJHByb3RvdHlwZTtcbiAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbmNsdWRlci4kJHByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBtb2R1bGUgaGFzIGJlZW4gYWxyZWFkeSBpbmNsdWRlZCxcbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcHV0IGl0IGludG8gdGhlIGFuY2VzdG9ycyBjaGFpbiBhZ2FpbixcbiAgICAgIC8vIGJ1dCB0aGlzIG1vZHVsZSBtYXkgaGF2ZSBuZXcgaW5jbHVkZWQgbW9kdWxlcy5cbiAgICAgIC8vIElmIGl0J3MgdHJ1ZSB3ZSBuZWVkIHRvIGNvcHkgdGhlbS5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgc2ltcGxlc3Qgd2F5IGlzIHRvIHJlcGxhY2UgYW5jZXN0b3JzIGNoYWluIGZyb21cbiAgICAgIC8vICAgICAgICAgIHBhcmVudFxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIGBtb2R1bGVgIGljbGFzcyAoaGFzIGEgJCRyb290IGZsYWcpXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgLi4ucHJldmlvcyBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlcyAuLi5cbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXG4gICAgICAvL1xuICAgICAgLy8gdG9cbiAgICAgIC8vICAgICAgICAgIHBhcmVudFxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgICBgbW9kdWxlYCBpY2xhc3MgKGhhcyBhICQkcm9vdCBmbGFnKVxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIC4uLnJlZ2VuZXJhdGVkIGNoYWluIG9mIG1vZHVsZS5pbmNsdWRlZF9tb2R1bGVzXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgXCJuZXh0IGFuY2VzdG9yXCIgKGhhcyBhICQkcm9vdCBmbGFnIG9yIGlzIGEgcmVhbCBjbGFzcylcbiAgICAgIC8vXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGFyZSBubyBpbnRlcm1lZGlhdGUgY2xhc3NlcyBiZXR3ZWVuIGBwYXJlbnRgIGFuZCBgbmV4dCBhbmNlc3RvcmAuXG4gICAgICAvLyBJdCBkb2Vzbid0IGJyZWFrIGFueSBwcm90b3R5cGVzIG9mIG90aGVyIG9iamVjdHMgYXMgd2UgZG9uJ3QgY2hhbmdlIGNsYXNzIHJlZmVyZW5jZXMuXG5cbiAgICAgIHZhciBwYXJlbnQgPSBpbmNsdWRlci4kJHByb3RvdHlwZSwgbW9kdWxlX2ljbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnQpO1xuXG4gICAgICB3aGlsZSAobW9kdWxlX2ljbGFzcyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtb2R1bGVfaWNsYXNzLiQkbW9kdWxlID09PSBtb2R1bGUgJiYgaXNSb290KG1vZHVsZV9pY2xhc3MpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBtb2R1bGVfaWNsYXNzO1xuICAgICAgICBtb2R1bGVfaWNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9pY2xhc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kdWxlX2ljbGFzcykge1xuICAgICAgICAvLyBtb2R1bGUgaGFzIGJlZW4gZGlyZWN0bHkgaW5jbHVkZWRcbiAgICAgICAgdmFyIG5leHRfYW5jZXN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlX2ljbGFzcyk7XG5cbiAgICAgICAgLy8gc2tpcCBub24tcm9vdCBpY2xhc3NlcyAodGhhdCB3ZXJlIHJlY3Vyc2l2ZWx5IGluY2x1ZGVkKVxuICAgICAgICB3aGlsZSAobmV4dF9hbmNlc3Rvci5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSAmJiAhaXNSb290KG5leHRfYW5jZXN0b3IpKSB7XG4gICAgICAgICAgbmV4dF9hbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXh0X2FuY2VzdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gcGFyZW50O1xuICAgICAgICBlbmRfY2hhaW5fb24gPSBuZXh0X2FuY2VzdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW9kdWxlIGhhcyBub3QgYmVlbiBkaXJlY3RseSBpbmNsdWRlZCBidXQgd2FzIGluIGFuY2VzdG9yIGNoYWluIGJlY2F1c2UgaXQgd2FzIGluY2x1ZGVkIGJ5IGFub3RoZXIgbW9kdWxlXG4gICAgICAgIC8vIGluY2x1ZGUgaXQgZGlyZWN0bHlcbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBpbmNsdWRlci4kJHByb3RvdHlwZTtcbiAgICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGluY2x1ZGVyLiQkcHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkc2V0X3Byb3RvKHN0YXJ0X2NoYWluX2FmdGVyLCBjaGFpbi5maXJzdCk7XG4gICAgJHNldF9wcm90byhjaGFpbi5sYXN0LCBlbmRfY2hhaW5fb24pO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgb3duX2luY2x1ZGVkX21vZHVsZXMgY2FjaGVcbiAgICBpbmNsdWRlci4kJG93bl9pbmNsdWRlZF9tb2R1bGVzID0gb3duX2luY2x1ZGVkX21vZHVsZXMoaW5jbHVkZXIpO1xuXG4gICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG4gIH07XG5cbiAgT3BhbC5wcmVwZW5kX2ZlYXR1cmVzID0gZnVuY3Rpb24obW9kdWxlLCBwcmVwZW5kZXIpIHtcbiAgICAvLyBIZXJlIHdlIGNoYW5nZSB0aGUgYW5jZXN0b3JzIGNoYWluIGZyb21cbiAgICAvL1xuICAgIC8vICAgcHJlcGVuZGVyXG4gICAgLy8gICAgICB8XG4gICAgLy8gICAgcGFyZW50XG4gICAgLy9cbiAgICAvLyB0bzpcbiAgICAvL1xuICAgIC8vIGR1bW15KHByZXBlbmRlcilcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgaWNsYXNzKG1vZHVsZSlcbiAgICAvLyAgICAgIHxcbiAgICAvLyBpY2xhc3MocHJlcGVuZGVyKVxuICAgIC8vICAgICAgfFxuICAgIC8vICAgIHBhcmVudFxuICAgIHZhciBtb2R1bGVfYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKTtcbiAgICB2YXIgaWNsYXNzZXMgPSBbXTtcblxuICAgIGlmIChtb2R1bGVfYW5jZXN0b3JzLmluZGV4T2YocHJlcGVuZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgcHJlcGVuZCBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRwcm9wKGljbGFzcywgJyQkcHJlcGVuZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuXG4gICAgdmFyIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBkdW1teV9wcmVwZW5kZXIgPSBwcmVwZW5kZXIuJCRwcm90b3R5cGUsXG4gICAgICAgIHByZXZpb3VzX3BhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpLFxuICAgICAgICBwcmVwZW5kZXJfaWNsYXNzLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGR1bW15X3ByZXBlbmRlci5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGFscmVhZHkgaGFzIHNvbWUgcHJlcGVuZGVkIG1vZHVsZXNcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBtYWtlIGl0IFwiZHVtbXlcIlxuICAgICAgcHJlcGVuZGVyX2ljbGFzcyA9IGR1bW15X3ByZXBlbmRlci4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNYWtpbmcgdGhlIG1vZHVsZSBcImR1bW15XCJcbiAgICAgIHByZXBlbmRlcl9pY2xhc3MgPSBjcmVhdGVfZHVtbXlfaWNsYXNzKHByZXBlbmRlcik7XG4gICAgICBmbHVzaF9tZXRob2RzX2luKHByZXBlbmRlcik7XG4gICAgICAkcHJvcChkdW1teV9wcmVwZW5kZXIsICckJGR1bW15JywgdHJ1ZSk7XG4gICAgICAkcHJvcChkdW1teV9wcmVwZW5kZXIsICckJGRlZmluZV9tZXRob2RzX29uJywgcHJlcGVuZGVyX2ljbGFzcyk7XG5cbiAgICAgIC8vIENvbnZlcnRpbmdcbiAgICAgIC8vICAgZHVtbXkocHJlcGVuZGVyKSAtPiBwcmV2aW91c19wYXJlbnRcbiAgICAgIC8vIHRvXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gaWNsYXNzKHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAkc2V0X3Byb3RvKGR1bW15X3ByZXBlbmRlciwgcHJlcGVuZGVyX2ljbGFzcyk7XG4gICAgICAkc2V0X3Byb3RvKHByZXBlbmRlcl9pY2xhc3MsIHByZXZpb3VzX3BhcmVudCk7XG4gICAgfVxuXG4gICAgdmFyIHByZXBlbmRlcl9hbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhwcmVwZW5kZXIpO1xuXG4gICAgaWYgKHByZXBlbmRlcl9hbmNlc3RvcnMuaW5kZXhPZihtb2R1bGUpID09PSAtMSkge1xuICAgICAgLy8gZmlyc3QgdGltZSBwcmVwZW5kXG5cbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gZHVtbXlfcHJlcGVuZGVyO1xuXG4gICAgICAvLyBuZXh0ICQkcm9vdCBvciBwcmVwZW5kZXJfaWNsYXNzIG9yIG5vbi0kJGljbGFzc1xuICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlcik7XG4gICAgICB3aGlsZSAoZW5kX2NoYWluX29uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRyb290JykgfHxcbiAgICAgICAgICBlbmRfY2hhaW5fb24gPT09IHByZXBlbmRlcl9pY2xhc3MgfHxcbiAgICAgICAgICAhZW5kX2NoYWluX29uLmhhc093blByb3BlcnR5KCckJGljbGFzcycpXG4gICAgICAgICkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVuZF9jaGFpbl9vbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJQcmVwZW5kaW5nIGEgbW9kdWxlIG11bHRpcGxlIHRpbWVzIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9wcmVwZW5kZWRfbW9kdWxlcyBjYWNoZVxuICAgIHByZXBlbmRlci4kJG93bl9wcmVwZW5kZWRfbW9kdWxlcyA9IG93bl9wcmVwZW5kZWRfbW9kdWxlcyhwcmVwZW5kZXIpO1xuXG4gICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmx1c2hfbWV0aG9kc19pbihtb2R1bGUpIHtcbiAgICB2YXIgcHJvdG8gPSBtb2R1bGUuJCRwcm90b3R5cGUsXG4gICAgICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICBkZWxldGUgcHJvdG9bcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlX2ljbGFzcyhtb2R1bGUpIHtcbiAgICB2YXIgaWNsYXNzID0gY3JlYXRlX2R1bW15X2ljbGFzcyhtb2R1bGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJGlzX21vZHVsZSkge1xuICAgICAgbW9kdWxlLiQkaWNsYXNzZXMucHVzaChpY2xhc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBpY2xhc3M7XG4gIH1cblxuICAvLyBEdW1teSBpY2xhc3MgZG9lc24ndCByZWNlaXZlIHVwZGF0ZXMgd2hlbiB0aGUgbW9kdWxlIGdldHMgYSBuZXcgbWV0aG9kLlxuICBmdW5jdGlvbiBjcmVhdGVfZHVtbXlfaWNsYXNzKG1vZHVsZSkge1xuICAgIHZhciBpY2xhc3MgPSB7fSxcbiAgICAgICAgcHJvdG8gPSBtb2R1bGUuJCRwcm90b3R5cGU7XG5cbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgJHByb3AoaWNsYXNzLCBwcm9wLCBwcm90b1twcm9wXSk7XG4gICAgfVxuXG4gICAgJHByb3AoaWNsYXNzLCAnJCRpY2xhc3MnLCB0cnVlKTtcbiAgICAkcHJvcChpY2xhc3MsICckJG1vZHVsZScsIG1vZHVsZSk7XG5cbiAgICByZXR1cm4gaWNsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpIHtcbiAgICB2YXIgbGVuZ3RoID0gaWNsYXNzZXMubGVuZ3RoLCBmaXJzdCA9IGljbGFzc2VzWzBdO1xuXG4gICAgJHByb3AoZmlyc3QsICckJHJvb3QnLCB0cnVlKTtcblxuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7IGZpcnN0OiBmaXJzdCwgbGFzdDogZmlyc3QgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXMgPSBmaXJzdDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaWNsYXNzZXNbaV07XG4gICAgICAkc2V0X3Byb3RvKHByZXZpb3VzLCBjdXJyZW50KTtcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cblxuICAgIHJldHVybiB7IGZpcnN0OiBpY2xhc3Nlc1swXSwgbGFzdDogaWNsYXNzZXNbbGVuZ3RoIC0gMV0gfTtcbiAgfVxuXG4gIC8vIEZvciBwZXJmb3JtYW5jZSwgc29tZSBjb3JlIFJ1YnkgY2xhc3NlcyBhcmUgdG9sbC1mcmVlIGJyaWRnZWQgdG8gdGhlaXJcbiAgLy8gbmF0aXZlIEphdmFTY3JpcHQgY291bnRlcnBhcnRzIChlLmcuIGEgUnVieSBBcnJheSBpcyBhIEphdmFTY3JpcHQgQXJyYXkpLlxuICAvL1xuICAvLyBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNldHVwIGEgbmF0aXZlIGNvbnN0cnVjdG9yIChlLmcuIEFycmF5KSwgdG8gaGF2ZVxuICAvLyBpdHMgcHJvdG90eXBlIGFjdCBsaWtlIGEgbm9ybWFsIFJ1YnkgY2xhc3MuIEZpcnN0bHksIGEgbmV3IFJ1YnkgY2xhc3MgaXNcbiAgLy8gY3JlYXRlZCB1c2luZyB0aGUgbmF0aXZlIGNvbnN0cnVjdG9yIHNvIHRoYXQgaXRzIHByb3RvdHlwZSBpcyBzZXQgYXMgdGhlXG4gIC8vIHRhcmdldCBmb3IgdGhlIG5ldyBjbGFzcy4gTm90ZTogYWxsIGJyaWRnZWQgY2xhc3NlcyBhcmUgc2V0IHRvIGluaGVyaXRcbiAgLy8gZnJvbSBPYmplY3QuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgIE9wYWwuYnJpZGdlKHNlbGYsIEZ1bmN0aW9uKTtcbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzICAgICAgIFtDbGFzc10gdGhlIFJ1YnkgY2xhc3MgdG8gYnJpZGdlXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIG5hdGl2ZSBKYXZhU2NyaXB0IGNvbnN0cnVjdG9yIHRvIHVzZVxuICAvLyBAcmV0dXJuIFtDbGFzc10gcmV0dXJucyB0aGUgcGFzc2VkIFJ1YnkgY2xhc3NcbiAgLy9cbiAgT3BhbC5icmlkZ2UgPSBmdW5jdGlvbihuYXRpdmVfa2xhc3MsIGtsYXNzKSB7XG4gICAgaWYgKG5hdGl2ZV9rbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRicmlkZ2UnKSkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJhbHJlYWR5IGJyaWRnZWRcIik7XG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0b3IgaXMgYSBKUyBmdW5jdGlvbiB3aXRoIGEgcHJvdG90eXBlIGNoYWluIGxpa2U6XG4gICAgLy8gLSBjb25zdHJ1Y3RvclxuICAgIC8vICAgLSBzdXBlclxuICAgIC8vXG4gICAgLy8gV2hhdCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGluamVjdCBvdXIgY2xhc3MgKHdpdGggaXRzIHByb3RvdHlwZSBjaGFpbilcbiAgICAvLyBiZXR3ZWVuIGNvbnN0cnVjdG9yIGFuZCBzdXBlci4gRm9yIGV4YW1wbGUsIGFmdGVyIGluamVjdGluZyA6Ok9iamVjdFxuICAgIC8vIGludG8gSlMgU3RyaW5nIHdlIGdldDpcbiAgICAvL1xuICAgIC8vIC0gY29uc3RydWN0b3IgKHdpbmRvdy5TdHJpbmcpXG4gICAgLy8gICAtIE9wYWwuT2JqZWN0XG4gICAgLy8gICAgIC0gT3BhbC5LZXJuZWxcbiAgICAvLyAgICAgICAtIE9wYWwuQmFzaWNPYmplY3RcbiAgICAvLyAgICAgICAgIC0gc3VwZXIgKHdpbmRvdy5PYmplY3QpXG4gICAgLy8gICAgICAgICAgIC0gbnVsbFxuICAgIC8vXG4gICAgJHByb3AobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRwcm90b3R5cGUnLCBuYXRpdmVfa2xhc3MucHJvdG90eXBlKTtcblxuICAgICRwcm9wKGtsYXNzLiQkcHJvdG90eXBlLCAnJCRjbGFzcycsIGtsYXNzKTtcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRicmlkZ2UnLCB0cnVlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwcm90b1RvTW9kdWxlKHByb3RvKSB7XG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGljbGFzcycpKSB7XG4gICAgICByZXR1cm4gcHJvdG8uJCRtb2R1bGU7XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICByZXR1cm4gcHJvdG8uJCRjbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvd25fYW5jZXN0b3JzKG1vZHVsZSkge1xuICAgIHJldHVybiBtb2R1bGUuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMuY29uY2F0KFttb2R1bGVdKS5jb25jYXQobW9kdWxlLiQkb3duX2luY2x1ZGVkX21vZHVsZXMpO1xuICB9XG5cbiAgLy8gVGhlIEFycmF5IG9mIGFuY2VzdG9ycyBmb3IgYSBnaXZlbiBtb2R1bGUvY2xhc3NcbiAgT3BhbC5hbmNlc3RvcnMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgeyByZXR1cm4gW107IH1cblxuICAgIGlmIChtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9PT0gT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLiQkYW5jZXN0b3JzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbW9kcywgbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCwgbW9kcyA9IG93bl9hbmNlc3RvcnMobW9kdWxlKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2gobW9kc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG1vZHVsZS4kJHN1cGVyKSB7XG4gICAgICBmb3IgKGkgPSAwLCBtb2RzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlLiQkc3VwZXIpLCBsZW5ndGggPSBtb2RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS4kJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uID0gT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uO1xuICAgIG1vZHVsZS4kJGFuY2VzdG9ycyA9IHJlc3VsdDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgT3BhbC5pbmNsdWRlZF9tb2R1bGVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QgPSBudWxsLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgZm9yICg7IHByb3RvICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSkge1xuICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICBpZiAobW9kICYmIG1vZC4kJGlzX21vZHVsZSAmJiBwcm90by4kJGljbGFzcyAmJiBwcm90by4kJGluY2x1ZGVkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuXG4gIC8vIE1ldGhvZCBNaXNzaW5nXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gTWV0aG9kcyBzdHVicyBhcmUgdXNlZCB0byBmYWNpbGl0YXRlIG1ldGhvZF9taXNzaW5nIGluIG9wYWwuIEEgc3R1YiBpcyBhXG4gIC8vIHBsYWNlaG9sZGVyIGZ1bmN0aW9uIHdoaWNoIGp1c3QgY2FsbHMgYG1ldGhvZF9taXNzaW5nYCBvbiB0aGUgcmVjZWl2ZXIuXG4gIC8vIElmIG5vIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIGFjdHVhbGx5IGRlZmluZWQgb24gYW4gb2JqZWN0LCB0aGVuIGl0XG4gIC8vIGlzIG9idmlvdXMgdG8gc2F5IHRoYXQgdGhlIHN0dWIgd2lsbCBiZSBjYWxsZWQgaW5zdGVhZCwgYW5kIHRoZW4gaW4gdHVyblxuICAvLyBtZXRob2RfbWlzc2luZyB3aWxsIGJlIGNhbGxlZC5cbiAgLy9cbiAgLy8gV2hlbiBhIGZpbGUgaW4gcnVieSBnZXRzIGNvbXBpbGVkIHRvIGphdmFzY3JpcHQsIGl0IGluY2x1ZGVzIGEgY2FsbCB0b1xuICAvLyB0aGlzIGZ1bmN0aW9uIHdoaWNoIGFkZHMgc3R1YnMgZm9yIGV2ZXJ5IG1ldGhvZCBuYW1lIGluIHRoZSBjb21waWxlZCBmaWxlLlxuICAvLyBJdCBzaG91bGQgdGhlbiBiZSBzYWZlIHRvIGFzc3VtZSB0aGF0IG1ldGhvZF9taXNzaW5nIHdpbGwgd29yayBmb3IgYW55XG4gIC8vIG1ldGhvZCBjYWxsIGRldGVjdGVkLlxuICAvL1xuICAvLyBNZXRob2Qgc3R1YnMgYXJlIGFkZGVkIHRvIHRoZSBCYXNpY09iamVjdCBwcm90b3R5cGUsIHdoaWNoIGV2ZXJ5IG90aGVyXG4gIC8vIHJ1Ynkgb2JqZWN0IGluaGVyaXRzLCBzbyBhbGwgb2JqZWN0cyBzaG91bGQgaGFuZGxlIG1ldGhvZCBtaXNzaW5nLiBBIHN0dWJcbiAgLy8gaXMgb25seSBhZGRlZCBpZiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZSAobWV0aG9kIG5hbWUpIGlzIG5vdCBhbHJlYWR5XG4gIC8vIGRlZmluZWQuXG4gIC8vXG4gIC8vIE5vdGU6IGFsbCBydWJ5IG1ldGhvZHMgaGF2ZSBhIGAkYCBwcmVmaXggaW4gamF2YXNjcmlwdCwgc28gYWxsIHN0dWJzIHdpbGxcbiAgLy8gaGF2ZSB0aGlzIHByZWZpeCBhcyB3ZWxsICh0byBtYWtlIHRoaXMgbWV0aG9kIG1vcmUgcGVyZm9ybWFudCkuXG4gIC8vXG4gIC8vICAgIE9wYWwuYWRkX3N0dWJzKFwiZm9vLGJhcixiYXo9XCIpO1xuICAvL1xuICAvLyBBbGwgc3R1YiBmdW5jdGlvbnMgd2lsbCBoYXZlIGEgcHJpdmF0ZSBgJCRzdHViYCBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZSBzb1xuICAvLyB0aGF0IG90aGVyIGludGVybmFsIG1ldGhvZHMgY2FuIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBqdXN0IGEgc3R1YiBvciBub3QuXG4gIC8vIGBLZXJuZWwjcmVzcG9uZF90bz9gIHVzZXMgdGhpcyBwcm9wZXJ0eSB0byBkZXRlY3QgYSBtZXRob2RzIHByZXNlbmNlLlxuICAvL1xuICAvLyBAcGFyYW0gc3R1YnMgW0FycmF5XSBhbiBhcnJheSBvZiBtZXRob2Qgc3R1YnMgdG8gYWRkXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1YnMgPSBmdW5jdGlvbihzdHVicykge1xuICAgIHZhciBwcm90byA9IE9wYWwuQmFzaWNPYmplY3QuJCRwcm90b3R5cGU7XG4gICAgdmFyIHN0dWIsIGV4aXN0aW5nX21ldGhvZDtcbiAgICBzdHVicyA9IHN0dWJzLnNwbGl0KCcsJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3R1YnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0dWIgPSAnJCcrc3R1YnNbaV0sIGV4aXN0aW5nX21ldGhvZCA9IHByb3RvW3N0dWJdO1xuXG4gICAgICBpZiAoZXhpc3RpbmdfbWV0aG9kID09IG51bGwgfHwgZXhpc3RpbmdfbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICBPcGFsLmFkZF9zdHViX2Zvcihwcm90bywgc3R1Yik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZCBhIG1ldGhvZF9taXNzaW5nIHN0dWIgZnVuY3Rpb24gdG8gdGhlIGdpdmVuIHByb3RvdHlwZSBmb3IgdGhlXG4gIC8vIGdpdmVuIG5hbWUuXG4gIC8vXG4gIC8vIEBwYXJhbSBwcm90b3R5cGUgW1Byb3RvdHlwZV0gdGhlIHRhcmdldCBwcm90b3R5cGVcbiAgLy8gQHBhcmFtIHN0dWIgW1N0cmluZ10gc3R1YiBuYW1lIHRvIGFkZCAoZS5nLiBcIiRmb29cIilcbiAgLy8gQHJldHVybiBbdW5kZWZpbmVkXVxuICBPcGFsLmFkZF9zdHViX2ZvciA9IGZ1bmN0aW9uKHByb3RvdHlwZSwgc3R1Yikge1xuICAgIC8vIE9wYWwuc3R1Yl9mb3Ioc3R1YikgaXMgdGhlIG1ldGhvZF9taXNzaW5nX3N0dWJcbiAgICAkcHJvcChwcm90b3R5cGUsIHN0dWIsIE9wYWwuc3R1Yl9mb3Ioc3R1YikpO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIHRoZSBtZXRob2RfbWlzc2luZyBzdHViIGZvciBhIGdpdmVuIG1ldGhvZCBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gbWV0aG9kX25hbWUgW1N0cmluZ10gVGhlIGpzLW5hbWUgb2YgdGhlIG1ldGhvZCB0byBzdHViIChlLmcuIFwiJGZvb1wiKVxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuc3R1Yl9mb3IgPSBmdW5jdGlvbihtZXRob2RfbmFtZSkge1xuXG4gICAgZnVuY3Rpb24gbWV0aG9kX21pc3Npbmdfc3R1YigpIHtcbiAgICAgIC8vIENvcHkgYW55IGdpdmVuIGJsb2NrIG9udG8gdGhlIG1ldGhvZF9taXNzaW5nIGRpc3BhdGNoZXJcbiAgICAgIHRoaXMuJG1ldGhvZF9taXNzaW5nLiQkcCA9IG1ldGhvZF9taXNzaW5nX3N0dWIuJCRwO1xuXG4gICAgICAvLyBTZXQgYmxvY2sgcHJvcGVydHkgdG8gbnVsbCByZWFkeSBmb3IgdGhlIG5leHQgY2FsbCAoc3RvcCBmYWxzZS1wb3NpdGl2ZXMpXG4gICAgICBkZWxldGUgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHA7XG5cbiAgICAgIC8vIGNhbGwgbWV0aG9kIG1pc3Npbmcgd2l0aCBjb3JyZWN0IGFyZ3MgKHJlbW92ZSAnJCcgcHJlZml4IG9uIG1ldGhvZCBuYW1lKVxuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3VtZW50c1tpXTsgfVxuXG4gICAgICByZXR1cm4gdGhpcy4kbWV0aG9kX21pc3NpbmcuYXBwbHkodGhpcywgW21ldGhvZF9uYW1lLnNsaWNlKDEpXS5jb25jYXQoYXJnc19hcnkpKTtcbiAgICB9XG5cbiAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkc3R1YiA9IHRydWU7XG5cbiAgICByZXR1cm4gbWV0aG9kX21pc3Npbmdfc3R1YjtcbiAgfTtcblxuXG4gIC8vIE1ldGhvZHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIG1ldGhvZHNcbiAgLy9cbiAgLy8gQHBhcmFtIGFjdHVhbCBbRml4bnVtXSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuIHRvIG1ldGhvZFxuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIG93bmVyIG9mIHRoZSBtZXRob2QgK21ldGgrXG4gIC8vIEBwYXJhbSBtZXRoIFtTdHJpbmddIG1ldGhvZCBuYW1lIHRoYXQgZ290IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHJhaXNlIFtBcmd1bWVudEVycm9yXVxuICBPcGFsLmFjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgb2JqZWN0LCBtZXRoKSB7XG4gICAgdmFyIGluc3BlY3QgPSAnJztcbiAgICBpZiAob2JqZWN0LiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGluc3BlY3QgKz0gb2JqZWN0LiQkbmFtZSArICcuJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJGNsYXNzLiQkbmFtZSArICcjJztcbiAgICB9XG4gICAgaW5zcGVjdCArPSBtZXRoO1xuXG4gICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoJ1snICsgaW5zcGVjdCArICddIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuICcgKyBhY3R1YWwgKyAnLCBleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnKScpO1xuICB9O1xuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIGJsb2Nrc1xuICAvL1xuICAvLyBAcGFyYW0gYWN0dWFsIFtGaXhudW1dIG51bWJlciBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gYmxvY2tcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIGNvbnRleHQgW09iamVjdF0gY29udGV4dCBvZiB0aGUgYmxvY2sgZGVmaW5pdGlvblxuICAvLyBAcmFpc2UgW0FyZ3VtZW50RXJyb3JdXG4gIE9wYWwuYmxvY2tfYWMgPSBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3BlY3QgPSBcImBibG9jayBpbiBcIiArIGNvbnRleHQgKyBcIidcIjtcblxuICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KGluc3BlY3QgKyAnOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAnICsgYWN0dWFsICsgJywgZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJyknKTtcbiAgfTtcblxuICAvLyBTdXBlciBkaXNwYXRjaGVyXG4gIE9wYWwuZmluZF9zdXBlciA9IGZ1bmN0aW9uKG9iaiwgbWlkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBhbGxvd19zdHVicykge1xuICAgIHZhciBqc2lkID0gJyQnICsgbWlkLCBhbmNlc3RvcnMsIHN1cGVyX21ldGhvZDtcblxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvYmouJCRtZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob2JqLiQkY2xhc3MpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50X2luZGV4ID0gYW5jZXN0b3JzLmluZGV4T2YoY3VycmVudF9mdW5jLiQkb3duZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnRfaW5kZXggKyAxOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV0sXG4gICAgICAgICAgcHJvdG8gPSBhbmNlc3Rvci4kJHByb3RvdHlwZTtcblxuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoanNpZCkpIHtcbiAgICAgICAgc3VwZXJfbWV0aG9kID0gcHJvdG9banNpZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGVmY2hlY2sgJiYgc3VwZXJfbWV0aG9kICYmIHN1cGVyX21ldGhvZC4kJHN0dWIgJiYgb2JqLiRtZXRob2RfbWlzc2luZy4kJHByaXN0aW5lKSB7XG4gICAgICAvLyBtZXRob2RfbWlzc2luZyBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgIHRocm93IE9wYWwuTm9NZXRob2RFcnJvci4kbmV3KCdzdXBlcjogbm8gc3VwZXJjbGFzcyBtZXRob2QgYCcrbWlkK1wiJyBmb3IgXCIrb2JqLCBtaWQpO1xuICAgIH1cblxuICAgIHJldHVybiAoc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiAhYWxsb3dfc3R1YnMpID8gbnVsbCA6IHN1cGVyX21ldGhvZDtcbiAgfTtcblxuICAvLyBJdGVyIGRpc3BhdGNoZXIgZm9yIHN1cGVyIGluIGEgYmxvY2tcbiAgT3BhbC5maW5kX2Jsb2NrX3N1cGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xuICAgIHZhciBjYWxsX2pzaWQgPSBqc2lkO1xuXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJzdXBlciBjYWxsZWQgb3V0c2lkZSBvZiBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKGltcGxpY2l0ICYmIGN1cnJlbnRfZnVuYy4kJGRlZmluZV9tZXRoKSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiaW1wbGljaXQgYXJndW1lbnQgcGFzc2luZyBvZiBzdXBlciBmcm9tIG1ldGhvZCBkZWZpbmVkIGJ5IGRlZmluZV9tZXRob2QoKSBpcyBub3Qgc3VwcG9ydGVkLiBTcGVjaWZ5IGFsbCBhcmd1bWVudHMgZXhwbGljaXRseVwiKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudF9mdW5jLiQkZGVmKSB7XG4gICAgICBjYWxsX2pzaWQgPSBjdXJyZW50X2Z1bmMuJCRqc2lkO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmZpbmRfc3VwZXIob2JqLCBjYWxsX2pzaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2spO1xuICB9O1xuXG4gIC8vIEBkZXByZWNhdGVkXG4gIE9wYWwuZmluZF9zdXBlcl9kaXNwYXRjaGVyID0gT3BhbC5maW5kX3N1cGVyO1xuXG4gIC8vIEBkZXByZWNhdGVkXG4gIE9wYWwuZmluZF9pdGVyX3N1cGVyX2Rpc3BhdGNoZXIgPSBPcGFsLmZpbmRfYmxvY2tfc3VwZXI7XG5cbiAgLy8gVXNlZCB0byByZXR1cm4gYXMgYW4gZXhwcmVzc2lvbi4gU29tZXRpbWVzLCB3ZSBjYW4ndCBzaW1wbHkgcmV0dXJuIGZyb21cbiAgLy8gYSBqYXZhc2NyaXB0IGZ1bmN0aW9uIGFzIGlmIHdlIHdlcmUgYSBtZXRob2QsIGFzIHRoZSByZXR1cm4gaXMgdXNlZCBhc1xuICAvLyBhbiBleHByZXNzaW9uLCBvciBldmVuIGluc2lkZSBhIGJsb2NrIHdoaWNoIG11c3QgXCJyZXR1cm5cIiB0byB0aGUgb3V0ZXJcbiAgLy8gbWV0aG9kLiBUaGlzIGhlbHBlciBzaW1wbHkgdGhyb3dzIGFuIGVycm9yIHdoaWNoIGlzIHRoZW4gY2F1Z2h0IGJ5IHRoZVxuICAvLyBtZXRob2QuIFRoaXMgYXBwcm9hY2ggaXMgZXhwZW5zaXZlLCBzbyBpdCBpcyBvbmx5IHVzZWQgd2hlbiBhYnNvbHV0ZWx5XG4gIC8vIG5lZWRlZC5cbiAgLy9cbiAgT3BhbC5yZXQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBPcGFsLnJldHVybmVyLiR2ID0gdmFsO1xuICAgIHRocm93IE9wYWwucmV0dXJuZXI7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBicmVhayBvdXQgb2YgYSBibG9jay5cbiAgT3BhbC5icmsgPSBmdW5jdGlvbih2YWwsIGJyZWFrZXIpIHtcbiAgICBicmVha2VyLiR2ID0gdmFsO1xuICAgIHRocm93IGJyZWFrZXI7XG4gIH07XG5cbiAgLy8gQnVpbGRzIGEgbmV3IHVuaXF1ZSBicmVha2VyLCB0aGlzIGlzIHRvIGF2b2lkIG11bHRpcGxlIG5lc3RlZCBicmVha3MgdG8gZ2V0XG4gIC8vIGluIHRoZSB3YXkgb2YgZWFjaCBvdGhlci5cbiAgT3BhbC5uZXdfYnJrID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigndW5leHBlY3RlZCBicmVhaycpO1xuICB9O1xuXG4gIC8vIGhhbmRsZXMgeWllbGQgY2FsbHMgZm9yIDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZDEgPSBmdW5jdGlvbihibG9jaywgYXJnKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhhc19tbGhzID0gYmxvY2suJCRoYXNfdG9wX2xldmVsX21saHNfYXJnLFxuICAgICAgICBoYXNfdHJhaWxpbmdfY29tbWEgPSBibG9jay4kJGhhc190cmFpbGluZ19jb21tYV9pbl9hcmdzO1xuXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgfHwgKChoYXNfbWxocyB8fCBoYXNfdHJhaWxpbmdfY29tbWEpICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgIGFyZyA9IE9wYWwudG9fYXJ5KGFyZyk7XG4gICAgfVxuXG4gICAgaWYgKChibG9jay5sZW5ndGggPiAxIHx8IChoYXNfdHJhaWxpbmdfY29tbWEgJiYgYmxvY2subGVuZ3RoID09PSAxKSkgJiYgYXJnLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBibG9jayhhcmcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGZvciA+IDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZFggPSBmdW5jdGlvbihibG9jaywgYXJncykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJnc1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuJCRpc19hcnJheSkge1xuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzX2FyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIEZpbmRzIHRoZSBjb3JyZXNwb25kaW5nIGV4Y2VwdGlvbiBtYXRjaCBpbiBjYW5kaWRhdGVzLiAgRWFjaCBjYW5kaWRhdGUgY2FuXG4gIC8vIGJlIGEgdmFsdWUsIG9yIGFuIGFycmF5IG9mIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXG4gIE9wYWwucmVzY3VlID0gZnVuY3Rpb24oZXhjZXB0aW9uLCBjYW5kaWRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcblxuICAgICAgaWYgKGNhbmRpZGF0ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPcGFsLnJlc2N1ZShleGNlcHRpb24sIGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZSA9PT0gT3BhbC5KUy5FcnJvcikge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlWyckPT09J10oZXhjZXB0aW9uKSkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE9wYWwuaXNfYSA9IGZ1bmN0aW9uKG9iamVjdCwga2xhc3MpIHtcbiAgICBpZiAoa2xhc3MgIT0gbnVsbCAmJiBvYmplY3QuJCRtZXRhID09PSBrbGFzcyB8fCBvYmplY3QuJCRjbGFzcyA9PT0ga2xhc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QuJCRpc19udW1iZXIgJiYga2xhc3MuJCRpc19udW1iZXJfY2xhc3MpIHtcbiAgICAgIHJldHVybiAoa2xhc3MuJCRpc19pbnRlZ2VyX2NsYXNzKSA/IChvYmplY3QgJSAxKSA9PT0gMCA6IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGksIGxlbmd0aCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob2JqZWN0LiQkaXNfY2xhc3MgPyBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KSA6IChvYmplY3QuJCRtZXRhIHx8IG9iamVjdC4kJGNsYXNzKSk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IGtsYXNzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBleHRyYWN0aW5nIGt3c3BsYXRzXG4gIC8vIFVzZWQgZm9yOiB7ICoqaCB9XG4gIE9wYWwudG9faGFzaCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfaGFzaCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2hhc2gnLCB0cnVlKSkge1xuICAgICAgdmFyIGhhc2ggPSB2YWx1ZS4kdG9faGFzaCgpO1xuICAgICAgaWYgKGhhc2guJCRpc19oYXNoKSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gSGFzaCAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9faGFzaCBnaXZlcyBcIiArIGhhc2guJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiBcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiBpbnRvIEhhc2hcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhlbHBlcnMgZm9yIGltcGxlbWVudGluZyBtdWx0aXBsZSBhc3NpZ25tZW50XG4gIC8vIE91ciBjb2RlIGZvciBleHRyYWN0aW5nIHRoZSB2YWx1ZXMgYW5kIGFzc2lnbmluZyB0aGVtIG9ubHkgd29ya3MgaWYgdGhlXG4gIC8vIHJldHVybiB2YWx1ZSBpcyBhIEpTIGFycmF5LlxuICAvLyBTbyBpZiB3ZSBnZXQgYW4gQXJyYXkgc3ViY2xhc3MsIGV4dHJhY3QgdGhlIHdyYXBwZWQgSlMgYXJyYXkgZnJvbSBpdFxuXG4gIC8vIFVzZWQgZm9yOiBhLCBiID0gc29tZXRoaW5nIChubyBzcGxhdClcbiAgT3BhbC50b19hcnkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlWyckcmVzcG9uZF90bz8nXSgndG9fYXJ5JywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYXJ5KCk7XG4gICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcnkuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYXJ5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gQXJyYXkgKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2FyeSBnaXZlcyBcIiArIGFyeS4kJGNsYXNzICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9ICpzb21ldGhpbmcgKHdpdGggc3BsYXQpXG4gIE9wYWwudG9fYSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgIC8vIEEgc3BsYXR0ZWQgYXJyYXkgbXVzdCBiZSBjb3BpZWRcbiAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2EnLCB0cnVlKSkge1xuICAgICAgdmFyIGFyeSA9IHZhbHVlLiR0b19hKCk7XG4gICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcnkuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYXJ5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gQXJyYXkgKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2EgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3IgZXh0cmFjdGluZyBrZXl3b3JkIGFyZ3VtZW50cyBmcm9tIGFyZ3VtZW50cyBwYXNzZWQgdG9cbiAgLy8gSlMgZnVuY3Rpb24uIElmIHByb3ZpZGVkICthcmd1bWVudHMrIGxpc3QgZG9lc24ndCBoYXZlIGEgSGFzaFxuICAvLyBhcyBhIGxhc3QgaXRlbSwgcmV0dXJucyBhIGJsYW5rIEhhc2guXG4gIC8vXG4gIC8vIEBwYXJhbSBwYXJhbWV0ZXJzIFtBcnJheV1cbiAgLy8gQHJldHVybiBbSGFzaF1cbiAgLy9cbiAgT3BhbC5leHRyYWN0X2t3YXJncyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIga3dhcmdzID0gcGFyYW1ldGVyc1twYXJhbWV0ZXJzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChrd2FyZ3MgIT0gbnVsbCAmJiBPcGFsLnJlc3BvbmRfdG8oa3dhcmdzLCAnJHRvX2hhc2gnLCB0cnVlKSkge1xuICAgICAgJHNwbGljZS5jYWxsKHBhcmFtZXRlcnMsIHBhcmFtZXRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm4ga3dhcmdzLiR0b19oYXNoKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIE9wYWwuaGFzaDIoW10sIHt9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byBnZXQgYSBsaXN0IG9mIHJlc3Qga2V5d29yZCBhcmd1bWVudHMuIE1ldGhvZCB0YWtlcyB0aGUgZ2l2ZW5cbiAgLy8ga2V5d29yZCBhcmdzLCBpLmUuIHRoZSBoYXNoIGxpdGVyYWwgcGFzc2VkIHRvIHRoZSBtZXRob2QgY29udGFpbmluZyBhbGxcbiAgLy8ga2V5d29yZCBhcmd1ZW1udHMgcGFzc2VkIHRvIG1ldGhvZCwgYXMgd2VsbCBhcyB0aGUgdXNlZCBhcmdzIHdoaWNoIGFyZVxuICAvLyB0aGUgbmFtZXMgb2YgcmVxdWlyZWQgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cyBkZWZpbmVkLiBUaGlzIG1ldGhvZCB0aGVuXG4gIC8vIGp1c3QgcmV0dXJucyBhbGwga2V5L3ZhbHVlIHBhaXJzIHdoaWNoIGhhdmUgbm90IGJlZW4gdXNlZCwgaW4gYSBuZXdcbiAgLy8gaGFzaCBsaXRlcmFsLlxuICAvL1xuICAvLyBAcGFyYW0gZ2l2ZW5fYXJncyBbSGFzaF0gYWxsIGt3YXJncyBnaXZlbiB0byBtZXRob2RcbiAgLy8gQHBhcmFtIHVzZWRfYXJncyBbT2JqZWN0PFN0cmluZzogdHJ1ZT5dIGFsbCBrZXlzIHVzZWQgYXMgbmFtZWQga3dhcmdzXG4gIC8vIEByZXR1cm4gW0hhc2hdXG4gIC8vXG4gIE9wYWwua3dyZXN0YXJncyA9IGZ1bmN0aW9uKGdpdmVuX2FyZ3MsIHVzZWRfYXJncykge1xuICAgIHZhciBrZXlzICAgICAgPSBbXSxcbiAgICAgICAgbWFwICAgICAgID0ge30sXG4gICAgICAgIGtleSAgICAgICAgICAgLFxuICAgICAgICBnaXZlbl9tYXAgPSBnaXZlbl9hcmdzLiQkc21hcDtcblxuICAgIGZvciAoa2V5IGluIGdpdmVuX21hcCkge1xuICAgICAgaWYgKCF1c2VkX2FyZ3Nba2V5XSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgbWFwW2tleV0gPSBnaXZlbl9tYXBba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5oYXNoMihrZXlzLCBtYXApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFwcGx5X2Jsb2Nrb3B0cyhibG9jaywgYmxvY2tvcHRzKSB7XG4gICAgaWYgKHR5cGVvZihibG9ja29wdHMpID09PSAnbnVtYmVyJykge1xuICAgICAgYmxvY2suJCRhcml0eSA9IGJsb2Nrb3B0cztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mKGJsb2Nrb3B0cykgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGJsb2NrLCBibG9ja29wdHMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxzIHBhc3NlZCBtZXRob2Qgb24gYSBydWJ5IG9iamVjdCB3aXRoIGFyZ3VtZW50cyBhbmQgYmxvY2s6XG4gIC8vXG4gIC8vIENhbiB0YWtlIGEgbWV0aG9kIG9yIGEgbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIDEuIFdoZW4gbWV0aG9kIG5hbWUgZ2V0cyBwYXNzZWQgaXQgaW52b2tlcyBpdCBieSBpdHMgbmFtZVxuICAvLyAgICBhbmQgY2FsbHMgJ21ldGhvZF9taXNzaW5nJyB3aGVuIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSBtZXRob2QgdGhhdCB0YWtlcyBhIGJsb2NrIG9yIGEgc3BsYXQuXG4gIC8vIDIuIFdoZW4gbWV0aG9kIChpLmUuIG1ldGhvZCBib2R5KSBnZXRzIHBhc3NlZCwgaXQgZG9lc24ndCB0cmlnZ2VyICdtZXRob2RfbWlzc2luZydcbiAgLy8gICAgYmVjYXVzZSBpdCBkb2Vzbid0IGtub3cgdGhlIG5hbWUgb2YgdGhlIGFjdHVhbCBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSAnc3VwZXInLlxuICAvL1xuICAvLyBAZXhhbXBsZVxuICAvLyAgIHZhciBteV9hcnJheSA9IFsxLCAyLCAzLCA0XVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ2xlbmd0aCcpICAgICAgICAgICAgICAgICAgICAjID0+IDRcbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksIG15X2FycmF5LiRsZW5ndGgpICAgICAgICAgICAgIyA9PiA0XG4gIC8vXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCAncmV2ZXJzZSEnKSAgICAgICAgICAgICAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheVsnJHJldmVyc2UhJ10nKSAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vXG4gIC8vIEBwYXJhbSByZWN2IFtPYmplY3RdIHJ1Ynkgb2JqZWN0XG4gIC8vIEBwYXJhbSBtZXRob2QgW0Z1bmN0aW9uLCBTdHJpbmddIG1ldGhvZCBib2R5IG9yIG5hbWUgb2YgdGhlIG1ldGhvZFxuICAvLyBAcGFyYW0gYXJncyBbQXJyYXldIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QgY2FsbFxuICAvLyBAcGFyYW0gYmxvY2sgW0Z1bmN0aW9uXSBydWJ5IGJsb2NrXG4gIC8vIEBwYXJhbSBibG9ja29wdHMgW09iamVjdCwgTnVtYmVyXSBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIHNldCBvbiB0aGUgYmxvY2tcbiAgLy8gQHJldHVybiBbT2JqZWN0XSByZXR1cm5pbmcgdmFsdWUgb2YgdGhlIG1ldGhvZCBjYWxsXG4gIE9wYWwuc2VuZCA9IGZ1bmN0aW9uKHJlY3YsIG1ldGhvZCwgYXJncywgYmxvY2ssIGJsb2Nrb3B0cykge1xuICAgIHZhciBib2R5O1xuXG4gICAgYXBwbHlfYmxvY2tvcHRzKGJsb2NrLCBibG9ja29wdHMpO1xuXG4gICAgaWYgKHR5cGVvZihtZXRob2QpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib2R5ID0gbWV0aG9kO1xuICAgICAgbWV0aG9kID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZihtZXRob2QpID09PSAnc3RyaW5nJykge1xuICAgICAgYm9keSA9IHJlY3ZbJyQnK21ldGhvZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJQYXNzZWQgbWV0aG9kIHNob3VsZCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQyKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2spO1xuICB9O1xuXG4gIE9wYWwuc2VuZDIgPSBmdW5jdGlvbihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICBpZiAoYm9keSA9PSBudWxsICYmIG1ldGhvZCAhPSBudWxsICYmIHJlY3YuJG1ldGhvZF9taXNzaW5nKSB7XG4gICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XG4gICAgICBhcmdzID0gW21ldGhvZF0uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIGFwcGx5X2Jsb2Nrb3B0cyhibG9jaywgYmxvY2tvcHRzKTtcblxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XG4gIH07XG5cbiAgT3BhbC5yZWZpbmVkX3NlbmQgPSBmdW5jdGlvbihyZWZpbmVtZW50X2dyb3VwcywgcmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKSB7XG4gICAgdmFyIGksIGosIGssIGFuY2VzdG9ycywgYW5jZXN0b3IsIHJlZmluZW1lbnRzLCByZWZpbmVtZW50LCByZWZpbmVfbW9kdWxlcywgcmVmaW5lX21vZHVsZSwgYm9keTtcblxuICAgIGlmIChyZWN2Lmhhc093blByb3BlcnR5KCckJG1ldGEnKSkge1xuICAgICAgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMocmVjdi4kJG1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhyZWN2LiQkY2xhc3MpO1xuICAgIH1cblxuICAgIGFwcGx5X2Jsb2Nrb3B0cyhibG9jaywgYmxvY2tvcHRzKTtcblxuICAgIC8vIEZvciBhbGwgYW5jZXN0b3JzIHRoYXQgdGhlcmUgYXJlLCBzdGFydGluZyBmcm9tIHRoZSBjbG9zZXN0IHRvIHRoZSBmdXJ0aGVzdC4uLlxuICAgIGZvciAoaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuY2VzdG9yID0gT3BhbC5pZChhbmNlc3RvcnNbaV0pO1xuICAgICAgLy8gRm9yIGFsbCByZWZpbmVtZW50IGdyb3VwcyB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGNsb3Nlc3Qgc2NvcGUgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICBmb3IgKGogPSAwOyBqIDwgcmVmaW5lbWVudF9ncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmVmaW5lbWVudHMgPSByZWZpbmVtZW50X2dyb3Vwc1tqXTtcbiAgICAgICAgLy8gRm9yIGFsbCByZWZpbmVtZW50cyB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGxhc3QgYHVzaW5nYCBjYWxsIHRvIHRoZSBmdXJ0aGVzdC4uLlxuICAgICAgICBmb3IgKGsgPSByZWZpbmVtZW50cy5sZW5ndGggLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICAgIHJlZmluZW1lbnQgPSByZWZpbmVtZW50c1trXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlZmluZW1lbnQuJCRyZWZpbmVfbW9kdWxlcyA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuICAgICAgICAgIC8vIEEgc2luZ2xlIG1vZHVsZSBiZWluZyBnaXZlbiBhcyBhbiBhcmd1bWVudCBvZiB0aGUgYHVzaW5nYCBjYWxsIGNvbnRhaW5zIG11bHRpcGxlXG4gICAgICAgICAgLy8gcmVmaW5lbWVudCBtb2R1bGVzXG4gICAgICAgICAgcmVmaW5lX21vZHVsZXMgPSByZWZpbmVtZW50LiQkcmVmaW5lX21vZHVsZXM7XG4gICAgICAgICAgLy8gRG9lcyB0aGlzIG1vZHVsZSByZWZpbmUgYSBnaXZlbiBjYWxsIGZvciBhIGdpdmVuIGFuY2VzdG9yIG1vZHVsZT9cbiAgICAgICAgICBpZiAodHlwZW9mIHJlZmluZV9tb2R1bGVzW2FuY2VzdG9yXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlZmluZV9tb2R1bGUgPSByZWZpbmVfbW9kdWxlc1thbmNlc3Rvcl07XG4gICAgICAgICAgICAvLyBEb2VzIHRoaXMgbW9kdWxlIGRlZmluZSBhIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGw/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZmluZV9tb2R1bGUuJCRwcm90b3R5cGVbJyQnK21ldGhvZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGJvZHkgPSByZWZpbmVfbW9kdWxlLiQkcHJvdG90eXBlWyckJyttZXRob2RdO1xuICAgICAgICAgICAgICByZXR1cm4gT3BhbC5zZW5kMihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5zZW5kKHJlY3YsIG1ldGhvZCwgYXJncywgYmxvY2spO1xuICB9O1xuXG4gIE9wYWwubGFtYmRhID0gZnVuY3Rpb24oYmxvY2ssIGJsb2Nrb3B0cykge1xuICAgIGJsb2NrLiQkaXNfbGFtYmRhID0gdHJ1ZTtcblxuICAgIGFwcGx5X2Jsb2Nrb3B0cyhibG9jaywgYmxvY2tvcHRzKTtcblxuICAgIHJldHVybiBibG9jaztcbiAgfTtcblxuICAvLyBVc2VkIHRvIGRlZmluZSBtZXRob2RzIG9uIGFuIG9iamVjdC4gVGhpcyBpcyBhIGhlbHBlciBtZXRob2QsIHVzZWQgYnkgdGhlXG4gIC8vIGNvbXBpbGVkIHNvdXJjZSB0byBkZWZpbmUgbWV0aG9kcyBvbiBzcGVjaWFsIGNhc2Ugb2JqZWN0cyB3aGVuIHRoZSBjb21waWxlclxuICAvLyBjYW4gbm90IGRldGVybWluZSB0aGUgZGVzdGluYXRpb24gb2JqZWN0LCBvciB0aGUgb2JqZWN0IGlzIGEgTW9kdWxlXG4gIC8vIGluc3RhbmNlLiBUaGlzIGNhbiBnZXQgY2FsbGVkIGJ5IGBNb2R1bGUjZGVmaW5lX21ldGhvZGAgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgTW9kdWxlc1xuICAvL1xuICAvLyBBbnkgbWV0aG9kIGRlZmluZWQgb24gYSBtb2R1bGUgd2lsbCBjb21lIHRocm91Z2ggdGhpcyBydW50aW1lIGhlbHBlci5cbiAgLy8gVGhlIG1ldGhvZCBpcyBhZGRlZCB0byB0aGUgbW9kdWxlIGJvZHksIGFuZCB0aGUgb3duZXIgb2YgdGhlIG1ldGhvZCBpc1xuICAvLyBzZXQgdG8gYmUgdGhlIG1vZHVsZSBpdHNlbGYuIFRoaXMgaXMgdXNlZCBsYXRlciB3aGVuIGNob29zaW5nIHdoaWNoXG4gIC8vIG1ldGhvZCBzaG91bGQgc2hvdyBvbiBhIGNsYXNzIGlmIG1vcmUgdGhhbiAxIGluY2x1ZGVkIG1vZHVsZXMgZGVmaW5lXG4gIC8vIHRoZSBzYW1lIG1ldGhvZC4gRmluYWxseSwgaWYgdGhlIG1vZHVsZSBpcyBpbiBgbW9kdWxlX2Z1bmN0aW9uYCBtb2RlLFxuICAvLyB0aGVuIHRoZSBtZXRob2QgaXMgYWxzbyBkZWZpbmVkIG9udG8gdGhlIG1vZHVsZSBpdHNlbGYuXG4gIC8vXG4gIC8vICMjIENsYXNzZXNcbiAgLy9cbiAgLy8gVGhpcyBoZWxwZXIgd2lsbCBvbmx5IGJlIGNhbGxlZCBmb3IgY2xhc3NlcyB3aGVuIGEgbWV0aG9kIGlzIGJlaW5nXG4gIC8vIGRlZmluZWQgaW5kaXJlY3RseTsgZWl0aGVyIHRocm91Z2ggYE1vZHVsZSNkZWZpbmVfbWV0aG9kYCwgb3IgYnkgYVxuICAvLyBsaXRlcmFsIGBkZWZgIG1ldGhvZCBpbnNpZGUgYW4gYGluc3RhbmNlX2V2YWxgIG9yIGBjbGFzc19ldmFsYCBib2R5LiBJblxuICAvLyBlaXRoZXIgY2FzZSwgdGhlIG1ldGhvZCBpcyBzaW1wbHkgYWRkZWQgdG8gdGhlIGNsYXNzJyBwcm90b3R5cGUuIEEgc3BlY2lhbFxuICAvLyBleGNlcHRpb24gZXhpc3RzIGZvciBgQmFzaWNPYmplY3RgIGFuZCBgT2JqZWN0YC4gVGhlc2UgdHdvIGNsYXNzZXMgYXJlXG4gIC8vIHNwZWNpYWwgYmVjYXVzZSB0aGV5IGFyZSB1c2VkIGluIHRvbGwtZnJlZSBicmlkZ2VkIGNsYXNzZXMuIEluIGVhY2ggb2ZcbiAgLy8gdGhlc2UgdHdvIGNhc2VzLCBleHRyYSB3b3JrIGlzIHJlcXVpcmVkIHRvIGRlZmluZSB0aGUgbWV0aG9kcyBvbiB0b2xsLWZyZWVcbiAgLy8gYnJpZGdlZCBjbGFzcycgcHJvdG90eXBlcyBhcyB3ZWxsLlxuICAvL1xuICAvLyAjIyBPYmplY3RzXG4gIC8vXG4gIC8vIElmIGEgc2ltcGxlIHJ1Ynkgb2JqZWN0IGlzIHRoZSBvYmplY3QsIHRoZW4gdGhlIG1ldGhvZCBpcyBzaW1wbHkganVzdFxuICAvLyBkZWZpbmVkIG9uIHRoZSBvYmplY3QgYXMgYSBzaW5nbGV0b24gbWV0aG9kLiBUaGlzIHdvdWxkIGJlIHRoZSBjYXNlIHdoZW5cbiAgLy8gYSBtZXRob2QgaXMgZGVmaW5lZCBpbnNpZGUgYW4gYGluc3RhbmNlX2V2YWxgIGJsb2NrLlxuICAvL1xuICAvLyBAcGFyYW0gb2JqICBbT2JqZWN0LCBDbGFzc10gdGhlIGFjdHVhbCBvYmogdG8gZGVmaW5lIG1ldGhvZCBmb3JcbiAgLy8gQHBhcmFtIGpzaWQgW1N0cmluZ10gdGhlIEphdmFTY3JpcHQgZnJpZW5kbHkgbWV0aG9kIG5hbWUgKGUuZy4gJyRmb28nKVxuICAvLyBAcGFyYW0gYm9keSBbSlMuRnVuY3Rpb25dIHRoZSBsaXRlcmFsIEphdmFTY3JpcHQgZnVuY3Rpb24gdXNlZCBhcyBtZXRob2RcbiAgLy8gQHBhcmFtIGJsb2Nrb3B0cyBbT2JqZWN0LCBOdW1iZXJdIG9wdGlvbmFsIHByb3BlcnRpZXMgdG8gc2V0IG9uIHRoZSBib2R5XG4gIC8vIEByZXR1cm4gW251bGxdXG4gIC8vXG4gIE9wYWwuZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5LCBibG9ja29wdHMpIHtcbiAgICBhcHBseV9ibG9ja29wdHMoYm9keSwgYmxvY2tvcHRzKTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBtZXRob2QgZGVmaW5pdGlvbiBpbiB0aGVcbiAgICAvLyB0b3AtbGV2ZWwgbmFtZXNwYWNlXG4gICAgaWYgKG9iaiA9PT0gT3BhbC50b3ApIHtcbiAgICAgIHJldHVybiBPcGFsLmRlZm4oT3BhbC5PYmplY3QsIGpzaWQsIGJvZHkpO1xuICAgIH1cbiAgICAvLyBpZiBpbnN0YW5jZV9ldmFsIGlzIGludm9rZWQgb24gYSBtb2R1bGUvY2xhc3MsIGl0IHNldHMgaW5zdF9ldmFsX21vZFxuICAgIGVsc2UgaWYgKCFvYmouJCRldmFsICYmIG9iai4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICByZXR1cm4gT3BhbC5kZWZuKG9iaiwganNpZCwgYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIE9wYWwuZGVmcyhvYmosIGpzaWQsIGJvZHkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWZpbmUgbWV0aG9kIG9uIGEgbW9kdWxlIG9yIGNsYXNzIChzZWUgT3BhbC5kZWYpLlxuICBPcGFsLmRlZm4gPSBmdW5jdGlvbihtb2R1bGUsIGpzaWQsIGJvZHkpIHtcbiAgICBib2R5LmRpc3BsYXlOYW1lID0ganNpZDtcbiAgICBib2R5LiQkb3duZXIgPSBtb2R1bGU7XG5cbiAgICB2YXIgbmFtZSA9IGpzaWQuc3Vic3RyKDEpO1xuXG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuICAgICRwcm9wKHByb3RvLCBqc2lkLCBib2R5KTtcblxuICAgIGlmIChtb2R1bGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIGlmIChtb2R1bGUuJCRtb2R1bGVfZnVuY3Rpb24pIHtcbiAgICAgICAgT3BhbC5kZWZzKG1vZHVsZSwganNpZCwgYm9keSlcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGljbGFzc2VzID0gbW9kdWxlLiQkaWNsYXNzZXMsIGxlbmd0aCA9IGljbGFzc2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpY2xhc3MgPSBpY2xhc3Nlc1tpXTtcbiAgICAgICAgJHByb3AoaWNsYXNzLCBqc2lkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2luZ2xldG9uX29mID0gbW9kdWxlLiQkc2luZ2xldG9uX29mO1xuICAgIGlmIChtb2R1bGUuJG1ldGhvZF9hZGRlZCAmJiAhbW9kdWxlLiRtZXRob2RfYWRkZWQuJCRzdHViICYmICFzaW5nbGV0b25fb2YpIHtcbiAgICAgIG1vZHVsZS4kbWV0aG9kX2FkZGVkKG5hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkICYmICFzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQuJCRzdHViKSB7XG4gICAgICBzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQobmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG5cbiAgLy8gRGVmaW5lIGEgc2luZ2xldG9uIG1ldGhvZCBvbiB0aGUgZ2l2ZW4gb2JqZWN0IChzZWUgT3BhbC5kZWYpLlxuICBPcGFsLmRlZnMgPSBmdW5jdGlvbihvYmosIGpzaWQsIGJvZHksIGJsb2Nrb3B0cykge1xuICAgIGFwcGx5X2Jsb2Nrb3B0cyhib2R5LCBibG9ja29wdHMpO1xuXG4gICAgaWYgKG9iai4kJGlzX3N0cmluZyB8fCBvYmouJCRpc19udW1iZXIpIHtcbiAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJjYW4ndCBkZWZpbmUgc2luZ2xldG9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gT3BhbC5kZWZuKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopLCBqc2lkLCBib2R5KTtcbiAgfTtcblxuICAvLyBDYWxsZWQgZnJvbSAjcmVtb3ZlX21ldGhvZC5cbiAgT3BhbC5yZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCEkaGFzX293bi5jYWxsKG9iai4kJHByb3RvdHlwZSwganNpZCkpIHtcbiAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJtZXRob2QgJ1wiICsganNpZC5zdWJzdHIoMSkgKyBcIicgbm90IGRlZmluZWQgaW4gXCIgKyBvYmouJG5hbWUoKSk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9iai4kJHByb3RvdHlwZVtqc2lkXTtcblxuICAgIGlmIChvYmouJCRpc19zaW5nbGV0b24pIHtcbiAgICAgIGlmIChvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZCAmJiAhb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAob2JqLiRtZXRob2RfcmVtb3ZlZCAmJiAhb2JqLiRtZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiRtZXRob2RfcmVtb3ZlZChqc2lkLnN1YnN0cigxKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENhbGxlZCBmcm9tICN1bmRlZl9tZXRob2QuXG4gIE9wYWwudWRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCkge1xuICAgIGlmICghb2JqLiQkcHJvdG90eXBlW2pzaWRdIHx8IG9iai4kJHByb3RvdHlwZVtqc2lkXS4kJHN0dWIpIHtcbiAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJtZXRob2QgJ1wiICsganNpZC5zdWJzdHIoMSkgKyBcIicgbm90IGRlZmluZWQgaW4gXCIgKyBvYmouJG5hbWUoKSk7XG4gICAgfVxuXG4gICAgT3BhbC5hZGRfc3R1Yl9mb3Iob2JqLiQkcHJvdG90eXBlLCBqc2lkKTtcblxuICAgIGlmIChvYmouJCRpc19zaW5nbGV0b24pIHtcbiAgICAgIGlmIChvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAob2JqLiRtZXRob2RfdW5kZWZpbmVkICYmICFvYmouJG1ldGhvZF91bmRlZmluZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kbWV0aG9kX3VuZGVmaW5lZChqc2lkLnN1YnN0cigxKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzX21ldGhvZF9ib2R5KGJvZHkpIHtcbiAgICByZXR1cm4gKHR5cGVvZihib2R5KSA9PT0gXCJmdW5jdGlvblwiICYmICFib2R5LiQkc3R1Yik7XG4gIH1cblxuICBPcGFsLmFsaWFzID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBvbGQpIHtcbiAgICB2YXIgaWQgICAgID0gJyQnICsgbmFtZSxcbiAgICAgICAgb2xkX2lkID0gJyQnICsgb2xkLFxuICAgICAgICBib2R5LFxuICAgICAgICBhbGlhcztcblxuICAgIC8vIEFsaWFzaW5nIG9uIG1haW4gbWVhbnMgYWxpYXNpbmcgb24gT2JqZWN0Li4uXG4gICAgaWYgKHR5cGVvZiBvYmouJCRwcm90b3R5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvYmogPSBPcGFsLk9iamVjdDtcbiAgICB9XG5cbiAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlWyckJyArIG9sZF07XG5cbiAgICAvLyBXaGVuIHJ1bm5pbmcgaW5zaWRlICNpbnN0YW5jZV9ldmFsIHRoZSBhbGlhcyByZWZlcnMgdG8gY2xhc3MgbWV0aG9kcy5cbiAgICBpZiAob2JqLiQkZXZhbCkge1xuICAgICAgcmV0dXJuIE9wYWwuYWxpYXMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaiksIG5hbWUsIG9sZCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc19tZXRob2RfYm9keShib2R5KSkge1xuICAgICAgdmFyIGFuY2VzdG9yID0gb2JqLiQkc3VwZXI7XG5cbiAgICAgIHdoaWxlICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiAmJiBhbmNlc3Rvcikge1xuICAgICAgICBib2R5ICAgICA9IGFuY2VzdG9yW29sZF9pZF07XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IuJCRzdXBlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc19tZXRob2RfYm9keShib2R5KSAmJiBvYmouJCRpc19tb2R1bGUpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGxvb2sgaW50byBPYmplY3RcbiAgICAgICAgYm9keSA9IE9wYWwuT2JqZWN0LiQkcHJvdG90eXBlW29sZF9pZF1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc19tZXRob2RfYm9keShib2R5KSkge1xuICAgICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgXCIgKyBvbGQgKyBcIicgZm9yIGNsYXNzIGBcIiArIG9iai4kbmFtZSgpICsgXCInXCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGJvZHkgaXMgaXRzZWxmIGFuIGFsaWFzIHVzZSB0aGUgb3JpZ2luYWwgYm9keVxuICAgIC8vIHRvIGtlZXAgdGhlIG1heCBkZXB0aCBhdCAxLlxuICAgIGlmIChib2R5LiQkYWxpYXNfb2YpIGJvZHkgPSBib2R5LiQkYWxpYXNfb2Y7XG5cbiAgICAvLyBXZSBuZWVkIGEgd3JhcHBlciBiZWNhdXNlIG90aGVyd2lzZSBwcm9wZXJ0aWVzXG4gICAgLy8gd291bGQgYmUgb3ZlcndyaXR0ZW4gb24gdGhlIG9yaWdpbmFsIGJvZHkuXG4gICAgYWxpYXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBibG9jayA9IGFsaWFzLiQkcCwgYXJncywgaSwgaWk7XG5cbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICBmb3IoaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGFsaWFzLiQkcDtcblxuICAgICAgcmV0dXJuIE9wYWwuc2VuZCh0aGlzLCBib2R5LCBhcmdzLCBibG9jayk7XG4gICAgfTtcblxuICAgIC8vIEFzc2lnbiB0aGUgJ2xlbmd0aCcgdmFsdWUgd2l0aCBkZWZpbmVQcm9wZXJ0eSBiZWNhdXNlXG4gICAgLy8gaW4gc3RyaWN0IG1vZGUgdGhlIHByb3BlcnR5IGlzIG5vdCB3cml0YWJsZS5cbiAgICAvLyBJdCBkb2Vzbid0IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDM4KSwgd2hlcmVcbiAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGJyZWFraW5nIE9wYWwgYWx0b2dldGhlci5cbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFsaWFzLCAnbGVuZ3RoJywgeyB2YWx1ZTogYm9keS5sZW5ndGggfSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIFRyeSB0byBtYWtlIHRoZSBicm93c2VyIHBpY2sgdGhlIHJpZ2h0IG5hbWVcbiAgICBhbGlhcy5kaXNwbGF5TmFtZSAgICAgICA9IG5hbWU7XG5cbiAgICBhbGlhcy4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eTtcbiAgICBhbGlhcy4kJHBhcmFtZXRlcnMgICAgICA9IGJvZHkuJCRwYXJhbWV0ZXJzO1xuICAgIGFsaWFzLiQkc291cmNlX2xvY2F0aW9uID0gYm9keS4kJHNvdXJjZV9sb2NhdGlvbjtcbiAgICBhbGlhcy4kJGFsaWFzX29mICAgICAgICA9IGJvZHk7XG4gICAgYWxpYXMuJCRhbGlhc19uYW1lICAgICAgPSBuYW1lO1xuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGFsaWFzKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgT3BhbC5hbGlhc19ndmFyID0gZnVuY3Rpb24obmV3X25hbWUsIG9sZF9uYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9wYWwuZ3ZhcnMsIG5ld19uYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuZ3ZhcnNbb2xkX25hbWVdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24obmV3X3ZhbHVlKSB7XG4gICAgICAgIE9wYWwuZ3ZhcnNbb2xkX25hbWVdID0gbmV3X3ZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBPcGFsLmFsaWFzX25hdGl2ZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgbmF0aXZlX25hbWUpIHtcbiAgICB2YXIgaWQgICA9ICckJyArIG5hbWUsXG4gICAgICAgIGJvZHkgPSBvYmouJCRwcm90b3R5cGVbbmF0aXZlX25hbWVdO1xuXG4gICAgaWYgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiIHx8IGJvZHkuJCRzdHViKSB7XG4gICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwidW5kZWZpbmVkIG5hdGl2ZSBtZXRob2QgYFwiICsgbmF0aXZlX25hbWUgKyBcIicgZm9yIGNsYXNzIGBcIiArIG9iai4kbmFtZSgpICsgXCInXCIpXG4gICAgfVxuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGJvZHkpO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuXG4gIC8vIEhhc2hlc1xuICAvLyAtLS0tLS1cblxuICBPcGFsLmhhc2hfaW5pdCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLiQkc21hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaGFzaC4kJG1hcCAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRrZXlzID0gW107XG4gIH07XG5cbiAgT3BhbC5oYXNoX2Nsb25lID0gZnVuY3Rpb24oZnJvbV9oYXNoLCB0b19oYXNoKSB7XG4gICAgdG9faGFzaC4kJG5vbmUgPSBmcm9tX2hhc2guJCRub25lO1xuICAgIHRvX2hhc2guJCRwcm9jID0gZnJvbV9oYXNoLiQkcHJvYztcblxuICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gZnJvbV9oYXNoLiQka2V5cywgc21hcCA9IGZyb21faGFzaC4kJHNtYXAsIGxlbiA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgdmFsdWUgPSBzbWFwW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5oYXNoX3B1dCh0b19oYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX3B1dCA9IGZ1bmN0aW9uKGhhc2gsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgaGFzaC4kJGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgaGFzaC4kJHNtYXBba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0LCBsYXN0X2J1Y2tldDtcbiAgICBrZXlfaGFzaCA9IGhhc2guJCRieV9pZGVudGl0eSA/IE9wYWwuaWQoa2V5KSA6IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgYnVja2V0ID0ge2tleToga2V5LCBrZXlfaGFzaDoga2V5X2hhc2gsIHZhbHVlOiB2YWx1ZX07XG4gICAgICBoYXNoLiQka2V5cy5wdXNoKGJ1Y2tldCk7XG4gICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGJ1Y2tldDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcblxuICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBidWNrZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgIH1cblxuICAgIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgYnVja2V0ID0ge2tleToga2V5LCBrZXlfaGFzaDoga2V5X2hhc2gsIHZhbHVlOiB2YWx1ZX07XG4gICAgICBoYXNoLiQka2V5cy5wdXNoKGJ1Y2tldCk7XG4gICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gYnVja2V0O1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfZ2V0ID0gZnVuY3Rpb24oaGFzaCwga2V5KSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGhhc2guJCRzbWFwW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleV9oYXNoLCBidWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICgkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgICByZXR1cm4gYnVja2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfZGVsZXRlID0gZnVuY3Rpb24oaGFzaCwga2V5KSB7XG4gICAgdmFyIGksIGtleXMgPSBoYXNoLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIHZhbHVlLCBrZXlfdG1wO1xuXG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIGtleSA9IGtleS52YWx1ZU9mKCk7XG5cbiAgICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkc21hcCwga2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXlfdG1wID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5X3RtcC4kJGlzX3N0cmluZyAmJiB0eXBlb2Yga2V5X3RtcCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGtleV90bXAgPSBrZXlfdG1wLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlfdG1wID09PSBrZXkpIHtcbiAgICAgICAgICBrZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGhhc2guJCRzbWFwW2tleV07XG4gICAgICBkZWxldGUgaGFzaC4kJHNtYXBba2V5XTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5X2hhc2ggPSBrZXkuJGhhc2goKTtcblxuICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF0sIGxhc3RfYnVja2V0O1xuXG4gICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgdmFsdWUgPSBidWNrZXQudmFsdWU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGtleXNbaV0gPT09IGJ1Y2tldCkge1xuICAgICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdF9idWNrZXQgJiYgYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgICBkZWxldGUgbGFzdF9idWNrZXQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChidWNrZXQubmV4dCkge1xuICAgICAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2guJCRtYXBba2V5X2hhc2hdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX3JlaGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaGFzaC4kJGtleXMubGVuZ3RoLCBrZXlfaGFzaCwgYnVja2V0LCBsYXN0X2J1Y2tldDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIGlmIChoYXNoLiQka2V5c1tpXS4kJGlzX3N0cmluZykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAga2V5X2hhc2ggPSBoYXNoLiQka2V5c1tpXS5rZXkuJGhhc2goKTtcblxuICAgICAgaWYgKGtleV9oYXNoID09PSBoYXNoLiQka2V5c1tpXS5rZXlfaGFzaCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF07XG4gICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgICBpZiAoYnVja2V0ID09PSBoYXNoLiQka2V5c1tpXSkge1xuICAgICAgICAgIGlmIChsYXN0X2J1Y2tldCAmJiBidWNrZXQubmV4dCkge1xuICAgICAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgICAgICAgZGVsZXRlIGxhc3RfYnVja2V0Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgICBoYXNoLiQkbWFwW2hhc2guJCRrZXlzW2ldLmtleV9oYXNoXSA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBoYXNoLiQkbWFwW2hhc2guJCRrZXlzW2ldLmtleV9oYXNoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBoYXNoLiQka2V5c1tpXS5rZXlfaGFzaCA9IGtleV9oYXNoO1xuXG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gaGFzaC4kJGtleXNbaV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcbiAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChidWNrZXQgPT09IGhhc2guJCRrZXlzW2ldKSB7XG4gICAgICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGhhc2guJCRrZXlzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJndW1lbnRzX2xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MsIGhhc2gsIGksIGxlbmd0aCwga2V5LCB2YWx1ZTtcblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcbiAgICBPcGFsLmhhc2hfaW5pdChoYXNoKTtcblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXS4kJGlzX2FycmF5KSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJnc1tpXS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcInZhbHVlIG5vdCBvZiBsZW5ndGggMjogXCIgKyBhcmdzW2ldLiRpbnNwZWN0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gYXJnc1tpXVswXTtcbiAgICAgICAgdmFsdWUgPSBhcmdzW2ldWzFdO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxKSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yIChrZXkgaW4gYXJncykge1xuICAgICAgICBpZiAoJGhhc19vd24uY2FsbChhcmdzLCBrZXkpKSB7XG4gICAgICAgICAgdmFsdWUgPSBhcmdzW2tleV07XG5cbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaFwiKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzX2xlbmd0aDsgaSArPSAyKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgLy8gQSBmYXN0ZXIgSGFzaCBjcmVhdG9yIGZvciBoYXNoZXMgdGhhdCBqdXN0IHVzZSBzeW1ib2xzIGFuZFxuICAvLyBzdHJpbmdzIGFzIGtleXMuIFRoZSBtYXAgYW5kIGtleXMgYXJyYXkgY2FuIGJlIGNvbnN0cnVjdGVkIGF0XG4gIC8vIGNvbXBpbGUgdGltZSwgc28gdGhleSBhcmUganVzdCBhZGRlZCBoZXJlIGJ5IHRoZSBjb25zdHJ1Y3RvclxuICAvLyBmdW5jdGlvbi5cbiAgLy9cbiAgT3BhbC5oYXNoMiA9IGZ1bmN0aW9uKGtleXMsIHNtYXApIHtcbiAgICB2YXIgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcblxuICAgIGhhc2guJCRzbWFwID0gc21hcDtcbiAgICBoYXNoLiQkbWFwICA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaGFzaC4kJGtleXMgPSBrZXlzO1xuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHJhbmdlIGluc3RhbmNlIHdpdGggZmlyc3QgYW5kIGxhc3QgdmFsdWVzLCBhbmQgd2hldGhlciB0aGVcbiAgLy8gcmFuZ2UgZXhjbHVkZXMgdGhlIGxhc3QgdmFsdWUuXG4gIC8vXG4gIE9wYWwucmFuZ2UgPSBmdW5jdGlvbihmaXJzdCwgbGFzdCwgZXhjKSB7XG4gICAgdmFyIHJhbmdlICAgICAgICAgPSBuZXcgT3BhbC5SYW5nZSgpO1xuICAgICAgICByYW5nZS5iZWdpbiAgID0gZmlyc3Q7XG4gICAgICAgIHJhbmdlLmVuZCAgICAgPSBsYXN0O1xuICAgICAgICByYW5nZS5leGNsICAgID0gZXhjO1xuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgaXZhciBuYW1lIGZvciBhIGdpdmVuIG5hbWUuXG4gIC8vIE1vc3RseSBhZGRzIGEgdHJhaWxpbmcgJCB0byByZXNlcnZlZCBuYW1lcy5cbiAgLy9cbiAgT3BhbC5pdmFyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChcbiAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICBuYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJkaXNwbGF5TmFtZVwiIHx8XG4gICAgICAgIG5hbWUgPT09IFwiX19jb3VudF9fXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX25vU3VjaE1ldGhvZF9fXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX3BhcmVudF9fXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fFxuXG4gICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgbmFtZSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiIHx8XG4gICAgICAgIG5hbWUgPT09IFwidmFsdWVPZlwiXG4gICAgICAgKVxuICAgIHtcbiAgICAgIHJldHVybiBuYW1lICsgXCIkXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG5cblxuICAvLyBSZWdleHBzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBFc2NhcGUgUmVnZXhwIHNwZWNpYWwgY2hhcnMgbGV0dGluZyB0aGUgcmVzdWx0aW5nIHN0cmluZyBiZSB1c2VkIHRvIGJ1aWxkXG4gIC8vIGEgbmV3IFJlZ2V4cC5cbiAgLy9cbiAgT3BhbC5lc2NhcGVfcmVnZXhwID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy1bXFxdXFwve30oKSorPy5eJFxcXFx8IF0pL2csICdcXFxcJDEnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcbl0vZywgJ1xcXFxuJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHJdL2csICdcXFxccicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxmXS9nLCAnXFxcXGYnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdF0vZywgJ1xcXFx0Jyk7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZ2xvYmFsIFJlZ2V4cCBmcm9tIGEgUmVnRXhwIG9iamVjdCBhbmQgY2FjaGUgdGhlIHJlc3VsdFxuICAvLyBvbiB0aGUgb2JqZWN0IGl0c2VsZiAoJCRnIGF0dHJpYnV0ZSkuXG4gIC8vXG4gIE9wYWwuZ2xvYmFsX3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICBpZiAocGF0dGVybi5nbG9iYWwpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuOyAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBmbGFnXG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLiQkZyA9PSBudWxsKSB7XG4gICAgICBwYXR0ZXJuLiQkZyA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIChwYXR0ZXJuLm11bHRpbGluZSA/ICdnbScgOiAnZycpICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4uJCRnLmxhc3RJbmRleCA9IG51bGw7IC8vIHJlc2V0IGxhc3RJbmRleCBwcm9wZXJ0eVxuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybi4kJGc7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZ2xvYmFsIG11bHRpbGluZSBSZWdleHAgZnJvbSBhIFJlZ0V4cCBvYmplY3QgYW5kIGNhY2hlIHRoZSByZXN1bHRcbiAgLy8gb24gdGhlIG9iamVjdCBpdHNlbGYgKCQkZ20gb3IgJCRnIGF0dHJpYnV0ZSkuXG4gIC8vXG4gIE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAocGF0dGVybi5tdWx0aWxpbmUpIHtcbiAgICAgIGlmIChwYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgICByZXR1cm4gcGF0dGVybjsgLy8gUmVnRXhwIGFscmVhZHkgaGFzIHRoZSBnbG9iYWwgYW5kIG11bHRpbGluZSBmbGFnXG4gICAgICB9XG4gICAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlICQkZyBhdHRyaWJ1dGUgYmVjYXVzZSB0aGUgUmVnZXhwIGlzIGFscmVhZHkgbXVsdGlsaW5lXG4gICAgICBpZiAocGF0dGVybi4kJGcgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgJ2dtJyArIChwYXR0ZXJuLmlnbm9yZUNhc2UgPyAnaScgOiAnJykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0dGVybi4kJGdtICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGdtID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgJ2dtJyArIChwYXR0ZXJuLmlnbm9yZUNhc2UgPyAnaScgOiAnJykpO1xuICAgIH1cbiAgICByZXN1bHQubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb21iaW5lIG11bHRpcGxlIHJlZ2V4cCBwYXJ0cyB0b2dldGhlclxuICBPcGFsLnJlZ2V4cCA9IGZ1bmN0aW9uKHBhcnRzLCBmbGFncykge1xuICAgIHZhciBwYXJ0O1xuICAgIHZhciBpZ25vcmVDYXNlID0gdHlwZW9mIGZsYWdzICE9PSAndW5kZWZpbmVkJyAmJiBmbGFncyAmJiBmbGFncy5pbmRleE9mKCdpJykgPj0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmIChwYXJ0Lmlnbm9yZUNhc2UgIT09IGlnbm9yZUNhc2UpXG4gICAgICAgICAgT3BhbC5LZXJuZWwuJHdhcm4oXG4gICAgICAgICAgICBcImlnbm9yZSBjYXNlIGRvZXNuJ3QgbWF0Y2ggZm9yIFwiICsgcGFydC5zb3VyY2UuJGluc3BlY3QoKSxcbiAgICAgICAgICAgIE9wYWwuaGFzaCh7dXBsZXZlbDogMX0pXG4gICAgICAgICAgKVxuXG4gICAgICAgIHBhcnQgPSBwYXJ0LnNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0ID09PSAnJykgcGFydCA9ICcoPzonICsgcGFydCArICcpJztcbiAgICAgIHBhcnRzW2ldID0gcGFydDtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhcnRzLmpvaW4oJycpLCBmbGFncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhcnRzLmpvaW4oJycpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVxdWlyZSBzeXN0ZW1cbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICBPcGFsLm1vZHVsZXMgICAgICAgICA9IHt9O1xuICBPcGFsLmxvYWRlZF9mZWF0dXJlcyA9IFsnY29yZWxpYi9ydW50aW1lJ107XG4gIE9wYWwuY3VycmVudF9kaXIgICAgID0gJy4nO1xuICBPcGFsLnJlcXVpcmVfdGFibGUgICA9IHsnY29yZWxpYi9ydW50aW1lJzogdHJ1ZX07XG5cbiAgT3BhbC5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIHBhcnRzLCBwYXJ0LCBuZXdfcGFydHMgPSBbXSwgU0VQQVJBVE9SID0gJy8nO1xuXG4gICAgaWYgKE9wYWwuY3VycmVudF9kaXIgIT09ICcuJykge1xuICAgICAgcGF0aCA9IE9wYWwuY3VycmVudF9kaXIucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcGF0aDtcbiAgICB9XG5cbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwuXFwvLywgJycpO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLihyYnxvcGFsfGpzKSQvLCAnJyk7XG4gICAgcGFydHMgPSBwYXRoLnNwbGl0KFNFUEFSQVRPUik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgKHBhcnQgPT09ICcuLicpID8gbmV3X3BhcnRzLnBvcCgpIDogbmV3X3BhcnRzLnB1c2gocGFydClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3X3BhcnRzLmpvaW4oU0VQQVJBVE9SKTtcbiAgfTtcblxuICBPcGFsLmxvYWRlZCA9IGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgdmFyIGksIGwsIHBhdGg7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aHNbaV0pO1xuXG4gICAgICBpZiAoT3BhbC5yZXF1aXJlX3RhYmxlW3BhdGhdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBPcGFsLmxvYWRlZF9mZWF0dXJlcy5wdXNoKHBhdGgpO1xuICAgICAgT3BhbC5yZXF1aXJlX3RhYmxlW3BhdGhdID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5sb2FkID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIE9wYWwubG9hZGVkKFtwYXRoXSk7XG5cbiAgICB2YXIgbW9kdWxlID0gT3BhbC5tb2R1bGVzW3BhdGhdO1xuXG4gICAgaWYgKG1vZHVsZSkge1xuICAgICAgdmFyIHJldHZhbCA9IG1vZHVsZShPcGFsKTtcbiAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV0dmFsIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAvLyBBIHNwZWNpYWwgY2FzZSBvZiByZXF1aXJlIGhhdmluZyBhbiBhc3luYyB0b3A6XG4gICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBhd2FpdCBpdC5cbiAgICAgICAgcmV0dXJuIHJldHZhbC50aGVuKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNldmVyaXR5ID0gT3BhbC5jb25maWcubWlzc2luZ19yZXF1aXJlX3NldmVyaXR5O1xuICAgICAgdmFyIG1lc3NhZ2UgID0gJ2Nhbm5vdCBsb2FkIHN1Y2ggZmlsZSAtLSAnICsgcGF0aDtcblxuICAgICAgaWYgKHNldmVyaXR5ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgaWYgKE9wYWwuTG9hZEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgT3BhbC5Mb2FkRXJyb3IuJG5ldyhtZXNzYWdlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2V2ZXJpdHkgPT09IFwid2FybmluZ1wiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogTG9hZEVycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgT3BhbC5yZXF1aXJlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkKHBhdGgpO1xuICB9O1xuXG5cbiAgLy8gU3RyaW5nc1xuICAvLyAtLS0tLS0tXG5cbiAgT3BhbC5lbmNvZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIFNldHMgdGhlIGVuY29kaW5nIG9uIGEgc3RyaW5nLCB3aWxsIHRyZWF0IHN0cmluZyBsaXRlcmFscyBhcyBmcm96ZW4gc3RyaW5nc1xuICAvLyByYWlzaW5nIGEgRnJvemVuRXJyb3IuXG4gIC8vXG4gIC8vIEBwYXJhbSBzdHIgW1N0cmluZ10gdGhlIHN0cmluZyBvbiB3aGljaCB0aGUgZW5jb2Rpbmcgc2hvdWxkIGJlIHNldFxuICAvLyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgY2Fub25pY2FsIG5hbWUgb2YgdGhlIGVuY29kaW5nXG4gIC8vIEBwYXJhbSB0eXBlIFtTdHJpbmddIHBvc3NpYmxlIHZhbHVlcyBhcmUgZWl0aGVyIGBcImVuY29kaW5nXCJgLCBgXCJpbnRlcm5hbF9lbmNvZGluZ1wiYCwgb3IgYHVuZGVmaW5lZFxuICBPcGFsLnNldF9lbmNvZGluZyA9IGZ1bmN0aW9uKHN0ciwgbmFtZSwgdHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJ1bmRlZmluZWRcIikgdHlwZSA9IFwiZW5jb2RpbmdcIjtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyLiQkZnJvemVuID09PSB0cnVlKVxuICAgICAgdGhyb3cgT3BhbC5Gcm96ZW5FcnJvci4kbmV3KFwiY2FuJ3QgbW9kaWZ5IGZyb3plbiBTdHJpbmdcIik7XG5cbiAgICB2YXIgZW5jb2RpbmcgPSBPcGFsLmZpbmRfZW5jb2RpbmcobmFtZSk7XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09IHN0clt0eXBlXSkgeyByZXR1cm4gc3RyOyB9XG5cbiAgICBzdHJbdHlwZV0gPSBlbmNvZGluZztcblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLy8gRmV0Y2hlcyB0aGUgZW5jb2RpbmcgZm9yIHRoZSBnaXZlbiBuYW1lIG9yIHJhaXNlcyBBcmd1bWVudEVycm9yLlxuICBPcGFsLmZpbmRfZW5jb2RpbmcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHJlZ2lzdGVyID0gT3BhbC5lbmNvZGluZ3M7XG4gICAgdmFyIGVuY29kaW5nID0gcmVnaXN0ZXJbbmFtZV0gfHwgcmVnaXN0ZXJbbmFtZS50b1VwcGVyQ2FzZSgpXTtcbiAgICBpZiAoIWVuY29kaW5nKSB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcInVua25vd24gZW5jb2RpbmcgbmFtZSAtIFwiICsgbmFtZSk7XG4gICAgcmV0dXJuIGVuY29kaW5nO1xuICB9XG5cbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGVuY29kaW5nIHNldCBmcm9tIGEgc3RyaW5nIGxpdGVyYWxcbiAgT3BhbC5lbmMgPSBmdW5jdGlvbihzdHIsIG5hbWUpIHtcbiAgICB2YXIgZHVwID0gbmV3IFN0cmluZyhzdHIpO1xuICAgIGR1cCA9IE9wYWwuc2V0X2VuY29kaW5nKGR1cCwgbmFtZSk7XG4gICAgZHVwLmludGVybmFsX2VuY29kaW5nID0gZHVwLmVuY29kaW5nO1xuICAgIHJldHVybiBkdXBcbiAgfVxuXG4gIC8vIEByZXR1cm5zIGEgU3RyaW5nIG9iamVjdCB3aXRoIHRoZSBpbnRlcm5hbCBlbmNvZGluZyBzZXQgdG8gQmluYXJ5XG4gIE9wYWwuYmluYXJ5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGR1cCA9IG5ldyBTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gT3BhbC5zZXRfZW5jb2RpbmcoZHVwLCBcImJpbmFyeVwiLCBcImludGVybmFsX2VuY29kaW5nXCIpO1xuICB9XG5cbiAgT3BhbC5sYXN0X3Byb21pc2UgPSBudWxsO1xuICBPcGFsLnByb21pc2VfdW5oYW5kbGVkX2V4Y2VwdGlvbiA9IGZhbHNlO1xuXG4gIC8vIFJ1biBhIGJsb2NrIG9mIGNvZGUsIGJ1dCBpZiBpdCByZXR1cm5zIGEgUHJvbWlzZSwgZG9uJ3QgcnVuIHRoZSBuZXh0XG4gIC8vIG9uZSwgYnV0IHF1ZXVlIGl0LlxuICBPcGFsLnF1ZXVlID0gZnVuY3Rpb24ocHJvYykge1xuICAgIGlmIChPcGFsLmxhc3RfcHJvbWlzZSkge1xuICAgICAgLy8gVGhlIGFzeW5jIHBhdGggaXMgdGFrZW4gb25seSBpZiBhbnl0aGluZyBiZWZvcmUgcmV0dXJuZWQgYVxuICAgICAgLy8gUHJvbWlzZShWMikuXG4gICAgICBPcGFsLmxhc3RfcHJvbWlzZSA9IE9wYWwubGFzdF9wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghT3BhbC5wcm9taXNlX3VuaGFuZGxlZF9leGNlcHRpb24pIHJldHVybiBwcm9jKE9wYWwpO1xuICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKE9wYWwucmVzcG9uZF90byhlcnJvciwgJyRmdWxsX21lc3NhZ2UnKSkge1xuICAgICAgICAgIGVycm9yID0gZXJyb3IuJGZ1bGxfbWVzc2FnZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAvLyBBYm9ydCBmdXJ0aGVyIGV4ZWN1dGlvblxuICAgICAgICBPcGFsLnByb21pc2VfdW5oYW5kbGVkX2V4Y2VwdGlvbiA9IHRydWU7XG4gICAgICAgIE9wYWwuZXhpdCgxKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIE9wYWwubGFzdF9wcm9taXNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciByZXQgPSBwcm9jKE9wYWwpO1xuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXQgPT09ICdvYmplY3QnICYmIHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgT3BhbC5sYXN0X3Byb21pc2UgPSByZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfVxuXG4gIC8vIE9wZXJhdG9yIGhlbHBlcnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuICBPcGFsLnJiX3BsdXMgICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gKHR5cGVvZihsKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKHIpID09PSAnbnVtYmVyJykgPyBsICsgciA6IGxbJyQrJ10ocik7IH1cbiAgT3BhbC5yYl9taW51cyAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuICh0eXBlb2YobCkgPT09ICdudW1iZXInICYmIHR5cGVvZihyKSA9PT0gJ251bWJlcicpID8gbCAtIHIgOiBsWyckLSddKHIpOyB9XG4gIE9wYWwucmJfdGltZXMgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiAodHlwZW9mKGwpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YocikgPT09ICdudW1iZXInKSA/IGwgKiByIDogbFsnJConXShyKTsgfVxuICBPcGFsLnJiX2RpdmlkZSA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gKHR5cGVvZihsKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKHIpID09PSAnbnVtYmVyJykgPyBsIC8gciA6IGxbJyQvJ10ocik7IH1cbiAgT3BhbC5yYl9sdCAgICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuICh0eXBlb2YobCkgPT09ICdudW1iZXInICYmIHR5cGVvZihyKSA9PT0gJ251bWJlcicpID8gbCA8IHIgOiBsWyckPCddKHIpOyB9XG4gIE9wYWwucmJfZ3QgICAgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiAodHlwZW9mKGwpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YocikgPT09ICdudW1iZXInKSA/IGwgPiByIDogbFsnJD4nXShyKTsgfVxuICBPcGFsLnJiX2xlICAgICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gKHR5cGVvZihsKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKHIpID09PSAnbnVtYmVyJykgPyBsIDw9IHIgOiBsWyckPD0nXShyKTsgfVxuICBPcGFsLnJiX2dlICAgICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gKHR5cGVvZihsKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKHIpID09PSAnbnVtYmVyJykgPyBsID49IHIgOiBsWyckPj0nXShyKTsgfVxuXG4gIC8vIE9wdGltaXplZCBoZWxwZXJzIGZvciBjYWxscyBsaWtlICR0cnV0aHkoKGEpWyckPT09J10oYikpIC0+ICRlcWVxZXEoYSwgYilcbiAgT3BhbC5lcWVxID0gZnVuY3Rpb24obGhzLCByaHMpIHtcbiAgICBpZiAoKHR5cGVvZiBsaHMgPT09ICdudW1iZXInICYmIHR5cGVvZiByaHMgPT09ICdudW1iZXInKSB8fFxuICAgICAgICAodHlwZW9mIGxocyA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHJocyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICByZXR1cm4gbGhzID09PSByaHM7XG4gICAgfVxuICAgIHJldHVybiAkdHJ1dGh5KChsaHMpWyckPT0nXShyaHMpKTtcbiAgfTtcbiAgT3BhbC5lcWVxZXEgPSBmdW5jdGlvbihsaHMsIHJocykge1xuICAgIGlmICgodHlwZW9mIGxocyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHJocyA9PT0gJ251bWJlcicpIHx8XG4gICAgICAgICh0eXBlb2YgbGhzID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgcmhzID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHJldHVybiBsaHMgPT09IHJocztcbiAgICB9XG4gICAgcmV0dXJuICR0cnV0aHkoKGxocylbJyQ9PT0nXShyaHMpKTtcbiAgfTtcbiAgT3BhbC5uZXFlcSA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XG4gICAgaWYgKCh0eXBlb2YgbGhzID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcmhzID09PSAnbnVtYmVyJykgfHxcbiAgICAgICAgKHR5cGVvZiBsaHMgPT09ICdzdHJpbmcnICYmIHR5cGVvZiByaHMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuIGxocyAhPT0gcmhzO1xuICAgIH1cbiAgICByZXR1cm4gJHRydXRoeSgobGhzKVsnJCE9J10ocmhzKSk7XG4gIH07XG4gIE9wYWwubm90ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHRydWUgPT09IGFyZykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh1bmRlZmluZWQgPT09IGFyZyB8fCBudWxsID09PSBhcmcgfHwgZmFsc2UgPT09IGFyZyB8fCBuaWwgPT09IGFyZykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuICR0cnV0aHkoYXJnWyckISddKCkpO1xuICB9XG5cblxuXG4gIC8vIEluaXRpYWxpemF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIE9wYWwuQmFzaWNPYmplY3QgPSBCYXNpY09iamVjdCA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ0Jhc2ljT2JqZWN0JywgbnVsbCk7XG4gIE9wYWwuT2JqZWN0ICAgICAgPSBfT2JqZWN0ICAgICA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ09iamVjdCcsIE9wYWwuQmFzaWNPYmplY3QpO1xuICBPcGFsLk1vZHVsZSAgICAgID0gTW9kdWxlICAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdNb2R1bGUnLCBPcGFsLk9iamVjdCk7XG4gIE9wYWwuQ2xhc3MgICAgICAgPSBDbGFzcyAgICAgICA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ0NsYXNzJywgT3BhbC5Nb2R1bGUpO1xuICBPcGFsLk9wYWwgICAgICAgID0gX09wYWwgICAgICAgPSBPcGFsLmFsbG9jYXRlX21vZHVsZSgnT3BhbCcpO1xuICBPcGFsLktlcm5lbCAgICAgID0gS2VybmVsICAgICAgPSBPcGFsLmFsbG9jYXRlX21vZHVsZSgnS2VybmVsJyk7XG5cbiAgJHNldF9wcm90byhPcGFsLkJhc2ljT2JqZWN0LCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLk9iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5Nb2R1bGUsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuQ2xhc3MsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gIC8vIEJhc2ljT2JqZWN0IGNhbiByZWFjaCBpdHNlbGYsIGF2b2lkIGNvbnN0X3NldCB0byBza2lwIHRoZSAkJGJhc2VfbW9kdWxlIGxvZ2ljXG4gIEJhc2ljT2JqZWN0LiQkY29uc3RbXCJCYXNpY09iamVjdFwiXSA9IEJhc2ljT2JqZWN0O1xuXG4gIC8vIEFzc2lnbiBiYXNpYyBjb25zdGFudHNcbiAgJGNvbnN0X3NldChfT2JqZWN0LCBcIkJhc2ljT2JqZWN0XCIsICBCYXNpY09iamVjdCk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJPYmplY3RcIiwgICAgICAgX09iamVjdCk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJNb2R1bGVcIiwgICAgICAgTW9kdWxlKTtcbiAgJGNvbnN0X3NldChfT2JqZWN0LCBcIkNsYXNzXCIsICAgICAgICBDbGFzcyk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJPcGFsXCIsICAgICAgICAgX09wYWwpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiS2VybmVsXCIsICAgICAgIEtlcm5lbCk7XG5cbiAgLy8gRml4IGJvb3RlZCBjbGFzc2VzIHRvIGhhdmUgY29ycmVjdCAuY2xhc3MgdmFsdWVcbiAgQmFzaWNPYmplY3QuJCRjbGFzcyA9IENsYXNzO1xuICBfT2JqZWN0LiQkY2xhc3MgICAgID0gQ2xhc3M7XG4gIE1vZHVsZS4kJGNsYXNzICAgICAgPSBDbGFzcztcbiAgQ2xhc3MuJCRjbGFzcyAgICAgICA9IENsYXNzO1xuICBfT3BhbC4kJGNsYXNzICAgICAgID0gTW9kdWxlO1xuICBLZXJuZWwuJCRjbGFzcyAgICAgID0gTW9kdWxlO1xuXG4gIC8vIEZvcndhcmQgLnRvU3RyaW5nKCkgdG8gI3RvX3NcbiAgJHByb3AoX09iamVjdC4kJHByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvX3MgPSB0aGlzLiR0b19zKCk7XG4gICAgaWYgKHRvX3MuJCRpc19zdHJpbmcgJiYgdHlwZW9mKHRvX3MpID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gYSBzdHJpbmcgY3JlYXRlZCB1c2luZyBuZXcgU3RyaW5nKCdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRvX3MudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9fcztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ha2UgS2VybmVsI3JlcXVpcmUgaW1tZWRpYXRlbHkgYXZhaWxhYmxlIGFzIGl0J3MgbmVlZGVkIHRvIHJlcXVpcmUgYWxsIHRoZVxuICAvLyBvdGhlciBjb3JlbGliIGZpbGVzLlxuICAkcHJvcChfT2JqZWN0LiQkcHJvdG90eXBlLCAnJHJlcXVpcmUnLCBPcGFsLnJlcXVpcmUpO1xuXG4gIC8vIEluc3RhbnRpYXRlIHRoZSBtYWluIG9iamVjdFxuICBPcGFsLnRvcCA9IG5ldyBfT2JqZWN0KCk7XG4gIE9wYWwudG9wLiR0b19zID0gT3BhbC50b3AuJGluc3BlY3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdtYWluJyB9O1xuICBPcGFsLnRvcC4kZGVmaW5lX21ldGhvZCA9IHRvcF9kZWZpbmVfbWV0aG9kO1xuXG4gIC8vIEZvd2FyZCBjYWxscyB0byBkZWZpbmVfbWV0aG9kIG9uIHRoZSB0b3Agb2JqZWN0IHRvIE9iamVjdFxuICBmdW5jdGlvbiB0b3BfZGVmaW5lX21ldGhvZCgpIHtcbiAgICB2YXIgYXJncyA9IE9wYWwuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBibG9jayA9IHRvcF9kZWZpbmVfbWV0aG9kLiQkcDtcbiAgICBkZWxldGUgdG9wX2RlZmluZV9tZXRob2QuJCRwO1xuICAgIHJldHVybiBPcGFsLnNlbmQoX09iamVjdCwgJ2RlZmluZV9tZXRob2QnLCBhcmdzLCBibG9jaylcbiAgfTtcblxuICAvLyBOaWxcbiAgT3BhbC5OaWxDbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ05pbENsYXNzJywgT3BhbC5PYmplY3QpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsICdOaWxDbGFzcycsIE9wYWwuTmlsQ2xhc3MpO1xuICBuaWwgPSBPcGFsLm5pbCA9IG5ldyBPcGFsLk5pbENsYXNzKCk7XG4gIG5pbC4kJGlkID0gbmlsX2lkO1xuICBuaWwuY2FsbCA9IG5pbC5hcHBseSA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBPcGFsLkxvY2FsSnVtcEVycm9yLiRuZXcoJ25vIGJsb2NrIGdpdmVuJyk7IH07XG5cbiAgLy8gRXJyb3JzXG4gIE9wYWwuYnJlYWtlciAgPSBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJlYWsgKG9sZCknKTtcbiAgT3BhbC5yZXR1cm5lciA9IG5ldyBFcnJvcigndW5leHBlY3RlZCByZXR1cm4nKTtcbiAgVHlwZUVycm9yLiQkc3VwZXIgPSBFcnJvcjtcbn0pLmNhbGwodGhpcyk7XG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3J1bnRpbWUuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUU7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7O0FBRUY7QUFDRTs7QUFFRjtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUY7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUU7QUFDRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUU7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRDtBQUNIO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDVTtBQUNBO0FBQ0E7QUFDQTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNFO0FBQ0U7QUFDQTtBQUNGOztBQUVGO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0k7QUFDRjtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDSTtBQUNGO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNJO0FBQ0Y7QUFDRjtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNBIn19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4ODIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2hlbHBlcnMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0eXBlX2Vycm9yLCBjb2VyY2VfdG9cblxubW9kdWxlIDo6T3BhbFxuICBkZWYgc2VsZi5icmlkZ2UoY29uc3RydWN0b3IsIGtsYXNzKVxuICAgIGBPcGFsLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpYFxuICBlbmRcblxuICBkZWYgc2VsZi5jb2VyY2VfdG8hKG9iamVjdCwgdHlwZSwgbWV0aG9kLCAqYXJncylcbiAgICBjb2VyY2VkID0gYCRjb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGFyZ3MpYFxuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZClgXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvZXJjZV90bz8ob2JqZWN0LCB0eXBlLCBtZXRob2QsICphcmdzKVxuICAgIHJldHVybiB1bmxlc3Mgb2JqZWN0LnJlc3BvbmRfdG8/IG1ldGhvZFxuXG4gICAgY29lcmNlZCA9IGAkY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKWBcblxuICAgIHJldHVybiBpZiBjb2VyY2VkLm5pbD9cblxuICAgIHVubGVzcyB0eXBlID09PSBjb2VyY2VkXG4gICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpYFxuICAgIGVuZFxuXG4gICAgY29lcmNlZFxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydChvYmplY3QsIHR5cGUsIG1ldGhvZClcbiAgICByZXR1cm4gb2JqZWN0IGlmIHR5cGUgPT09IG9iamVjdFxuXG4gICAgaWYgb2JqZWN0LnJlc3BvbmRfdG8/IG1ldGhvZFxuICAgICAgb2JqZWN0Ll9fc2VuZF9fIG1ldGhvZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5jb21wYXJlKGEsIGIpXG4gICAgY29tcGFyZSA9IGEgPD0+IGJcblxuICAgIGlmIGBjb21wYXJlID09PSBuaWxgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2EuY2xhc3N9IHdpdGggI3tiLmNsYXNzfSBmYWlsZWRcIlxuICAgIGVuZFxuXG4gICAgY29tcGFyZVxuICBlbmRcblxuICBkZWYgc2VsZi5kZXN0cnVjdHVyZShhcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmdzLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3NbaV07IH1cblxuICAgICAgICByZXR1cm4gYXJnc19hcnk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yZXNwb25kX3RvPyhvYmosIG1ldGhvZCwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iai5yZXNwb25kX3RvPyhtZXRob2QsIGluY2x1ZGVfYWxsKVxuICBlbmRcblxuICBkZWYgc2VsZi5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgIG5hbWUgPSA6Ok9wYWwuY29lcmNlX3RvIShuYW1lLCA6OlN0cmluZywgOnRvX3N0cilcblxuICAgIHVubGVzcyBgL15AW2EtekEtWl9dW2EtekEtWjAtOV9dKj8kLy50ZXN0KG5hbWUpYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwiJyN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmNvZXJjZV90byEobmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpXG5cbiAgICBpZiBgbmFtZS5sZW5ndGggPCAzIHx8IG5hbWUuc2xpY2UoMCwyKSAhPT0gJ0BAJ2BcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcImAje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZT8oY29uc3RfbmFtZSlcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2YgY29uc3RfbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgI3tjb25zdF9uYW1lID0gOjpPcGFsLmNvZXJjZV90byEoY29uc3RfbmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tjb25zdF9uYW1lfVswXSA9PT0gI3tjb25zdF9uYW1lfVswXS50b1VwcGVyQ2FzZSgpXG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdF9uYW1lIShjb25zdF9uYW1lKVxuICAgIGNvbnN0X25hbWUgPSA6Ok9wYWwuY29lcmNlX3RvIShjb25zdF9uYW1lLCA6OlN0cmluZywgOnRvX3N0cikgaWYgZGVmaW5lZD8gOjpTdHJpbmdcblxuICAgICV4e1xuICAgICAgaWYgKCFjb25zdF9uYW1lIHx8IGNvbnN0X25hbWVbMF0gIT0gY29uc3RfbmFtZVswXS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICN7cmFpc2UgOjpOYW1lRXJyb3IsIFwid3JvbmcgY29uc3RhbnQgbmFtZSAje2NvbnN0X25hbWV9XCJ9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RfbmFtZVxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gICMgTWFyayBzb21lIG1ldGhvZHMgYXMgcHJpc3RpbmUgaW4gb3JkZXIgdG8gYXBwbHkgb3B0aW1pemF0aW9ucyB3aGVuIHRoZXlcbiAgIyBhcmUgc3RpbGwgaW4gdGhlaXIgb3JpZ2luYWwgZm9ybS4gVGhpcyBjb3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0b1xuICAjIHRoZSBgT3BhbC5kZWYoKWAgSlMgQVBJLCBidXQgZm9yIG5vdyBpdCB3aWxsIHN0YXkgbWFudWFsLlxuICAjXG4gICMgQGV4YW1wbGVcbiAgI1xuICAjICAgT3BhbC5wcmlzdGluZSBBcnJheSwgOmFsbG9jYXRlLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuICAjXG4gICMgICBjbGFzcyBBcnJheVxuICAjICAgICBkZWYgZHVwXG4gICMgICAgICAgJXh7XG4gICMgICAgICAgICBpZiAoXG4gICMgICAgICAgICAgIHNlbGYuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kY29weV9pbnN0YW5jZV92YXJpYWJsZXMuJCRwcmlzdGluZSAmJlxuICAjICAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lXG4gICMgICAgICAgICApIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAjICAgICAgIH1cbiAgI1xuICAjICAgICAgIHN1cGVyXG4gICMgICAgIGVuZFxuICAjICAgZW5kXG4gICNcbiAgIyBAcGFyYW0gb3duZXJfY2xhc3MgW0NsYXNzXSB0aGUgY2xhc3Mgb3duaW5nIHRoZSBtZXRob2RzXG4gICMgQHBhcmFtIG1ldGhvZF9uYW1lcyBbQXJyYXk8U3ltYm9sPl0gdGhlIGxpc3Qgb2YgbWV0aG9kcyBuYW1lcyB0byBtYXJrXG4gICMgQHJldHVybiBbbmlsXVxuICBkZWYgc2VsZi5wcmlzdGluZShvd25lcl9jbGFzcywgKm1ldGhvZF9uYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBtZXRob2RfbmFtZSwgbWV0aG9kO1xuICAgICAgZm9yICh2YXIgaSA9IG1ldGhvZF9uYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZXRob2RfbmFtZSA9IG1ldGhvZF9uYW1lc1tpXTtcbiAgICAgICAgbWV0aG9kID0gb3duZXJfY2xhc3MuJCRwcm90b3R5cGVbJyQnK21ldGhvZF9uYW1lXTtcblxuICAgICAgICBpZiAobWV0aG9kICYmICFtZXRob2QuJCRzdHViKSB7XG4gICAgICAgICAgbWV0aG9kLiQkcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5pbFxuICBlbmRcblxuICBgdmFyIGluc3BlY3Rfc3RhY2sgPSBbXWBcblxuICAjIFBlcmZvcm1zIGEgc2FmZSBjYWxsIHRvIGluc3BlY3QgZm9yIGFueSB2YWx1ZSwgd2hldGhlclxuICAjIG5hdGl2ZSBvciBPcGFsLXdyYXBwZWQuXG4gICNcbiAgIyBAcGFyYW0gdmFsdWUgW09iamVjdF1cbiAgIyBAcmV0dXJuIFtTdHJpbmddXG4gIGRlZiBzZWxmLmluc3BlY3QodmFsdWUgPSB1bmRlZmluZWQpXG4gICAgYHZhciBwdXNoZWQgPSBmYWxzZWBcbiAgICBiZWdpblxuICAgICAgJXh7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEpTIG51bGwgdmFsdWVcbiAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBKUyB1bmRlZmluZWQgdmFsdWVcbiAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlLiQkY2xhc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gSlMgb2JqZWN0IC8gb3RoZXIgdmFsdWUgdGhhdCBpcyBub3QgYnJpZGdlZFxuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuJGluc3BlY3QgIT09ICdmdW5jdGlvbicgfHwgdmFsdWUuJGluc3BlY3QuJCRzdHViKSB7XG4gICAgICAgICAgLy8gQmFzaWNPYmplY3QgYW5kIGZyaWVuZHNcbiAgICAgICAgICByZXR1cm4gI3tcIiM8I3tgdmFsdWUuJCRjbGFzc2B9OjB4I3t2YWx1ZS5fX2lkX18udG9fcygxNil9PlwifVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluc3BlY3Rfc3RhY2suaW5kZXhPZigje3ZhbHVlLl9faWRfX30pICE9PSAtMSkge1xuICAgICAgICAgIC8vIGluc3BlY3QgcmVjdXJzaW5nIGluc2lkZSBpbnNwZWN0IHRvIGZpbmQgb3V0IGFib3V0IHRoZVxuICAgICAgICAgIC8vIHNhbWUgb2JqZWN0XG4gICAgICAgICAgcmV0dXJuICN7XCIjPCN7YHZhbHVlLiQkY2xhc3NgfToweCN7dmFsdWUuX19pZF9fLnRvX3MoMTYpfT5cIn1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBhbnl0aGluZyBzdXBwb3J0aW5nIE9wYWxcbiAgICAgICAgICBpbnNwZWN0X3N0YWNrLnB1c2goI3t2YWx1ZS5fX2lkX199KTtcbiAgICAgICAgICBwdXNoZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB2YWx1ZS4kaW5zcGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuaWxcbiAgICByZXNjdWUgOjpFeGNlcHRpb24gPT4gZSAjIHJ1Ym9jb3A6ZGlzYWJsZSBMaW50L1Jlc2N1ZUV4Y2VwdGlvblxuICAgICAgXCIjPCN7YHZhbHVlLiQkY2xhc3NgfToweCN7dmFsdWUuX19pZF9fLnRvX3MoMTYpfT5cIlxuICAgIGVuc3VyZVxuICAgICAgYGlmIChwdXNoZWQpIGluc3BlY3Rfc3RhY2sucG9wKClgXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6T3BhbD4iLCJicmlkZ2UiLCJzZWxmIiwiY29uc3RydWN0b3IiLCJrbGFzcyIsImNvZXJjZV90byEiLCJvYmplY3QiLCJ0eXBlIiwibWV0aG9kIiwiY29lcmNlZCIsIktlcm5lbCIsInJhaXNlIiwiY29lcmNlX3RvPyIsInJlc3BvbmRfdG8/IiwibmlsPyIsInRyeV9jb252ZXJ0IiwiX19zZW5kX18iLCJjb21wYXJlIiwiYSIsImIiLCI8PT4iLCJBcmd1bWVudEVycm9yIiwiY2xhc3MiLCJkZXN0cnVjdHVyZSIsImFyZ3MiLCJvYmoiLCJpbmNsdWRlX2FsbCIsImluc3RhbmNlX3ZhcmlhYmxlX25hbWUhIiwibmFtZSIsIk9wYWwiLCJTdHJpbmciLCJOYW1lRXJyb3IiLCJuZXciLCJjbGFzc192YXJpYWJsZV9uYW1lISIsImNvbnN0X25hbWU/IiwiY29uc3RfbmFtZSIsImNvbnN0X25hbWUhIiwicHJpc3RpbmUiLCJvd25lcl9jbGFzcyIsImluc3BlY3QiLCJ2YWx1ZSIsIl9faWRfXyIsInRvX3MiLCIxNiIsIkV4Y2VwdGlvbiIsImUiXSwibWFwcGluZ3MiOiJBQUFBQSxrREFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOzs7O0lBQ0VDLE1BQUlDLElBQUpELGFBQUFBLGtCQUFnQkUsV0FBRCxFQUFjQyxLQUE3Qkg7QUFBQUE7TUFDRUEsT0FBQ0EsK0JBQURBO0lBREZBLENBQUFBLEdBQUFBO0lBSUFJLE1BQUlILElBQUpHLGlCQUFBQSxnQ0FBb0JDLE1BQUQsRUFBU0MsSUFBVCxFQUFlQyxNQUFmLEVBUHJCLEVBT0VIO0FBQUFBLE1BQUFBOzs7O01BUEY7O01BTzRDO01BQ3hDSSxVQUFXSjtNQUVYLEtBQUEsUUFBT0UsSUFBUCxFQUFnQkUsT0FBaEIsQ0FBQTtRQUNFQyxPQUFRQyxPQUFBQSxDQUFRTiwwQ0FBUk07TUFEVjtNQUlBTixPQUFBSTtJQVBGSixDQUFBQSxJQUFBQTtJQVVBTyxNQUFJVixJQUFKVSxpQkFBQUEsZ0NBQW9CTixNQUFELEVBQVNDLElBQVQsRUFBZUMsTUFBZixFQWpCckIsRUFpQkVJO0FBQUFBLE1BQUFBOzs7O01BakJGOztNQWlCNEM7TUFDeEMsS0FBQSxRQUFjTixNQUFNTyxnQkFBQUEs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QTtBQUNBQTtBQUNBQSxpQkFBb0JBLElBQUQsR0FBQSxDQUFNQSxhQUFOLENBQUEsR0FBcUJBLEtBQXJCLEdBQUEsQ0FBMEJDLEtBQUtDLFFBQUFBLENBQUFBLENBQU9DLE1BQUFBLENBQU1DLEVBQU5ELENBQXRDLENBQUEsR0FBZ0RIO0FBQ25FQTtBQUNBQTtBQUNBQTtBQUNBQSw2QkFBK0JDLEtBQUtDLFFBQUFBLENBQUFBLENBQVFGO0FBQzVDQTtBQUNBQTtBQUNBQTtBQUNBQTtRQUNNQSxPQUFBO01BN0JBO1FBOEJGLHNCQUFPLENBQUFLLGdCQUFBLENBQVAsSUFBc0JDLENBQUFBLElBQXRCLElBQXNCQTtVQUF0QjtZQUNFTixPQUFDQSxJQUFELEdBQUEsQ0FBTUEsYUFBTixDQUFBLEdBQXFCQSxLQUFyQixHQUFBLENBQTBCQyxLQUFLQyxRQUFBQSxDQUFBQSxDQUFPQyxNQUFBQSxDQUFNQyxFQUFORCxDQUF0QyxDQUFBLEdBQWdESDtVQURsRDtRQUFBLENBOUJFO01BQUE7TUFBQTtRQWlDQ0E7TUFqQ0QsQ0FBQTtJQUhKQSxDQUFBQSxJQUFBQTtFQXBLRnZDLEdBQU8sSUFBUEE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwOTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21vZHVsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCBjb25zdF9zZXQsIE9iamVjdFxuXG5jbGFzcyA6Ok1vZHVsZVxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIG1vZHVsZSA9IE9wYWwuYWxsb2NhdGVfbW9kdWxlKG5pbCwgZnVuY3Rpb24oKXt9KTtcbiAgICAgIC8vIExpbmsgdGhlIHByb3RvdHlwZSBvZiBNb2R1bGUgc3ViY2xhc3Nlc1xuICAgICAgaWYgKHNlbGYgIT09IE9wYWwuTW9kdWxlKSBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kdWxlLCBzZWxmLiQkcHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgbW9kdWxlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cbiAgZW5kXG5cbiAgZGVmID09PShvYmplY3QpXG4gICAgcmV0dXJuIGZhbHNlIGlmIGBvYmplY3QgPT0gbnVsbGBcblxuICAgIGBPcGFsLmlzX2Eob2JqZWN0LCBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgdW5sZXNzIDo6TW9kdWxlID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdjb21wYXJlZCB3aXRoIG5vbiBjbGFzcy9tb2R1bGUnXG4gICAgZW5kXG5cbiAgICAjIGNsYXNzIGNhbm5vdCBiZSBhIGRlc2NlbmRhbnQgb2YgaXRzZWxmXG4gICAgJXh7XG4gICAgICB2YXIgd29ya2luZyA9IHNlbGYsXG4gICAgICAgICAgYW5jZXN0b3JzLFxuICAgICAgICAgIGksIGxlbmd0aDtcblxuICAgICAgaWYgKHdvcmtpbmcgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoc2VsZiksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBvdGhlcikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG90aGVyKSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBlcXVhbD8ob3RoZXIpIHx8IHNlbGYgPCBvdGhlclxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICB1bmxlc3MgOjpNb2R1bGUgPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcbiAgICBlbmRcblxuICAgIG90aGVyIDwgc2VsZlxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmID4gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgOjpNb2R1bGUgPT09IG90aGVyXG4gICAgICByZXR1cm4gbmlsXG4gICAgZW5kXG5cbiAgICBsdCA9IHNlbGYgPCBvdGhlclxuICAgIHJldHVybiBuaWwgaWYgbHQubmlsP1xuICAgIGx0ID8gLTEgOiAxXG4gIGVuZFxuXG4gIGRlZiBhbGlhc19tZXRob2QobmV3bmFtZSwgb2xkbmFtZSlcbiAgICBuZXduYW1lID0gYCRjb2VyY2VfdG8obmV3bmFtZSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcbiAgICBvbGRuYW1lID0gYCRjb2VyY2VfdG8ob2xkbmFtZSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcbiAgICBgT3BhbC5hbGlhcyhzZWxmLCBuZXduYW1lLCBvbGRuYW1lKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFsaWFzX25hdGl2ZShtaWQsIGpzaWQgPSBtaWQpXG4gICAgYE9wYWwuYWxpYXNfbmF0aXZlKHNlbGYsIG1pZCwganNpZClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbmNlc3RvcnNcbiAgICBgT3BhbC5hbmNlc3RvcnMoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhcHBlbmRfZmVhdHVyZXMoaW5jbHVkZXIpXG4gICAgYE9wYWwuYXBwZW5kX2ZlYXR1cmVzKHNlbGYsIGluY2x1ZGVyKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhdHRyX2FjY2Vzc29yKCpuYW1lcylcbiAgICBhdHRyX3JlYWRlcigqbmFtZXMpXG4gICAgYXR0cl93cml0ZXIoKm5hbWVzKVxuICBlbmRcblxuICBkZWYgYXR0cigqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyICYmIChhcmdzWzFdID09PSB0cnVlIHx8IGFyZ3NbMV0gPT09IGZhbHNlKSkge1xuICAgICAgICAje3dhcm4gJ29wdGlvbmFsIGJvb2xlYW4gYXJndW1lbnQgaXMgb2Jzb2xldGVkJywgdXBsZXZlbDogMX1cblxuICAgICAgICBhcmdzWzFdID8gI3thdHRyX2FjY2Vzc29yKGBhcmdzWzBdYCl9IDogI3thdHRyX3JlYWRlcihgYXJnc1swXWApfTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyX3JlYWRlcigqYXJncylcbiAgZW5kXG5cbiAgZGVmIGF0dHJfcmVhZGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICckJyArIG5hbWUsXG4gICAgICAgICAgICBpdmFyID0gT3BhbC5pdmFyKG5hbWUpO1xuXG4gICAgICAgIC8vIHRoZSBjbG9zdXJlIGhlcmUgaXMgbmVlZGVkIGJlY2F1c2UgbmFtZSB3aWxsIGNoYW5nZSBhdCB0aGUgbmV4dFxuICAgICAgICAvLyBjeWNsZSwgSSB3aXNoIHdlIGNvdWxkIHVzZSBsZXQuXG4gICAgICAgIHZhciBib2R5ID0gKGZ1bmN0aW9uKGl2YXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpdmFyXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaXZhcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoaXZhcik7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwucHJvcChwcm90bywgaXZhciwgbmlsKTtcblxuICAgICAgICBib2R5LiQkcGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBib2R5LiQkYXJpdHkgPSAwO1xuXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBhdHRyX3dyaXRlcigqbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvdG8gPSBzZWxmLiQkcHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXSxcbiAgICAgICAgICAgIGlkICAgPSAnJCcgKyBuYW1lICsgJz0nLFxuICAgICAgICAgICAgaXZhciA9IE9wYWwuaXZhcihuYW1lKTtcblxuICAgICAgICAvLyB0aGUgY2xvc3VyZSBoZXJlIGlzIG5lZWRlZCBiZWNhdXNlIG5hbWUgd2lsbCBjaGFuZ2UgYXQgdGhlIG5leHRcbiAgICAgICAgLy8gY3ljbGUsIEkgd2lzaCB3ZSBjb3VsZCB1c2UgbGV0LlxuICAgICAgICB2YXIgYm9keSA9IChmdW5jdGlvbihpdmFyKXtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2l2YXJdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KShpdmFyKTtcblxuICAgICAgICBib2R5LiQkcGFyYW1ldGVycyA9IFtbJ3JlcSddXTtcbiAgICAgICAgYm9keS4kJGFyaXR5ID0gMTtcblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBpbnN0YW5jZSB2YXJpYWJsZSBhcyBuaWxcbiAgICAgICAgT3BhbC5wcm9wKHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZChjb25zdCwgcGF0aClcbiAgICAleHtcbiAgICAgIGlmICghI3tPcGFsLmNvbnN0X25hbWU/KGNvbnN0KX0pIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvciwgXCJhdXRvbG9hZCBtdXN0IGJlIGNvbnN0YW50IG5hbWU6ICN7Y29uc3R9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoID09IFwiXCIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdlbXB0eSBmaWxlIG5hbWUnfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuJCRjb25zdC5oYXNPd25Qcm9wZXJ0eSgje2NvbnN0fSkpIHtcbiAgICAgICAgaWYgKCFzZWxmLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgICBzZWxmLiQkYXV0b2xvYWQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgICAgICAgc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XSA9IHsgcGF0aDogI3twYXRofSwgbG9hZGVkOiBmYWxzZSwgcmVxdWlyZWQ6IGZhbHNlLCBzdWNjZXNzOiBmYWxzZSwgZXhjZXB0aW9uOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZD8oY29uc3QpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGF1dG9sb2FkICYmIHNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0gJiYgIXNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0ucmVxdWlyZWQgJiYgIXNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0uc3VjY2Vzcykge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XS5wYXRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5jZXN0b3JzID0gc2VsZi4kYW5jZXN0b3JzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkICYmIGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkWyN7Y29uc3R9XSAmJiAhYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dLnJlcXVpcmVkICYmICFhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFsje2NvbnN0fV0uc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiBhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFsje2NvbnN0fV0ucGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZXNcbiAgICBgT2JqZWN0LmtleXMoT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikpYFxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVfZ2V0KG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0KHNlbGYsIG5hbWUsIGZhbHNlKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX3NldChuYW1lLCB2YWx1ZSlcbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZV9zZXQoc2VsZiwgbmFtZSwgdmFsdWUpYFxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVfZGVmaW5lZD8obmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikuaGFzT3duUHJvcGVydHkobmFtZSlgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY2xhc3NfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZi4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIGRlbGV0ZSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwiY2Fubm90IHJlbW92ZSAje25hbWV9IGZvciAje3NlbGZ9XCJ9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RhbnRzKGluaGVyaXQgPSB0cnVlKVxuICAgIGBPcGFsLmNvbnN0YW50cyhzZWxmLCBpbmhlcml0KWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RhbnRzKGluaGVyaXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoaW5oZXJpdCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBuZXN0aW5nID0gKHNlbGYuJCRuZXN0aW5nIHx8IFtdKS5jb25jYXQoJE9iamVjdCksXG4gICAgICAgICAgICBjb25zdGFudCwgY29uc3RhbnRzID0ge30sXG4gICAgICAgICAgICBpLCBpaTtcblxuICAgICAgICBmb3IoaSA9IDAsIGlpID0gbmVzdGluZy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgZm9yIChjb25zdGFudCBpbiBuZXN0aW5nW2ldLiQkY29uc3QpIHtcbiAgICAgICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLmNvbnN0YW50cyhzZWxmLCBpbmhlcml0KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubmVzdGluZ1xuICAgIGBzZWxmLiQkbmVzdGluZyB8fCBbXWBcbiAgZW5kXG5cbiAgIyBjaGVjayBmb3IgY29uc3RhbnQgd2l0aGluIGN1cnJlbnQgc2NvcGVcbiAgIyBpZiBpbmhlcml0IGlzIHRydWUgb3Igc2VsZiBpcyBPYmplY3QsIHdpbGwgYWxzbyBjaGVjayBhbmNlc3RvcnNcbiAgZGVmIGNvbnN0X2RlZmluZWQ/KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gOjpPcGFsOjpDT05TVF9OQU1FX1JFR0VYUFxuXG4gICAgJXh7XG4gICAgICB2YXIgbW9kdWxlLCBtb2R1bGVzID0gW3NlbGZdLCBtb2R1bGVfY29uc3RhbnRzLCBpLCBpaTtcblxuICAgICAgLy8gQWRkIHVwIGFuY2VzdG9ycyBpZiBpbmhlcml0IGlzIHRydWVcbiAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChPcGFsLmFuY2VzdG9ycyhzZWxmKSk7XG5cbiAgICAgICAgLy8gQWRkIE9iamVjdCdzIGFuY2VzdG9ycyBpZiBpdCdzIGEgbW9kdWxlIOKAkyBtb2R1bGVzIGhhdmUgbm8gYW5jZXN0b3JzIG90aGVyd2lzZVxuICAgICAgICBpZiAoc2VsZi4kJGlzX21vZHVsZSkge1xuICAgICAgICAgIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbJE9iamVjdF0pLmNvbmNhdChPcGFsLmFuY2VzdG9ycygkT2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kdWxlID0gbW9kdWxlc1tpXTtcbiAgICAgICAgaWYgKG1vZHVsZS4kJGNvbnN0WyN7bmFtZX1dICE9IG51bGwpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1vZHVsZS4kJGF1dG9sb2FkICYmXG4gICAgICAgICAgbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0gJiZcbiAgICAgICAgICAhbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0ucmVxdWlyZWQgJiZcbiAgICAgICAgICAhbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0uc3VjY2Vzc1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfZ2V0KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChuYW1lLmluZGV4T2YoJzo6JykgPT09IDAgJiYgbmFtZSAhPT0gJzo6Jyl7XG4gICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBuYW1lLmluZGV4T2YoJzo6JykgIT0gLTEgJiYgbmFtZSAhPSAnOjonYFxuICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJzo6JykuaW5qZWN0KHNlbGYpIHsgfG8sIGN8IG8uY29uc3RfZ2V0KGMpIH1cbiAgICBlbmRcblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKSB1bmxlc3MgbmFtZSA9fiA6Ok9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgIHJldHVybiBPcGFsLiQkKFtzZWxmXSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfbG9jYWwoc2VsZiwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfbWlzc2luZyhuYW1lKVxuICAgIGZ1bGxfY29uc3RfbmFtZSA9IHNlbGYgPT0gOjpPYmplY3QgPyBuYW1lIDogXCIje3NlbGZ9Ojoje25hbWV9XCJcblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcInVuaW5pdGlhbGl6ZWQgY29uc3RhbnQgI3tmdWxsX2NvbnN0X25hbWV9XCIsIG5hbWUpXG4gIGVuZFxuXG4gIGRlZiBjb25zdF9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IDo6T3BhbC5jb25zdF9uYW1lIShuYW1lKVxuXG4gICAgaWYgbmFtZSAhfiA6Ok9wYWw6OkNPTlNUX05BTUVfUkVHRVhQIHx8IG5hbWUuc3RhcnRfd2l0aD8oJzo6JylcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKVxuICAgIGVuZFxuXG4gICAgYCRjb25zdF9zZXQoc2VsZiwgbmFtZSwgdmFsdWUpYFxuXG4gICAgdmFsdWVcbiAgZW5kXG5cbiAgZGVmIHB1YmxpY19jb25zdGFudChjb25zdF9uYW1lKVxuICBlbmRcblxuICBkZWYgZGVmaW5lX21ldGhvZChuYW1lLCBtZXRob2QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsKVxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNyZWF0ZSBhIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jayd9XG4gICAgfVxuXG4gICAgYmxvY2sgfHw9IGNhc2UgbWV0aG9kXG4gICAgICAgICAgICAgIHdoZW4gOjpQcm9jXG4gICAgICAgICAgICAgICAgbWV0aG9kXG5cbiAgICAgICAgICAgICAgd2hlbiA6Ok1ldGhvZFxuICAgICAgICAgICAgICAgIGAje21ldGhvZC50b19wcm9jfS4kJHVuYm91bmRgXG5cbiAgICAgICAgICAgICAgd2hlbiA6OlVuYm91bmRNZXRob2RcbiAgICAgICAgICAgICAgICAtPigqYXJncykge1xuICAgICAgICAgICAgICAgICAgYm91bmQgPSBtZXRob2QuYmluZChzZWxmKVxuICAgICAgICAgICAgICAgICAgYm91bmQuY2FsbCgqYXJncylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tibG9jay5jbGFzc30gKGV4cGVjdGVkIFByb2MvTWV0aG9kKVwiXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgaWQgPSAnJCcgKyBuYW1lO1xuXG4gICAgICBibG9jay4kJGpzaWQgICAgICAgID0gbmFtZTtcbiAgICAgIGJsb2NrLiQkcyAgICAgICAgICAgPSBudWxsO1xuICAgICAgYmxvY2suJCRkZWYgICAgICAgICA9IGJsb2NrO1xuICAgICAgYmxvY2suJCRkZWZpbmVfbWV0aCA9IHRydWU7XG5cbiAgICAgIHJldHVybiBPcGFsLmRlZm4oc2VsZiwgaWQsIGJsb2NrKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfbWV0aG9kKCpuYW1lcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBPcGFsLnJkZWYoc2VsZiwgXCIkXCIgKyBuYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzP1xuICAgIGAhIXNlbGYuJCRpc19zaW5nbGV0b25gXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlKCptb2RzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5pbmNsdWRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZF9tb2R1bGVzXG4gICAgYE9wYWwuaW5jbHVkZWRfbW9kdWxlcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1vZClcbiAgICAleHtcbiAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGlpLCBtb2QyLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhzZWxmKTtcblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBtb2QyID0gYW5jZXN0b3JzW2ldO1xuICAgICAgICBpZiAobW9kMiA9PT0gbW9kICYmIG1vZDIgIT09IHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aCA9IHNlbGYuJCRwcm90b3R5cGVbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICghbWV0aCB8fCBtZXRoLiQkc3R1Yikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLm5hbWV9J1wiLCBuYW1lKX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAjezo6VW5ib3VuZE1ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGZ9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kcyhpbmNsdWRlX3N1cGVyID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7aW5jbHVkZV9zdXBlcn0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiBleHRlbmRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiBleHRlbmRfb2JqZWN0KG9iamVjdClcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3JlbW92ZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF91bmRlZmluZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7bmV3IEZ1bmN0aW9uKFwiT3BhbCxzZWxmXCIsIFwicmV0dXJuIFwiICsgY29tcGlsZWQpKE9wYWwsIHNlbGYpfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLnNpemV9IGZvciAwKVwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXFxuICBOT1RFOklmIHlvdSB3YW50IHRvIGVuYWJsZSBwYXNzaW5nIGEgU3RyaW5nIGFyZ3VtZW50IHBsZWFzZSBhZGQgXFxcInJlcXVpcmUgJ29wYWwtcGFyc2VyJ1xcXCIgdG8geW91ciBzY3JpcHRcXG5cIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIFtzZWxmXSk7XG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2V4ZWMoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJ31cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfZGVmaW5lZD8obWV0aG9kKVxuICAgICV4e1xuICAgICAgdmFyIGJvZHkgPSBzZWxmLiQkcHJvdG90eXBlWyckJyArIG1ldGhvZF07XG4gICAgICByZXR1cm4gKCEhYm9keSkgJiYgIWJvZHkuJCRzdHViO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9mdW5jdGlvbigqbWV0aG9kcylcbiAgICAleHtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtZXRoID0gbWV0aG9kc1tpXSxcbiAgICAgICAgICAgICAgaWQgICA9ICckJyArIG1ldGgsXG4gICAgICAgICAgICAgIGZ1bmMgPSBzZWxmLiQkcHJvdG90eXBlW2lkXTtcblxuICAgICAgICAgIE9wYWwuZGVmcyhzZWxmLCBpZCwgZnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZHMubGVuZ3RoID09PSAxID8gbWV0aG9kc1swXSA6IG1ldGhvZHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hbWVcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkZnVsbF9uYW1lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGJhc2UgPSBzZWxmO1xuXG4gICAgICB3aGlsZSAoYmFzZSkge1xuICAgICAgICAvLyBHaXZlIHVwIGlmIGFueSBvZiB0aGUgYW5jZXN0b3JzIGlzIHVubmFtZWRcbiAgICAgICAgaWYgKGJhc2UuJCRuYW1lID09PSBuaWwgfHwgYmFzZS4kJG5hbWUgPT0gbnVsbCkgcmV0dXJuIG5pbDtcblxuICAgICAgICByZXN1bHQudW5zaGlmdChiYXNlLiQkbmFtZSk7XG5cbiAgICAgICAgYmFzZSA9IGJhc2UuJCRiYXNlX21vZHVsZTtcblxuICAgICAgICBpZiAoYmFzZSA9PT0gJE9iamVjdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lID0gcmVzdWx0LmpvaW4oJzo6Jyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJlcGVuZCgqbW9kcylcbiAgICAleHtcbiAgICAgIGlmIChtb2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuIDAsIGV4cGVjdGVkIDErKSd9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLnByZXBlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kX2ZlYXR1cmVzKHByZXBlbmRlcilcbiAgICAleHtcbiAgICAgIGlmICghc2VsZi4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tzZWxmLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5wcmVwZW5kX2ZlYXR1cmVzKHNlbGYsIHByZXBlbmRlcilcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcHJlcGVuZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9jb25zdChuYW1lKVxuICAgIGBPcGFsLmNvbnN0X3JlbW92ZShzZWxmLCBuYW1lKWBcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgT3BhbC5Nb2R1bGUuJG5hbWUuY2FsbChzZWxmKWAgfHwgXCIjPCN7YHNlbGYuJCRpc19tb2R1bGUgPyAnTW9kdWxlJyA6ICdDbGFzcydgfToweCN7X19pZF9fLnRvX3MoMTYpfT5cIlxuICBlbmRcblxuICBkZWYgdW5kZWZfbWV0aG9kKCpuYW1lcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBPcGFsLnVkZWYoc2VsZiwgXCIkXCIgKyBuYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgY29uc3RzID0gY29uc3RhbnRzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gJyQnICYmIG5hbWUgIT09ICdjb25zdHJ1Y3RvcicgJiYgISN7Y29uc3RzLmluY2x1ZGU/KGBuYW1lYCl9KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gc3VwZXJcbiAgICBjb3B5LmNvcHlfY2xhc3NfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5jb3B5X2NvbnN0YW50cyhzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGNvcHlfY2xhc3NfdmFyaWFibGVzKG90aGVyKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlci4kJGN2YXJzKSB7XG4gICAgICAgIHNlbGYuJCRjdmFyc1tuYW1lXSA9IG90aGVyLiQkY3ZhcnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29weV9jb25zdGFudHMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgbmFtZSwgb3RoZXJfY29uc3RhbnRzID0gb3RoZXIuJCRjb25zdDtcblxuICAgICAgZm9yIChuYW1lIGluIG90aGVyX2NvbnN0YW50cykge1xuICAgICAgICAkY29uc3Rfc2V0KHNlbGYsIG5hbWUsIG90aGVyX2NvbnN0YW50c1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVmaW5lKGtsYXNzLCAmYmxvY2spXG4gICAgcmVmaW5lbWVudF9tb2R1bGUsIG0sIGtsYXNzX2lkID0gc2VsZiwgbmlsLCBuaWxcbiAgICAleHtcbiAgICAgIGtsYXNzX2lkID0gT3BhbC5pZChrbGFzcyk7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuJCRyZWZpbmVfbW9kdWxlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZWxmLiQkcmVmaW5lX21vZHVsZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VsZi4kJHJlZmluZV9tb2R1bGVzW2tsYXNzX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBtID0gc2VsZi4kJHJlZmluZV9tb2R1bGVzW2tsYXNzX2lkXSA9ICN7OjpSZWZpbmVtZW50Lm5ld307XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbSA9IHNlbGYuJCRyZWZpbmVfbW9kdWxlc1trbGFzc19pZF07XG4gICAgICB9XG4gICAgICBtLnJlZmluZW1lbnRfbW9kdWxlID0gcmVmaW5lbWVudF9tb2R1bGVcbiAgICAgIG0ucmVmaW5lZF9jbGFzcyA9IGtsYXNzXG4gICAgfVxuICAgIG0uY2xhc3NfZXhlYygmYmxvY2spXG4gICAgbVxuICBlbmRcblxuICAjIENvbXBpbGVyIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxuICBkZWYgdXNpbmcobW9kKVxuICAgIDo6S2VybmVsLnJhaXNlICdNb2R1bGUjdXNpbmcgaXMgbm90IHBlcm1pdHRlZCBpbiBtZXRob2RzJ1xuICBlbmRcblxuICBhbGlhcyBjbGFzc19ldmFsIG1vZHVsZV9ldmFsXG4gIGFsaWFzIGNsYXNzX2V4ZWMgbW9kdWxlX2V4ZWNcbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5lbmRcblxuY2xhc3MgOjpSZWZpbmVtZW50IDwgOjpNb2R1bGVcbiAgZGVmIGluc3BlY3RcbiAgICBpZiBAcmVmaW5lbWVudF9tb2R1bGVcbiAgICAgIFwiIzxyZWZpbmVtZW50OiN7QHJlZmluZWRfY2xhc3MuaW5zcGVjdH1AI3tAcmVmaW5lbWVudF9tb2R1bGUuaW5zcGVjdH0+XCJcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6TW9kdWxlPiIsImFsbG9jYXRlIiwic2VsZiIsImluaXRpYWxpemUiLCJibG9ja19naXZlbj8iLCJtb2R1bGVfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsIj09PSIsIm9iamVjdCIsIjwiLCJvdGhlciIsIk1vZHVsZSIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwiPD0iLCIkcmV0X29yXzEiLCJlcXVhbD8iLCI+IiwiPj0iLCI8PT4iLCJsdCIsIm5pbD8iLCItMSIsIjEiLCJhbGlhc19tZXRob2QiLCJuZXduYW1lIiwib2xkbmFtZSIsIlN0cmluZyIsImFsaWFzX25hdGl2ZSIsIm1pZCIsImpzaWQiLCJhbmNlc3RvcnMiLCJhcHBlbmRfZmVhdHVyZXMiLCJpbmNsdWRlciIsImF0dHJfYWNjZXNzb3IiLCJhdHRyX3JlYWRlciIsIm5hbWVzIiwiYXR0cl93cml0ZXIiLCJhdHRyIiwid2FybiIsImFyZ3MiLCJhdXRvbG9hZCIsImNvbnN0JCIsInBhdGgiLCJPcGFsIiwiY29uc3RfbmFtZT8iLCJOYW1lRXJyb3IiLCJBcmd1bWVudEVycm9yIiwiYXV0b2xvYWQ/IiwiY2xhc3NfdmFyaWFibGVzIiwiY2xhc3NfdmFyaWFibGVfZ2V0IiwibmFtZSIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY2xhc3NfdmFyaWFibGVfc2V0IiwidmFsdWUiLCJjbGFzc192YXJpYWJsZV9kZWZpbmVkPyIsInJlbW92ZV9jbGFzc192YXJpYWJsZSIsImNvbnN0YW50cyIsImluaGVyaXQiLCJuZXN0aW5nIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9uYW1lISIsIj1+IiwiT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFAiLCJuZXciLCJjb25zdF9nZXQiLCJpbmplY3QiLCJzcGxpdCIsImJsb2NrIGluIGNvbnN0X2dldCIsIm8iLCJjIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb25zdF9nZXQiLCJjb25zdF9taXNzaW5nIiwiZnVsbF9jb25zdF9uYW1lIiwiT2JqZWN0IiwiY29uc3Rfc2V0IiwiIX4iLCJzdGFydF93aXRoPyIsInB1YmxpY19jb25zdGFudCIsImNvbnN0X25hbWUiLCJkZWZpbmVfbWV0aG9kIiwibWV0aG9kIiwiUHJvYyIsIiRyZXRfb3JfMiIsIk1ldGhvZCIsIlVuYm91bmRNZXRob2QiLCJibG9jayBpbiBkZWZpbmVfbWV0aG9kIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWZpbmVfbWV0aG9kIiwiYm91bmQiLCJiaW5kIiwiY2FsbCIsImNsYXNzIiwicmVtb3ZlX21ldGhvZCIsInNpbmdsZXRvbl9jbGFzcz8iLCJpbmNsdWRlIiwiaW5jbHVkZWQiLCJpbmNsdWRlZF9tb2R1bGVzIiwiaW5jbHVkZT8iLCJtb2QiLCJpbnN0YW5jZV9tZXRob2QiLCJpbnN0YW5jZV9tZXRob2RzIiwiaW5jbHVkZV9zdXBlciIsImV4dGVuZGVkIiwiZXh0ZW5kX29iamVjdCIsIm1ldGhvZF9hZGRlZCIsIm1ldGhvZF9yZW1vdmVkIiwibWV0aG9kX3VuZGVmaW5lZCIsIjMiLCJjb3Zlcj8iLCJzaXplIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYmxvY2sgaW4gbW9kdWxlX2V2YWwiLCJibG9jayAoMiBsZXZlbHMpIGluIG1vZHVsZV9ldmFsIiwiYW55PyIsIm1vZHVsZV9leGVjIiwiTG9jYWxKdW1wRXJyb3IiLCJtZXRob2RfZGVmaW5lZD8iLCJtb2R1bGVfZnVuY3Rpb24iLCJwcmVwZW5kIiwicHJlcGVuZF9mZWF0dXJlcyIsInByZXBlbmRlZCIsInByZXBlbmRlciIsInJlbW92ZV9jb25zdCIsInRvX3MiLCJfX2lkX18iLCIxNiIsInVuZGVmX21ldGhvZCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsImNvbnN0cyIsImR1cCIsImNvcHkiLCJjb3B5X2NsYXNzX3ZhcmlhYmxlcyIsImNvcHlfY29uc3RhbnRzIiwicmVmaW5lIiwia2xhc3MiLCJyZWZpbmVtZW50X21vZHVsZSIsIm0iLCJrbGFzc19pZCIsIlJlZmluZW1lbnQiLCJjbGFzc19leGVjIiwidXNpbmciLCI8Y2xhc3M6UmVmaW5lbWVudD4iLCJpbnNwZWN0IiwiQHJlZmluZW1lbnRfbW9kdWxlIiwiQHJlZmluZWRfY2xhc3MiXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxNQUFJQyxJQUFKRCxlQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQU5FQSxDQUFBQSxHQUFBQTs7QUFTQUUsSUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUNFLElBQXVCQyxlQUF2QjtRQUFBRCxPQUFBRSxNQUFBSCxJQUFBRyxlQUFBQSxFQUFBQSxFQUFBQSxFQUFhQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFaRjtNQUFBO1FBYkpGLE9BQUE7TUFhSTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUssSUFBQUEsbUJBQUFBLDZCQUFRQyxNQUFSRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFpQkEsY0FBakIsQ0FBQTtRQUFBLE9BQU87TUFBUDtNQUVBQSxPQUFDQSx1QkFBREE7SUFIRkEsQ0FBQUEsR0FBQUE7O0FBTUFF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LENBQUs4RTtBQUNqRUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7TUFDS00sTUFBREgsQ0FBQ0csY0FBQUEsRUFBQUEsRUFBQUEsRUFBYWhKLEtBQURDLFNBQUFBLENBQUFBLENBQVorSTtNQUNETixPQUFBRztJQWpCRkgsQ0FBQUEsR0FBQUE7O0FBcUJBTyxJQUFBQSxxQkFBQUEsaUJBQVVuRCxHQUFWbUQ7QUFBQUE7TUFDRUEsT0FBQTFJLE9BQVFDLE9BQUFBLENBQU95SSwwQ0FBUHpJO0lBRFZ5SSxDQUFBQSxHQUFBQTtJQUlBLGFBQU0sWUFBTixFQUFpQixhQUFqQjtJQUNBLGFBQU0sWUFBTixFQUFpQixhQUFqQjtJQUNBdkosT0FBQSxhQUFNLFNBQU4sRUFBYyxNQUFkO0VBbHRCRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQXF0QkFELE9BQUF5SjtFQUFBQTs7SUFBQUE7O0FBQUFBO0lBQ0VBLE9BQUFDLHVCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBO01BQ0UsSUFBQSxRQUFHQyxzQkFBSCxDQUFBO1FBQ0VELE9BQUNBLGVBQUQsR0FBQSxDQUFnQkUsa0JBQWNGLFNBQUFBLENBQUFBLENBQTlCLENBQUEsR0FBdUNBLEdBQXZDLEdBQUEsQ0FBMENDLHNCQUFrQkQsU0FBQUEsQ0FBQUEsQ0FBNUQsQ0FBQSxHQUFxRUE7TUFEdkU7UUFHRUEsT0FBQSxPQUFBdkosSUFBQSxFQUFBLG9EQUFBLFdBQUEsRUFBQSxFQUFBLEVBQUEsTUFBQTtNQUhGO0lBREZ1SixDQUFBQSxHQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQXFCNUksT0FBckI0STtBQXZ0QkF6SjsifX0seyJvZmZzZXQiOnsibGluZSI6NDA4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY2xhc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG5cbmNsYXNzIDo6Q2xhc3NcbiAgZGVmIHNlbGYubmV3KHN1cGVyY2xhc3MgPSBPYmplY3QsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghc3VwZXJjbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzc1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHN1cGVyY2xhc3MpO1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICAgICN7YGtsYXNzYC5jbGFzc19ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/fVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuICAgICAgb2JqLiQkaWQgPSBPcGFsLnVpZCgpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZXNjZW5kYW50c1xuICAgIHN1YmNsYXNzZXMgKyBzdWJjbGFzc2VzLm1hcCgmOmRlc2NlbmRhbnRzKS5mbGF0dGVuXG4gIGVuZFxuXG4gIGRlZiBpbmhlcml0ZWQoY2xzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3JpZ2luYWwpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG9yaWdpbmFsKVxuICAgICV4e1xuICAgICAgc2VsZi4kJG5hbWUgPSBudWxsO1xuICAgICAgc2VsZi4kJGZ1bGxfbmFtZSA9IG51bGw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV3KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqZWN0ID0gI3thbGxvY2F0ZX07XG4gICAgICBPcGFsLnNlbmQob2JqZWN0LCBvYmplY3QuJGluaXRpYWxpemUsIGFyZ3MsIGJsb2NrKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3ViY2xhc3Nlc1xuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBXZWFrUmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaSwgc3ViY2xhc3MsIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi4kJHN1YmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJjbGFzcyA9IHNlbGYuJCRzdWJjbGFzc2VzW2ldLmRlcmVmKCk7XG4gICAgICAgICAgaWYgKHN1YmNsYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHN1YmNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHN1YmNsYXNzZXM7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VwZXJjbGFzc1xuICAgIGBzZWxmLiQkc3VwZXIgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICV4e1xuICAgICAgdmFyIHNpbmdsZXRvbl9vZiA9IHNlbGYuJCRzaW5nbGV0b25fb2Y7XG5cbiAgICAgIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiN7YHNpbmdsZXRvbl9vZmAubmFtZX0+XCJ9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2luZ2xldG9uX29mKSB7XG4gICAgICAgIC8vIGEgc2luZ2xldG9uIGNsYXNzIGNyZWF0ZWQgZnJvbSBhbiBvYmplY3RcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiM8I3tgc2luZ2xldG9uX29mLiQkY2xhc3NgLm5hbWV9OjB4I3tgT3BhbC5pZChzaW5nbGV0b25fb2YpYC50b19zKDE2KX0+PlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7c3VwZXIoKX07XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBpbnNwZWN0IHRvX3NcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpDbGFzcz4iLCJuZXciLCJzdXBlcmNsYXNzIiwiT2JqZWN0IiwiYmxvY2tfZ2l2ZW4/IiwiY2xhc3NfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImFsbG9jYXRlIiwiZGVzY2VuZGFudHMiLCIrIiwic3ViY2xhc3NlcyIsIm1hcCIsImZsYXR0ZW4iLCJpbmhlcml0ZWQiLCJjbHMiLCJpbml0aWFsaXplX2R1cCIsIm9yaWdpbmFsIiwiaW5pdGlhbGl6ZV9jb3B5IiwidG9fcyIsIm5hbWUiLCIxNiJdLCJtYXBwaW5ncyI6IkFBQUFBLGdEQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFQyxNQUFJSCxJQUFKRyxVQUFBQSxzQkFBYUMsVUFBYkQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7O01BQWEscUNBQWFFLFlBQWI7O0FBRWZGO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSxNQUFRLENBQThCRyxlQUE5QixHQUFBLENBQU9DLE1BQVBKLENBQUNBLEtBQURBLENBQU9JLGNBQUFBLEVBQUFBLEVBQUFBLEVBQWFDLEtBQURDLFNBQUFBLENBQUFBLENBQVpGLENBQVAsSUFBQSxHQUFBO0FBQ1JKO0FBQ0FBO0lBVkVBLENBQUFBLElBQUFBOztBQWFBTyxJQUFBQSx3QkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsR0FBQUE7O0FBUUFDLElBQUFBLDJCQUFBQSx1QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQVdDLFNBQVhaLElBQUFhLFlBQUFBLENBQUFBLENBQVdELEVBQVlFLE1BQVZkLElBQUFhLFlBQUFBLENBQUFBLENBQVVDLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sYUFBREwsU0FBQUEsQ0FBQUEsQ0FBTEssQ0FBbUJDLFNBQUFBLENBQUFBLENBQS9CSDtJQURiRCxDQUFBQSxHQUFBQTs7QUFJQUssSUFBQUEseUJBQUFBLHFCQUFjQyxHQUFkRDtBQUFBQTtNQTVCRkEsT0FBQTtJQTRCRUEsQ0FBQUEsR0FBQUE7O0FBR0FFLElBQUFBLDhCQUFBQSwwQkFBbUJDLFFBQW5CRDtBQUFBQSxNQUFBQTs7O01BQ0VsQixJQUFBb0IsaUJBQUFBLENBQWdCRCxRQUFoQkM7O0FBRUpGO0FBQ0FBO0FBQ0FBO0lBTEVBLENBQUFBLEdBQUFBOztBQVFBZixJQUFBQSxtQkFBQUEsc0JBdkNGLEVBdUNFQTtBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7TUF2Q0Y7O01BdUNVOztBQUVWQSxtQkFBcUJILElBQUFVLFVBQUFBLENBQUFBLENBQVNQO0FBQzlCQTtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQSxJQUFBQTs7QUFRQVUsSUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBZkVBLENBQUFBLEdBQUFBOztBQWtCQVQsSUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsbUJBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBaUIsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7O0FBRUZBOztBQUVBQTtBQUNBQSxlQUFrQkEsVUFBRCxHQUFBLENBQVdBLENBQUNBLFlBQURBLENBQWNDLE1BQUFBLENBQUFBLENBQXpCLENBQUEsR0FBK0JELEdBQUdBO0FBQ25EQTtBQUNBQTtBQUNBQTtBQUNBQSxlQUFrQkEsWUFBRCxHQUFBLENBQWFBLENBQUNBLG9CQUFEQSxDQUFzQkMsTUFBQUEsQ0FBQUEsQ0FBbkMsQ0FBQSxHQUF5Q0QsS0FBekMsR0FBQSxDQUE4Q0EsQ0FBQ0EscUJBQURBLENBQXVCQSxNQUFBQSxDQUFNRSxFQUFORixDQUFyRSxDQUFBLEdBQStFQSxJQUFJQTtBQUNwR0E7O0FBRUFBLGFBQWUsT0FBQXJCLElBQUEsRUFBQSw4Q0FBQSxRQUFBLEVBQUEsRUFBQSxFQUFBLElBQUEsQ0FBUXFCO0FBQ3ZCQTtJQWJFQSxDQUFBQSxHQUFBQTtJQWdCQW5CLE9BQUEsYUFBTSxTQUFOLEVBQWMsTUFBZDtFQW5GRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBSDsifX0seyJvZmZzZXQiOnsibGluZSI6NDIxMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYmFzaWNfb2JqZWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgdXNlX3N0cmljdDogdHJ1ZVxuXG5jbGFzcyA6OkJhc2ljT2JqZWN0XG4gIGRlZiBpbml0aWFsaXplKCopXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgYWxpYXMgZXF1YWw/ID09XG5cbiAgZGVmIF9faWRfX1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgICB9XG4gICAgICBPcGFsLnByb3Aoc2VsZiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19zZW5kX18oc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFzeW1ib2wuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tyYWlzZSA6OlR5cGVFcnJvciwgXCIje2luc3BlY3R9IGlzIG5vdCBhIHN5bWJvbCBub3IgYSBzdHJpbmdcIn1cbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bmMgPSBzZWxmWyckJyArIHN5bWJvbF07XG5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgZnVuYy4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRtZXRob2RfbWlzc2luZy4kJHAgPSBibG9jaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHNlbGYsIFtzeW1ib2xdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgIVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiAhPShvdGhlcilcbiAgICAhKHNlbGYgPT0gb3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7bmV3IEZ1bmN0aW9uKFwiT3BhbCxzZWxmXCIsIFwicmV0dXJuIFwiICsgY29tcGlsZWQpKE9wYWwsIHNlbGYpfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2submlsPyAmJiBhcmdzLmxlbmd0aCA+PSAxICYmIGFyZ3MuZmlyc3RbMF0gPT0gJ0AnXG4gICAgICAjIGdldCBpbnN0YW5jZSB2YXJpYWJsZVxuICAgICAgcmV0dXJuIGluc3RhbmNlX3ZhcmlhYmxlX2dldChhcmdzLmZpcnN0KVxuICAgIGVsc2lmIGFyZ3MuYW55P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5zaXplfSBmb3IgMClcIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgLy8gTmVlZCB0byBwYXNzICQkZXZhbCBzbyB0aGF0IG1ldGhvZCBkZWZpbml0aW9ucyBrbm93IGlmIHRoaXMgaXNcbiAgICAgIC8vIGJlaW5nIGRvbmUgb24gYSBjbGFzcy9tb2R1bGUuIENhbm5vdCBiZSBjb21waWxlciBkcml2ZW4gc2luY2VcbiAgICAgIC8vIHNlbmQoOmluc3RhbmNlX2V2YWwpIG5lZWRzIHRvIHdvcmsuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgfVxuXG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXhlYygqYXJncywgJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IGJsb2NrX3NlbGY7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3Npbmcoc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgIGluc3BlY3RfcmVzdWx0ID0gOjpPcGFsLmluc3BlY3Qoc2VsZilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vTWV0aG9kRXJyb3IubmV3KFxuICAgICAgXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3RfcmVzdWx0fVwiLCBzeW1ib2wsIGFyZ3NcbiAgICApLCBuaWwsIDo6S2VybmVsLmNhbGxlcigxKVxuICBlbmRcblxuICA6Ok9wYWwucHJpc3RpbmUoc2VsZiwgOm1ldGhvZF9taXNzaW5nKVxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZF9uYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpCYXNpY09iamVjdD4iLCJpbml0aWFsaXplIiwiPT0iLCJvdGhlciIsImVxbD8iLCJzZWxmIiwiX19pZF9fIiwiX19zZW5kX18iLCJzeW1ib2wiLCJyYWlzZSIsIlR5cGVFcnJvciIsImluc3BlY3QiLCIhIiwiIT0iLCJpbnN0YW5jZV9ldmFsIiwiYmxvY2siLCJuaWw/IiwiMSIsIjMiLCJjb3Zlcj8iLCJhcmdzIiwic2l6ZSIsIktlcm5lbCIsIkFyZ3VtZW50RXJyb3IiLCJzdHJpbmciLCJmaWxlIiwiX2xpbmVubyIsImRlZmF1bHRfZXZhbF9vcHRpb25zIiwiJHJldF9vcl8xIiwiY29tcGlsaW5nX29wdGlvbnMiLCJfX09QQUxfQ09NUElMRVJfQ09ORklHX18iLCJtZXJnZSIsImNvbXBpbGVkIiwiT3BhbCIsImNvbXBpbGUiLCJwcm9jIiwiYmxvY2sgaW4gaW5zdGFuY2VfZXZhbCIsImJsb2NrICgyIGxldmVscykgaW4gaW5zdGFuY2VfZXZhbCIsIj49IiwibGVuZ3RoIiwiZmlyc3QiLCJbXSIsIjAiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCJhbnk/IiwiaW5zdGFuY2VfZXhlYyIsInNpbmdsZXRvbl9tZXRob2RfYWRkZWQiLCJzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQiLCJzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCIsIm1ldGhvZF9taXNzaW5nIiwiaW5zcGVjdF9yZXN1bHQiLCJOb01ldGhvZEVycm9yIiwibmV3IiwiY2FsbGVyIiwicHJpc3RpbmUiLCJyZXNwb25kX3RvX21p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SUFBQUE7O0FBR0FDLElBQUFBLHdDQUFBQSxvQ0F2SUYsRUF1SUVBO0FBQUFBLE1BQUFBOzs7O01BdklGOztNQXVJK0I7TUF2SS9CQSxPQUFBO0lBdUlFQSxDQUFBQSxJQUFBQTs7QUFHQUMsSUFBQUEsMENBQUFBLHNDQTFJRixFQTBJRUE7QUFBQUEsTUFBQUE7Ozs7TUExSUY7O01BMElpQztNQTFJakNBLE9BQUE7SUEwSUVBLENBQUFBLElBQUFBOztBQUdBQyxJQUFBQSw4QkFBQUEsMEJBQW1CekMsTUFBRCxFQTdJcEIsRUE2SUV5QztBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7TUE3SUY7O01BNkk2QjtNQUN6QkMsaUJBQWlCakIsS0FBTXRCLFNBQUFBLENBQVNOLElBQVRNO01BQ3ZCc0MsT0FBQTNCLE9BQVFiLE9BQUFBLENBQU8wQyxvQkFBZUMsS0FBQUEsQ0FDM0JILG9CQUFELEdBQUEsQ0FBcUJ6QyxNQUFyQixDQUFBLEdBQTRCeUMsUUFBNUIsR0FBQSxDQUFvQ0MsY0FBcEMsQ0FEYSxFQUN5QzFDLE1BRHpDLEVBQ2lEWSxJQURsQ2dDLENBQTlCLEVBRUcsR0FGSCxFQUVROUIsT0FBUStCLFFBQUFBLENBQVFwQyxDQUFSb0MsQ0FGUjVDO0lBRlZ3QyxDQUFBQSxJQUFBQTtJQU9BaEIsS0FBTXFCLFVBQUFBLENBQVVqRCxJQUFoQixFQUFzQixnQkFBaEJpRDtJQUVOdEQsT0FBQXVELG1DQUFBQSxnREFBd0JDLFdBQUQsRUFBY0MsV0FBckNGO0FBQUFBOzs7TUFBcUMsdUNBQWMsS0FBZDtNQUNuQ0EsT0FBQTtJQURGQSxDQUFBQSxJQUFBQTtFQXBKRnZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ0NTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCByZXNwb25kX3RvLCBPcGFsXG4jIHVzZV9zdHJpY3Q6IHRydWVcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiA9fihvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmICF+KG9iailcbiAgICAhKHNlbGYgPX4gb2JqKVxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgIG9iamVjdF9pZCA9PSBvdGhlci5vYmplY3RfaWQgfHwgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgICV4e1xuICAgICAgLy8gc2V0IGd1YXJkIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgIHNlbGYuJCRjb21wYXJhYmxlID0gdHJ1ZTtcblxuICAgICAgdmFyIHggPSAje3NlbGYgPT0gb3RoZXJ9O1xuXG4gICAgICBpZiAoeCAmJiB4ICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aCA9IHNlbGZbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICghbWV0aCB8fCBtZXRoLiQkc3R1Yikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLmNsYXNzfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3s6Ok1ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGYuY2xhc3N9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kcyhhbGwgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCR0cnV0aHkoI3thbGx9KSkge1xuICAgICAgICByZXR1cm4gT3BhbC5tZXRob2RzKHNlbGYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwub3duX21ldGhvZHMoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHVibGljX21ldGhvZHMoYWxsID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7YWxsfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwubWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLnJlY2VpdmVyX21ldGhvZHMoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgQXJyYXkob2JqZWN0KVxuICAgICV4e1xuICAgICAgdmFyIGNvZXJjZWQ7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBjb2VyY2VkID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhvYmplY3QsIDo6QXJyYXksIDp0b19hcnkpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgY29lcmNlZCA9ICN7OjpPcGFsLmNvZXJjZV90bz8ob2JqZWN0LCA6OkFycmF5LCA6dG9fYSl9O1xuICAgICAgaWYgKGNvZXJjZWQgIT09IG5pbCkgeyByZXR1cm4gY29lcmNlZDsgfVxuXG4gICAgICByZXR1cm4gW29iamVjdF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXRfZXhpdCgmYmxvY2spXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuICAgICRfX2F0X2V4aXRfXyA8PCBibG9ja1xuICAgIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBjYWxsZXIoc3RhcnQgPSAxLCBsZW5ndGggPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgc3RhY2ssIHJlc3VsdDtcblxuICAgICAgc3RhY2sgPSBuZXcgRXJyb3IoKS4kYmFja3RyYWNlKCk7XG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9ICN7c3RhcnR9ICsgMSwgaWkgPSBzdGFjay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICghc3RhY2tbaV0ubWF0Y2goL3J1bnRpbWVcXC5qcy8pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2tbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoICE9IG5pbCkgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsYXNzXG4gICAgYHNlbGYuJCRjbGFzc2BcbiAgZW5kXG5cbiAgZGVmIGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvdGhlciksIGksIGlpLCBuYW1lO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBrZXlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IGtleXNbaV07XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29weV9zaW5nbGV0b25fbWV0aG9kcyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBpLCBuYW1lLCBuYW1lcywgbGVuZ3RoO1xuXG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICAgIHZhciBvdGhlcl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob3RoZXIpO1xuICAgICAgICB2YXIgc2VsZl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZik7XG4gICAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICBpZiAoT3BhbC5pc19tZXRob2QobmFtZSkpIHtcbiAgICAgICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdID0gb3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QgPSBPYmplY3QuYXNzaWduKHt9LCBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihcbiAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG90aGVyKSwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICckJyAmJiBuYW1lLmNoYXJBdCgxKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2Nsb25lKG90aGVyKVxuICAgIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHNpbmdsZXRvbl9jbGFzcy5kZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHNlbGYuY2xhc3MuYWxsb2NhdGVcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvdGhlcilcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICA6OkVudW1lcmF0b3IuZm9yKHNlbGYsIG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBleGl0KHN0YXR1cyA9IHRydWUpXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuXG4gICAgdW50aWwgJF9fYXRfZXhpdF9fLmVtcHR5P1xuICAgICAgYmxvY2sgPSAkX19hdF9leGl0X18ucG9wXG4gICAgICBibG9jay5jYWxsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzdGF0dXMuJCRpc19ib29sZWFuKSB7XG4gICAgICAgIHN0YXR1cyA9IHN0YXR1cyA/IDAgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gJGNvZXJjZV90byhzdGF0dXMsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpXG4gICAgICB9XG5cbiAgICAgIE9wYWwuZXhpdChzdGF0dXMpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZCgqbW9kcylcbiAgICAleHtcbiAgICAgIHZhciBzaW5nbGV0b24gPSAje3NpbmdsZXRvbl9jbGFzc307XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5hcHBlbmRfZmVhdHVyZXMgYHNpbmdsZXRvbmB9O1xuICAgICAgICAje2Btb2RgLmV4dGVuZF9vYmplY3Qgc2VsZn07XG4gICAgICAgICN7YG1vZGAuZXh0ZW5kZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZ2V0cygqYXJncylcbiAgICAkc3RkaW4uZ2V0cygqYXJncylcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBfX2lkX19cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgYHZhciBpbnNwZWN0X3N0YWNrID0gW11gXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpdnMgPSAnJ1xuICAgIGlkID0gX19pZF9fXG4gICAgaWYgYGluc3BlY3Rfc3RhY2tgLmluY2x1ZGU/IGlkXG4gICAgICBpdnMgPSAnIC4uLidcbiAgICBlbHNlXG4gICAgICBgaW5zcGVjdF9zdGFja2AgPDwgaWRcbiAgICAgIHB1c2hlZCA9IHRydWVcbiAgICAgIGluc3RhbmNlX3ZhcmlhYmxlcy5lYWNoIGRvIHxpfFxuICAgICAgICBpdmFyID0gaW5zdGFuY2VfdmFyaWFibGVfZ2V0KGkpXG4gICAgICAgIGluc3BlY3QgPSBPcGFsLmluc3BlY3QoaXZhcilcbiAgICAgICAgaXZzICs9IFwiICN7aX09I3tpbnNwZWN0fVwiXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7aWQudG9fcygxNil9I3tpdnN9PlwiXG4gIHJlc2N1ZSA9PiBlXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje2lkLnRvX3MoMTYpfT5cIlxuICBlbnN1cmVcbiAgICBgaW5zcGVjdF9zdGFja2AucG9wIGlmIHB1c2hlZFxuICBlbmRcblxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2xhc3MgPT09IGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLCBuYW1lLnN1YnN0cigxKSlgXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9nZXQobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBpdmFyID0gc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXTtcblxuICAgICAgcmV0dXJuIGl2YXIgPT0gbnVsbCA/IG5pbCA6IGl2YXI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfc2V0KG5hbWUsIHZhbHVlKVxuICAgIG5hbWUgPSA6Ok9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBzZWxmW09wYWwuaXZhcihuYW1lLnN1YnN0cigxKSldID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBrZXkgPSBPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpLFxuICAgICAgICAgIHZhbDtcbiAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFsID0gc2VsZltrZXldO1xuICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcImluc3RhbmNlIHZhcmlhYmxlICN7bmFtZX0gbm90IGRlZmluZWRcIlxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGl2YXI7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gJyQnKSB7XG4gICAgICAgICAgaWYgKG5hbWUuc3Vic3RyKC0xKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgaXZhcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBJbnRlZ2VyKHZhbHVlLCBiYXNlID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGksIHN0ciwgYmFzZV9kaWdpdHM7XG5cbiAgICAgIGlmICghdmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYmFzZSBzcGVjaWZpZWQgZm9yIG5vbiBzdHJpbmcgdmFsdWUnfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEludGVnZXJcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8IHZhbHVlID09PSAtSW5maW5pdHkgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgdmFsdWV9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyg6dG9faW50KX0pIHtcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pbnR9O1xuICAgICAgICAgIGlmIChpICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3s6Ok9wYWwuY29lcmNlX3RvISh2YWx1ZSwgOjpJbnRlZ2VyLCA6dG9faSl9O1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IFwiMFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJhc2UgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9ICRjb2VyY2VfdG8oYmFzZSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChiYXNlID09PSAxIHx8IGJhc2UgPCAwIHx8IGJhc2UgPiAzNikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwifVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0ciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KS8sIGZ1bmN0aW9uIChfLCBoZWFkLCBmbGFnKSB7XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMikge1xuICAgICAgICAgICAgYmFzZSA9IDI7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8tYnJlYWtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSA4KSB7XG4gICAgICAgICAgICBiYXNlID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTApIHtcbiAgICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgICAgIGJhc2UgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICB9XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfSk7XG5cbiAgICAgIGJhc2UgPSAoYmFzZSA9PT0gMCA/IDEwIDogYmFzZSk7XG5cbiAgICAgIGJhc2VfZGlnaXRzID0gJzAtJyArIChiYXNlIDw9IDEwID8gYmFzZSAtIDEgOiAnOWEtJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAoYmFzZSAtIDExKSkpO1xuXG4gICAgICBpZiAoIShuZXcgUmVnRXhwKCdeXFxcXHMqWystXT9bJyArIGJhc2VfZGlnaXRzICsgJ10rXFxcXHMqJCcpKS50ZXN0KHN0cikpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9XG5cbiAgICAgIGkgPSBwYXJzZUludChzdHIsIGJhc2UpO1xuXG4gICAgICBpZiAoaXNOYU4oaSkpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEZsb2F0KHZhbHVlKVxuICAgICV4e1xuICAgICAgdmFyIHN0cjtcblxuICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEZsb2F0XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBoZXggc3RyaW5ncyBvbmx5OlxuICAgICAgICBpZiAoL15cXHMqWy0rXT8wW3hYXVswLTlhLWZBLUZdK1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5JbnRlZ2VyKGBzdHJgKX07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIS9eXFxzKlstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspP1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBGbG9hdCgpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3s6Ok9wYWwuY29lcmNlX3RvISh2YWx1ZSwgOjpGbG9hdCwgOnRvX2YpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBIYXNoKGFyZylcbiAgICByZXR1cm4ge30gaWYgYXJnLm5pbD8gfHwgYXJnID09IFtdXG4gICAgcmV0dXJuIGFyZyBpZiA6Okhhc2ggPT09IGFyZ1xuICAgIDo6T3BhbC5jb2VyY2VfdG8hKGFyZywgOjpIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPcGFsLmlzX2Eoc2VsZiwga2xhc3MpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGl0c2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxhbWJkYSgmYmxvY2spXG4gICAgYE9wYWwubGFtYmRhKGJsb2NrKWBcbiAgZW5kXG5cbiAgZGVmIGxvYWQoZmlsZSlcbiAgICBmaWxlID0gOjpPcGFsLmNvZXJjZV90byEoZmlsZSwgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgYE9wYWwubG9hZCgje2ZpbGV9KWBcbiAgZW5kXG5cbiAgZGVmIGxvb3BcbiAgICByZXR1cm4gZW51bV9mb3IoOmxvb3ApIHsgOjpGbG9hdDo6SU5GSU5JVFkgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSB0cnVlXG4gICAgICBiZWdpblxuICAgICAgICB5aWVsZFxuICAgICAgcmVzY3VlIDo6U3RvcEl0ZXJhdGlvbiA9PiBlXG4gICAgICAgIHJldHVybiBlLnJlc3VsdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaW50ZigqYXJncylcbiAgICBpZiBhcmdzLmFueT9cbiAgICAgIHByaW50IGZvcm1hdCgqYXJncylcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcHJvYygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYGJsb2NrLiQkaXNfbGFtYmRhID0gZmFsc2VgXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKnN0cnMpXG4gICAgJHN0ZG91dC5wdXRzKCpzdHJzKVxuICBlbmRcblxuICBkZWYgcCgqYXJncylcbiAgICBhcmdzLmVhY2ggeyB8b2JqfCAkc3Rkb3V0LnB1dHMgb2JqLmluc3BlY3QgfVxuXG4gICAgYXJncy5sZW5ndGggPD0gMSA/IGFyZ3NbMF0gOiBhcmdzXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqc3RycylcbiAgICAkc3Rkb3V0LnByaW50KCpzdHJzKVxuICBlbmRcblxuICBkZWYgcmVhZGxpbmUoKmFyZ3MpXG4gICAgJHN0ZGluLnJlYWRsaW5lKCphcmdzKVxuICBlbmRcblxuICBkZWYgd2Fybigqc3RycywgdXBsZXZlbDogbmlsKVxuICAgIGlmIHVwbGV2ZWxcbiAgICAgIHVwbGV2ZWwgPSA6Ok9wYWwuY29lcmNlX3RvISh1cGxldmVsLCA6OkludGVnZXIsIDp0b19zdHIpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibmVnYXRpdmUgbGV2ZWwgKCN7dXBsZXZlbH0pXCIgaWYgdXBsZXZlbCA8IDBcbiAgICAgIGxvY2F0aW9uID0gY2FsbGVyKHVwbGV2ZWwgKyAxLCAxKS5maXJzdCYuc3BsaXQoJzppbiBgJykmLmZpcnN0XG4gICAgICBsb2NhdGlvbiA9IFwiI3tsb2NhdGlvbn06IFwiIGlmIGxvY2F0aW9uXG4gICAgICBzdHJzID0gc3Rycy5tYXAgeyB8c3wgXCIje2xvY2F0aW9ufXdhcm5pbmc6ICN7c31cIiB9XG4gICAgZW5kXG5cbiAgICAkc3RkZXJyLnB1dHMoKnN0cnMpIHVubGVzcyAkVkVSQk9TRS5uaWw/IHx8IHN0cnMuZW1wdHk/XG4gIGVuZFxuXG4gIGRlZiByYWlzZShleGNlcHRpb24gPSB1bmRlZmluZWQsIHN0cmluZyA9IG5pbCwgYmFja3RyYWNlID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKGV4Y2VwdGlvbiA9PSBudWxsICYmICN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgdGhyb3cgI3skIX07XG4gICAgICB9XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3s6OlJ1bnRpbWVFcnJvci5uZXcgJyd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoJHJlc3BvbmRfdG8oZXhjZXB0aW9uLCAnJHRvX3N0cicpKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7OjpSdW50aW1lRXJyb3IubmV3IGV4Y2VwdGlvbi50b19zdHJ9O1xuICAgICAgfVxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfY2xhc3MgJiYgJHJlc3BvbmRfdG8oZXhjZXB0aW9uLCAnJGV4Y2VwdGlvbicpKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7ZXhjZXB0aW9uLmV4Y2VwdGlvbiBzdHJpbmd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfZXhjZXB0aW9uKSB7XG4gICAgICAgIC8vIGV4Y2VwdGlvbiBpcyBmaW5lXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3s6OlR5cGVFcnJvci5uZXcgJ2V4Y2VwdGlvbiBjbGFzcy9vYmplY3QgZXhwZWN0ZWQnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhY2t0cmFjZSAhPT0gbmlsKSB7XG4gICAgICAgIGV4Y2VwdGlvbi4kc2V0X2JhY2t0cmFjZShiYWNrdHJhY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3skIX0gIT09IG5pbCkge1xuICAgICAgICBPcGFsLmV4Y2VwdGlvbnMucHVzaCgjeyQhfSk7XG4gICAgICB9XG5cbiAgICAgICN7JCF9ID0gZXhjZXB0aW9uO1xuICAgICAgI3skQH0gPSAje2BleGNlcHRpb25gLmJhY2t0cmFjZX07XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByYW5kKG1heCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3s6OlJhbmRvbTo6REVGQVVMVC5yYW5kfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAobWF4IDwgMCkge1xuICAgICAgICAgIG1heCA9IE1hdGguYWJzKG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ICUgMSAhPT0gMCkge1xuICAgICAgICAgIG1heCA9IG1heC4kdG9faSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCA9PT0gMCkge1xuICAgICAgICAgIG1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICA6OlJhbmRvbTo6REVGQVVMVC5yYW5kKG1heClcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG8/KG5hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgJXh7XG4gICAgICB2YXIgYm9keSA9IHNlbGZbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmWyckcmVzcG9uZF90b19taXNzaW5nPyddLiQkcHJpc3RpbmUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7cmVzcG9uZF90b19taXNzaW5nPyhuYW1lLCBpbmNsdWRlX2FsbCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kX25hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgOjpPcGFsLnByaXN0aW5lKHNlbGYsIDpyZXNwb25kX3RvPywgOnJlc3BvbmRfdG9fbWlzc2luZz8pXG5cbiAgZGVmIHJlcXVpcmUoZmlsZSlcbiAgICAleHtcbiAgICAgIC8vIEFzIE9iamVjdC5yZXF1aXJlIHJlZmVycyB0byBLZXJuZWwucmVxdWlyZSBvbmNlIEtlcm5lbCBoYXMgYmVlbiBsb2FkZWQgdGhlIFN0cmluZ1xuICAgICAgLy8gY2xhc3MgbWF5IG5vdCBiZSBhdmFpbGFibGUgeWV0LCB0aGUgY29lcmNpb24gcmVxdWlyZXMgYm90aCAgU3RyaW5nIGFuZCBBcnJheSB0byBiZSBsb2FkZWQuXG4gICAgICBpZiAodHlwZW9mICN7ZmlsZX0gIT09ICdzdHJpbmcnICYmIE9wYWwuU3RyaW5nICYmIE9wYWwuQXJyYXkpIHtcbiAgICAgICAgI3tmaWxlID0gOjpPcGFsLmNvZXJjZV90byEoZmlsZSwgOjpTdHJpbmcsIDp0b19zdHIpIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcGFsLnJlcXVpcmUoI3tmaWxlfSlcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXF1aXJlX3JlbGF0aXZlKGZpbGUpXG4gICAgOjpPcGFsLnRyeV9jb252ZXJ0IShmaWxlLCA6OlN0cmluZywgOnRvX3N0cilcbiAgICBmaWxlID0gOjpGaWxlLmV4cGFuZF9wYXRoIDo6RmlsZS5qb2luKGBPcGFsLmN1cnJlbnRfZmlsZWAsICcuLicsIGZpbGUpXG5cbiAgICBgT3BhbC5yZXF1aXJlKCN7ZmlsZX0pYFxuICBlbmRcblxuICAjIGBwYXRoYCBzaG91bGQgYmUgdGhlIGZ1bGwgcGF0aCB0byBiZSBmb3VuZCBpbiByZWdpc3RlcmVkIG1vZHVsZXMgKGBPcGFsLm1vZHVsZXNgKVxuICBkZWYgcmVxdWlyZV90cmVlKHBhdGgsIGF1dG9sb2FkOiBmYWxzZSlcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcGF0aCA9ICN7OjpGaWxlLmV4cGFuZF9wYXRoKHBhdGgpfVxuICAgICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuICAgICAgaWYgKHBhdGggPT09ICcuJykgcGF0aCA9ICcnO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBPcGFsLm1vZHVsZXMpIHtcbiAgICAgICAgaWYgKCN7YG5hbWVgLnN0YXJ0X3dpdGg/KHBhdGgpfSkge1xuICAgICAgICAgIGlmKCEje2F1dG9sb2FkfSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW25hbWUsIE9wYWwucmVxdWlyZShuYW1lKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgdHJ1ZV0pOyAvLyBkbyBub3RoaW5nLCBkZWxlZ2F0ZWQgdG8gYSBhdXRvbG9hZGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBzbGVlcChzZWNvbmRzID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHNlY29uZHMgPT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgTmlsQ2xhc3MgaW50byB0aW1lIGludGVydmFsXCJ9XG4gICAgICB9XG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2Vjb25kcy5jbGFzc30gaW50byB0aW1lIGludGVydmFsXCJ9XG4gICAgICB9XG4gICAgICBpZiAoc2Vjb25kcyA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0aW1lIGludGVydmFsIG11c3QgYmUgcG9zaXRpdmUnfVxuICAgICAgfVxuICAgICAgdmFyIGdldF90aW1lID0gT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UgP1xuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCl9XG5cbiAgICAgIHZhciB0ID0gZ2V0X3RpbWUoKTtcbiAgICAgIHdoaWxlIChnZXRfdGltZSgpIC0gdCA8PSBzZWNvbmRzICogMTAwMCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcmFuZChzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIDo6UmFuZG9tLnNyYW5kKHNlZWQpXG4gIGVuZFxuXG4gIGRlZiBTdHJpbmcoc3RyKVxuICAgIDo6T3BhbC5jb2VyY2VfdG8/KHN0ciwgOjpTdHJpbmcsIDp0b19zdHIpIHx8XG4gICAgICA6Ok9wYWwuY29lcmNlX3RvIShzdHIsIDo6U3RyaW5nLCA6dG9fcylcbiAgZW5kXG5cbiAgZGVmIHRhcCgmYmxvY2spXG4gICAgeWllbGQgc2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje19faWRfXy50b19zKDE2KX0+XCJcbiAgZW5kXG5cbiAgZGVmIGNhdGNoKHRhZyA9IG5pbClcbiAgICB0YWcgfHw9IDo6T2JqZWN0Lm5ld1xuICAgIHlpZWxkKHRhZylcbiAgcmVzY3VlIDo6VW5jYXVnaHRUaHJvd0Vycm9yID0+IGVcbiAgICByZXR1cm4gZS52YWx1ZSBpZiBlLnRhZyA9PSB0YWdcbiAgICA6Oktlcm5lbC5yYWlzZVxuICBlbmRcblxuICBkZWYgdGhyb3codGFnLCBvYmogPSBuaWwpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpVbmNhdWdodFRocm93RXJyb3IubmV3KHRhZywgb2JqKVxuICBlbmRcblxuICAjIGJhc2ljIGltcGxlbWVudGF0aW9uIG9mIG9wZW4sIGRlbGVnYXRlIHRvIEZpbGUub3BlblxuICBkZWYgb3BlbigqYXJncywgJmJsb2NrKVxuICAgIDo6RmlsZS5vcGVuKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB5aWVsZF9zZWxmXG4gICAgcmV0dXJuIGVudW1fZm9yKDp5aWVsZF9zZWxmKSB7IDEgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgeWllbGQgc2VsZlxuICBlbmRcblxuICBhbGlhcyBmYWlsIHJhaXNlXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cbiAgYWxpYXMgcHVibGljX3NlbmQgX19zZW5kX19cbiAgYWxpYXMgc2VuZCBfX3NlbmRfX1xuICBhbGlhcyB0aGVuIHlpZWxkX3NlbGZcbiAgYWxpYXMgdG9fZW51bSBlbnVtX2ZvclxuZW5kXG5cbmNsYXNzIDo6T2JqZWN0XG4gICMgT2JqZWN0LnJlcXVpcmUgaGFzIGJlZW4gc2V0IHRvIHJ1bnRpbWUuanMgT3BhbC5yZXF1aXJlXG4gICMgTm93IHdlIGhhdmUgS2VybmVsIGxvYWRlZCwgbWFrZSBzdXJlIE9iamVjdC5yZXF1aXJlIHJlZmVycyB0byBLZXJuZWwucmVxdWlyZVxuICAjIHdoaWNoIGlzIHdoYXQgcnVieSBkb2VzIGFuZCBhbGxvd3MgZm9yIG92ZXJ3cml0aW5nIGJ5IGF1dG9sb2FkZXJzXG4gIGBkZWxldGUgJE9iamVjdC4kJHByb3RvdHlwZS4kcmVxdWlyZWBcbiAgaW5jbHVkZSA6Oktlcm5lbFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsIj1+Iiwib2JqIiwiIX4iLCJzZWxmIiwiISIsIj09PSIsIm90aGVyIiwiJHJldF9vcl8xIiwib2JqZWN0X2lkIiwiPT0iLCI8PT4iLCJtZXRob2QiLCJuYW1lIiwiS2VybmVsIiwicmFpc2UiLCJOYW1lRXJyb3IiLCJuZXciLCJjbGFzcyIsIk1ldGhvZCIsIm1ldGhvZHMiLCJhbGwiLCJwdWJsaWNfbWV0aG9kcyIsIkFycmF5Iiwib2JqZWN0IiwiT3BhbCIsImNvZXJjZV90bz8iLCJhdF9leGl0IiwiJF9fYXRfZXhpdF9fIiwiPDwiLCJibG9jayIsImNhbGxlciIsInN0YXJ0IiwibGVuZ3RoIiwiMSIsImNvcHlfaW5zdGFuY2VfdmFyaWFibGVzIiwiY29weV9zaW5nbGV0b25fbWV0aG9kcyIsImNsb25lIiwiJGt3YXJncyIsImNvcHkiLCJhbGxvY2F0ZSIsImluaXRpYWxpemVfY2xvbmUiLCJpbml0aWFsaXplX2NvcHkiLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImRlZmluZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19wcm9jIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJlbnVtX2ZvciIsImZvciIsIkVudW1lcmF0b3IiLCJhcmdzIiwiZXF1YWw/IiwiZXhpdCIsInN0YXR1cyIsImVtcHR5PyIsInBvcCIsImNhbGwiLCJJbnRlZ2VyIiwiZXh0ZW5kIiwiVHlwZUVycm9yIiwiYXBwZW5kX2ZlYXR1cmVzIiwiZXh0ZW5kX29iamVjdCIsImV4dGVuZGVkIiwiZ2V0cyIsIiRzdGRpbiIsImhhc2giLCJfX2lkX18iLCJpbnNwZWN0IiwiaXZzIiwiaWQiLCJpbmNsdWRlPyIsInB1c2hlZCIsImVhY2giLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJibG9jayBpbiBpbnNwZWN0IiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gaW5zcGVjdCIsIml2YXIiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCIrIiwidG9fcyIsIjE2IiwiU3RhbmRhcmRFcnJvciIsImUiLCJpbnN0YW5jZV9vZj8iLCJrbGFzcyIsImluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJ2YWx1ZSIsInJlbW92ZV9pbnN0YW5jZV92YXJpYWJsZSIsImJhc2UiLCJBcmd1bWVudEVycm9yIiwiRmxvYXREb21haW5FcnJvciIsInJlc3BvbmRfdG8/IiwidG9faW50IiwiY29lcmNlX3RvISIsIkZsb2F0IiwiSGFzaCIsImFyZyIsIm5pbD8iLCJpc19hPyIsIml0c2VsZiIsImxhbWJkYSIsImxvYWQiLCJmaWxlIiwiU3RyaW5nIiwibG9vcCIsImJsb2NrX2dpdmVuPyIsImJsb2NrIGluIGxvb3AiLCJibG9jayAoMiBsZXZlbHMpIGluIGxvb3AiLCJGbG9hdDo6SU5GSU5JVFkiLCJTdG9wSXRlcmF0aW9uIiwicmVzdWx0IiwicHJpbnRmIiwiYW55PyIsInByaW50IiwiZm9ybWF0IiwicHJvYyIsInB1dHMiLCIkc3Rkb3V0Iiwic3RycyIsInAiLCJibG9jayBpbiBwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwIiwiPD0iLCJbXSIsIjAiLCJyZWFkbGluZSIsIndhcm4iLCJ1cGxldmVsIiwiPCIsImxvY2F0aW9uIiwiZmlyc3QiLCJtYXAiLCJibG9jayBpbiB3YXJuIiwicyIsImJsb2NrICgyIGxldmVscykgaW4gd2FybiIsIiRWRVJCT1NFIiwiJHN0ZGVyciIsImV4Y2VwdGlvbiIsInN0cmluZyIsImJhY2t0cmFjZSIsIiQhIiwiUnVudGltZUVycm9yIiwidG9fc3RyIiwiJEAiLCJyYW5kIiwibWF4IiwiUmFuZG9tOjpERUZBVUxUIiwiUmFuZG9tIiwiaW5jbHVkZV9hbGwiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwibWV0aG9kX25hbWUiLCJwcmlzdGluZSIsInJlcXVpcmUiLCJyZXF1aXJlX3JlbGF0aXZlIiwidHJ5X2NvbnZlcnQhIiwiRmlsZSIsImV4cGFuZF9wYXRoIiwiam9pbiIsInJlcXVpcmVfdHJlZSIsInBhdGgiLCJzdGFydF93aXRoPyIsImF1dG9sb2FkIiwic2xlZXAiLCJzZWNvbmRzIiwic3JhbmQiLCJzZWVkIiwibmV3X3NlZWQiLCJzdHIiLCJ0YXAiLCJjYXRjaCIsInRhZyIsIk9iamVjdCIsIlVuY2F1Z2h0VGhyb3dFcnJvciIsInRocm93Iiwib3BlbiIsInlpZWxkX3NlbGYiLCJibG9jayBpbiB5aWVsZF9zZWxmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB5aWVsZF9zZWxmIiwiPGNsYXNzOk9iamVjdD4iLCJpbmNsdWRlIl0sIm1hcHBpbmdzIjoiQUFBQUEsaURBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUM7RUFBQUE7O0lBQUFBOzs7O0FBQ0VDLElBQUFBLGtCQUFBQSw2QkFBT0MsR0FBUEQ7QUFBQUE7TUFDRUEsT0FBQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEsa0JBQUFBLCtCQUFPRCxHQUFQQztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBRUMsSUFBS0gsT0FBQUEsQ0FBR0MsR0FBSEQsQ0FBUEksTUFBQUEsQ0FBQUE7SUFERkYsQ0FBQUEsR0FBQUE7O0FBSUFHLElBQUFBLG1CQUFBQSw2QkFBUUMsS0FBUkQ7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFBRSxDQUFBQSxZQUFBSixJQUFBSyxXQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHSCxLQUFLRSxXQUFBQSxDQUFBQSxDQUFSQyxDQUFWRixDQUFBLENBQUE7UUFBQUYsT0FBQTtNQUFBO1FBQWdDQSxPQUFBRixJQUFLTSxPQUFBQSxDQUFHSCxLQUFIRztNQUFyQztJQURGSixDQUFBQSxHQUFBQTs7QUFJQUssSUFBQUEsbUJBQUFBLDZCQUFRSixLQUFSSTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBOztBQUVBQSxjQUFnQlAsSUFBS00sT0FBQUEsQ0FBR0gsS0FBSEcsQ0FBU0M7O0FBRTlCQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFaRUEsQ0FBQUEsR0FBQUE7O0FBZUFDLElBQUFBLHNCQUFBQSxrQkFBV0MsSUFBWEQ7QUFBQUEsTUFBQUE7OztBQUVGQTs7QUFFQUE7QUFDQUEsUUFBVUUsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQVdDLEtBQUFBLENBQU1MLG9CQUFELEdBQUEsQ0FBcUJDLElBQXJCLENBQUEsR0FBMEJELGVBQTFCLEdB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Qm1KLENBQUFBLEdBQUFwSTtNQUFQO01BQ0EsT0FBQSxvQkFBTTdDLElBQU4sQ0FBQTtJQUZGZ0wsQ0FBQUEsR0FBQUE7SUFLQSxhQUFNLE1BQU4sRUFBVyxPQUFYO0lBQ0EsYUFBTSxVQUFOLEVBQWUsT0FBZjtJQUNBLGFBQU0sV0FBTixFQUFnQixRQUFoQjtJQUNBLGFBQU0sYUFBTixFQUFrQixVQUFsQjtJQUNBLGFBQU0sTUFBTixFQUFXLFVBQVg7SUFDQSxhQUFNLE1BQU4sRUFBVyxZQUFYO0lBQ0FwTCxPQUFBLGFBQU0sU0FBTixFQUFjLFVBQWQ7RUF6dUJGQSxHQUFPLElBQVBBO0VBNHVCQUQsT0FBQXdMO0VBQUFBOzs7O0lBSUdBO0lBQ0RBLE9BQUFuTCxJQUFBb0wsU0FBQUEsQ0FBUTFLLE9BQVIwSztFQUxGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBL3VCQXhMOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1NTUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYWluLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDw8IHNlbGZcbiAgZGVmIHRvX3NcbiAgICAnbWFpbidcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGUobW9kKVxuICAgIDo6T2JqZWN0LmluY2x1ZGUgbW9kXG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZCgqYXJncylcbiAgICBgT3BhbC5PYmplY3QuJGF1dG9sb2FkLmFwcGx5KE9wYWwuT2JqZWN0LCBhcmdzKWBcbiAgZW5kXG5cbiAgIyBDb21waWxlciBvdmVycmlkZXMgdGhpcyBtZXRob2RcbiAgZGVmIHVzaW5nKG1vZClcbiAgICA6Oktlcm5lbC5yYWlzZSAnbWFpbi51c2luZyBpcyBwZXJtaXR0ZWQgb25seSBhdCB0b3BsZXZlbCdcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwidG9fcyIsImluY2x1ZGUiLCJtb2QiLCJPYmplY3QiLCJhdXRvbG9hZCIsInVzaW5nIiwiS2VybmVsIiwicmFpc2UiLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBOzs7O0FBQ0VDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQUE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHVCQUFBQSxtQkFBWUMsR0FBWkQ7QUFBQUE7TUFDRUEsT0FBQUUsT0FBUUYsU0FBQUEsQ0FBU0MsR0FBVEQ7SUFEVkEsQ0FBQUEsR0FBQUE7O0FBSUFHLElBQUFBLHdCQUFBQSxvQkFURixFQVNFQTtBQUFBQSxNQUFBQTs7OztNQVRGOztNQVNlO01BQ1hBLE9BQUNBLDhDQUFEQTtJQURGQSxDQUFBQSxJQUFBQTtJQUtBLE9BQUFDLHFCQUFBQSxpQkFBVUgsR0FBVkc7QUFBQUE7TUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0YsMENBQVBFO0lBRFZGLENBQUFBLEdBQUFBO0VBZEYsNEJBQVNHLElBQVQ7QUFBQVQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU1ODcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yL2Vycm5vLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSA6OkVycm5vXG4gIGVycm9ycyA9IFtcbiAgICBbOkVJTlZBTCwgJ0ludmFsaWQgYXJndW1lbnQnLCAyMl0sXG4gICAgWzpFRVhJU1QsICdGaWxlIGV4aXN0cycsIDE3XSxcbiAgICBbOkVJU0RJUiwgJ0lzIGEgZGlyZWN0b3J5JywgMjFdLFxuICAgIFs6RU1GSUxFLCAnVG9vIG1hbnkgb3BlbiBmaWxlcycsIDI0XSxcbiAgICBbOkVBQ0NFUywgJ1Blcm1pc3Npb24gZGVuaWVkJywgMTNdLFxuICAgIFs6RVBFUk0sICdPcGVyYXRpb24gbm90IHBlcm1pdHRlZCcsIDFdLFxuICAgIFs6RU5PRU5ULCAnTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScsIDJdXG4gIF1cblxuICBrbGFzcyA9IG5pbFxuXG4gICV4e1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbigpIHsgLy8gQ3JlYXRlIGEgY2xvc3VyZVxuICAgICAgICB2YXIgY2xhc3NfbmFtZSA9IGVycm9yc1tpXVswXTtcbiAgICAgICAgdmFyIGRlZmF1bHRfbWVzc2FnZSA9IGVycm9yc1tpXVsxXTtcbiAgICAgICAgdmFyIGVycm5vID0gZXJyb3JzW2ldWzJdO1xuXG4gICAgICAgIGtsYXNzID0gT3BhbC5rbGFzcyhzZWxmLCBPcGFsLlN5c3RlbUNhbGxFcnJvciwgY2xhc3NfbmFtZSk7XG4gICAgICAgIGtsYXNzLmVycm5vID0gZXJybm87XG5cbiAgICAgICAgI3tcbiAgICAgICAgICBjbGFzcyA8PCBrbGFzc1xuICAgICAgICAgICAgZGVmIG5ldyhuYW1lID0gbmlsKVxuICAgICAgICAgICAgICBtZXNzYWdlID0gYGRlZmF1bHRfbWVzc2FnZWBcbiAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAtICN7bmFtZX1cIiBpZiBuYW1lXG4gICAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG4gIH1cbmVuZFxuXG5jbGFzcyA6OlN5c3RlbUNhbGxFcnJvciA8IDo6U3RhbmRhcmRFcnJvclxuICBkZWYgZXJybm9cbiAgICBzZWxmLmNsYXNzLmVycm5vXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhdHRyX3JlYWRlciA6ZXJybm9cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpFcnJubz4iLCJlcnJvcnMiLCIyMiIsIjE3IiwiMjEiLCIyNCIsIjEzIiwiMSIsIjIiLCJrbGFzcyIsIm5ldyIsIm5hbWUiLCJtZXNzYWdlIiwiKyIsInNlbGYiLCI8Y2xhc3M6U3lzdGVtQ2FsbEVycm9yPiIsImVycm5vIiwiY2xhc3MiLCJhdHRyX3JlYWRlciIsIlN0YW5kYXJkRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxzREFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxTQUFTLENBQ1AsQ0FBQyxRQUFELEVBQVVELGtCQUFWLEVBQThCRSxFQUE5QixDQURPLEVBRVAsQ0FBQyxRQUFELEVBQVVGLGFBQVYsRUFBeUJHLEVBQXpCLENBRk8sRUFHUCxDQUFDLFFBQUQsRUFBVUgsZ0JBQVYsRUFBNEJJLEVBQTVCLENBSE8sRUFJUCxDQUFDLFFBQUQsRUFBVUoscUJBQVYsRUFBaUNLLEVBQWpDLENBSk8sRUFLUCxDQUFDLFFBQUQsRUFBVUwsbUJBQVYsRUFBK0JNLEVBQS9CLENBTE8sRUFNUCxDQUFDLE9BQUQsRUFBU04seUJBQVQsRUFBb0NPLENBQXBDLENBTk8sRUFPUCxDQUFDLFFBQUQsRUFBVVAsMkJBQVYsRUFBdUNRLENBQXZDLENBUE87SUFVVEMsUUFBUTs7QUFHVlQ7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQSxRQUNVOztNQUNFLE9BQUFVLG1CQUFBQSxnQkFBUUMsSUFBUkQ7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFBUSx5QkFBTyxHQUFQO1FBQ05FLFVBQVdGO1FBQ1gsSUFBQSxRQUEyQkMsSUFBM0IsQ0FBQTtVQUFBQyxVQUFRQyxTQUFSRCxPQUFRQyxFQUFJSCxLQUFELEdBQUEsQ0FBTUMsSUFBTixDQUFIRTtRQUFSO1FBQ0FILE9BQUEsT0FBQUksSUFBQSxFQUFBLDZDQUFBLE9BQUEsRUFBQSxDQUFNRixPQUFOLENBQUEsRUFBQSxJQUFBO01BSEZGLENBQUFBLElBQUFBO0lBREYsNEJBQVNELEtBQVQ7QUFRVlQ7QUFDQUE7QUFDQUE7RUFuQ0FBLEdBQU8sSUFBUEE7RUFzQ0FELE9BQUFnQjtFQUFBQTs7SUFBQUE7Ozs7QUFDRUMsSUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUYsSUFBSUcsT0FBQUEsQ0FBQUEsQ0FBTUQsT0FBQUEsQ0FBQUE7SUFEWkEsQ0FBQUEsR0FBQUE7SUFJQUQsT0FBQTs7TUFDRSxPQUFBRCxJQUFBSSxhQUFBQSxDQUFZLE9BQVpBO0lBREYsNEJBQVNKLElBQVQ7RUFMRkMsR0FBTSxJQUFOQSxFQUEwQkksb0JBQTFCSjtBQXRDQWhCOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1NjUwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lcnJvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6OkV4Y2VwdGlvbiA8IGBFcnJvcmBcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19leGNlcHRpb24nLCB0cnVlKWBcbiAgYHZhciBzdGFja190cmFjZV9saW1pdGBcblxuICBkZWYgc2VsZi5uZXcoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgbWVzc2FnZSAgID0gKGFyZ3MubGVuZ3RoID4gMCkgPyBhcmdzWzBdIDogbmlsO1xuICAgICAgdmFyIGVycm9yICAgICA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3IobWVzc2FnZSk7XG4gICAgICBlcnJvci5uYW1lICAgID0gc2VsZi4kJG5hbWU7XG4gICAgICBlcnJvci5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIGVycm9yLmNhdXNlICAgPSAjeyQhfTtcbiAgICAgIE9wYWwuc2VuZChlcnJvciwgZXJyb3IuJGluaXRpYWxpemUsIGFyZ3MpO1xuXG4gICAgICAvLyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSgpIHdpbGwgdXNlIC5uYW1lIGFuZCAudG9TdHJpbmcgdG8gYnVpbGQgdGhlXG4gICAgICAvLyBmaXJzdCBsaW5lIG9mIHRoZSBzdGFjayB0cmFjZSBzbyBpdCBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGUgZXJyb3JcbiAgICAgIC8vIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXY2LngvZG9jcy9hcGkvZXJyb3JzLmh0bWxcbiAgICAgIGlmIChPcGFsLmNvbmZpZy5lbmFibGVfc3RhY2tfdHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgLy8gUGFzc2luZyBLZXJuZWwucmFpc2Ugd2lsbCBjdXQgdGhlIHN0YWNrIHRyYWNlIGZyb20gdGhhdCBwb2ludCBhYm92ZVxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgc3RhY2tfdHJhY2VfbGltaXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICBlbmRcbiAgYHN0YWNrX3RyYWNlX2xpbWl0ID0gc2VsZi4kbmV3YFxuXG4gIGRlZiBzZWxmLmV4Y2VwdGlvbigqYXJncylcbiAgICBuZXcoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgICMgdXNpbmcgc2VsZi5tZXNzYWdlIGFrYSBAbWVzc2FnZSB0byByZXRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG5hdGl2ZSBleGNlcHRpb24ncyBtZXNzYWdlIHByb3BlcnR5XG4gICAgYHNlbGYubWVzc2FnZSA9IChhcmdzLmxlbmd0aCA+IDApID8gYXJnc1swXSA6IG5pbGBcbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gQ29udmVydCBiYWNrdHJhY2UgZnJvbSBhbnkgZm9ybWF0IHRvIFJ1YnkgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlKSB7XG4gICAgICB2YXIgbmV3X2J0ID0gW10sIG07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFja3RyYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsb2MgPSBiYWNrdHJhY2VbaV07XG4gICAgICAgIGlmICghbG9jIHx8ICFsb2MuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAvKiBEbyBub3RoaW5nICovXG4gICAgICAgIH1cbiAgICAgICAgLyogQ2hyb21pdW0gZm9ybWF0ICovXG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICAgIGF0ICguKj8pIFxcKCguKj8pXFwpJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMl0gKyBcIjppbiBgXCIgKyBtWzFdICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICAgIGF0ICguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMV0gKyBcIjppbiBgdW5kZWZpbmVkJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBOb2RlIGZvcm1hdCAqL1xuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiAgZnJvbSAoLio/KSQvKSkpIHtcbiAgICAgICAgICBuZXdfYnQucHVzaChtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBNb3ppbGxhL0FwcGxlIGZvcm1hdCAqL1xuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiguKj8pQCguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMl0gKyAnOmluIGAnICsgbVsxXSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3X2J0O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBiYWNrdHJhY2VcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkge1xuICAgICAgICAvLyBuaWwgaXMgYSB2YWxpZCBiYWNrdHJhY2VcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFja3RyYWNlID0gc2VsZi5zdGFjaztcblxuICAgICAgaWYgKHR5cGVvZihiYWNrdHJhY2UpICE9PSAndW5kZWZpbmVkJyAmJiBiYWNrdHJhY2UuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlID0gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDAsIDE1KSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiYWNrdHJhY2UpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlID0gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlLnNsaWNlKDAsIDE1KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBiYWNrdHJhY2VfbG9jYXRpb25zXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zKSByZXR1cm4gc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zO1xuICAgICAgc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zID0gI3tiYWNrdHJhY2UmLm1hcCBkbyB8bG9jfFxuICAgICAgICA6OlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbi5uZXcobG9jKVxuICAgICAgZW5kfVxuICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjYXVzZVxuICAgIGBzZWxmLmNhdXNlIHx8IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdGlvbihzdHIgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoc3RyID09PSBuaWwgfHwgc2VsZiA9PT0gc3RyKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmVkID0gI3tjbG9uZX07XG4gICAgICBjbG9uZWQubWVzc2FnZSA9IHN0cjtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkgY2xvbmVkLmJhY2t0cmFjZSA9IHNlbGYuYmFja3RyYWNlLiRkdXAoKTtcbiAgICAgIGNsb25lZC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICBjbG9uZWQuY2F1c2UgPSBzZWxmLmNhdXNlO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIGVuZFxuXG4gICMgbm90IHVzaW5nIGFsaWFzIG1lc3NhZ2UgdG9fcyBiZWNhdXNlIHlvdSBuZWVkIHRvIGJlIGFibGUgdG8gb3ZlcnJpZGUgdG9fcyBhbmQgaGF2ZSBtZXNzYWdlIHVzZSBvdmVycmlkZGVuIG1ldGhvZCwgd29uJ3Qgd29yayB3aXRoIGFsaWFzXG4gIGRlZiBtZXNzYWdlXG4gICAgdG9fc1xuICBlbmRcblxuICBkZWYgZnVsbF9tZXNzYWdlKGt3YXJncyA9IG5pbClcbiAgICB1bmxlc3MgZGVmaW5lZD8gSGFzaFxuICAgICAgIyBXZSBhcmUgZGVhbGluZyB3aXRoIGFuIHVuZnVsbHkgbG9hZGVkIE9wYWwgbGlicmFyeSwgc28gd2Ugc2hvdWxkXG4gICAgICAjIGRvIHdpdGggYXMgbGl0dGxlIGFzIHdlIGNhbi5cblxuICAgICAgcmV0dXJuIFwiI3tAbWVzc2FnZX1cXG4je2BzZWxmLnN0YWNrYH1cIlxuICAgIGVuZFxuXG4gICAga3dhcmdzID0geyBoaWdobGlnaHQ6ICRzdGRlcnIudHR5Pywgb3JkZXI6IDp0b3AgfS5tZXJnZShrd2FyZ3MgfHwge30pXG4gICAgaGlnaGxpZ2h0LCBvcmRlciA9IGt3YXJnc1s6aGlnaGxpZ2h0XSwga3dhcmdzWzpvcmRlcl1cblxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJleHBlY3RlZCB0cnVlIG9yIGZhbHNlIGFzIGhpZ2hsaWdodDogI3toaWdobGlnaHR9XCIgdW5sZXNzIFt0cnVlLCBmYWxzZV0uaW5jbHVkZT8gaGlnaGxpZ2h0XG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImV4cGVjdGVkIDp0b3Agb3IgOmJvdHRvbSBhcyBvcmRlcjogI3tvcmRlcn1cIiB1bmxlc3MgJWlbdG9wIGJvdHRvbV0uaW5jbHVkZT8gb3JkZXJcblxuICAgIGlmIGhpZ2hsaWdodFxuICAgICAgYm9sZF91bmRlcmxpbmUgPSBcIlxcZVsxOzRtXCJcbiAgICAgIGJvbGQgPSBcIlxcZVsxbVwiXG4gICAgICByZXNldCA9IFwiXFxlW21cIlxuICAgIGVsc2VcbiAgICAgIGJvbGRfdW5kZXJsaW5lID0gYm9sZCA9IHJlc2V0ID0gJydcbiAgICBlbmRcblxuICAgIGJ0ID0gYmFja3RyYWNlLmR1cFxuICAgIGJ0ID0gY2FsbGVyIGlmICFidCB8fCBidC5lbXB0eT9cbiAgICBmaXJzdCA9IGJ0LnNoaWZ0XG5cbiAgICBtc2cgPSBcIiN7Zmlyc3R9OiBcIlxuICAgIG1zZyArPSBcIiN7Ym9sZH0je3RvX3N9ICgje2JvbGRfdW5kZXJsaW5lfSN7c2VsZi5jbGFzc30je3Jlc2V0fSN7Ym9sZH0pI3tyZXNldH1cXG5cIlxuXG4gICAgbXNnICs9IGJ0Lm1hcCB7IHxsb2N8IFwiXFx0ZnJvbSAje2xvY31cXG5cIiB9LmpvaW5cblxuICAgIG1zZyArPSBjYXVzZS5mdWxsX21lc3NhZ2UoaGlnaGxpZ2h0OiBoaWdobGlnaHQpIGlmIGNhdXNlXG5cbiAgICBpZiBvcmRlciA9PSA6Ym90dG9tXG4gICAgICBtc2cgPSBtc2cuc3BsaXQoXCJcXG5cIikucmV2ZXJzZS5qb2luKFwiXFxuXCIpXG4gICAgICBtc2cgPSBcIiN7Ym9sZH1UcmFjZWJhY2sje3Jlc2V0fSAobW9zdCByZWNlbnQgY2FsbCBsYXN0KTpcXG5cIiArIG1zZ1xuICAgIGVuZFxuXG4gICAgbXNnXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgYXNfc3RyID0gdG9fc1xuICAgIGFzX3N0ci5lbXB0eT8gPyBzZWxmLmNsYXNzLnRvX3MgOiBcIiM8I3tzZWxmLmNsYXNzLnRvX3N9OiAje3RvX3N9PlwiXG4gIGVuZFxuXG4gIGRlZiBzZXRfYmFja3RyYWNlKGJhY2t0cmFjZSlcbiAgICAleHtcbiAgICAgIHZhciB2YWxpZCA9IHRydWUsIGksIGlpO1xuXG4gICAgICBpZiAoYmFja3RyYWNlID09PSBuaWwpIHtcbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBuaWw7XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoYmFja3RyYWNlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gW2JhY2t0cmFjZV07XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnICBmcm9tICcgKyBiYWNrdHJhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFja3RyYWNlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJhY2t0cmFjZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWJhY2t0cmFjZVtpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnYmFja3RyYWNlIG11c3QgYmUgQXJyYXkgb2YgU3RyaW5nJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gYmFja3RyYWNlO1xuICAgICAgICBzZWxmLnN0YWNrID0gI3tgYmFja3RyYWNlYC5tYXAgeyB8aXwgJyAgZnJvbSAnICsgaSB9fS5qb2luKFwiXFxuXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFja3RyYWNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICAjIHVzaW5nIHNlbGYubWVzc2FnZSBha2EgQG1lc3NhZ2UgdG8gcmV0YWluIGNvbXBhdGliaWxpdHkgd2l0aCBuYXRpdmUgZXhjZXB0aW9uJ3MgbWVzc2FnZSBwcm9wZXJ0eVxuICAgIChAbWVzc2FnZSAmJiBAbWVzc2FnZS50b19zKSB8fCBzZWxmLmNsYXNzLnRvX3NcbiAgZW5kXG5lbmRcblxuIyBrZWVwIHRoZSBpbmRlbnRhdGlvbiwgaXQgbWFrZXMgdGhlIGV4Y2VwdGlvbiBoaWVyYXJjaHkgY2xlYXJcbmNsYXNzIDo6U2NyaXB0RXJyb3IgICAgICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OlN5bnRheEVycm9yICAgICAgICAgPCA6OlNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIDo6TG9hZEVycm9yICAgICAgICAgICA8IDo6U2NyaXB0RXJyb3I7IGVuZFxuY2xhc3MgOjpOb3RJbXBsZW1lbnRlZEVycm9yIDwgOjpTY3JpcHRFcnJvcjsgZW5kXG5cbmNsYXNzIDo6U3lzdGVtRXhpdCAgICAgICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6Ok5vTWVtb3J5RXJyb3IgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpTaWduYWxFeGNlcHRpb24gICA8IDo6RXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6SW50ZXJydXB0ICAgICAgICAgICA8IDo6U2lnbmFsRXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6U2VjdXJpdHlFcnJvciAgICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OlN5c3RlbVN0YWNrRXJyb3IgIDwgOjpFeGNlcHRpb247IGVuZFxuXG5jbGFzcyA6OlN0YW5kYXJkRXJyb3IgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpFbmNvZGluZ0Vycm9yICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6WmVyb0RpdmlzaW9uRXJyb3IgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6Ok5hbWVFcnJvciAgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpOb01ldGhvZEVycm9yICAgICAgICAgPCA6Ok5hbWVFcnJvcjsgZW5kXG5jbGFzcyA6OlJ1bnRpbWVFcnJvciAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpGcm96ZW5FcnJvciAgICAgICAgICAgPCA6OlJ1bnRpbWVFcnJvcjsgZW5kXG5jbGFzcyA6OkxvY2FsSnVtcEVycm9yICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpUeXBlRXJyb3IgICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6QXJndW1lbnRFcnJvciAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OlVuY2F1Z2h0VGhyb3dFcnJvciAgICA8IDo6QXJndW1lbnRFcnJvcjsgZW5kXG5jbGFzcyA6OkluZGV4RXJyb3IgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpTdG9wSXRlcmF0aW9uICAgICAgICAgPCA6OkluZGV4RXJyb3I7IGVuZFxuY2xhc3MgOjpDbG9zZWRRdWV1ZUVycm9yICAgICAgICA8IDo6U3RvcEl0ZXJhdGlvbjsgZW5kXG5jbGFzcyA6OktleUVycm9yICAgICAgICAgICAgICA8IDo6SW5kZXhFcnJvcjsgZW5kXG5jbGFzcyA6OlJhbmdlRXJyb3IgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpGbG9hdERvbWFpbkVycm9yICAgICAgPCA6OlJhbmdlRXJyb3I7IGVuZFxuY2xhc3MgOjpJT0Vycm9yICAgICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6RU9GRXJyb3IgICAgICAgICAgICAgIDwgOjpJT0Vycm9yOyBlbmRcbmNsYXNzIDo6U3lzdGVtQ2FsbEVycm9yICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OlJlZ2V4cEVycm9yICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpUaHJlYWRFcnJvciAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6RmliZXJFcnJvciAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5cbjo6T2JqZWN0LmF1dG9sb2FkIDpFcnJubywgJ2NvcmVsaWIvZXJyb3IvZXJybm8nXG5cbmNsYXNzIDo6VW5jYXVnaHRUaHJvd0Vycm9yIDwgOjpBcmd1bWVudEVycm9yXG4gIGF0dHJfcmVhZGVyIDp0YWcsIDp2YWx1ZVxuXG4gIGRlZiBpbml0aWFsaXplKHRhZywgdmFsdWUgPSBuaWwpXG4gICAgQHRhZyA9IHRhZ1xuICAgIEB2YWx1ZSA9IHZhbHVlXG5cbiAgICBzdXBlcihcInVuY2F1Z2h0IHRocm93ICN7QHRhZy5pbnNwZWN0fVwiKVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6Ok5hbWVFcnJvclxuICBhdHRyX3JlYWRlciA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwpXG4gICAgc3VwZXIgbWVzc2FnZVxuICAgIEBuYW1lID0gbmFtZVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6Ok5vTWV0aG9kRXJyb3JcbiAgYXR0cl9yZWFkZXIgOmFyZ3NcblxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCBuYW1lID0gbmlsLCBhcmdzID0gW10pXG4gICAgc3VwZXIgbWVzc2FnZSwgbmFtZVxuICAgIEBhcmdzID0gYXJnc1xuICBlbmRcbmVuZFxuXG5jbGFzcyA6OlN0b3BJdGVyYXRpb25cbiAgYXR0cl9yZWFkZXIgOnJlc3VsdFxuZW5kXG5cbmNsYXNzIDo6S2V5RXJyb3JcbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgcmVjZWl2ZXI6IG5pbCwga2V5OiBuaWwpXG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICAgIEBrZXkgPSBrZXlcbiAgZW5kXG5cbiAgZGVmIHJlY2VpdmVyXG4gICAgQHJlY2VpdmVyIHx8IDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgJ25vIHJlY2VpdmVyIGlzIGF2YWlsYWJsZScpXG4gIGVuZFxuXG4gIGRlZiBrZXlcbiAgICBAa2V5IHx8IDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgJ25vIGtleSBpcyBhdmFpbGFibGUnKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgOjpKU1xuICBjbGFzcyBFcnJvclxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RXhjZXB0aW9uPiIsIm5ldyIsInNlbGYiLCIkISIsImV4Y2VwdGlvbiIsImFyZ3MiLCJpbml0aWFsaXplIiwiYmFja3RyYWNlIiwiYmFja3RyYWNlX2xvY2F0aW9ucyIsImJsb2NrIGluIGJhY2t0cmFjZV9sb2NhdGlvbnMiLCJsb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIGJhY2t0cmFjZV9sb2NhdGlvbnMiLCJUaHJlYWQ6OkJhY2t0cmFjZTo6TG9jYXRpb24iLCJUaHJlYWQ6OkJhY2t0cmFjZSIsIlRocmVhZCIsImNhdXNlIiwic3RyIiwiY2xvbmUiLCJtZXNzYWdlIiwidG9fcyIsImZ1bGxfbWVzc2FnZSIsImt3YXJncyIsIkBtZXNzYWdlIiwiJHN0ZGVyciIsInR0eT8iLCJtZXJnZSIsIiRyZXRfb3JfMSIsIltdIiwiaGlnaGxpZ2h0Iiwib3JkZXIiLCJpbmNsdWRlPyIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImJvbGRfdW5kZXJsaW5lIiwiYm9sZCIsInJlc2V0IiwiYnQiLCJkdXAiLCJlbXB0eT8iLCJjYWxsZXIiLCJmaXJzdCIsInNoaWZ0IiwibXNnIiwiKyIsImNsYXNzIiwibWFwIiwiYmxvY2sgaW4gZnVsbF9tZXNzYWdlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmdWxsX21lc3NhZ2UiLCJqb2luIiwic3BsaXQiLCJyZXZlcnNlIiwiaW5zcGVjdCIsImFzX3N0ciIsInNldF9iYWNrdHJhY2UiLCJUeXBlRXJyb3IiLCJibG9jayBpbiBzZXRfYmFja3RyYWNlIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gc2V0X2JhY2t0cmFjZSIsIiRyZXRfb3JfMiIsIjxjbGFzczpTY3JpcHRFcnJvcj4iLCJFeGNlcHRpb24iLCI8Y2xhc3M6U3ludGF4RXJyb3I+IiwiU2NyaXB0RXJyb3IiLCI8Y2xhc3M6TG9hZEVycm9yPiIsIjxjbGFzczpOb3RJbXBsZW1lbnRlZEVycm9yPiIsIjxjbGFzczpTeXN0ZW1FeGl0PiIsIjxjbGFzczpOb01lbW9yeUVycm9yPiIsIjxjbGFzczpTaWduYWxFeGNlcHRpb24+IiwiPGNsYXNzOkludGVycnVwdD4iLCJTaWduYWxFeGNlcHRpb24iLCI8Y2xhc3M6U2VjdXJpdHlFcnJvcj4iLCI8Y2xhc3M6U3lzdGVtU3RhY2tFcnJvcj4iLCI8Y2xhc3M6U3RhbmRhcmRFcnJvcj4iLCI8Y2xhc3M6RW5jb2RpbmdFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOlplcm9EaXZpc2lvbkVycm9yPiIsIjxjbGFzczpOYW1lRXJyb3I+IiwiPGNsYXNzOk5vTWV0aG9kRXJyb3I+IiwiTmFtZUVycm9yIiwiPGNsYXNzOlJ1bnRpbWVFcnJvcj4iLCI8Y2xhc3M6RnJvemVuRXJyb3I+IiwiUnVudGltZUVycm9yIiwiPGNsYXNzOkxvY2FsSnVtcEVycm9yPiIsIjxjbGFzczpUeXBlRXJyb3I+IiwiPGNsYXNzOkFyZ3VtZW50RXJyb3I+IiwiPGNsYXNzOlVuY2F1Z2h0VGhyb3dFcnJvcj4iLCI8Y2xhc3M6SW5kZXhFcnJvcj4iLCI8Y2xhc3M6U3RvcEl0ZXJhdGlvbj4iLCJJbmRleEVycm9yIiwiPGNsYXNzOkNsb3NlZFF1ZXVlRXJyb3I+IiwiU3RvcEl0ZXJhdGlvbiIsIjxjbGFzczpLZXlFcnJvcj4iLCI8Y2xhc3M6UmFuZ2VFcnJvcj4iLCI8Y2xhc3M6RmxvYXREb21haW5FcnJvcj4iLCJSYW5nZUVycm9yIiwiPGNsYXNzOklPRXJyb3I+IiwiPGNsYXNzOkVPRkVycm9yPiIsIklPRXJyb3IiLCI8Y2xhc3M6U3lzdGVtQ2FsbEVycm9yPiIsIjxjbGFzczpSZWdleHBFcnJvcj4iLCI8Y2xhc3M6VGhyZWFkRXJyb3I+IiwiPGNsYXNzOkZpYmVyRXJyb3I+IiwiT2JqZWN0IiwiYXV0b2xvYWQiLCJhdHRyX3JlYWRlciIsInRhZyIsInZhbHVlIiwiQHRhZyIsIkB2YWx1ZSIsIm5hbWUiLCJAbmFtZSIsIkBhcmdzIiwiJGt3YXJncyIsIkByZWNlaXZlciIsInJlY2VpdmVyIiwiQGtleSIsImtleSIsIjxtb2R1bGU6SlM+IiwiPGNsYXNzOkVycm9yPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGdE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QTNGLENBQUFBLFlBQUEwRixRQUFBMUYsQ0FBQSxDQUFBO1FBQUEyRixPQUFBO01BQUE7UUFBUUEsT0FBQXRGLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDb0YscUJBQXhCckY7TUFBaEI7SUFERnFGLENBQUFBLEdBQUFBO0VBWEZ6QixHQUFNLElBQU5BLEVBQUFBLElBQUFBO0VBZ0JBN0YsT0FBQXVIO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsUUFBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFERkQsR0FBTyxJQUFQQTtBQXZTQXZIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo2MDc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb25zdGFudHMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiOjpSVUJZX1BMQVRGT1JNICAgICAgID0gJ29wYWwnXG46OlJVQllfRU5HSU5FICAgICAgICAgPSAnb3BhbCdcbjo6UlVCWV9WRVJTSU9OICAgICAgICA9ICczLjEuMCdcbjo6UlVCWV9FTkdJTkVfVkVSU0lPTiA9ICcxLjQuMSdcbjo6UlVCWV9SRUxFQVNFX0RBVEUgICA9ICcyMDIyLTAxLTEyJ1xuOjpSVUJZX1BBVENITEVWRUwgICAgID0gMFxuOjpSVUJZX1JFVklTSU9OICAgICAgID0gJzAnXG46OlJVQllfQ09QWVJJR0hUICAgICAgPSAnb3BhbCAtIENvcHlyaWdodCAoQykgMjAxMy0yMDIxIEFkYW0gQmV5bm9uIGFuZCB0aGUgT3BhbCBjb250cmlidXRvcnMnXG46OlJVQllfREVTQ1JJUFRJT04gICAgPSBcIm9wYWwgI3s6OlJVQllfRU5HSU5FX1ZFUlNJT059ICgjezo6UlVCWV9SRUxFQVNFX0RBVEV9IHJldmlzaW9uICN7OjpSVUJZX1JFVklTSU9OfSlcIlxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCIwIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsIlJVQllfUkVMRUFTRV9EQVRFIiwiUlVCWV9SRVZJU0lPTiJdLCJtYXBwaW5ncyI6IkFBQUFBLG9EQUFBQTtFQUFBQTs7O0VBQUEsV0FBQSxJQUFBLG1CQUF3QkEsTUFBeEI7RUFDQSxXQUFBLElBQUEsaUJBQXdCQSxNQUF4QjtFQUNBLFdBQUEsSUFBQSxrQkFBd0JBLE9BQXhCO0VBQ0EsV0FBQSxJQUFBLHlCQUF3QkEsT0FBeEI7RUFDQSxXQUFBLElBQUEsdUJBQXdCQSxZQUF4QjtFQUNBLFdBQUEsSUFBQSxxQkFBd0JDLENBQXhCO0VBQ0EsV0FBQSxJQUFBLG1CQUF3QkQsR0FBeEI7RUFDQSxXQUFBLElBQUEsb0JBQXdCQSxzRUFBeEI7RUFDQUEsT0FBQSxXQUFBLElBQUEsc0JBQXlCQSxPQUFELEdBQUEsQ0FBUUUsMEJBQVIsQ0FBQSxHQUE4QkYsSUFBOUIsR0FBQSxDQUFrQ0csd0JBQWxDLENBQUEsR0FBc0RILFlBQXRELEdBQUEsQ0FBa0VJLG9CQUFsRSxDQUFBLEdBQWtGSixHQUExRztBQVJBQTsifX0seyJvZmZzZXQiOnsibGluZSI6NjA5MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyI6Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3J1bnRpbWUnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2hlbHBlcnMnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL21vZHVsZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY2xhc3MnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2Jhc2ljX29iamVjdCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIva2VybmVsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9tYWluJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9lcnJvcidcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb25zdGFudHMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIk9iamVjdCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQSw0Q0FBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixpQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsaUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixlQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixzQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGNBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGVBQVRFO0VBRVJGLE9BQUFDLE9BQVFDLFNBQUFBLENBQVNGLG1CQUFURTtBQVRSRjsifX0seyJvZmZzZXQiOnsibGluZSI6NjEwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbmlsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6TmlsQ2xhc3NcbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRtZXRhID0gI3tzZWxmfWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcbiAgZW5kXG5cbiAgZGVmICFcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIGBvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYG90aGVyID09PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogdHJ1ZSlcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAnbmlsJ1xuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIDo6TmlsQ2xhc3NcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbXVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIGBPcGFsLmhhc2goKWBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgJydcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICA6OkNvbXBsZXgubmV3KDAsIDApXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZSgqYXJncylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IgaWYgYXJncy5sZW5ndGggPiAxXG4gICAgOjpLZXJuZWwuUmF0aW9uYWwoMCwgMSlcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICA6Oktlcm5lbC5SYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgdG9fZiB0b19pXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk5pbENsYXNzPiIsInNlbGYiLCJhbGxvY2F0ZSIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwibmFtZSIsIiEiLCImIiwib3RoZXIiLCJ8IiwiXiIsIj09IiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwiaW5zcGVjdCIsIm5pbD8iLCJzaW5nbGV0b25fY2xhc3MiLCJOaWxDbGFzcyIsInRvX2EiLCJ0b19oIiwidG9faSIsIjAiLCJ0b19zIiwidG9fYyIsIkNvbXBsZXgiLCJuZXciLCJyYXRpb25hbGl6ZSIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMSIsIkFy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Q0VBLE9BQUE7SUFERkEsQ0FBQUEsR0FBQUE7SUFJQXBDLE9BQUEsYUFBTSxNQUFOLEVBQVcsTUFBWDtFQXBGRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NjI0OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYm9vbGVhbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHVzZV9zdHJpY3Q6IHRydWVcblxuY2xhc3MgOjpCb29sZWFuIDwgYEJvb2xlYW5gXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfYm9vbGVhbicsIHRydWUpYFxuXG4gICV4e1xuICAgIHZhciBwcm9wZXJ0aWVzID0gWyckJGNsYXNzJywgJyQkbWV0YSddO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgcHJvcGVydGllc1tpXSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzID09IHRydWUgID8gT3BhbC5UcnVlQ2xhc3MgOlxuICAgICAgICAgICAgICAgICB0aGlzID09IGZhbHNlID8gT3BhbC5GYWxzZUNsYXNzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wYWwuQm9vbGVhbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsIFwiJCRpZFwiLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IHRydWUgID8gMiA6XG4gICAgICAgICAgICAgICB0aGlzID09IGZhbHNlID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmlsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiBfX2lkX19cbiAgICBgc2VsZi52YWx1ZU9mKCkgPyAyIDogMGBcbiAgZW5kXG5cbiAgZGVmICFcbiAgICBgc2VsZiAhPSB0cnVlYFxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpIDogZmFsc2VgXG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IHRydWUgOiAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpYFxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAob3RoZXIgPT09IGZhbHNlIHx8IG90aGVyID09PSBuaWwpIDogKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKWBcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA9PT0gb3RoZXIudmFsdWVPZigpYFxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgYHNlbGYuJCRtZXRhYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAoc2VsZiA9PSB0cnVlKSA/ICd0cnVlJyA6ICdmYWxzZSdgXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICAjIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvMjIzMFxuICAjXG4gICMgVGhpcyBpcyBhIGhhY2sgdGhhdCBhbGxvd3MgeW91IHRvIGFkZCBtZXRob2RzIHRvIFRydWVDbGFzcyBhbmQgRmFsc2VDbGFzcy5cbiAgIyBEbyBub3RlLCB0aGF0IHdoaWxlIHRydWUgYW5kIGZhbHNlIGhhdmUgYSBjb3JyZWN0ICQkY2xhc3MgKGl0J3MgZWl0aGVyXG4gICMgVHJ1ZUNsYXNzIG9yIEZhbHNlQ2xhc3MpLCB0aGVpciBwcm90b3R5cGUgaXMgYEJvb2xlYW4uJCRwcm90b3R5cGVgLCB3aGljaFxuICAjIGJhc2ljYWxseSBtZWFucyB0aGF0IHdoZW4gY2FsbGluZyBgdHJ1ZS5zb21ldGhpbmdgIHdlIGFjdHVhbGx5IGNhbGxcbiAgIyBgQm9vbGVhbiNzb21ldGhpbmdgIGluc3RlYWQgb2YgYFRydWVDbGFzcyNzb21ldGhpbmdgLiBTbyB1c2luZ1xuICAjIG1ldGhvZF9taXNzaW5nIHdlIGRpc3BhdGNoIGl0IHRvIGBUcnVlQ2xhc3MvRmFsc2VDbGFzcyNzb21ldGhpbmdgIGNvcnJlY3RseS5cbiAgI1xuICAjIFRoZSBkb3duc2lkZSBpcyB0aGF0IGEgY29ycmVjdCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBhbHNvIGFsbG93IHVzIHRvIG92ZXJyaWRlXG4gICMgdGhlIG1ldGhvZHMgZGVmaW5lZCBvbiBCb29sZWFuLCBidXQgb3VyIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgYWxsb3cgdGhhdCxcbiAgIyB1bmxlc3MgeW91IGRlZmluZSB0aGVtIG9uIEJvb2xlYW4gYW5kIG5vdCBvbiBUcnVlQ2xhc3MvRmFsc2VDbGFzcy5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgICBgdmFyIGJvZHkgPSBzZWxmLiQkY2xhc3MuJCRwcm90b3R5cGVbJyQnICsgI3ttZXRob2R9XWBcbiAgICBzdXBlciB1bmxlc3MgYHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyAmJiAhYm9keS4kJHN0dWJgXG4gICAgYE9wYWwuc2VuZChzZWxmLCBib2R5LCAje2FyZ3N9LCAje2Jsb2NrfSlgXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZCwgX2luY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgYHZhciBib2R5ID0gc2VsZi4kJGNsYXNzLiQkcHJvdG90eXBlWyckJyArICN7bWV0aG9kfV1gXG4gICAgYHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyAmJiAhYm9keS4kJHN0dWJgXG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgZXF1YWw/ID09XG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5lbmRcblxuY2xhc3MgOjpUcnVlQ2xhc3MgPCA6OkJvb2xlYW47IGVuZFxuY2xhc3MgOjpGYWxzZUNsYXNzIDwgOjpCb29sZWFuOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJvb2xlYW4+IiwiYWxsb2NhdGUiLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsInNlbGYiLCJuYW1lIiwiX19pZF9fIiwiISIsIiYiLCJvdGhlciIsInwiLCJeIiwiPT0iLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19zIiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwibWV0aG9kX21pc3NpbmciLCJtZXRob2QiLCJhcmdzIiwiYmxvY2siLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiX2luY2x1ZGVfYWxsIiwiPGNsYXNzOlRydWVDbGFzcz4iLCJCb29sZWFuIiwiPGNsYXNzOkZhbHNlQ2xhc3M+Il0sIm1hcHBpbmdzIjoiQUFBQUEsa0RBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUM7RUFBQUE7O0lBQUFBOzs7SUFDR0E7O0FBR0hBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNB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InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29tcGFyYWJsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeVxuXG5tb2R1bGUgOjpDb21wYXJhYmxlXG4gICV4e1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh3aGF0KSB7XG4gICAgICBpZiAoT3BhbC5pc19hKHdoYXQsIE9wYWwuSW50ZWdlcikpIHsgcmV0dXJuIHdoYXQ7IH1cblxuICAgICAgaWYgKCN7YHdoYXRgID4gMH0pIHsgcmV0dXJuIDE7IH1cbiAgICAgIGlmICgje2B3aGF0YCA8IDB9KSB7IHJldHVybiAtMTsgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmFpbF9jb21wYXJpc29uKGxocywgcmhzKSB7XG4gICAgICB2YXIgY2xhc3NfbmFtZTtcbiAgICAgICN7XG4gICAgICAgIGNhc2UgYHJoc2BcbiAgICAgICAgd2hlbiBuaWwsIHRydWUsIGZhbHNlLCA6OkludGVnZXIsIDo6RmxvYXRcbiAgICAgICAgICBgY2xhc3NfbmFtZSA9IHJocy4kaW5zcGVjdCgpYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJCRjbGFzc2BcbiAgICAgICAgZW5kXG4gICAgICB9XG4gICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7YGxoc2AuY2xhc3N9IHdpdGggI3tgY2xhc3NfbmFtZWB9IGZhaWxlZFwifVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNtcF9vcl9mYWlsKGxocywgcmhzKSB7XG4gICAgICB2YXIgY21wID0gI3tgbGhzYCA8PT4gYHJoc2B9O1xuICAgICAgaWYgKCEkdHJ1dGh5KGNtcCkpIGZhaWxfY29tcGFyaXNvbihsaHMsIHJocyk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplKGNtcCk7XG4gICAgfVxuICB9XG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiB0cnVlIGlmIGVxdWFsPyhvdGhlcilcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGZbXCIkPD0+XCJdID09IE9wYWwuS2VybmVsW1wiJDw9PlwiXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgIGlmIChzZWxmLiQkY29tcGFyYWJsZSkge1xuICAgICAgICBkZWxldGUgc2VsZi4kJGNvbXBhcmFibGU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGNtcCA9IChzZWxmIDw9PiBvdGhlcilcblxuICAgIGBub3JtYWxpemUoY21wKSA9PSAwYFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpID4gMGBcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPj0gMGBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA8IDBgXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDw9IDBgXG4gIGVuZFxuXG4gIGRlZiBiZXR3ZWVuPyhtaW4sIG1heClcbiAgICByZXR1cm4gZmFsc2UgaWYgc2VsZiA8IG1pblxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmID4gbWF4XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgY2xhbXAobWluLCBtYXggPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgYywgZXhjbDtcblxuICAgICAgaWYgKG1heCA9PT0gbmlsKSB7XG4gICAgICAgIC8vIFdlIGFyZSBkZWFsaW5nIHdpdGggYSBuZXcgUnVieSAyLjcgYmVoYXZpb3VyIHRoYXQgd2UgYXJlIGFibGUgdG9cbiAgICAgICAgLy8gcHJvdmlkZSBhIHNpbmdsZSBSYW5nZSBhcmd1bWVudCBpbnN0ZWFkIG9mIDIgQ29tcGFyYWJsZXMuXG5cbiAgICAgICAgaWYgKCFPcGFsLmlzX2EobWluLCBPcGFsLlJhbmdlKSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje21pbi5jbGFzc30gKGV4cGVjdGVkIFJhbmdlKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgZXhjbCA9IG1pbi5leGNsO1xuICAgICAgICBtYXggPSBtaW4uZW5kO1xuICAgICAgICBtaW4gPSBtaW4uYmVnaW47XG5cbiAgICAgICAgaWYgKG1heCAhPT0gbmlsICYmIGV4Y2wpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2Nhbm5vdCBjbGFtcCB3aXRoIGFuIGV4Y2x1c2l2ZSByYW5nZSd9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiAhPT0gbmlsICYmIG1heCAhPT0gbmlsICYmIGNtcF9vcl9mYWlsKG1pbiwgbWF4KSA+IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdtaW4gYXJndW1lbnQgbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtaW4pO1xuXG4gICAgICAgIGlmIChjID09IDApIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoYyA8IDApIHJldHVybiBtaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggIT09IG5pbCkge1xuICAgICAgICBjID0gY21wX29yX2ZhaWwoc2VsZiwgbWF4KTtcblxuICAgICAgICBpZiAoYyA+IDApIHJldHVybiBtYXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpDb21wYXJhYmxlPiIsIj4iLCIwIiwiPCIsIiRyZXRfb3JfMSIsIkludGVnZXIiLCJGbG9hdCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImNsYXNzIiwiPD0+IiwiPT0iLCJvdGhlciIsInNlbGYiLCJlcXVhbD8iLCJjbXAiLCI+PSIsIjw9IiwiYmV0d2Vlbj8iLCJtaW4iLCJtYXgiLCJjbGFtcCIsIlR5cGVFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBLHFEQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7O0FBRUFBO0FBQ0FBOztBQUVBQSxVQUFtQkMsT0FBTkQsSUFBTUMsRUFBRUMsQ0FBRkQsQ0FBSUQ7QUFDdkJBLFVBQW1CRyxPQUFOSCxJQUFNRyxFQUFFRCxDQUFGQyxDQUFJSDtBQUN2QkE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLE1BRVEsQ0FoQlIsQ0FBQSxRQWdCYSxHQWhCYixFQWVRSSxDQUFBQSxZQUFNSixHQUFOSSxDQWZSLENBQUEsSUFBQSxDQUFBLENBQUEsUUFnQmtCLElBaEJsQixFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxRQWdCd0IsS0FoQnhCLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLFFBZ0IrQkMsY0FoQi9CLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxRQWdCMENDLFlBaEIxQyxFQUFBLFNBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBZ0JRLEdBQUEsQ0FDR04sMkJBREgsSUFBQSxDQUdHQSx3QkFISCxDQUFBO0FBTVJBLE1BQVFPLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDVCxnQkFBRCxHQUFBLENBQWlCQSxDQUFDQSxHQUFEQSxDQUFLVSxPQUFBQSxDQUFBQSxDQUF0QixDQUFBLEdBQTZCVixRQUE3QixHQUFBLENBQXNDQSxVQUF0QyxDQUFBLEdBQWtEQSxTQUExRVE7QUFDaEJSOztBQUVBQTtBQUNBQSxnQkFBa0JBLENBQUNBLEdBQURBLENBQU1XLFFBQUFBLENBQUtYLEdBQUxXLENBQVVYO0FBQ2xDQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFRVksSUFBQUEsa0JBQUFBLDhCQUFPQyxLQUFQRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFlRSxJQUFBQyxXQUFBQSxDQUFPRixLQUFQRSxDQUFmLENBQUE7UUFBQSxPQUFPO01BQVA7O0FBR0pIO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJLEtBQUEsUUFBb0JJLENBQUFBLE1BQU9GLElBQUtILFFBQUFBLENBQUlFLEtBQUpGLENBQVpLLENBQXBCLENBQUE7UUFBQSxPQUFPO01BQVA7TUFFQUosT0FBQ0EsbUJBQURBO0lBakJGQSxDQUFBQSxHQUFBQTs7QUFvQkFYLElBQUFBLGlCQUFBQSwyQkFBTVksS0FBTlo7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDRCQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQWdCLElBQUFBLGtCQUFBQSw4QkFBT0osS0FBUEk7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDZCQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQWQsSUFBQUEsaUJBQUFBLDJCQUFNVSxLQUFOVjtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsNEJBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBZSxJQUFBQSxrQkFBQUEsOEJBQU9MLEtBQVBLO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSw2QkFBREE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSxvQ0FBYUMsR0FBRCxFQUFNQyxHQUFsQkY7QUFBQUEsTUFBQUE7OztNQUNFLElBQXFCaEIsT0FBTFcsSUFBS1gsRUFBRWlCLEdBQUZqQixDQUFyQjtRQUFBLE9BQU87TUFBUDtNQUNBLElBQXFCRixPQUFMYSxJQUFLYixFQUFFb0IsR0FBRnBCLENBQXJCO1FBQUEsT0FBTztNQUFQO01BQ0FrQixPQUFBO0lBSEZBLENBQUFBLEdBQUFBO0lBTUFuQixPQUFBc0IscUJBQUFBLGlCQUFVRixHQUFELEVBQU1DLEdBQWZDO0FBQUFBLE1BQUFBOzs7O01BQWUsdUJBQU0sR0FBTjs7QUFFakJBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsVUFBWWYsT0FBUUMsT0FBQUEsQ0FBT2UsZ0JBQWYsRUFBNkJELHNCQUFELEdBQUEsQ0FBdUJGLEdBQUdWLE9BQUFBLENBQUFBLENBQTFCLENBQUEsR0FBaUNZLG1CQUFyRGQ7QUFDcEJjOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsVUFBWWYsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NhLHNDQUF4QmQ7QUFDcEJjO0FBQ0FBOztBQUVBQTtBQUNBQSxRQUFVZixPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2EsZ0RBQXhCZDtBQUNsQmM7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQXZDRUEsQ0FBQUEsSUFBQUE7RUF4RUZ0QixHQUFPLElBQVBBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo2NTQ3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yZWdleHAucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG9cblxuY2xhc3MgOjpSZWdleHBFcnJvciA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5cbmNsYXNzIDo6UmVnZXhwIDwgYFJlZ0V4cGBcbiAgc2VsZjo6SUdOT1JFQ0FTRSA9IDFcbiAgc2VsZjo6RVhURU5ERUQgPSAyXG4gIHNlbGY6Ok1VTFRJTElORSA9IDRcblxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3JlZ2V4cCcsIHRydWUpYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIGFsbG9jYXRlZCA9IHN1cGVyXG4gICAgICBgI3thbGxvY2F0ZWR9LnVuaW5pdGlhbGl6ZWQgPSB0cnVlYFxuICAgICAgYWxsb2NhdGVkXG4gICAgZW5kXG5cbiAgICBkZWYgZXNjYXBlKHN0cmluZylcbiAgICAgIGBPcGFsLmVzY2FwZV9yZWdleHAoc3RyaW5nKWBcbiAgICBlbmRcblxuICAgIGRlZiBsYXN0X21hdGNoKG4gPSBuaWwpXG4gICAgICBpZiBuLm5pbD9cbiAgICAgICAgJH5cbiAgICAgIGVsc2lmICR+XG4gICAgICAgICR+W25dXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB1bmlvbigqcGFydHMpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGlzX2ZpcnN0X3BhcnRfYXJyYXksIHF1b3RlZF92YWxpZGF0ZWQsIHBhcnQsIG9wdGlvbnMsIGVhY2hfcGFydF9vcHRpb25zO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICByZXR1cm4gLyg/ISkvO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBmYXN0IGlmIHRoZXJlJ3Mgb25seSBvbmUgZWxlbWVudFxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09IDEgJiYgcGFydHNbMF0uJCRpc19yZWdleHApIHtcbiAgICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY292ZXIgdGhlIDIgYXJyYXlzIHBhc3NlZCBhcyBhcmd1bWVudHMgY2FzZVxuICAgICAgICBpc19maXJzdF9wYXJ0X2FycmF5ID0gcGFydHNbMF0uJCRpc19hcnJheTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEgJiYgaXNfZmlyc3RfcGFydF9hcnJheSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIEFycmF5IGludG8gU3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgICAvLyBkZWFsIHdpdGggc3BsYXQgaXNzdWVzIChyZWxhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwvaXNzdWVzLzg1OClcbiAgICAgICAgaWYgKGlzX2ZpcnN0X3BhcnRfYXJyYXkpIHtcbiAgICAgICAgICBwYXJ0cyA9IHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHF1b3RlZF92YWxpZGF0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKHBhcnQuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgje2VzY2FwZShgcGFydGApfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHBhcnQuJCRpc19yZWdleHApIHtcbiAgICAgICAgICAgIGVhY2hfcGFydF9vcHRpb25zID0gI3tgcGFydGAub3B0aW9uc307XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucyAhPSBlYWNoX3BhcnRfb3B0aW9ucykge1xuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnQWxsIGV4cHJlc3Npb25zIG11c3QgdXNlIHRoZSBzYW1lIG9wdGlvbnMnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IGVhY2hfcGFydF9vcHRpb25zO1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCcoJytwYXJ0LnNvdXJjZSsnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgje2VzY2FwZShgcGFydGAudG9fc3RyKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgIyBUYWtlIGFkdmFudGFnZSBvZiBsb2dpYyB0aGF0IGNhbiBwYXJzZSBvcHRpb25zIGZyb20gSlMgUmVnZXhcbiAgICAgIG5ldyhgcXVvdGVkX3ZhbGlkYXRlZGAuam9pbignfCcpLCBgb3B0aW9uc2ApXG4gICAgZW5kXG5cbiAgICBkZWYgbmV3KHJlZ2V4cCwgb3B0aW9ucyA9IHVuZGVmaW5lZClcbiAgICAgICV4e1xuICAgICAgICBpZiAocmVnZXhwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2V4cCA9ICN7OjpPcGFsLmNvZXJjZV90byEocmVnZXhwLCA6OlN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICAgIGlmIChyZWdleHAuY2hhckF0KHJlZ2V4cC5sZW5ndGggLSAxKSA9PT0gJ1xcXFwnICYmIHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDIpICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmVnZXhwRXJyb3IsIFwidG9vIHNob3J0IGVzY2FwZSBzZXF1ZW5jZTogLyN7cmVnZXhwfS9cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgI3shb3B0aW9uc30pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9ICcnO1xuICAgICAgICAgIGlmICgje0lHTk9SRUNBU0V9ICYgb3B0aW9ucykgeyB0ZW1wICs9ICdpJzsgfVxuICAgICAgICAgIGlmICgje01VTFRJTElORX0gICYgb3B0aW9ucykgeyB0ZW1wICs9ICdtJzsgfVxuICAgICAgICAgIG9wdGlvbnMgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSAnaSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgYWxpYXMgY29tcGlsZSBuZXdcbiAgICBhbGlhcyBxdW90ZSBlc2NhcGVcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBvdGhlciBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiA9PT0oc3RyaW5nKVxuICAgIGAje21hdGNoKDo6T3BhbC5jb2VyY2VfdG8/KHN0cmluZywgOjpTdHJpbmcsIDp0b19zdHIpKX0gIT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmID1+KHN0cmluZylcbiAgICBtYXRjaChzdHJpbmcpICYmICR+LmJlZ2luKDApXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgIyBVc2UgYSByZWdleHAgdG8gZXh0cmFjdCB0aGUgcmVndWxhciBleHByZXNzaW9uIGFuZCB0aGUgb3B0aW9uYWwgbW9kZSBtb2RpZmllcnMgZnJvbSB0aGUgc3RyaW5nLlxuICAgICMgSW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZXNjYXBlIGFueSBmcm9udCBzbGFzaCAobm90IGFscmVhZHkgZXNjYXBlZCkgd2l0aCBhIGJhY2tzbGFzaC5cbiAgICAleHtcbiAgICAgIHZhciByZWdleHBfZm9ybWF0ID0gL15cXC8oLiopXFwvKFteXFwvXSopJC87XG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4cF9mb3JtYXQuZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm4gPSBtYXRjaGVzWzFdO1xuICAgICAgICB2YXIgcmVnZXhwX2ZsYWdzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgdmFyIGNoYXJzID0gcmVnZXhwX3BhdHRlcm4uc3BsaXQoJycpO1xuICAgICAgICB2YXIgY2hhcnNfbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudF9jaGFyID0gY2hhcnNbaV07XG4gICAgICAgICAgaWYgKCFjaGFyX2VzY2FwZWQgJiYgY3VycmVudF9jaGFyID09ICcvJykge1xuICAgICAgICAgICAgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9IHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQuY29uY2F0KCdcXFxcJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdChjdXJyZW50X2NoYXIpO1xuICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAoY2hhcl9lc2NhcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IG92ZXIgZXNjYXBlXG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLycgKyByZWdleHBfcGF0dGVybl9lc2NhcGVkICsgJy8nICsgcmVnZXhwX2ZsYWdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKHN0cmluZywgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RyaW5nID09PSBuaWwpIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgdmFyIG0gPSBzZWxmLmV4ZWMoJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJykpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcoYHNlbGZgLCBgbWApfTtcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyArPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnbG9iYWwgUmVnRXhwIG1haW50YWlucyBzdGF0ZSwgc28gbm90IHVzaW5nIHNlbGYvdGhpc1xuICAgICAgdmFyIG1kLCByZSA9IE9wYWwuZ2xvYmFsX3JlZ2V4cChzZWxmKTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWQgPSByZS5leGVjKHN0cmluZyk7XG4gICAgICAgIGlmIChtZCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWQuaW5kZXggPj0gcG9zKSB7XG4gICAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgcmVgLCBgbWRgKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG1kLmluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8oc3RyaW5nLCBwb3MgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nID09PSBuaWwgPyBmYWxzZSA6IHNlbGYudGVzdCgkY29lcmNlX3RvKHN0cmluZywgI3s6OlN0cmluZ30sICd0b19zdHInKSk7XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyArPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnbG9iYWwgUmVnRXhwIG1haW50YWlucyBzdGF0ZSwgc28gbm90IHVzaW5nIHNlbGYvdGhpc1xuICAgICAgdmFyIG1kLCByZSA9IE9wYWwuZ2xvYmFsX3JlZ2V4cChzZWxmKTtcblxuICAgICAgbWQgPSByZS5leGVjKHN0cmluZyk7XG4gICAgICBpZiAobWQgPT09IG51bGwgfHwgbWQuaW5kZXggPCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmFtZXNcbiAgICBzb3VyY2Uuc2NhbigvXFwoPzwoXFx3Kyk+Lywgbm9fbWF0Y2hkYXRhOiB0cnVlKS5tYXAoJjpmaXJzdCkudW5pcVxuICBlbmRcblxuICBkZWYgbmFtZWRfY2FwdHVyZXNcbiAgICBzb3VyY2Uuc2NhbigvXFwoPzwoXFx3Kyk+Lywgbm9fbWF0Y2hkYXRhOiB0cnVlKSAjIFNjYW4gZm9yIGNhcHR1cmUgZ3JvdXBzXG4gICAgICAgICAgLm1hcCgmOmZpcnN0KSAgICAgICAgICAgICAgICAgICAgICAgICAgICMgR2V0IHRoZSBmaXJzdCByZWdleHAgbWF0Y2ggKFxcdyspXG4gICAgICAgICAgLmVhY2hfd2l0aF9pbmRleCAgICAgICAgICAgICAgICAgICAgICAgICMgQWRkIGluZGV4IHRvIGFuIGl0ZXJhdG9yXG4gICAgICAgICAgLmdyb3VwX2J5KCY6Zmlyc3QpICAgICAgICAgICAgICAgICAgICAgICMgR3JvdXAgYnkgdGhlIGNhcHR1cmUgZ3JvdXAgbmFtZXNcbiAgICAgICAgICAudHJhbnNmb3JtX3ZhbHVlcyBkbyB8aXwgICAgICAgICAgICAgICAgIyBDb252ZXJ0IGhhc2ggdmFsdWVzXG4gICAgICAgICAgICBpLm1hcCB7IHxqfCBqLmxhc3QgKyAxIH0gICAgICAgICAgICAgICMgRHJvcCB0aGUgY2FwdHVyZSBncm91cCBuYW1lczsgaW5jcmVhc2UgaW5kZXhlcyBieSAxXG4gICAgICAgICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB+XG4gICAgc2VsZiA9fiAkX1xuICBlbmRcblxuICBkZWYgc291cmNlXG4gICAgYHNlbGYuc291cmNlYFxuICBlbmRcblxuICBkZWYgb3B0aW9uc1xuICAgICMgRmxhZ3Mgd291bGQgYmUgbmljZSB0byB1c2Ugd2l0aCB0aGlzLCBidXQgc3RpbGwgZXhwZXJpbWVudGFsIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL2ZsYWdzXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIC8vIHNob3VsZCBiZSBzdXBwb3J0ZWQgaW4gSUU2IGFjY29yZGluZyB0byBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5LzdmNXoyNnc0KHY9dnMuOTQpLmFzcHhcbiAgICAgIGlmIChzZWxmLm11bHRpbGluZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tNVUxUSUxJTkV9O1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuaWdub3JlQ2FzZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tJR05PUkVDQVNFfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FzZWZvbGQ/XG4gICAgYHNlbGYuaWdub3JlQ2FzZWBcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyB0b19zIHNvdXJjZVxuZW5kXG5cbmNsYXNzIE1hdGNoRGF0YVxuICBhdHRyX3JlYWRlciA6cG9zdF9tYXRjaCwgOnByZV9tYXRjaCwgOnJlZ2V4cCwgOnN0cmluZ1xuXG4gIGRlZiBpbml0aWFsaXplKHJlZ2V4cCwgbWF0Y2hfZ3JvdXBzLCBub19tYXRjaGRhdGE6IGZhbHNlKVxuICAgICR+ICAgICAgICAgID0gc2VsZiB1bmxlc3Mgbm9fbWF0Y2hkYXRhXG4gICAgQHJlZ2V4cCAgICAgPSByZWdleHBcbiAgICBAYmVnaW4gICAgICA9IGBtYXRjaF9ncm91cHMuaW5kZXhgXG4gICAgQHN0cmluZyAgICAgPSBgbWF0Y2hfZ3JvdXBzLmlucHV0YFxuICAgIEBwcmVfbWF0Y2ggID0gYG1hdGNoX2dyb3Vwcy5pbnB1dC5zbGljZSgwLCBtYXRjaF9ncm91cHMuaW5kZXgpYFxuICAgIEBwb3N0X21hdGNoID0gYG1hdGNoX2dyb3Vwcy5pbnB1dC5zbGljZShtYXRjaF9ncm91cHMuaW5kZXggKyBtYXRjaF9ncm91cHNbMF0ubGVuZ3RoKWBcbiAgICBAbWF0Y2hlcyAgICA9IFtdXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtYXRjaF9ncm91cHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gbWF0Y2hfZ3JvdXBzW2ldO1xuXG4gICAgICAgIGlmIChncm91cCA9PSBudWxsKSB7XG4gICAgICAgICAgI3tAbWF0Y2hlc30ucHVzaChuaWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7QG1hdGNoZXN9LnB1c2goZ3JvdXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2goaWR4KVxuICAgIGlmIChtYXRjaCA9IHNlbGZbaWR4XSlcbiAgICAgIG1hdGNoXG4gICAgZWxzaWYgaWR4LmlzX2E/KEludGVnZXIpICYmIGlkeCA+PSBsZW5ndGhcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJpbmRleCAje2lkeH0gb3V0IG9mIG1hdGNoZXNcIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWF0Y2hfbGVuZ3RoKGlkeClcbiAgICBtYXRjaChpZHgpJi5sZW5ndGhcbiAgZW5kXG5cbiAgZGVmIFtdKCphcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3NbMF0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKCN7IXJlZ2V4cC5uYW1lcy5pbmNsdWRlPyhhcmdzWzBdKX0pIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJ1bmRlZmluZWQgZ3JvdXAgbmFtZSByZWZlcmVuY2U6ICN7YXJnc1swXX1cIn1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tuYW1lZF9jYXB0dXJlc1thcmdzWzBdXX1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tAbWF0Y2hlc1sqYXJnc119XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgb2Zmc2V0KG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNvZmZzZXQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gW3NlbGYuYmVnaW4sIHNlbGYuYmVnaW4gKyBzZWxmLm1hdGNoZXNbbl0ubGVuZ3RoXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIDo6TWF0Y2hEYXRhID09PSBvdGhlclxuXG4gICAgYHNlbGYuc3RyaW5nID09IG90aGVyLnN0cmluZ2AgJiZcbiAgICAgIGBzZWxmLnJlZ2V4cC50b1N0cmluZygpID09IG90aGVyLnJlZ2V4cC50b1N0cmluZygpYCAmJlxuICAgICAgYHNlbGYucHJlX21hdGNoID09IG90aGVyLnByZV9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLnBvc3RfbWF0Y2ggPT0gb3RoZXIucG9zdF9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luYFxuICBlbmRcblxuICBkZWYgYmVnaW4obilcbiAgICAleHtcbiAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI2JlZ2luIG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuYmVnaW47XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW5kKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNlbmQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FwdHVyZXNcbiAgICBgI3tAbWF0Y2hlc30uc2xpY2UoMSlgXG4gIGVuZFxuXG4gIGRlZiBuYW1lZF9jYXB0dXJlc1xuICAgIG1hdGNoZXMgPSBjYXB0dXJlc1xuICAgIHJlZ2V4cC5uYW1lZF9jYXB0dXJlcy50cmFuc2Zvcm1fdmFsdWVzIGRvIHxpfFxuICAgICAgbWF0Y2hlc1tpLmxhc3QgLSAxXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbmFtZXNcbiAgICByZWdleHAubmFtZXNcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBcIiM8TWF0Y2hEYXRhIFwiICsgI3tgI3tAbWF0Y2hlc31bMF1gLmluc3BlY3R9O1xuXG4gICAgICBpZiAoI3tyZWdleHAubmFtZXMuZW1wdHk/fSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gI3tAbWF0Y2hlc30ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdHIgKz0gXCIgXCIgKyBpICsgXCI6XCIgKyAje2Aje0BtYXRjaGVzfVtpXWAuaW5zcGVjdH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAjeyBuYW1lZF9jYXB0dXJlcy5lYWNoIGRvIHxrLCB2fFxuICAgICAgICAgICAgICV4e1xuICAgICAgICAgICAgICAgc3RyICs9IFwiIFwiICsgI3trfSArIFwiOlwiICsgI3t2Lmluc3BlY3R9XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICBlbmQgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyICsgXCI+XCI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYCN7QG1hdGNoZXN9Lmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBAbWF0Y2hlc1xuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAje0BtYXRjaGVzfVswXWBcbiAgZW5kXG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBpLCBhLCBpbmRleCwgdmFsdWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19yYW5nZSkge1xuICAgICAgICAgIGEgPSAje2BhcmdzW2ldYC50b19hfTtcbiAgICAgICAgICBhLnVuc2hpZnQoaSwgMSk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShhcmdzLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgYXJnc1tpXWAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSAje0BtYXRjaGVzfS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gobmlsKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlcy5wdXNoKCN7QG1hdGNoZXN9W2luZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlJlZ2V4cEVycm9yPiIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6UmVnZXhwPiIsInNlbGYiLCIxIiwiMiIsIjQiLCJhbGxvY2F0ZSIsImFsbG9jYXRlZCIsImVzY2FwZSIsInN0cmluZyIsImxhc3RfbWF0Y2giLCJuIiwibmlsPyIsIiR+IiwiW10iLCJ1bmlvbiIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwib3B0aW9ucyIsInRvX3N0ciIsIm5ldyIsImpvaW4iLCJyZWdleHAiLCJPcGFsIiwiY29lcmNlX3RvISIsIlN0cmluZyIsIlJlZ2V4cEVycm9yIiwiISIsIklHTk9SRUNBU0UiLCJNVUxUSUxJTkUiLCI9PSIsIm90aGVyIiwiPT09IiwibWF0Y2giLCJjb2VyY2VfdG8/IiwiPX4iLCIkcmV0X29yXzEiLCJiZWdpbiIsIjAiLCJpbnNwZWN0IiwicG9zIiwiTWF0Y2hEYXRhIiwiSW50ZWdlciIsIm1hdGNoPyIsIm5hbWVzIiwibWFwIiwic291cmNlIiwic2NhbiIsInRvX3Byb2MiLCJ1bmlxIiwibmFtZWRfY2FwdHVyZXMiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwiZ3JvdXBfYnkiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9jayBpbiBuYW1lZF9jYXB0dXJlcyIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIG5hbWVkX2NhcHR1cmVzIiwiaiIsImJsb2NrICgzIGxldmVscykgaW4gbmFtZWRfY2FwdHVyZXMiLCIrIiwibGFzdCIsIn4iLCIkXyIsImNhc2Vmb2xkPyIsIjxjbGFzczpNYXRjaERhdGE+IiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwibWF0Y2hfZ3JvdXBzIiwiJGt3YXJncyIsIm5vX21hdGNoZGF0YSIsIkByZWdleHAiLCJAYmVnaW4iLCJAc3RyaW5nIiwiQHByZV9tYXRjaCIsIkBwb3N0X21hdGNoIiwiQG1hdGNoZXMiLCJpZHgiLCJpc19hPyIsIj49IiwibGVuZ3RoIiwiSW5kZXhFcnJvciIsIm1hdGNoX2xlbmd0aCIsImluY2x1ZGU/IiwiYXJncyIsIm9mZnNldCIsIkFyZ3VtZW50RXJyb3IiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCJlbmQiLCJjYXB0dXJlcyIsIm1hdGNoZXMiLCItIiwiZW1wdHk/IiwiZWFjaCIsImJsb2NrIGluIGluc3BlY3QiLCJrIiwidiIsImJsb2NrICgyIGxldmVscykgaW4gaW5zcGVjdCIsInRvX2EiLCJ0b19zIiwidmFsdWVzX2F0Il0sIm1hcHBpbmdzIjoiQUFBQUEsaURBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsT0FBTSxJQUFOQSxFQUFzQkMsb0JBQXRCRDtFQUVBRTtFQUFBQTs7SUFBQUE7OztJQUNFLFdBQUFDLElBQUEsZ0JBQW1CQyxDQUFuQjtJQUNBLFdBQUFELElBQUEsY0FBaUJFLENBQWpCO0lBQ0EsV0FBQUYsSUFBQSxlQUFrQkcsQ0FBbEI7SUFFQ0o7SUFFRDtNQUFBOzs7O0FBQ0VLLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOztRQUNFQyxZQUFZLE9BQUFMLElBQUEsRUFBQSxzREFBQSxZQUFBLEVBQUEsRUFBQSxFQUFBLE1BQUE7UUFDVEssU0FBVUQ7UUFDYkEsT0FBQUM7TUFIRkQsQ0FBQUEsR0FBQUE7O0FBTUFFLE1BQUFBLHNCQUFBQSxrQkFBV0MsTUFBWEQ7QUFBQUE7UUFDRUEsT0FBQ0EsMEJBQURBO01BREZBLENBQUFBLEdBQUFBOztBQUlBRSxNQUFBQSwwQkFBQUEsc0JBQWVDLENBQWZEO0FBQUFBLFFBQUFBOzs7O1FBQWUsbUJBQUksR0FBSjtRQUNiLElBQUEsUUFBR0MsQ0FBQ0MsU0FBQUEsQ0FBQUEsQ0FBSixDQUFBO1VBQ0VGLE9BQUFHO1FBREYsT0FFQSxJQUFBLFFBQU1BLFdBQU4sQ0FBQTtVQUNF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QWdCQSxDQUFDQSxPQUFEQSxDQUFTRixNQUFBQSxDQUFBQSxDQUFNRTtBQUMvQkE7QUFDQUE7QUFDQUE7O0FBRUFBLGdCQUFrQjlFLEtBQU1DLGVBQUFBLENBQWE2RSxPQUFuQixFQUE2QjNELGNBQTdCLEVBQXdDLFFBQWxDbEIsQ0FBMkM2RTs7QUFFbkVBO0FBQ0FBLG1CQUFxQjFCLFlBQVMwQjtBQUM5QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBLG9CQUFzQjFCLFlBQVMwQjtBQUMvQkE7O0FBRUFBO0FBQ0FBO0lBMUJFQSxDQUFBQSxJQUFBQTtJQTZCQSxhQUFNLE1BQU4sRUFBVyxJQUFYO0lBQ0FyQyxPQUFBLGFBQU0sTUFBTixFQUFXLFFBQVg7RUF2S0ZBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBblNBbkU7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjcxMzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cmluZy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90bywgcmVzcG9uZF90bywgZ2xvYmFsX211bHRpbGluZV9yZWdleHBcblxucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG5cbmNsYXNzIDo6U3RyaW5nIDwgYFN0cmluZ2BcbiAgaW5jbHVkZSA6OkNvbXBhcmFibGVcblxuICAleHtcbiAgICBPcGFsLnByb3AoI3tzZWxmfS4kJHByb3RvdHlwZSwgJyQkaXNfc3RyaW5nJywgdHJ1ZSk7XG5cbiAgICBPcGFsLnByb3AoI3tzZWxmfS4kJHByb3RvdHlwZSwgJyQkY2FzdCcsIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIGtsYXNzID0gdGhpcy4kJGNsYXNzO1xuICAgICAgaWYgKGtsYXNzLiQkY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBrbGFzcy4kJGNvbnN0cnVjdG9yKHN0cmluZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQod2hhdClcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyh3aGF0LCA6OlN0cmluZywgOnRvX3N0cilcbiAgZW5kXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IGFyZ3NbMF0gfHwgXCJcIjtcbiAgICAgIHZhciBvcHRzID0gYXJnc1thcmdzLmxlbmd0aC0xXTtcbiAgICAgIHN0ciA9ICRjb2VyY2VfdG8oc3RyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy4kJGlzX2hhc2gpIHtcbiAgICAgICAgaWYgKG9wdHMuJCRzbWFwLmVuY29kaW5nKSBzdHIgPSBzdHIuJGZvcmNlX2VuY29kaW5nKG9wdHMuJCRzbWFwLmVuY29kaW5nKTtcbiAgICAgIH1cbiAgICAgIHN0ciA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3Ioc3RyKTtcbiAgICAgIGlmICghc3RyLiRpbml0aWFsaXplLiQkcHJpc3RpbmUpICN7YHN0cmAuaW5pdGlhbGl6ZSgqYXJncyl9O1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGVuZFxuXG4gICMgT3VyIGluaXRpYWxpemUgbWV0aG9kIGRvZXMgbm90aGluZywgdGhlIHN0cmluZyB2YWx1ZSBzZXR1cCBpcyBiZWluZ1xuICAjIGRvbmUgYnkgU3RyaW5nLm5ldy4gVGhlcmVmb3JlIG5vdCBhbGwga2luZHMgb2Ygc3ViY2xhc3Npbmcgd2lsbCB3b3JrLlxuICAjIEFzIGEgcnVsZSBvZiB0aHVtYiwgd2hlbiBzdWJjbGFzc2luZyBTdHJpbmcsIGVpdGhlciBtYWtlIHN1cmUgdG8gb3ZlcnJpZGVcbiAgIyAubmV3IG9yIG1ha2Ugc3VyZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCBnaXZlbiB0byBhIGNvbnN0cnVjdG9yIGlzXG4gICMgYSBzdHJpbmcgd2Ugd2FudCBvdXIgc3ViY2xhc3Mtc3RyaW5nIHRvIGhvbGQuXG4gIGRlZiBpbml0aWFsaXplKHN0ciA9IHVuZGVmaW5lZCwgZW5jb2Rpbmc6IG5pbCwgY2FwYWNpdHk6IG5pbClcbiAgZW5kXG5cbiAgZGVmICUoZGF0YSlcbiAgICBpZiA6OkFycmF5ID09PSBkYXRhXG4gICAgICBmb3JtYXQoc2VsZiwgKmRhdGEpXG4gICAgZWxzZVxuICAgICAgZm9ybWF0KHNlbGYsIGRhdGEpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKGNvdW50KVxuICAgICV4e1xuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdCgnJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCk7XG5cbiAgICAgIC8vIEFsbCBjcmVkaXQgZm9yIHRoZSBiaXQtdHdpZGRsaW5nIG1hZ2ljIGNvZGUgYmVsb3cgZ29lcyB0byBNb3ppbGxhXG4gICAgICAvLyBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvbiBvZiBTdHJpbmcucHJvdG90eXBlLnJlcGVhdCgpIHBvc3RlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCAqIGNvdW50ID49IDEgPDwgMjgpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdtdWx0aXBseSBjb3VudCBtdXN0IG5vdCBvdmVyZmxvdyBtYXhpbXVtIHN0cmluZyBzaXplJ31cbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoKGNvdW50ICYgMSkgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ID4+Pj0gMTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKCN7b3RoZXJ9LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYFxuXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIgPT0gXCJcIiAmJiBzZWxmLiQkY2xhc3MgPT09IE9wYWwuU3RyaW5nKSByZXR1cm4gI3tzZWxmfTtcbiAgICAgIGlmIChzZWxmID09IFwiXCIgJiYgb3RoZXIuJCRjbGFzcyA9PT0gT3BhbC5TdHJpbmcpIHJldHVybiAje290aGVyfTtcbiAgICAgIHZhciBvdXQgPSBzZWxmICsgb3RoZXI7XG4gICAgICBpZiAoc2VsZi5lbmNvZGluZyA9PT0gb3V0LmVuY29kaW5nICYmIG90aGVyLmVuY29kaW5nID09PSBvdXQuZW5jb2RpbmcpIHJldHVybiBvdXQ7XG4gICAgICBpZiAoc2VsZi5lbmNvZGluZy5uYW1lID09PSBcIlVURi04XCIgfHwgb3RoZXIuZW5jb2RpbmcubmFtZSA9PT0gXCJVVEYtOFwiKSByZXR1cm4gb3V0O1xuICAgICAgcmV0dXJuIE9wYWwuZW5jKG91dCwgc2VsZi5lbmNvZGluZyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19zdHJcbiAgICAgIG90aGVyID0gb3RoZXIudG9fc3RyLnRvX3NcblxuICAgICAgYHNlbGYgPiBvdGhlciA/IDEgOiAoc2VsZiA8IG90aGVyID8gLTEgOiAwKWBcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgdmFyIGNtcCA9ICN7b3RoZXIgPD0+IHNlbGZ9O1xuXG4gICAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNtcCA+IDAgPyAtMSA6IChjbXAgPCAwID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICByZXR1cm4gc2VsZi50b1N0cmluZygpID09PSBvdGhlci50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKCRyZXNwb25kX3RvKG90aGVyLCAnJHRvX3N0cicpKSB7XG4gICAgICAgIHJldHVybiAje290aGVyID09IHNlbGZ9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID1+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd0eXBlIG1pc21hdGNoOiBTdHJpbmcgZ2l2ZW4nfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7b3RoZXIgPX4gc2VsZn07XG4gICAgfVxuICBlbmRcblxuICBkZWYgW10oaW5kZXgsIGxlbmd0aCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsIGV4Y2x1ZGUsIHJhbmdlO1xuXG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICBleGNsdWRlID0gaW5kZXguZXhjbDtcbiAgICAgICAgcmFuZ2UgICA9IGluZGV4O1xuICAgICAgICBsZW5ndGggID0gaW5kZXguZW5kID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8oaW5kZXguZW5kLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaW5kZXggICA9IGluZGV4LmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhpbmRleC5iZWdpbiwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGluZGV4KSA+IHNpemUpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGNsdWRlIHx8IHJhbmdlLmVuZCA9PT0gbmlsKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSBsZW5ndGggLSBpbmRleDtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIGxlbmd0aCkpO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YoaW5kZXgpICE9PSAtMSA/IHNlbGYuJCRjYXN0KGluZGV4KSA6IG5pbDtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoaW5kZXguJCRpc19yZWdleHApIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc2VsZi5tYXRjaChpbmRleCk7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgaW5kZXhgLCBgbWF0Y2hgKX1cblxuICAgICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gJGNvZXJjZV90byhsZW5ndGgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwICYmIC1sZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbbGVuZ3RoICs9IG1hdGNoLmxlbmd0aF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChtYXRjaFtsZW5ndGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIDEpKTtcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gJGNvZXJjZV90byhsZW5ndGgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIGxlbmd0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJcbiAgICBgbmV3IFN0cmluZygje3NlbGZ9KWAuZm9yY2VfZW5jb2RpbmcoJ2JpbmFyeScpXG4gIGVuZFxuXG4gIGRlZiBjYXBpdGFsaXplXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzZWxmLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpKWBcbiAgZW5kXG5cbiAgZGVmIGNhc2VjbXAob3RoZXIpXG4gICAgcmV0dXJuIG5pbCB1bmxlc3Mgb3RoZXIucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKG90aGVyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG4gICAgJXh7XG4gICAgICB2YXIgYXNjaWlfb25seSA9IC9eW1xceDAwLVxceDdGXSokLztcbiAgICAgIGlmIChhc2NpaV9vbmx5LnRlc3Qoc2VsZikgJiYgYXNjaWlfb25seS50ZXN0KG90aGVyKSkge1xuICAgICAgICBzZWxmID0gc2VsZi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBvdGhlciA9IG90aGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYgPD0+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjYXNlY21wPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBjbXAgPSAje2Nhc2VjbXAob3RoZXIpfTtcbiAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNtcCA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZW50ZXIod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgcGFkc3RyID0gYCRjb2VyY2VfdG8oI3twYWRzdHJ9LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG5cbiAgICBpZiBwYWRzdHIuZW1wdHk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBsanVzdGlmaWVkID0gI3tsanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5jZWlsLCBwYWRzdHJ9LFxuICAgICAgICAgIHJqdXN0aWZpZWQgPSAje3JqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmZsb29yLCBwYWRzdHJ9O1xuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qocmp1c3RpZmllZCArIGxqdXN0aWZpZWQuc2xpY2Uoc2VsZi5sZW5ndGgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaG9tcChzZXBhcmF0b3IgPSAkLylcbiAgICByZXR1cm4gc2VsZiBpZiBgc2VwYXJhdG9yID09PSBuaWwgfHwgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBzZXBhcmF0b3IgPSA6Ok9wYWwuY29lcmNlX3RvIShzZXBhcmF0b3IsIDo6U3RyaW5nLCA6dG9fc3RyKS50b19zXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5yZXBsYWNlKC9cXHI/XFxuPyQvLCAnJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZXBhcmF0b3IgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5yZXBsYWNlKC8oXFxyP1xcbikrJC8sICcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlbGYubGVuZ3RoID49IHNlcGFyYXRvci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHRhaWwgPSBzZWxmLnN1YnN0cihzZWxmLmxlbmd0aCAtIHNlcGFyYXRvci5sZW5ndGgsIHNlcGFyYXRvci5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0YWlsID09PSBzZXBhcmF0b3IpIHtcbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBzZWxmLmxlbmd0aCAtIHNlcGFyYXRvci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjaG9wXG4gICAgJXh7XG4gICAgICB2YXIgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHJlc3VsdDtcblxuICAgICAgaWYgKGxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuY2hhckF0KGxlbmd0aCAtIDEpID09PSBcIlxcblwiICYmIHNlbGYuY2hhckF0KGxlbmd0aCAtIDIpID09PSBcIlxcclwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIGxlbmd0aCAtIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNoclxuICAgIGBzZWxmLmNoYXJBdCgwKWBcbiAgZW5kXG5cbiAgZGVmIGNsb25lXG4gICAgY29weSA9IGBuZXcgU3RyaW5nKHNlbGYpYFxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgbmV3IFN0cmluZyhzZWxmKWBcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgY291bnQoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggLSBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ0FyZ3VtZW50RXJyb3I6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDErKSd9XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9wcmVmaXgocHJlZml4KVxuICAgICV4e1xuICAgICAgaWYgKCFwcmVmaXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcHJlZml4ID0gJGNvZXJjZV90byhwcmVmaXgsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNsaWNlKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc2xpY2UocHJlZml4Lmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX3N1ZmZpeChzdWZmaXgpXG4gICAgJXh7XG4gICAgICBpZiAoIXN1ZmZpeC4kJGlzX3N0cmluZykge1xuICAgICAgICBzdWZmaXggPSAkY29lcmNlX3RvKHN1ZmZpeCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc2xpY2Uoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSA9PT0gc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnNsaWNlKDAsIHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZG93bmNhc2VcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi50b0xvd2VyQ2FzZSgpKWBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfbGluZShzZXBhcmF0b3IgPSAkLywgY2hvbXA6IGZhbHNlLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2xpbmUsIHNlcGFyYXRvciwgY2hvbXA6IGNob21wIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gbmlsKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmKTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgc2VwYXJhdG9yID0gJGNvZXJjZV90byhzZXBhcmF0b3IsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIHZhciBhLCBpLCBuLCBsZW5ndGgsIGNob21wZWQsIHRyYWlsaW5nLCBzcGxpdHRlZCwgdmFsdWU7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZvciAoYSA9IHNlbGYuc3BsaXQoLygoPzpcXHI/XFxuKXsyfSkoPzooPzpcXHI/XFxuKSopLyksIGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoYVtpXSB8fCBhW2kgKyAxXSkge1xuICAgICAgICAgICAgdmFsdWUgPSAoYVtpXSB8fCBcIlwiKSArIChhW2kgKyAxXSB8fCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChjaG9tcCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9ICN7YHZhbHVlYC5jaG9tcChcIlxcblwiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBjaG9tcGVkICA9ICN7Y2hvbXAoc2VwYXJhdG9yKX07XG4gICAgICB0cmFpbGluZyA9IHNlbGYubGVuZ3RoICE9IGNob21wZWQubGVuZ3RoO1xuICAgICAgc3BsaXR0ZWQgPSBjaG9tcGVkLnNwbGl0KHNlcGFyYXRvcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNwbGl0dGVkLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXR0ZWRbaV07XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSB8fCB0cmFpbGluZykge1xuICAgICAgICAgIHZhbHVlICs9IHNlcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvbXApIHtcbiAgICAgICAgICB2YWx1ZSA9ICN7YHZhbHVlYC5jaG9tcChzZXBhcmF0b3IpfTtcbiAgICAgICAgfVxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVuZF93aXRoPygqc3VmZml4ZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3VmZml4ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1ZmZpeCA9ICRjb2VyY2VfdG8oc3VmZml4ZXNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPj0gc3VmZml4Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoLCBzdWZmaXgubGVuZ3RoKSA9PSBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBnc3ViKHBhdHRlcm4sIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDpnc3ViLCBwYXR0ZXJufTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9ICcnLCBtYXRjaF9kYXRhID0gbmlsLCBpbmRleCA9IDAsIG1hdGNoLCBfcmVwbGFjZW1lbnQ7XG5cbiAgICAgIGlmIChwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHBhdHRlcm4gPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEluZGV4O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXN1bHQgKz0gc2VsZi5zbGljZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaF9kYXRhID0gI3s6Ok1hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcblxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhc3RJbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IGJsb2NrKG1hdGNoWzBdKTtcbiAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IGxhc3RJbmRleDsgLy8gc2F2ZSBhbmQgcmVzdG9yZSBsYXN0SW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKCFyZXBsYWNlbWVudC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSAkY29lcmNlX3RvKHJlcGxhY2VtZW50LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yZXBsYWNlKC8oW1xcXFxdKykoWzAtOSsmYCddKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIHNsYXNoZXMsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2gubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoWzBdO1xuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyAobWF0Y2hbY29tbWFuZF0gfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQgKyAoc2VsZlttYXRjaC5pbmRleF0gfHwgXCJcIikpO1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQpXG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgaGV4XG4gICAgdG9faSAxNlxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIG90aGVyID0gJGNvZXJjZV90byhvdGhlciwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2Yob3RoZXIpICE9PSAtMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICByZWdleDtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAkY29lcmNlX3RvKG9mZnNldCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VhcmNoLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHJlZ2V4ID0gJGdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHNlYXJjaCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgbWF0Y2ggPSByZWdleC5leGVjKHNlbGYpO1xuICAgICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgI3skfiA9IG5pbH07XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcoYHJlZ2V4YCwgYG1hdGNoYCl9XG4gICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIGlmIChzZWFyY2gubGVuZ3RoID09PSAwICYmIG9mZnNldCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCA9IHNlbGYuaW5kZXhPZihzZWFyY2gsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG5pbCA6IGluZGV4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzICovXG4gICAgICB2YXIgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx1MDA3Ri1cXHUwMDlGXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgICBtZXRhID0ge1xuICAgICAgICAgICAgJ1xcdTAwMDcnOiAnXFxcXGEnLFxuICAgICAgICAgICAgJ1xcdTAwMWInOiAnXFxcXGUnLFxuICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICdcXHYnOiAnXFxcXHYnLFxuICAgICAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlc2NhcGVkID0gc2VsZi5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGNocikge1xuICAgICAgICAgICAgaWYgKG1ldGFbY2hyXSkgcmV0dXJuIG1ldGFbY2hyXTtcbiAgICAgICAgICAgIGNociA9IGNoci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKGNociA8PSAweGZmICYmIChzZWxmLmVuY29kaW5nW1wiJGJpbmFyeT9cIl0oKSB8fCBzZWxmLmludGVybmFsX2VuY29kaW5nW1wiJGJpbmFyeT9cIl0oKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxceCcgKyAoJzAwJyArIGNoci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgKyAoJzAwMDAnICsgY2hyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXFwjW1xcJFxcQFxce10vZywgJ1xcXFwkJicpICsgJ1wiJztcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3MgKi9cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnRlcm5cbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgbGluZXMoc2VwYXJhdG9yID0gJC8sIGNob21wOiBmYWxzZSwgJmJsb2NrKVxuICAgIGUgPSBlYWNoX2xpbmUoc2VwYXJhdG9yLCBjaG9tcDogY2hvbXAsICZibG9jaylcbiAgICBibG9jayA/IHNlbGYgOiBlLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGxqdXN0KHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gYCRjb2VyY2VfdG8oI3t3aWR0aH0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3s6OlN0cmluZ30sICd0b19zdHInKWAudG9fc1xuXG4gICAgaWYgcGFkc3RyLmVtcHR5P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnemVybyB3aWR0aCBwYWRkaW5nJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIHNlbGYgaWYgYHdpZHRoIDw9IHNlbGYubGVuZ3RoYFxuXG4gICAgJXh7XG4gICAgICB2YXIgaW5kZXggID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gXCJcIjtcblxuICAgICAgd2lkdGggLT0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgd2lkdGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IHBhZHN0cjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYgKyByZXN1bHQuc2xpY2UoMCwgd2lkdGgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsc3RyaXBcbiAgICBgc2VsZi5yZXBsYWNlKC9eW1xcdTAwMDBcXHNdKi8sICcnKWBcbiAgZW5kXG5cbiAgZGVmIGFzY2lpX29ubHk/XG4gICAgIyBub24tQVNDSUktY29tcGF0aWJsZSBlbmNvZGluZyBtdXN0IHJldHVybiBmYWxzZVxuICAgICV4e1xuICAgICAgaWYgKCFzZWxmLmVuY29kaW5nLmFzY2lpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2gocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgU3RyaW5nID09PSBwYXR0ZXJuIHx8IHBhdHRlcm4ucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICAgIHBhdHRlcm4gPSA6OlJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgOjpSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3twYXR0ZXJuLmNsYXNzfSAoZXhwZWN0ZWQgUmVnZXhwKVwiXG4gICAgZW5kXG5cbiAgICBwYXR0ZXJuLm1hdGNoKHNlbGYsIHBvcywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWF0Y2g/KHBhdHRlcm4sIHBvcyA9IHVuZGVmaW5lZClcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IDo6UmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyA6OlJlZ2V4cCA9PT0gcGF0dGVyblxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2g/KHNlbGYsIHBvcylcbiAgZW5kXG5cbiAgZGVmIG5leHRcbiAgICAleHtcbiAgICAgIHZhciBpID0gc2VsZi5sZW5ndGg7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QoJycpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHNlbGY7XG4gICAgICB2YXIgZmlyc3RfYWxwaGFudW1fY2hhcl9pbmRleCA9IHNlbGYuc2VhcmNoKC9bYS16QS1aMC05XS8pO1xuICAgICAgdmFyIGNhcnJ5ID0gZmFsc2U7XG4gICAgICB2YXIgY29kZTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29kZSA9IHNlbGYuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8XG4gICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikpIHtcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDU3OlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDQ4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSA2NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDk3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDI1NSkge1xuICAgICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICAgIGNvZGUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSArIDEpO1xuICAgICAgICBpZiAoY2FycnkgJiYgKGkgPT09IDAgfHwgaSA9PT0gZmlyc3RfYWxwaGFudW1fY2hhcl9pbmRleCkpIHtcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDY1OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5NzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgcmVzdWx0LnNsaWNlKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FycnkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgb2N0XG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYsXG4gICAgICAgICAgcmFkaXggPSA4O1xuXG4gICAgICBpZiAoL15cXHMqXy8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KSguKykkL2ksIGZ1bmN0aW9uIChvcmlnaW5hbCwgaGVhZCwgZmxhZywgdGFpbCkge1xuICAgICAgICBzd2l0Y2ggKHRhaWwuY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgIGlmICh0YWlsLmNoYXJBdCgxKSA9PT0gJ3gnICYmIGZsYWcgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICByYWRpeCA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcwbyc6XG4gICAgICAgICAgcmFkaXggPSA4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIHJhZGl4ID0gMTY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdCA9IHBhcnNlSW50KHN0cmluZy5yZXBsYWNlKC9fKD8hXykvZywgJycpLCByYWRpeCk7XG4gICAgICByZXR1cm4gaXNOYU4ocmVzdWx0KSA/IDAgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgb3JkXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuY29kZVBvaW50QXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc2VsZi5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5jaGFyQ29kZUF0KDApO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHBhcnRpdGlvbihzZXApXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbTtcblxuICAgICAgaWYgKHNlcC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gc2VwLmV4ZWMoc2VsZik7XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7OjpNYXRjaERhdGEubmV3IGBzZXBgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcCA9ICRjb2VyY2VfdG8oc2VwLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5pbmRleE9mKHNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gW3NlbGYsICcnLCAnJ107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNlbGYuc2xpY2UoMCwgaSksXG4gICAgICAgIHNlbGYuc2xpY2UoaSwgaSArIHNlcC5sZW5ndGgpLFxuICAgICAgICBzZWxmLnNsaWNlKGkgKyBzZXAubGVuZ3RoKVxuICAgICAgXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKWBcbiAgZW5kXG5cbiAgZGVmIHJpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtLCByLCBfbTtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gJGNvZXJjZV90byhvZmZzZXQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgciA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZWFyY2gpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIF9tID0gci5leGVjKHNlbGYpO1xuICAgICAgICAgIGlmIChfbSA9PT0gbnVsbCB8fCBfbS5pbmRleCA+IG9mZnNldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSBfbTtcbiAgICAgICAgICByLmxhc3RJbmRleCA9IG0uaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3s6Ok1hdGNoRGF0YS5uZXcgYHJgLCBgbWB9O1xuICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2ggPSAkY29lcmNlX3RvKHNlYXJjaCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VhcmNoLCBvZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaSA9PT0gLTEgPyBuaWwgOiBpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJqdXN0KHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gYCRjb2VyY2VfdG8oI3t3aWR0aH0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3s6OlN0cmluZ30sICd0b19zdHInKWAudG9fc1xuXG4gICAgaWYgcGFkc3RyLmVtcHR5P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnemVybyB3aWR0aCBwYWRkaW5nJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIHNlbGYgaWYgYHdpZHRoIDw9IHNlbGYubGVuZ3RoYFxuXG4gICAgJXh7XG4gICAgICB2YXIgY2hhcnMgICAgID0gTWF0aC5mbG9vcih3aWR0aCAtIHNlbGYubGVuZ3RoKSxcbiAgICAgICAgICBwYXR0ZXJucyAgPSBNYXRoLmZsb29yKGNoYXJzIC8gcGFkc3RyLmxlbmd0aCksXG4gICAgICAgICAgcmVzdWx0ICAgID0gQXJyYXkocGF0dGVybnMgKyAxKS5qb2luKHBhZHN0ciksXG4gICAgICAgICAgcmVtYWluaW5nID0gY2hhcnMgLSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0ICsgcGFkc3RyLnNsaWNlKDAsIHJlbWFpbmluZykgKyBzZWxmKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBycGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtLCByLCBfbTtcblxuICAgICAgaWYgKHNlcC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgciA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZXApO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgX20gPSByLmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKF9tID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbSA9IF9tO1xuICAgICAgICAgIHIubGFzdEluZGV4ID0gbS5pbmRleCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAjezo6TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgc2VwID0gbVswXTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXAgPSAkY29lcmNlX3RvKHNlcCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbJycsICcnLCBzZWxmXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZi5zbGljZSgwLCBpKSxcbiAgICAgICAgc2VsZi5zbGljZShpLCBpICsgc2VwLmxlbmd0aCksXG4gICAgICAgIHNlbGYuc2xpY2UoaSArIHNlcC5sZW5ndGgpXG4gICAgICBdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL1tcXHNcXHUwMDAwXSokLywgJycpYFxuICBlbmRcblxuICBkZWYgc2NhbihwYXR0ZXJuLCBub19tYXRjaGRhdGE6IGZhbHNlLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgbWF0Y2hfZGF0YSA9IG5pbCxcbiAgICAgICAgICBtYXRjaDtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZikpICE9IG51bGwpIHtcbiAgICAgICAgbWF0Y2hfZGF0YSA9ICN7OjpNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYCwgbm9fbWF0Y2hkYXRhOiBub19tYXRjaGRhdGF9O1xuICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgIG1hdGNoLmxlbmd0aCA9PSAxID8gcmVzdWx0LnB1c2gobWF0Y2hbMF0pIDogcmVzdWx0LnB1c2goI3tgbWF0Y2hfZGF0YWAuY2FwdHVyZXN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaC5sZW5ndGggPT0gMSA/IE9wYWwueWllbGQxKGJsb2NrLCBtYXRjaFswXSkgOiBPcGFsLnlpZWxkMShibG9jaywgI3tgbWF0Y2hfZGF0YWAuY2FwdHVyZXN9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW5vX21hdGNoZGF0YSkgI3skfiA9IGBtYXRjaF9kYXRhYH07XG5cbiAgICAgIHJldHVybiAoYmxvY2sgIT09IG5pbCA/IHNlbGYgOiByZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBXZSByZWRlZmluZSB0aGlzIG1ldGhvZCBvbiBTdHJpbmcsIGFzIGtlcm5lbC5yYiBpcyBpbiBzdHJpY3QgbW9kZVxuICAjIHNvIHRoYXQgdGhpbmdzIGxpa2UgQm9vbGVhbiBkb24ndCBnZXQgYm94ZWQuIEZvciBTdHJpbmcgdGhvdWdoIC1cbiAgIyB3ZSBlaXRoZXIgbmVlZCB0byBib3ggaXQgdG8gZGVmaW5lIHByb3BlcnRpZXMgb24gaXQsIG9yIHJ1biBpdCBpblxuICAjIG5vbi1zdHJpY3QgbW9kZS4gVGhpcyBpcyBhIG1lc3MgYW5kIHdlIG5lZWQgdG8gY29tZSBiYWNrIHRvIGl0XG4gICMgYXQgYSBsYXRlciB0aW1lLlxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgYE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIHNwbGl0KHBhdHRlcm4gPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGltaXQgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGxpbWl0LCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKGxpbWl0ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFtzZWxmXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkIHx8IHBhdHRlcm4gPT09IG5pbCkge1xuICAgICAgICBwYXR0ZXJuID0gI3skOyB8fCAnICd9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b1N0cmluZygpLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBpLCBpaTtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcgJykge1xuICAgICAgICAgIHBhdHRlcm4gPSAvXFxzKy9nbTtcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnZ20nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzdHJpbmcuc3BsaXQocGF0dGVybik7XG5cbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxICYmIHJlc3VsdFswXSA9PT0gc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbc2VsZi4kJGNhc3QocmVzdWx0WzBdKV07XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgoaSA9IHJlc3VsdC5pbmRleE9mKHVuZGVmaW5lZCkpICE9PSAtMSkge1xuICAgICAgICByZXN1bHQuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYXN0UmVzdWx0KCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0W2ldID0gc2VsZi4kJGNhc3QocmVzdWx0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT09IDApIHtcbiAgICAgICAgd2hpbGUgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgICAgcmVzdWx0Lmxlbmd0aCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyaW5nKTtcblxuICAgICAgaWYgKGxpbWl0IDwgMCkge1xuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnICYmIHBhdHRlcm4uc291cmNlLmluZGV4T2YoJyg/PScpID09PSAtMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gbWF0Y2gubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaFswXSA9PT0gJycpIHtcbiAgICAgICAgcmVzdWx0LnNwbGljZShsaW1pdCAtIDEsIHJlc3VsdC5sZW5ndGggLSAxLCByZXN1bHQuc2xpY2UobGltaXQgLSAxKS5qb2luKCcnKSk7XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID49IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGluZGV4ID0gcGF0dGVybi5sYXN0SW5kZXg7XG4gICAgICAgIGlmIChpICsgMSA9PT0gbGltaXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnNwbGljZShsaW1pdCAtIDEsIHJlc3VsdC5sZW5ndGggLSAxLCBzdHJpbmcuc2xpY2UoaW5kZXgpKTtcbiAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3F1ZWV6ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5yZXBsYWNlKC8oLilcXDErL2csICckMScpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFyX2NsYXNzID0gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKTtcbiAgICAgIGlmIChjaGFyX2NsYXNzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYucmVwbGFjZShuZXcgUmVnRXhwKCcoJyArIGNoYXJfY2xhc3MgKyAnKVxcXFwxKycsICdnJyksICckMScpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdGFydF93aXRoPygqcHJlZml4ZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcHJlZml4ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByZWZpeGVzW2ldLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgdmFyIHJlZ2V4cCA9IHByZWZpeGVzW2ldO1xuICAgICAgICAgIHZhciBtYXRjaCA9IHJlZ2V4cC5leGVjKHNlbGYpO1xuXG4gICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwgJiYgbWF0Y2guaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcoYHJlZ2V4cGAsIGBtYXRjaGApfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gJGNvZXJjZV90byhwcmVmaXhlc1tpXSwgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICAgICAgaWYgKHNlbGYuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvXltcXHNcXHUwMDAwXSp8W1xcc1xcdTAwMDBdKiQvZywgJycpYFxuICBlbmRcblxuICBkZWYgc3ViKHBhdHRlcm4sIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoIXBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCwgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICByZXN1bHQgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAjezo6TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGB9XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDEgZm9yIDIpJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBibG9jayhtYXRjaFswXSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50LiQkaXNfaGFzaCkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc30gKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSAkY29lcmNlX3RvKHJlcGxhY2VtZW50LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yZXBsYWNlKC8oW1xcXFxdKykoWzAtOSsmYCddKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIHNsYXNoZXMsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2gubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoWzBdO1xuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyAobWF0Y2hbY29tbWFuZF0gfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIHJlcGxhY2VtZW50ICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VtKG4gPSAxNilcbiAgICAleHtcbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgJiAoTWF0aC5wb3coMiwgbikgLSAxKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzd2FwY2FzZVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGYucmVwbGFjZSgvKFthLXpdKyl8KFtBLVpdKykvZywgZnVuY3Rpb24oJDAsJDEsJDIpIHtcbiAgICAgICAgcmV0dXJuICQxID8gJDAudG9VcHBlckNhc2UoKSA6ICQwLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlbGYuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tzZWxmLmNsYXNzLm5ldyBgc3RyYH07XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZsb2F0KHNlbGYucmVwbGFjZSgvXy9nLCAnJykpO1xuXG4gICAgICBpZiAoaXNOYU4ocmVzdWx0KSB8fCByZXN1bHQgPT0gSW5maW5pdHkgfHwgcmVzdWx0ID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2koYmFzZSA9IDEwKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgcmFkaXggPSAkY29lcmNlX3RvKGJhc2UsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAocmFkaXggPT09IDEgfHwgcmFkaXggPCAwIHx8IHJhZGl4ID4gMzYpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2ByYWRpeGB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICgvXlxccypfLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvLCBmdW5jdGlvbiAob3JpZ2luYWwsIGhlYWQsIGZsYWcsIHRhaWwpIHtcbiAgICAgICAgc3dpdGNoICh0YWlsLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICBpZiAodGFpbC5jaGFyQXQoMSkgPT09ICd4JyAmJiBmbGFnID09PSAnMHgnICYmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTYpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAyKSB7XG4gICAgICAgICAgICByYWRpeCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gOCkge1xuICAgICAgICAgICAgcmFkaXggPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMGQnOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTApIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxNikge1xuICAgICAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsXG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgbWV0aG9kX25hbWUgPSAnJCcgKyBgc2VsZi52YWx1ZU9mKClgXG5cbiAgICA6Oktlcm5lbC5wcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgZ2l2ZW4nfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3YgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChyZWN2ID09IG51bGwpIHJlY3YgPSBuaWw7XG5cbiAgICAgICAgdmFyIGJvZHkgPSByZWN2WyN7bWV0aG9kX25hbWV9XTtcblxuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdi4kbWV0aG9kX21pc3NpbmcuYXBwbHkocmVjdiwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYm9keS4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBib2R5LmNhbGwocmVjdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgdHIoZnJvbSwgdG8pXG4gICAgJXh7XG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICB0byA9ICRjb2VyY2VfdG8odG8sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDAgfHwgZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpbl9yYW5nZSwgYywgY2gsIHN0YXJ0LCBlbmQsIGxlbmd0aDtcbiAgICAgIHZhciBzdWJzID0ge307XG4gICAgICB2YXIgZnJvbV9jaGFycyA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG4gICAgICB2YXIgdG9fY2hhcnMgPSB0by5zcGxpdCgnJyk7XG4gICAgICB2YXIgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbF9zdWIgPSBudWxsO1xuICAgICAgaWYgKGZyb21fY2hhcnNbMF0gPT09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW52ZXJzZSA9IHRydWU7XG4gICAgICAgIGZyb21fY2hhcnMuc2hpZnQoKTtcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXG4gICAgICAgIGZyb21fbGVuZ3RoIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICB2YXIgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IGZyb21fY2hhcnNbaV07XG4gICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT09ICctJykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA9PSBmcm9tX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X3RvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGFzdF90byA9IGNoO1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSB0b19sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBsYXN0X3RvLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdfc3RyID0gJydcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzZWxmLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbY2hdO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiA9PSBudWxsID8gZ2xvYmFsX3N1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdfc3RyICs9IChzdWIgIT0gbnVsbCA/IHN1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KG5ld19zdHIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyX3MoZnJvbSwgdG8pXG4gICAgJXh7XG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICB0byA9ICRjb2VyY2VfdG8odG8sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpbl9yYW5nZSwgYywgY2gsIHN0YXJ0LCBlbmQsIGxlbmd0aDtcbiAgICAgIHZhciBzdWJzID0ge307XG4gICAgICB2YXIgZnJvbV9jaGFycyA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG4gICAgICB2YXIgdG9fY2hhcnMgPSB0by5zcGxpdCgnJyk7XG4gICAgICB2YXIgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbF9zdWIgPSBudWxsO1xuICAgICAgaWYgKGZyb21fY2hhcnNbMF0gPT09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW52ZXJzZSA9IHRydWU7XG4gICAgICAgIGZyb21fY2hhcnMuc2hpZnQoKTtcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXG4gICAgICAgIGZyb21fbGVuZ3RoIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICB2YXIgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IGZyb21fY2hhcnNbaV07XG4gICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT09ICctJykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA9PSBmcm9tX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b19jaGFycyA9IHRvX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgICAgIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IGZyb21fbGVuZ3RoIC0gdG9fbGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoX2RpZmYgPiAwKSB7XG4gICAgICAgICAgdmFyIHBhZF9jaGFyID0gKHRvX2xlbmd0aCA+IDAgPyB0b19jaGFyc1t0b19sZW5ndGggLSAxXSA6ICcnKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoX2RpZmY7IGkrKykge1xuICAgICAgICAgICAgdG9fY2hhcnMucHVzaChwYWRfY2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdG9fY2hhcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuZXdfc3RyID0gJydcbiAgICAgIHZhciBsYXN0X3N1YnN0aXR1dGUgPSBudWxsXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gc2VsZi5jaGFyQXQoaSk7XG4gICAgICAgIHZhciBzdWIgPSBzdWJzW2NoXVxuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIGlmIChzdWIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gZ2xvYmFsX3N1YjtcbiAgICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdfc3RyICs9IGNoO1xuICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHN1YiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGFzdF9zdWJzdGl0dXRlID09IG51bGwgfHwgbGFzdF9zdWJzdGl0dXRlICE9PSBzdWIpIHtcbiAgICAgICAgICAgICAgbmV3X3N0ciArPSBzdWI7XG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IHN1YjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdfc3RyICs9IGNoO1xuICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChuZXdfc3RyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1cGNhc2VcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi50b1VwcGVyQ2FzZSgpKWBcbiAgZW5kXG5cbiAgZGVmIHVwdG8oc3RvcCwgZXhjbCA9IGZhbHNlLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp1cHRvLCBzdG9wLCBleGNsIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIHZhciBhLCBiLCBzID0gc2VsZi50b1N0cmluZygpO1xuXG4gICAgICBzdG9wID0gJGNvZXJjZV90byhzdG9wLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocy5sZW5ndGggPT09IDEgJiYgc3RvcC5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICBhID0gcy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBiID0gc3RvcC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHMsIDEwKS50b1N0cmluZygpID09PSBzICYmIHBhcnNlSW50KHN0b3AsIDEwKS50b1N0cmluZygpID09PSBzdG9wKSB7XG5cbiAgICAgICAgYSA9IHBhcnNlSW50KHMsIDEwKTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHN0b3AsIDEwKTtcblxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgYSA9PT0gYikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2soYS50b1N0cmluZygpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHdoaWxlIChzLmxlbmd0aCA8PSBzdG9wLmxlbmd0aCAmJiBzIDw9IHN0b3ApIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBzID09PSBzdG9wKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhzKTtcblxuICAgICAgICAgIHMgPSAje2BzYC5zdWNjfTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cykge1xuICAgICAgZnVuY3Rpb24gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChzZXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgaSwgbGVuID0gc2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJfY2hhcixcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoLFxuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20sXG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byxcbiAgICAgICAgICAgIGNoYXJfY29kZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY3Vycl9jaGFyID0gc2V0LmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoY3Vycl9jaGFyID09PSAnLScgJiYgaSA+IDAgJiYgaSA8IChsZW4gLSAxKSAmJiAhc2tpcF9uZXh0X2Rhc2gpIHtcbiAgICAgICAgICAgIGNoYXJfY29kZV9mcm9tID0gc2V0LmNoYXJDb2RlQXQoaSAtIDEpO1xuICAgICAgICAgICAgY2hhcl9jb2RlX3VwdG8gPSBzZXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhcl9jb2RlX2Zyb20gPiBjaGFyX2NvZGVfdXB0bykge1xuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BjaGFyX2NvZGVfZnJvbWB9LSN7YGNoYXJfY29kZV91cHRvYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY2hhcl9jb2RlID0gY2hhcl9jb2RlX2Zyb20gKyAxOyBjaGFyX2NvZGUgPCBjaGFyX2NvZGVfdXB0byArIDE7IGNoYXJfY29kZSsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJfY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoID0gKGN1cnJfY2hhciA9PT0gJ1xcXFwnKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyX2NoYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXRBLCBzZXRCKSB7XG4gICAgICAgIGlmIChzZXRBLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzZXRCO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGksIGxlbiA9IHNldEEubGVuZ3RoLFxuICAgICAgICAgICAgY2hyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaHIgPSBzZXRBLmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoc2V0Qi5pbmRleE9mKGNocikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgbGVuLCBzZXQsIG5lZywgY2hyLCB0bXAsXG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9ICcnLFxuICAgICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzZXQgPSAkY29lcmNlX3RvKHNldHNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIG5lZyA9IChzZXQuY2hhckF0KDApID09PSAnXicgJiYgc2V0Lmxlbmd0aCA+IDEpO1xuICAgICAgICBzZXQgPSBleHBsb2RlX3NlcXVlbmNlc19pbl9jaGFyYWN0ZXJfc2V0KG5lZyA/IHNldC5zbGljZSgxKSA6IHNldCk7XG4gICAgICAgIGlmIChuZWcpIHtcbiAgICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uKG5lZ19pbnRlcnNlY3Rpb24sIHNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihwb3NfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgJiYgbmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRtcCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hyID0gcG9zX2ludGVyc2VjdGlvbi5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24uaW5kZXhPZihjaHIpID09PSAtMSkge1xuICAgICAgICAgICAgdG1wICs9IGNocjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9IHRtcDtcbiAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnWycgKyAjezo6UmVnZXhwLmVzY2FwZShgcG9zX2ludGVyc2VjdGlvbmApfSArICddJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1teJyArICN7OjpSZWdleHAuZXNjYXBlKGBuZWdfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuX2xvYWQoKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUoZm9ybSA9IDpuZmMpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIkludmFsaWQgbm9ybWFsaXphdGlvbiBmb3JtICN7Zm9ybX1cIiB1bmxlc3MgJWlbbmZjIG5mZCBuZmtjIG5ma2RdLmluY2x1ZGU/KGZvcm0pXG4gICAgYHNlbGYubm9ybWFsaXplKCN7Zm9ybS51cGNhc2V9KWBcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplZD8oZm9ybSA9IDpuZmMpXG4gICAgdW5pY29kZV9ub3JtYWxpemUoZm9ybSkgPT0gc2VsZlxuICBlbmRcblxuICBkZWYgdW5wYWNrKGZvcm1hdClcbiAgICA6Oktlcm5lbC5yYWlzZSBcIlRvIHVzZSBTdHJpbmcjdW5wYWNrLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL3N0cmluZy91bnBhY2snLlwiXG4gIGVuZFxuXG4gIGRlZiB1bnBhY2sxKGZvcm1hdClcbiAgICA6Oktlcm5lbC5yYWlzZSBcIlRvIHVzZSBTdHJpbmcjdW5wYWNrMSwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSByZXR1cm4gc2VsZjtcbiAgICAgIHNlbGYuJCRmcm96ZW4gPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgLUBcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycpIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuJCRmcm96ZW4gPT09IHRydWUpIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcubmFtZSA9PSAnVVRGLTgnICYmIHNlbGYuaW50ZXJuYWxfZW5jb2RpbmcubmFtZSA9PSAnVVRGLTgnKSByZXR1cm4gc2VsZi50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIHNlbGYuJGR1cCgpLiRmcmVlemUoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgYHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJyB8fCBzZWxmLiQkZnJvemVuID09PSB0cnVlYFxuICBlbmRcblxuICBhbGlhcyArQCBkdXBcbiAgYWxpYXMgPT09ID09XG4gIGFsaWFzIGJ5dGVzbGljZSBbXVxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIGVxdWFsPyA9PT1cbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuICBhbGlhcyBzbGljZSBbXVxuICBhbGlhcyBzdWNjIG5leHRcbiAgYWxpYXMgdG9fc3RyIHRvX3NcbiAgYWxpYXMgdG9fc3ltIGludGVyblxuXG4gIDo6T3BhbC5wcmlzdGluZSBzZWxmLCA6aW5pdGlhbGl6ZVxuZW5kXG5cblN5bWJvbCA9IFN0cmluZ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpTdHJpbmc+IiwiaW5jbHVkZSIsIkNvbXBhcmFibGUiLCJfX2lkX18iLCJ0cnlfY29udmVydCIsIndoYXQiLCJPcGFsIiwiY29lcmNlX3RvPyIsIlN0cmluZyIsIm5ldyIsImluaXRpYWxpemUiLCJhcmdzIiwiJSIsImRhdGEiLCJBcnJheSIsImZvcm1hdCIsIioiLCJjb3VudCIsIkludGVnZXIiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJSYW5nZUVycm9yIiwiKyIsIm90aGVyIiwiPD0+IiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19zIiwiPT0iLCI9fiIsIlR5cGVFcnJvciIsIltdIiwiaW5kZXgiLCJsZW5ndGgiLCIkfiIsIk1hdGNoRGF0YSIsImIiLCJmb3JjZV9lbmNvZGluZyIsImNhcGl0YWxpemUiLCJjYXNlY21wIiwiY2FzZWNtcD8iLCJjZW50ZXIiLCJ3aWR0aCIsInBhZHN0ciIsImVtcHR5PyIsImxqdXN0IiwiLyIsIjIiLCJjZWlsIiwicmp1c3QiLCJmbG9vciIsImNob21wIiwic2VwYXJhdG9yIiwiJC8iLCJjb2VyY2VfdG8hIiwiY2hvcCIsImNociIsImNsb25lIiwiY29weSIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJpbml0aWFsaXplX2Nsb25lIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJkZWxldGUiLCJkZWxldGVfcHJlZml4IiwicHJlZml4IiwiZGVsZXRlX3N1ZmZpeCIsInN1ZmZpeCIsImRvd25jYXNlIiwiZWFjaF9saW5lIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJlbmRfd2l0aD8iLCJnc3ViIiwicGF0dGVybiIsInJlcGxhY2VtZW50IiwiaGFzaCIsImhleCIsInRvX2kiLCIxNiIsImluY2x1ZGU/Iiwic2VhcmNoIiwib2Zmc2V0IiwiaW5zcGVjdCIsImludGVybiIsImxpbmVzIiwiZSIsImJsb2NrIiwidG9fcHJvYyIsInRvX2EiLCJsc3RyaXAiLCJhc2NpaV9vbmx5PyIsIm1hdGNoIiwicG9zIiwiUmVnZXhwIiwiY2xhc3MiLCJtYXRjaD8iLCJuZXh0Iiwib2N0Iiwib3JkIiwicGFydGl0aW9uIiwic2VwIiwicmV2ZXJzZSIsInJpbmRleCIsInJwYXJ0aXRpb24iLCJyc3RyaXAiLCJzY2FuIiwiJGt3YXJncyIsIm5vX21hdGNoZGF0YSIsImNhcHR1cmVzIiwic2luZ2xldG9uX2NsYXNzIiwic3BsaXQiLCJsaW1pdCIsIiRyZXRfb3JfMSIsIiQ7Iiwic3F1ZWV6ZSIsInN0YXJ0X3dpdGg/Iiwic3RyaXAiLCJzdWIiLCJzdW0iLCJuIiwic3dhcGNhc2UiLCJ0b19mIiwiYmFzZSIsIjEwIiwibWV0aG9kX25hbWUiLCJwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInRyIiwiZnJvbSIsInRvIiwidHJfcyIsInVwY2FzZSIsInVwdG8iLCJzdG9wIiwiZXhjbCIsInN1Y2MiLCJlc2NhcGUiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJfbG9hZCIsInVuaWNvZGVfbm9ybWFsaXplIiwiZm9ybSIsInVuaWNvZGVfbm9ybWFsaXplZD8iLCJ1bnBhY2siLCJ1bnBhY2sxIiwiZnJlZXplIiwiLUAiLCJmcm96ZW4/IiwicHJpc3RpbmUiXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBRUFDO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFHRkQsY0FBZ0JGLElBQUtFOztBQUVyQkEsY0FBZ0JGLElBQUtFO0FBQ3JCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFRUcsSUFBQUEsc0JBQUFB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QSxrQ0FBU1csWUFBVDtBQWgyREFYOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo5MzQxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG8sIHlpZWxkMSwgeWllbGRYXG5cbm1vZHVsZSA6OkVudW1lcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBbbmlsXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZGVmIGFsbD8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiBmYWxzZSB1bmxlc3MgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIDo6T3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIGFueT8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiB0cnVlIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBjaHVuaygmYmxvY2spXG4gICAgcmV0dXJuIHRvX2VudW0oOmNodW5rKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIDo6RW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gbmlsLCBhY2N1bXVsYXRlID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gcmVsZWFzZUFjY3VtdWxhdGUoKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBwcmV2aW91c2AsIGBhY2N1bXVsYXRlYCl9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBrZXkgPSAkeWllbGQxKGJsb2NrLCB2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5pbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSBuaWwgfHwgcHJldmlvdXMgPT09IGtleSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2h1bmtfd2hpbGUoJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzbGljZV93aGVuIHsgfGJlZm9yZSwgYWZ0ZXJ8ICEoeWllbGQgYmVmb3JlLCBhZnRlcikgfVxuICBlbmRcblxuICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0X2NvbmNhdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0X2NvbmNhdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgbWFwIHsgfGl0ZW18IHlpZWxkIGl0ZW0gfS5mbGF0dGVuKDEpXG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgdG9fYS5jb21wYWN0XG4gIGVuZFxuXG4gIGRlZiBjb3VudChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXN1bHQgPSAwXG5cbiAgICAleHtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG8gfCphcmdzfFxuICAgICAgICA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqZWN0XG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9jay5uaWw/XG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgeyB0cnVlIH1cbiAgICBlbmRcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgYHJlc3VsdCsrYCBpZiBgJHlpZWxkWChibG9jaywgYXJncylgXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGN5Y2xlKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmN5Y2xlLCBuKSBkb1xuICAgICAgICBpZiBuLm5pbD9cbiAgICAgICAgICByZXNwb25kX3RvPyg6c2l6ZSkgPyA6OkZsb2F0OjpJTkZJTklUWSA6IG5pbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgICBuID4gMCA/IGVudW1lcmF0b3Jfc2l6ZSAqIG4gOiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICBuID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAgIHJldHVybiBpZiBgbiA8PSAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgYWxsID0gW10sIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBhbGwucHVzaChwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKGFsbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRldGVjdChpZm5vbmUgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmRldGVjdCwgaWZub25lIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAgIGlmIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaWZub25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihpZm5vbmUpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGlmbm9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpZm5vbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGRyb3AobnVtYmVyKVxuICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgbnVtYmVyIDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ICA9IFtdLFxuICAgICAgICAgIGN1cnJlbnQgPSAwO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobnVtYmVyIDw9IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQrKztcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZHJvcF93aGlsZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgICA9IFtdLFxuICAgICAgICAgIGRyb3BwaW5nID0gdHJ1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBpZiAoZHJvcHBpbmcpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgICBpZiAoISR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICBkcm9wcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NvbnMobiwgJmJsb2NrKVxuICAgIGlmIGBhcmd1bWVudHMubGVuZ3RoICE9IDFgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAxKVwiXG4gICAgZW5kXG5cbiAgICBuID0gOjpPcGFsLnRyeV9jb252ZXJ0IG4sIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2l6ZSdcbiAgICBlbmRcblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jb25zLCBuKSBkb1xuICAgICAgICBlbnVtX3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgICAgaWYgZW51bV9zaXplLm5pbD9cbiAgICAgICAgICBuaWxcbiAgICAgICAgZWxzaWYgZW51bV9zaXplID09IDAgfHwgZW51bV9zaXplIDwgblxuICAgICAgICAgIDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW1fc2l6ZSAtIG4gKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBidWZmZXIgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICBidWZmZXIucHVzaChlbGVtZW50KTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiBuKSB7XG4gICAgICAgICAgYnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbikge1xuICAgICAgICAgICR5aWVsZDEoYmxvY2ssIGJ1ZmZlci5zbGljZSgwLCBuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2VudHJ5KCpkYXRhLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIHRvX2VudW0oOmVhY2hfZW50cnksICpkYXRhKSB7IGVudW1lcmF0b3Jfc2l6ZSB9XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAkeWllbGQxKGJsb2NrLCBpdGVtKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBkYXRhKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9zbGljZShuLCAmYmxvY2spXG4gICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2xpY2Ugc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9zbGljZSwgbikgeyByZXNwb25kX3RvPyg6c2l6ZSkgPyAoc2l6ZSAvIG4pLmNlaWwgOiBuaWwgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBzbGljZSA9IFtdXG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA9PT0gbikge1xuICAgICAgICAgICR5aWVsZDEoYmxvY2ssIHNsaWNlKTtcbiAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIC8vIG91ciBcImxhc3RcIiBncm91cCwgaWYgc21hbGxlciB0aGFuIG4gdGhlbiB3b24ndCBoYXZlIGJlZW4geWllbGRlZFxuICAgICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9pbmRleCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX2luZGV4LCAqYXJncykgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfb2JqZWN0KG9iamVjdCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX29iamVjdCwgb2JqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgb2JqZWN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcbiAgICB9XG5cbiAgICBvYmplY3RcbiAgZW5kXG5cbiAgZGVmIGVudHJpZXMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0pO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaWx0ZXJfbWFwKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmZpbHRlcl9tYXApIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgbWFwKCZibG9jaykuc2VsZWN0KCY6aXRzZWxmKVxuICBlbmRcblxuICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmluZF9hbGwpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaW5kX2luZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZmluZF9pbmRleCBpZiBgb2JqZWN0ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gMFxuXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpID09IG9iamVjdFxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChudW1iZXIgPSB1bmRlZmluZWQpXG4gICAgaWYgYG51bWJlciA9PT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8dmFsdWV8XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgcmVzdWx0ID0gW11cbiAgICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgIGlmIGBudW1iZXIgPCAwYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbnVtYmVyID09IDBgXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnQgPSAwXG5cbiAgICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgICBgcmVzdWx0LnB1c2goI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9KWBcblxuICAgICAgICBpZiBgbnVtYmVyIDw9ICsrY3VycmVudGBcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IHVubGVzcyBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXG4gICAgICBlbHNpZiB2YWx1ZS5sZW5ndGggPD0gMVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGdyZXBfdihwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IGlmIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JvdXBfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Z3JvdXBfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaGFzaCA9IHt9XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAjeyhoYXNoW2B2YWx1ZWBdIHx8PSBbXSkgPDwgYHBhcmFtYH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaFxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8ob2JqKVxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaWYgOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9ialxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5qZWN0KG9iamVjdCA9IHVuZGVmaW5lZCwgc3ltID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gJHlpZWxkWChibG9jaywgW3Jlc3VsdCwgdmFsdWVdKTtcblxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICghI3s6OlN5bWJvbCA9PT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje29iamVjdC5pbnNwZWN0fSBpcyBub3QgYSBTeW1ib2xcIn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3ltICAgID0gb2JqZWN0O1xuICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gI3tgcmVzdWx0YC5fX3NlbmRfXyBzeW0sIGB2YWx1ZWB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxhenlcbiAgICA6OkVudW1lcmF0b3I6OkxhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVudW1lcmF0b3Jfc2l6ZVxuICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IHNpemUgOiBuaWxcbiAgZW5kXG5cbiAgZGVmIG1heChuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAobiA9PT0gdW5kZWZpbmVkIHx8IG4gPT09IG5pbCkge1xuICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBbaXRlbSwgcmVzdWx0XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gI3tgaXRlbWAgPD0+IGByZXN1bHRgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuID0gJGNvZXJjZV90byhuLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG5cbiAgICBzb3J0KCZibG9jaykucmV2ZXJzZS5maXJzdChuKVxuICBlbmRcblxuICBkZWYgbWF4X2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1heF9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykucmV2ZXJzZS50YWtlIG5cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPD0+IGBieWB9ID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtXG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbihuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHJldHVybiBzb3J0IHsgfGEsIGJ8IHlpZWxkIGEsIGIgfS50YWtlIG5cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHNvcnQudGFrZSBuXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBibG9jayhwYXJhbSwgcmVzdWx0KTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCN7OjpPcGFsLmNvbXBhcmUoYHBhcmFtYCwgYHJlc3VsdGApfSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWluX2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbl9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykudGFrZSBuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgYnk7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgIDw9PiBgYnlgfSA8IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5tYXgoJmJsb2NrKVxuICAgIGJsb2NrIHx8PSA6Oktlcm5lbC5wcm9jIHsgfGEsIGJ8IGEgPD0+IGIgfVxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gbmlsLCBtYXggPSBuaWwsIGZpcnN0X3RpbWUgPSB0cnVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIGlmIChmaXJzdF90aW1lKSB7XG4gICAgICAgICAgbWluID0gbWF4ID0gZWxlbWVudDtcbiAgICAgICAgICBmaXJzdF90aW1lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pbl9jbXAgPSAje2Jsb2NrLmNhbGwoYG1pbmAsIGBlbGVtZW50YCl9O1xuXG4gICAgICAgICAgaWYgKG1pbl9jbXAgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5fY21wID4gMCkge1xuICAgICAgICAgICAgbWluID0gZWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbWF4X2NtcCA9ICN7YmxvY2suY2FsbChgbWF4YCwgYGVsZW1lbnRgKX07XG5cbiAgICAgICAgICBpZiAobWF4X2NtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1heF9jbXAgPCAwKSB7XG4gICAgICAgICAgICBtYXggPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbm1heF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5tYXhfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW5fcmVzdWx0ID0gbmlsLFxuICAgICAgICAgIG1heF9yZXN1bHQgPSBuaWwsXG4gICAgICAgICAgbWluX2J5LFxuICAgICAgICAgIG1heF9ieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgobWluX2J5ID09PSB1bmRlZmluZWQpIHx8ICN7YHZhbHVlYCA8PT4gYG1pbl9ieWB9IDwgMCkge1xuICAgICAgICAgIG1pbl9yZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBtaW5fYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG1heF9ieSA9PT0gdW5kZWZpbmVkKSB8fCAje2B2YWx1ZWAgPD0+IGBtYXhfYnlgfSA+IDApIHtcbiAgICAgICAgICBtYXhfcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgbWF4X2J5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbbWluX3Jlc3VsdCwgbWF4X3Jlc3VsdF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbm9uZT8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGl0ZW0gPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgb25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgY291bnQgPSAwXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICByZXR1cm4gZmFsc2UgaWYgY291bnQgPiAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIG5leHQgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgOjpPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjb3VudCA9PSAxXG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cGFydGl0aW9uKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHRydXRoeSA9IFtdLCBmYWxzeSA9IFtdLCByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICB0cnV0aHkucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmFsc3kucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCEkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXZlcnNlX2VhY2gpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgJHlpZWxkWChibG9jaywgcmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzbGljZV9iZWZvcmUocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICA6OkVudW1lcmF0b3IubmV3IGRvIHxlfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmxvY2socGFyYW0sICN7cGF0dGVybi5kdXB9KTtcblxuICAgICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkgJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2VfYWZ0ZXIocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIHsgfGV8IHBhdHRlcm4gPT09IGUgfVxuICAgIGVuZFxuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgYWNjdW11bGF0ZTtcblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgZW5kX2NodW5rID0gJHlpZWxkMShibG9jaywgZWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCR0cnV0aHkoZW5kX2NodW5rKSkge1xuICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBhY2N1bXVsYXRlYCl9O1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAoYWNjdW11bGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBhY2N1bXVsYXRlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzbGljZV93aGVuKCZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKScgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBuaWwsIGxhc3RfYWZ0ZXIgPSBuaWw7XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbXMgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICBiZWZvcmUgPSBwYXJhbXNbMF0sXG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyYW1zWzFdLFxuICAgICAgICAgICAgICBtYXRjaCA9ICR5aWVsZFgoYmxvY2ssIFtiZWZvcmUsIGFmdGVyXSk7XG5cbiAgICAgICAgICBsYXN0X2FmdGVyID0gYWZ0ZXI7XG5cbiAgICAgICAgICBpZiAoc2xpY2UgPT09IG5pbCkge1xuICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShtYXRjaCkpIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zKDIpO1xuXG4gICAgICAgIGlmIChzbGljZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2xpY2UucHVzaChsYXN0X2FmdGVyKTtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICBhcnkgPSB0b19hXG4gICAgYmxvY2sgPSAtPihhLCBiKSB7IGEgPD0+IGIgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgYXJ5LnNvcnQoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc29ydF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGR1cCA9IG1hcCBkb1xuICAgICAgYXJnID0gOjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKVxuICAgICAgW3lpZWxkKGFyZyksIGFyZ11cbiAgICBlbmRcbiAgICBkdXAuc29ydCEgeyB8YSwgYnwgYGFbMF1gIDw9PiBgYlswXWAgfVxuICAgIGR1cC5tYXAhIHsgfGl8IGBpWzFdYCB9XG4gIGVuZFxuXG4gICMgVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgS2FoYW4gc3VtbWF0aW9uIGFsZ29yaXRobSBpZiBpdCBpcyBwb3NzaWJsZSB0byBhcHBseSBvbmUuXG4gIGRlZiBzdW0oaW5pdGlhbCA9IDApXG4gICAgcmVzdWx0ID0gaW5pdGlhbFxuICAgIGNvbXBlbnNhdGlvbiA9IDBcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaXRlbSA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgeWllbGQoKmFyZ3MpXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG4gICAgICAgICAgICAgZW5kXG5cbiAgICAgIGlmICFbOjpGbG9hdDo6SU5GSU5JVFksIC06OkZsb2F0OjpJTkZJTklUWV0uaW5jbHVkZT8oaXRlbSkgJiYgaXRlbS5yZXNwb25kX3RvPyg6LSlcbiAgICAgICAgeSA9IGl0ZW0gLSBjb21wZW5zYXRpb25cbiAgICAgICAgdCA9IHJlc3VsdCArIHlcbiAgICAgICAgY29tcGVuc2F0aW9uID0gKHQgLSByZXN1bHQpIC0geVxuICAgICAgICByZXN1bHQgPSB0XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdCArPSBpdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdGFrZShudW0pXG4gICAgZmlyc3QobnVtKVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp0YWtlX3doaWxlIHVubGVzcyBibG9ja1xuXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcblxuICAgICAgdW5sZXNzIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICBlbmRcblxuICAgICAgYHJlc3VsdC5wdXNoKHZhbHVlKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHVuaXEoJmJsb2NrKVxuICAgIGhhc2ggPSB7fVxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuXG4gICAgICBwcm9kdWNlZCA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgICAgIHlpZWxkKHZhbHVlKVxuICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIHVubGVzcyBoYXNoLmtleT8ocHJvZHVjZWQpXG4gICAgICAgIGhhc2hbcHJvZHVjZWRdID0gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaGFzaC52YWx1ZXNcbiAgZW5kXG5cbiAgZGVmIHRhbGx5KGhhc2ggPSB1bmRlZmluZWQpXG4gICAgb3V0ID0gZ3JvdXBfYnkoJjppdHNlbGYpLnRyYW5zZm9ybV92YWx1ZXMoJjpjb3VudClcbiAgICBpZiBoYXNoXG4gICAgICBvdXQuZWFjaCB7IHxrLCB2fCBoYXNoW2tdID0gaGFzaC5mZXRjaChrLCAwKSArIHYgfVxuICAgICAgaGFzaFxuICAgIGVsc2VcbiAgICAgIG91dFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9faCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oKCphcmdzKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgdmFyIGFyeSA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYHBhcmFtYCwgOjpBcnJheSwgOnRvX2FyeSl9LCBrZXksIHZhbDtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgZWxlbWVudCB0eXBlICN7YGFyeWAuY2xhc3N9IChleHBlY3RlZCBhcnJheSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJ5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIGFycmF5IGxlbmd0aCAoZXhwZWN0ZWQgMiwgd2FzICN7YGFyeWAubGVuZ3RofSlcIn1cbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBhcnlbMF07XG4gICAgICAgIHZhbCA9IGFyeVsxXTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXG4gICAgdG9fYS56aXAoKm90aGVycylcbiAgZW5kXG5cbiAgYWxpYXMgZmluZCBkZXRlY3RcbiAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXG4gIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG4gIGFsaWFzIG1hcCBjb2xsZWN0XG4gIGFsaWFzIG1lbWJlcj8gaW5jbHVkZT9cbiAgYWxpYXMgcmVkdWNlIGluamVjdFxuICBhbGlhcyBzZWxlY3QgZmluZF9hbGxcbiAgYWxpYXMgdG9fYSBlbnRyaWVzXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpFbnVtZXJhYmxlPiIsImFsbD8iLCJwYXR0ZXJuIiwiZWFjaCIsInNlbGYiLCJibG9jayBpbiBhbGw/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbGw/IiwiY29tcGFyYWJsZSIsInB1YmxpY19zZW5kIiwiYmxvY2tfZ2l2ZW4/IiwidmFsdWUiLCJPcGFsIiwiZGVzdHJ1Y3R1cmUiLCJhbnk/IiwiYmxvY2sgaW4gYW55PyIsImJsb2NrICgyIGxldmVscykgaW4gYW55PyIsImNodW5rIiwidG9fZW51bSIsImJsb2NrIGluIGNodW5rIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjaHVuayIsImVudW1lcmF0b3Jfc2l6ZSIsIm5ldyIsIkVudW1lcmF0b3IiLCJ5aWVsZGVyIiwieWllbGQiLCJjaHVua193aGlsZSIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInNsaWNlX3doZW4iLCJibG9jayBpbiBjaHVua193aGlsZSIsImJlZm9yZSIsImFmdGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjaHVua193aGlsZSIsIiEiLCJjb2xsZWN0IiwiZW51bV9mb3IiLCJibG9jayBpbiBjb2xsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0IiwiY29sbGVjdF9jb25jYXQiLCJibG9jayBpbiBjb2xsZWN0X2NvbmNhdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdF9jb25jYXQiLCJtYXAiLCJpdGVtIiwiZmxhdHRlbiIsIjEiLCJjb21wYWN0IiwidG9fYSIsImNvdW50Iiwib2JqZWN0IiwicmVzdWx0IiwiMCIsIndhcm4iLCJibG9jayIsInByb2MiLCJibG9jayBpbiBjb3VudCIsImJsb2NrICgyIGxldmVscykgaW4gY291bnQiLCJhcmdzIiwiPT0iLCJuaWw/IiwiY3ljbGUiLCJuIiwiYmxvY2sgaW4gY3ljbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGN5Y2xlIiwicmVzcG9uZF90bz8iLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiPiIsIioiLCJkZXRlY3QiLCJpZm5vbmUiLCJibG9jayBpbiBkZXRlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGRldGVjdCIsImRyb3AiLCJudW1iZXIiLCJkcm9wX3doaWxlIiwiZWFjaF9jb25zIiwidHJ5X2NvbnZlcnQiLCJibG9jayBpbiBlYWNoX2NvbnMiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfY29ucyIsImVudW1fc2l6ZSIsIjwiLCIrIiwiLSIsImVhY2hfZW50cnkiLCJkYXRhIiwiYmxvY2sgaW4gZWFjaF9lbnRyeSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9lbnRyeSIsImVhY2hfc2xpY2UiLCJibG9jayBpbiBlYWNoX3NsaWNlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3NsaWNlIiwiLyIsInNpemUiLCJjZWlsIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3dpdGhfaW5kZXgiLCJlYWNoX3dpdGhfb2JqZWN0IiwiYmxvY2sgaW4gZWFjaF93aXRoX29iamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF93aXRoX29iamVjdCIsImVudHJpZXMiLCJmaWx0ZXJfbWFwIiwiYmxvY2sgaW4gZmlsdGVyX21hcCIsImJsb2NrICgyIGxldmVscykgaW4gZmlsdGVyX21hcCIsInNlbGVjdCIsInRvX3Byb2MiLCJmaW5kX2FsbCIsImJsb2NrIGluIGZpbmRfYWxsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX2FsbCIsImZpbmRfaW5kZXgiLCJpbmRleCIsImJsb2NrIGluIGZpbmRfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbmRfaW5kZXgiLCJmaXJzdCIsImJsb2NrIGluIGZpcnN0IiwiY3VycmVudCIsImJsb2NrICgyIGxldmVscykgaW4gZmlyc3QiLCJncmVwIiwiYmxvY2sgaW4gZ3JlcCIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcCIsImNtcCIsIl9fc2VuZF9fIiwibGVuZ3RoIiwiPD0iLCJbXSIsInB1c2giLCJncmVwX3YiLCJibG9jayBpbiBncmVwX3YiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyZXBfdiIsImdyb3VwX2J5IiwiYmxvY2sgaW4gZ3JvdXBfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyb3VwX2J5IiwiaGFzaCIsIiRyZXRfb3JfMSIsIiR3cml0ZXIiLCJbXT0iLCI8PCIsImluY2x1ZGU/Iiwib2JqIiwiYmxvY2sgaW4gaW5jbHVkZT8iLCJibG9jayAoMiBsZXZlbHMpIGluIGluY2x1ZGU/IiwiaW5qZWN0Iiwic3ltIiwiU3ltYm9sIiwiPT09IiwiVHlwZUVycm9yIiwiaW5zcGVjdCIsImxhenkiLCJFbnVtZXJhdG9yOjpMYXp5IiwiYmxvY2sgaW4gbGF6eSIsImVudW0kIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBsYXp5IiwibWF4IiwiPD0+Iiwic29ydCIsInJldmVyc2UiLCJtYXhfYnkiLCJibG9jayBpbiBtYXhfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIG1heF9ieSIsInNvcnRfYnkiLCJ0YWtlIiwibWluIiwiYmxvY2sgaW4gbWluIiwiYSIsImIiLCJjb21wYXJlIiwibWluX2J5IiwiYmxvY2sgaW4gbWluX2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW5fYnkiLCJtaW5tYXgiLCJibG9jayBpbiBtaW5tYXgiLCJibG9jayAoMiBsZXZlbHMpIGluIG1pbm1heCIsImNhbGwiLCJtaW5tYXhfYnkiLCJibG9jayBpbiBtaW5tYXhfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIG1pbm1heF9ieSIsIm5vbmU/IiwiYmxvY2sgaW4gbm9uZT8iLCJibG9jayAoMiBsZXZlbHMpIGluIG5vbmU/Iiwib25lPyIsImJsb2NrIGluIG9uZT8iLCJibG9jayAoMiBsZXZlbHMpIGluIG9uZT8iLCJwYXJ0aXRpb24iLCJibG9jayBpbiBwYXJ0aXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHBhcnRpdGlvbiIsInJlamVjdCIsImJsb2NrIGluIHJlamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0IiwicmV2ZXJzZV9lYWNoIiwiYmxvY2sgaW4gcmV2ZXJzZV9lYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXZlcnNlX2VhY2giLCJzbGljZV9iZWZvcmUiLCJibG9jayBpbiBzbGljZV9iZWZvcmUiLCJlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzbGljZV9iZWZvcmUiLCJkdXAiLCJzbGljZV9hZnRlciIsImJsb2NrIGluIHNsaWNlX2FmdGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzbGljZV9hZnRlciIsImJsb2NrIGluIHNsaWNlX3doZW4iLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWNlX3doZW4iLCJhcnkiLCJibG9jayBpbiBzb3J0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0IiwiYmxvY2sgaW4gc29ydF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gc29ydF9ieSIsImFyZyIsInNvcnQhIiwibWFwISIsImkiLCJzdW0iLCJpbml0aWFsIiwiY29tcGVuc2F0aW9uIiwiYmxvY2sgaW4gc3VtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdW0iLCItQCIsInkiLCJ0IiwibnVtIiwidGFrZV93aGlsZSIsImJsb2NrIGluIHRha2Vfd2hpbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIHRha2Vfd2hpbGUiLCJ1bmlxIiwiYmxvY2sgaW4gdW5pcSIsImJsb2NrICgyIGxldmVscykgaW4gdW5pcSIsInByb2R1Y2VkIiwia2V5PyIsInZhbHVlcyIsInRhbGx5Iiwib3V0IiwidHJhbnNmb3JtX3ZhbHVlcyIsImJsb2NrIGluIHRhbGx5IiwiayIsInYiLCJibG9jayAoMiBsZXZlbHMpIGluIHRhbGx5IiwiZmV0Y2giLCJ0b19oIiwiY29lcmNlX3RvPyIsIkFycmF5IiwiY2xhc3MiLCJ6aXAiLCJvdGhlcnMiXSwibWFwcGluZ3MiOiJBQUFBQSxxREFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOzs7OztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FB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QUFWO0lBQ0EsYUFBTSxTQUFOLEVBQWMsVUFBZDtJQUNBLGFBQU0sUUFBTixFQUFhLFFBQWI7SUFDQSxhQUFNLFFBQU4sRUFBYSxVQUFiO0lBQ0FsUCxPQUFBLGFBQU0sTUFBTixFQUFXLFNBQVg7RUE3dkNGQSxHQUFPLElBQVBBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMTE5NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9hcml0aG1ldGljX3NlcXVlbmNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6RW51bWVyYXRvclxuICBjbGFzcyBzZWxmOjpBcml0aG1ldGljU2VxdWVuY2UgPCBzZWxmXG4gICAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19hcml0aG1ldGljX3NlcScsIHRydWUpYFxuXG4gICAgYHZhciBpbmYgPSBJbmZpbml0eWBcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgaW5pdGlhbGl6ZShyYW5nZSwgc3RlcCA9IHVuZGVmaW5lZCwgY3JlYXRpb25fbWV0aG9kID0gOnN0ZXApXG4gICAgICBAY3JlYXRpb25fbWV0aG9kID0gY3JlYXRpb25fbWV0aG9kXG4gICAgICBpZiByYW5nZS5pc19hPyA6OkFycmF5XG4gICAgICAgIEBzdGVwX2FyZzEsIEBzdGVwX2FyZzIsIEB0b3BmeCwgQGJ5cGZ4ID0gKnJhbmdlXG4gICAgICAgIEByZWNlaXZlcl9udW0gPSBzdGVwXG4gICAgICAgIEBzdGVwID0gMVxuXG4gICAgICAgIEByYW5nZSA9IGlmIEBzdGVwX2FyZzJcbiAgICAgICAgICAgICAgICAgICBAc3RlcCA9IEBzdGVwX2FyZzJcbiAgICAgICAgICAgICAgICAgICAoQHJlY2VpdmVyX251bS4uQHN0ZXBfYXJnMSlcbiAgICAgICAgICAgICAgICAgZWxzaWYgQHN0ZXBfYXJnMVxuICAgICAgICAgICAgICAgICAgIChAcmVjZWl2ZXJfbnVtLi5Ac3RlcF9hcmcxKVxuICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgKEByZWNlaXZlcl9udW0uLm5pbClcbiAgICAgICAgICAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIEBza2lwcGVkX2FyZyA9IHRydWUgdW5sZXNzIHN0ZXBcbiAgICAgICAgQHJhbmdlLCBAc3RlcCA9IHJhbmdlLCBzdGVwIHx8IDFcbiAgICAgIGVuZFxuXG4gICAgICBAb2JqZWN0ID0gc2VsZlxuXG4gICAgICA6Oktlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgMFwiIGlmIEBzdGVwID09IDBcbiAgICAgIHVubGVzcyBAc3RlcC5yZXNwb25kX3RvPyA6dG9faW50XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje0BzdGVwLmNsYXNzfSBcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW50byBJbnRlZ2VyJ1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhdHRyX3JlYWRlciA6c3RlcFxuXG4gICAgZGVmIGJlZ2luXG4gICAgICBAcmFuZ2UuYmVnaW5cbiAgICBlbmRcblxuICAgIGRlZiBlbmRcbiAgICAgIEByYW5nZS5lbmRcbiAgICBlbmRcblxuICAgIGRlZiBleGNsdWRlX2VuZD9cbiAgICAgIEByYW5nZS5leGNsdWRlX2VuZD9cbiAgICBlbmRcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgX2xlc3Nlcl90aGFuX2VuZD8odmFsKVxuICAgICAgZW5kXyA9IHNlbGYuZW5kIHx8IGBpbmZgXG4gICAgICBpZiBzdGVwID4gMFxuICAgICAgICBleGNsdWRlX2VuZD8gPyB2YWwgPCBlbmRfIDogdmFsIDw9IGVuZF9cbiAgICAgIGVsc2VcbiAgICAgICAgZXhjbHVkZV9lbmQ/ID8gdmFsID4gZW5kXyA6IHZhbCA+PSBlbmRfXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgX2dyZWF0ZXJfdGhhbl9iZWdpbj8odmFsKVxuICAgICAgYmVnaW5fID0gc2VsZi5iZWdpbiB8fCAtYGluZmBcbiAgICAgIGlmIHN0ZXAgPiAwXG4gICAgICAgIHZhbCA+IGJlZ2luX1xuICAgICAgZWxzZVxuICAgICAgICB2YWwgPCBiZWdpbl9cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGZpcnN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICAgaXRlciA9IHNlbGYuYmVnaW4gfHwgLWBpbmZgXG5cbiAgICAgIHJldHVybiBfbGVzc2VyX3RoYW5fZW5kPyhpdGVyKSA/IGl0ZXIgOiBuaWwgdW5sZXNzIGNvdW50XG5cbiAgICAgIG91dCA9IFtdXG5cbiAgICAgIHdoaWxlIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpICYmIGNvdW50ID4gMFxuICAgICAgICBvdXQgPDwgaXRlclxuICAgICAgICBpdGVyICs9IHN0ZXBcbiAgICAgICAgY291bnQgLT0gMVxuICAgICAgZW5kXG5cbiAgICAgIG91dFxuICAgIGVuZFxuXG4gICAgZGVmIGVhY2goJmJsb2NrKVxuICAgICAgcmV0dXJuIHNlbGYgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgICBjYXNlIHNlbGYuYmVnaW5cbiAgICAgIHdoZW4gbmlsXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIFR5cGVFcnJvciwgXCJuaWwgY2FuJ3QgYmUgY29lcmNlZCBpbnRvIEludGVnZXJcIlxuICAgICAgZW5kXG5cbiAgICAgIGl0ZXIgPSBzZWxmLmJlZ2luIHx8IC1gaW5mYFxuXG4gICAgICB3aGlsZSBfbGVzc2VyX3RoYW5fZW5kPyhpdGVyKVxuICAgICAgICB5aWVsZCBpdGVyXG4gICAgICAgIGl0ZXIgKz0gc3RlcFxuICAgICAgZW5kXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgbGFzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAgIGNhc2Ugc2VsZi5lbmRcbiAgICAgIHdoZW4gYGluZmAsIC1gaW5mYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsIHNlbGYuZW5kXG4gICAgICB3aGVuIG5pbFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgZW5kbGVzcyBhcml0aG1ldGljIHNlcXVlbmNlJ1xuICAgICAgZW5kXG5cbiAgICAgIGl0ZXIgPSBzZWxmLmVuZCAtICgoc2VsZi5lbmQgLSBzZWxmLmJlZ2luKSAlIHN0ZXApXG4gICAgICBpdGVyIC09IHN0ZXAgdW5sZXNzIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpXG5cbiAgICAgIHJldHVybiBfZ3JlYXRlcl90aGFuX2JlZ2luPyhpdGVyKSA/IGl0ZXIgOiBuaWwgdW5sZXNzIGNvdW50XG5cbiAgICAgIG91dCA9IFtdXG5cbiAgICAgIHdoaWxlIF9ncmVhdGVyX3RoYW5fYmVnaW4/KGl0ZXIpICYmIGNvdW50ID4gMFxuICAgICAgICBvdXQgPDwgaXRlclxuICAgICAgICBpdGVyIC09IHN0ZXBcbiAgICAgICAgY291bnQgLT0gMVxuICAgICAgZW5kXG5cbiAgICAgIG91dC5yZXZlcnNlXG4gICAgZW5kXG5cbiAgICBkZWYgc2l6ZVxuICAgICAgc3RlcF9zaWduID0gc3RlcCA+IDAgPyAxIDogLTFcblxuICAgICAgaWYgIV9sZXNzZXJfdGhhbl9lbmQ/KHNlbGYuYmVnaW4pXG4gICAgICAgIDBcbiAgICAgIGVsc2lmIFstYGluZmAsIGBpbmZgXS5pbmNsdWRlPyhzdGVwKVxuICAgICAgICAxXG4gICAgICBlbHNpZiBbLWBpbmZgICogc3RlcF9zaWduLCBuaWxdLmluY2x1ZGU/KHNlbGYuYmVnaW4pIHx8XG4gICAgICAgICAgICBbYGluZmAgKiBzdGVwX3NpZ24sIG5pbF0uaW5jbHVkZT8oc2VsZi5lbmQpXG4gICAgICAgIGBpbmZgXG4gICAgICBlbHNlXG4gICAgICAgIGl0ZXIgPSBzZWxmLmVuZCAtICgoc2VsZi5lbmQgLSBzZWxmLmJlZ2luKSAlIHN0ZXApXG4gICAgICAgIGl0ZXIgLT0gc3RlcCB1bmxlc3MgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcilcbiAgICAgICAgKChpdGVyIC0gc2VsZi5iZWdpbikgLyBzdGVwKS5hYnMudG9faSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmID09KG90aGVyKVxuICAgICAgc2VsZi5jbGFzcyA9PSBvdGhlci5jbGFzcyAmJlxuICAgICAgICBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luICYmXG4gICAgICAgIHNlbGYuZW5kID09IG90aGVyLmVuZCAmJlxuICAgICAgICBzdGVwID09IG90aGVyLnN0ZXAgJiZcbiAgICAgICAgZXhjbHVkZV9lbmQ/ID09IG90aGVyLmV4Y2x1ZGVfZW5kP1xuICAgIGVuZFxuXG4gICAgZGVmIGhhc2hcbiAgICAgIFtzZWxmLmJlZ2luLCBzZWxmLmVuZCwgc3RlcCwgZXhjbHVkZV9lbmQ/XS5oYXNoXG4gICAgZW5kXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgaWYgQHJlY2VpdmVyX251bVxuICAgICAgICBhcmdzID0gaWYgQHN0ZXBfYXJnMlxuICAgICAgICAgICAgICAgICBcIigje0B0b3BmeH0je0BzdGVwX2FyZzEuaW5zcGVjdH0sICN7QGJ5cGZ4fSN7QHN0ZXBfYXJnMi5pbnNwZWN0fSlcIlxuICAgICAgICAgICAgICAgZWxzaWYgQHN0ZXBfYXJnMVxuICAgICAgICAgICAgICAgICBcIigje0B0b3BmeH0je0BzdGVwX2FyZzEuaW5zcGVjdH0pXCJcbiAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICAgIFwiKCN7QHJlY2VpdmVyX251bS5pbnNwZWN0fS4je0BjcmVhdGlvbl9tZXRob2R9I3thcmdzfSlcIlxuICAgICAgZWxzZVxuICAgICAgICBhcmdzID0gdW5sZXNzIEBza2lwcGVkX2FyZ1xuICAgICAgICAgICAgICAgICBcIigje0BzdGVwfSlcIlxuICAgICAgICAgICAgICAgZW5kXG4gICAgICAgIFwiKCgje0ByYW5nZS5pbnNwZWN0fSkuI3tAY3JlYXRpb25fbWV0aG9kfSN7YXJnc30pXCJcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgPT09ID09XG4gICAgYWxpYXMgZXFsPyA9PVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6c2VsZjo6QXJpdGhtZXRpY1NlcXVlbmNlPiIsImluaXRpYWxpemUiLCJyYW5nZSIsInN0ZXAiLCJjcmVhdGlvbl9tZXRob2QiLCJAY3JlYXRpb25fbWV0aG9kIiwiaXNfYT8iLCJBcnJheSIsIkBzdGVwX2FyZzEiLCJAc3RlcF9hcmcyIiwiQHRvcGZ4IiwiQGJ5cGZ4IiwiQHJlY2VpdmVyX251bSIsIkBzdGVwIiwiMSIsIkByYW5nZSIsIkBza2lwcGVkX2FyZyIsIiRyZXRfb3JfMSIsIkBvYmplY3QiLCJzZWxmIiwiMCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInJlc3BvbmRfdG8/IiwiY2xhc3MiLCJhdHRyX3JlYWRlciIsImJlZ2luIiwiZW5kIiwiZXhjbHVkZV9lbmQ/IiwiX2xlc3Nlcl90aGFuX2VuZD8iLCJ2YWwiLCJlbmRfIiwiPiIsIjwiLCI8PSIsIj49IiwiX2dyZWF0ZXJfdGhhbl9iZWdpbj8iLCJiZWdpbl8iLCItQCIsImZpcnN0IiwiY291bnQiLCJpdGVyIiwib3V0IiwiPDwiLCIrIiwiLSIsImVhY2giLCJibG9ja19naXZlbj8iLCJUeXBlRXJyb3IiLCJsYXN0IiwiRmxvYXREb21haW5FcnJvciIsIlJhbmdlRXJyb3IiLCIlIiwicmV2ZXJzZSIsInNpemUiLCJzdGVwX3NpZ24iLCItMSIsImluY2x1ZGU/IiwiKiIsIi8iLCJhYnMiLCJ0b19pIiwiPT0iLCJvdGhlciIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsImhhc2giLCJpbnNwZWN0IiwiYXJncyJdLCJtYXBwaW5ncyI6IkFBQUFBLHlFQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFB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QUFBQSxDQUFqQixDQUFBLEdBQTBCQSxHQUExQixHQUFBLENBQTZCaEUsb0JBQTdCLENBQUEsR0FBQSxDQUFnRGlFLElBQWhELENBQUEsR0FBcUREO1FBUHZEOztVQVNFQyxPQUFPLENBQUEsUUFBT3RELGdCQUFQLENBQUEsR0FBQSxDQUFBLEdBQUEsSUFBQSxDQUNHcUQsR0FBRCxHQUFBLENBQUl4RCxTQUFKLENBQUEsR0FBVXdELEdBRFosQ0FBQTtVQUdQQSxPQUFDQSxJQUFELEdBQUEsQ0FBS3RELFVBQU1zRCxTQUFBQSxDQUFBQSxDQUFYLENBQUEsR0FBb0JBLElBQXBCLEdBQUEsQ0FBd0JoRSxvQkFBeEIsQ0FBQSxHQUFBLENBQTJDaUUsSUFBM0MsQ0FBQSxHQUFnREQ7UUFabEQ7TUFERkEsQ0FBQUEsR0FBQUE7TUFpQkEsYUFBTSxLQUFOLEVBQVUsSUFBVjtNQUNBckUsT0FBQSxhQUFNLE1BQU4sRUFBVyxJQUFYO0lBN0tGQSxHQUFNbUIsSUFBTm5CLEVBQWlDbUIsSUFBakNuQjtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMTQyMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9jaGFpbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6OkVudW1lcmF0b3JcbiAgY2xhc3Mgc2VsZjo6Q2hhaW4gPCBzZWxmXG4gICAgZGVmIGluaXRpYWxpemUoKmVudW1zKVxuICAgICAgQGVudW1zID0gZW51bXNcbiAgICAgIEBpdGVyYXRlZCA9IFtdXG4gICAgICBAb2JqZWN0ID0gc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIGVhY2goKmFyZ3MsICZibG9jaylcbiAgICAgIHJldHVybiB0b19lbnVtKDplYWNoLCAqYXJncykgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgICBAZW51bXMuZWFjaCBkbyB8ZW51bXxcbiAgICAgICAgQGl0ZXJhdGVkIDw8IGVudW1cbiAgICAgICAgZW51bS5lYWNoKCphcmdzLCAmYmxvY2spXG4gICAgICBlbmRcblxuICAgICAgc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIHNpemUoKmFyZ3MpXG4gICAgICBhY2N1bSA9IDBcbiAgICAgIEBlbnVtcy5lYWNoIGRvIHxlbnVtfFxuICAgICAgICBzaXplID0gZW51bS5zaXplKCphcmdzKVxuICAgICAgICByZXR1cm4gc2l6ZSBpZiBbbmlsLCA6OkZsb2F0OjpJTkZJTklUWV0uaW5jbHVkZT8gc2l6ZVxuICAgICAgICBhY2N1bSArPSBzaXplXG4gICAgICBlbmRcbiAgICAgIGFjY3VtXG4gICAgZW5kXG5cbiAgICBkZWYgcmV3aW5kXG4gICAgICBAaXRlcmF0ZWQucmV2ZXJzZV9lYWNoIGRvIHxlbnVtfFxuICAgICAgICBlbnVtLnJld2luZCBpZiBlbnVtLnJlc3BvbmRfdG8/IDpyZXdpbmRcbiAgICAgIGVuZFxuICAgICAgQGl0ZXJhdGVkID0gW11cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBcIiM8RW51bWVyYXRvcjo6Q2hhaW46ICN7QGVudW1zLmluc3BlY3R9PlwiXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpzZWxmOjpDaGFpbj4iLCJpbml0aWFsaXplIiwiQGVudW1zIiwiZW51bXMiLCJAaXRlcmF0ZWQiLCJAb2JqZWN0Iiwic2VsZiIsImVhY2giLCJibG9ja19naXZlbj8iLCJ0b19lbnVtIiwiYXJncyIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJzaXplIiwiZW51bSQiLCI8PCIsImJsb2NrIiwidG9fcHJvYyIsImFjY3VtIiwiMCIsImJsb2NrIGluIHNpemUiLCJibG9jayAoMiBsZXZlbHMpIGluIHNpemUiLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsImluY2x1ZGU/IiwiKyIsInJld2luZCIsInJldmVyc2VfZWFjaCIsImJsb2NrIGluIHJld2luZCIsInJlc3BvbmRfdG8/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXdpbmQiLCJpbnNwZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMkRBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7OztBQUNFQyxNQUFBQSwwQkFBQUEsc0JBRkosRUFFSUE7QUFBQUEsUUFBQUE7Ozs7UUFGSjs7UUFFbUI7UUFDYkMsYUFBU0M7UUFDVEMsZ0JBQVk7UUFDWkgsT0FBQUksQ0FBQUEsY0FBVUMsSUFBVkQ7TUFIRkosQ0FBQUEsSUFBQUE7O0FBTUFNLE1BQUFBLG9CQUFBQSxnQkFSSixFQVFJQTtBQUFBQSxRQUFBQTs7UUFBQUE7Ozs7UUFSSjs7UUFRYTtRQUNQLEtBQTZDQyxlQUE3QztVQUFBLE9BQU9DLE1BQUFILElBQUFHLFdBQUFBLEVBQUEsQ0FBUSxNQUFSLENBQUEsUUFBZSxNQUFDQyxJQUFELENBQWYsQ0FBQUQsRUFBQUUsYUFBQUEsRUFBQUM7O1lBQXdCQSxPQUFBTixJQUFBTyxNQUFBQSxDQUFBQSxDQUF4QkYsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFGO1FBQVA7UUFFTUYsTUFBTkwsVUFBTUssUUFBQUEsRUFBQUEsRUFBQUEsRUFBTkksYUFBZ0JHLEtBQWhCSCxFQUFBQztBQUFBQTs7OztVQUFnQjtVQUNkUixhQUFVVyxPQUFBQSxDQUFHRCxLQUFIQztVQUNWSCxPQUFJTCxNQUFKTyxLQUFJUCxRQUFBQSxFQUFNLE1BQUNHLElBQUQsQ0FBTkgsRUFBY1MsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBYlYsRUFGTkksQ0FBQUEsR0FBQUEscUJBQUFBLENBQU1KO1FBS05BLE9BQUFEO01BUkZDLENBQUFBLElBQUFBOztBQVdBTSxNQUFBQSxvQkFBQUEsZ0JBbkJKLEVBbUJJQSxHQUFBQTs7QUFBQUEsUUFBQUE7Ozs7UUFuQko7O1FBbUJhO1FBQ1BLLFFBQVFDO1FBQ0ZaLE1BQU5MLFVBQU1LLFFBQUFBLEVBQUFBLEVBQUFBLEVBQU5hLGFBQWdCTixLQUFoQk0sRUFBQUM7Ozs7VUFBZ0I7VUFDZFIsT0FBV0EsTUFBSkMsS0FBSUQsUUFBQUEsRUFBTSxNQUFDSCxJQUFELENBQU5HO1VBQ1gsSUFBQSxRQUFlLENBQUMsR0FBRCxFQUFNUyxJQUFBQyxZQUFBRCxhQUFOLENBQXdCRSxhQUFBQSxDQUFVWCxJQUFWVyxDQUF2QyxDQUFBO1lBQUEsU0FBT1gsSUFBUDtVQUFBO1VBQ0FRLE9BQUFILENBQUFBLFFBQU1PLFNBQU5QLEtBQU1PLEVBQUdaLElBQUhZLENBQU5QLEVBSEZFLENBQUFBLEdBQU1iO1FBS05NLE9BQUFLO1FBUEZMLDhFQUFBQTtNQUFBQSxDQUFBQSxJQUFBQTs7QUFVQWEsTUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxRQUFBQTs7O1FBQ1dDLE1BQVR2QixhQUFTdUIsZ0JBQUFBLEVBQUFBLEVBQUFBLEVBQVRDLGFBQTJCZCxLQUEzQmM7OztVQUEyQjtVQUN6QixJQUFBLFFBQWVkLEtBQUllLGdCQUFBQSxDQUFhLFFBQWJBLENBQW5CLENBQUE7WUFBQUMsT0FBQWhCLEtBQUlZLFFBQUFBLENBQUFBO1VBQUo7WUEvQlJJLE9BQUE7VUErQlEsRUFERkYsQ0FBQUEsR0FBU0Q7UUFHVHZCLGdCQUFZO1FBQ1pzQixPQUFBcEI7TUFMRm9CLENBQUFBLEdBQUFBO01BUUExQixPQUFBK0IsdUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQ0EsdUJBQUQsR0FBQSxDQUF3QjdCLFVBQU02QixTQUFBQSxDQUFBQSxDQUE5QixDQUFBLEdBQXVDQTtNQUR6Q0EsQ0FBQUEsR0FBQUE7SUFwQ0YvQixHQUFNTSxJQUFOTixFQUFvQk0sSUFBcEJOO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExNTI1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL2dlbmVyYXRvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGJyZWFrZXJcblxuY2xhc3MgRW51bWVyYXRvclxuICBjbGFzcyBHZW5lcmF0b3JcbiAgICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICAgQGJsb2NrID0gYmxvY2tcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgICB5aWVsZGVyID0gWWllbGRlci5uZXcoJmJsb2NrKVxuXG4gICAgICAleHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhcmdzLnVuc2hpZnQoI3t5aWVsZGVyfSk7XG5cbiAgICAgICAgICBPcGFsLnlpZWxkWCgje0BibG9ja30sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgPT09ICRicmVha2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gJGJyZWFrZXIuJHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6R2VuZXJhdG9yPiIsInNlbGYiLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsImluaXRpYWxpemUiLCJibG9jayIsIktlcm5lbCIsInJhaXNlIiwiTG9jYWxKdW1wRXJyb3IiLCJAYmxvY2siLCJlYWNoIiwieWllbGRlciIsIm5ldyIsIllpZWxkZXIiLCJ0b19wcm9jIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0RBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFFQUUsTUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNFLEtBQUEsUUFBeURDLEtBQXpELENBQUE7VUFBQUMsT0FBUUMsT0FBQUEsQ0FBT0MscUJBQWYsRUFBaUNKLGdCQUF6Qkc7UUFBUjtRQUVBSCxPQUFBSyxDQUFBQSxhQUFTSixLQUFUSTtNQUhGTCxDQUFBQSxHQUFBQTtNQU1BSixPQUFBVSxvQkFBQUEsZ0JBWkosRUFZSUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7O1FBWko7O1FBWWE7UUFDUEMsVUFBaUJDLE1BQVBDLGFBQU9ELE9BQUFBLEVBQUFBLEVBQUFBLEVBQU1QLEtBQURTLFNBQUFBLENBQUFBLENBQUxGOztBQUd2QkY7QUFDQUEsdUJBQXlCQyxPQUFRRDs7QUFFakNBLHNCQUF3QkQsVUFBT0M7QUFDL0JBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO1FBRU1BLE9BQUFUO01BbkJGUyxDQUFBQSxJQUFBQTtJQVRGVixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQURGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTE1ODYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IvbGF6eS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCB5aWVsZDEsIHlpZWxkWFxuXG5jbGFzcyA6OkVudW1lcmF0b3JcbiAgY2xhc3Mgc2VsZjo6TGF6eSA8IHNlbGZcbiAgICBjbGFzcyBzZWxmOjpTdG9wTGF6eUVycm9yIDwgOjpFeGNlcHRpb247IGVuZFxuXG4gICAgZGVmIHNlbGYuZm9yKG9iamVjdCwgKilcbiAgICAgIGxhenkgPSBzdXBlclxuICAgICAgYGxhenkuZW51bWVyYXRvciA9IG9iamVjdGBcbiAgICAgIGxhenlcbiAgICBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKG9iamVjdCwgc2l6ZSA9IG5pbCwgJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbmV3IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBAZW51bWVyYXRvciA9IG9iamVjdFxuXG4gICAgICBzdXBlciBzaXplIGRvIHx5aWVsZGVyLCAqZWFjaF9hcmdzfFxuICAgICAgICBvYmplY3QuZWFjaCgqZWFjaF9hcmdzKSBkbyB8KmFyZ3N8XG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoI3t5aWVsZGVyfSk7XG5cbiAgICAgICAgICAgICR5aWVsZFgoYmxvY2ssIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICByZXNjdWUgU3RvcExhenlFcnJvclxuICAgICAgICBuaWxcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGxhenlcbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbWFwIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBlbnVtZXJhdG9yX3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbWFwIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoI3tgdmFsdWVgLnJlc3BvbmRfdG8/IDpmb3JjZX0gJiYgI3tgdmFsdWVgLnJlc3BvbmRfdG8/IDplYWNofSkge1xuICAgICAgICAgICAgI3tgdmFsdWVgLmVhY2ggeyB8dnwgZW51bS55aWVsZCB2IH19XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gI3s6Ok9wYWwudHJ5X2NvbnZlcnQgYHZhbHVlYCwgOjpBcnJheSwgOnRvX2FyeX07XG5cbiAgICAgICAgICAgIGlmIChhcnJheSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgdmFsdWVgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBkcm9wKG4pXG4gICAgICBuID0gYCRjb2VyY2VfdG8oI3tufSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgIGlmIG4gPCAwXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnRfc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxuICAgICAgc2V0X3NpemUgICAgID0gaWYgOjpJbnRlZ2VyID09PSBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgbiA8IGN1cnJlbnRfc2l6ZSA/IG4gOiBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgZHJvcHBlZCA9IDBcbiAgICAgIExhenkubmV3KHNlbGYsIHNldF9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgIGlmIGRyb3BwZWQgPCBuXG4gICAgICAgICAgZHJvcHBlZCArPSAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBkcm9wX3doaWxlIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBzdWNjZWVkaW5nID0gdHJ1ZVxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgIGlmIHN1Y2NlZWRpbmdcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAoISR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHN1Y2NlZWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGVudW1fZm9yKG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxuICAgICAgc2VsZi5jbGFzcy5mb3Ioc2VsZiwgbWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICAgIGVuZFxuXG4gICAgZGVmIGZpbmRfYWxsKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgc2VsZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgICBpZiBibG9ja1xuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYCR5aWVsZDEoYmxvY2ssIHBhcmFtKWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgcGFyYW1gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgcmVqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoISR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHRha2UobilcbiAgICAgIG4gPSBgJGNvZXJjZV90bygje259LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byB0YWtlIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiA6OkludGVnZXIgPT09IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICBuIDwgY3VycmVudF9zaXplID8gbiA6IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICB0YWtlbiA9IDBcbiAgICAgIExhenkubmV3KHNlbGYsIHNldF9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgIGlmIHRha2VuIDwgblxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgICAgdGFrZW4gKz0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgOjpLZXJuZWwucmFpc2UgU3RvcExhenlFcnJvclxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHRha2Vfd2hpbGUoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSB0YWtlX3doaWxlIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgU3RvcExhenlFcnJvcn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAZW51bWVyYXRvci5pbnNwZWN0fT5cIlxuICAgIGVuZFxuXG4gICAgYWxpYXMgZm9yY2UgdG9fYVxuICAgIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuICAgIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG4gICAgYWxpYXMgbWFwIGNvbGxlY3RcbiAgICBhbGlhcyBzZWxlY3QgZmluZF9hbGxcbiAgICBhbGlhcyB0b19lbnVtIGVudW1fZm9yXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpzZWxmOjpMYXp5PiIsIjxjbGFzczpzZWxmOjpTdG9wTGF6eUVycm9yPiIsInNlbGYiLCJFeGNlcHRpb24iLCJmb3IiLCJvYmplY3QiLCJsYXp5IiwiaW5pdGlhbGl6ZSIsInNpemUiLCJibG9ja19naXZlbj8iLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJAZW51bWVyYXRvciIsImJsb2NrIGluIGluaXRpYWxpemUiLCJ5aWVsZGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiZWFjaCIsImVhY2hfYXJncyIsImJsb2NrICgzIGxldmVscykgaW4gaW5pdGlhbGl6ZSIsIlN0b3BMYXp5RXJyb3IiLCJjb2xsZWN0IiwiYmxvY2siLCJuZXciLCJMYXp5IiwiZW51bWVyYXRvcl9zaXplIiwiYmxvY2sgaW4gY29sbGVjdCIsImVudW0kIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0IiwieWllbGQiLCJjb2xsZWN0X2NvbmNhdCIsImJsb2NrIGluIGNvbGxlY3RfY29uY2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0X2NvbmNhdCIsInJlc3BvbmRfdG8/IiwidiIsImJsb2NrICgzIGxldmVscykgaW4gY29sbGVjdF9jb25jYXQiLCJPcGFsIiwidHJ5X2NvbnZlcnQiLCJBcnJheSIsImRyb3AiLCJuIiwiSW50ZWdlciIsIjwiLCIwIiwiY3VycmVudF9zaXplIiwic2V0X3NpemUiLCJkcm9wcGVkIiwiYmxvY2sgaW4gZHJvcCIsImJsb2NrICgyIGxldmVscykgaW4gZHJvcCIsIisiLCIxIiwiYXJncyIsImRyb3Bfd2hpbGUiLCJzdWNjZWVkaW5nIiwiYmxvY2sgaW4gZHJvcF93aGlsZSIsImJsb2NrICgyIGxldmVscykgaW4gZHJvcF93aGlsZSIsImVudW1fZm9yIiwiY2xhc3MiLCJtZXRob2QiLCJ0b19wcm9jIiwiZmluZF9hbGwiLCJibG9jayBpbiBmaW5kX2FsbCIsImJsb2NrICgyIGxldmVscykgaW4gZmluZF9hbGwiLCJncmVwIiwicGF0dGVybiIsImJsb2NrIGluIGdyZXAiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyZXAiLCJkZXN0cnVjdHVyZSIsIj09PSIsInJlamVjdCIsImJsb2NrIGluIHJlamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0IiwidGFrZSIsInRha2VuIiwiYmxvY2sgaW4gdGFrZSIsImJsb2NrICgyIGxldmVscykgaW4gdGFrZSIsInRha2Vfd2hpbGUiLCJibG9jayBpbiB0YWtlX3doaWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWtlX3doaWxlIiwiaW5zcGVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDBEQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxPQUFNQyxJQUFORCxFQUE0QkUsZ0JBQTVCRjtNQUVBRyxNQUFJRixJQUFKRSxVQUFBQSxxQkFBYUMsTUFBRCxFQU5oQixFQU1JRDtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQU5KOztRQU15QjtRQUNuQkUsT0FBTyxPQUFBSixJQUFBLEVBQUEsa0RBQUEsT0FBQSxFQUFBLENBQUFHLE1BQUEsQ0FBQSxRQUFBLE1BQUEsU0FBQSxDQUFBLENBQUEsRUFBQSxNQUFBO1FBQ05EO1FB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RSxlQUFXa0UsU0FBQUEsQ0FBQUEsQ0FBL0IsQ0FBQSxHQUF3Q0E7TUFEMUNBLENBQUFBLEdBQUFBO01BSUEsYUFBTSxPQUFOLEVBQVksTUFBWjtNQUNBLGFBQU0sUUFBTixFQUFhLFVBQWI7TUFDQSxhQUFNLFVBQU4sRUFBZSxnQkFBZjtNQUNBLGFBQU0sS0FBTixFQUFVLFNBQVY7TUFDQSxhQUFNLFFBQU4sRUFBYSxVQUFiO01BQ0EvRSxPQUFBLGFBQU0sU0FBTixFQUFjLFVBQWQ7SUE3T0ZBLEdBQU1FLElBQU5GLEVBQW1CRSxJQUFuQkY7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTE5ODgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IveWllbGRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGJyZWFrZXJcblxuY2xhc3MgRW51bWVyYXRvclxuICBjbGFzcyBZaWVsZGVyXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgQGJsb2NrID0gYmxvY2tcbiAgICAgICMgcnVib2NvcDpkaXNhYmxlIExpbnQvVm9pZFxuICAgICAgc2VsZlxuICAgICAgIyBydWJvY29wOmVuYWJsZSBMaW50L1ZvaWRcbiAgICBlbmRcblxuICAgIGRlZiB5aWVsZCgqdmFsdWVzKVxuICAgICAgJXh7XG4gICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKCN7QGJsb2NrfSwgdmFsdWVzKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09ICRicmVha2VyKSB7XG4gICAgICAgICAgdGhyb3cgJGJyZWFrZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgPDwodmFsdWUpXG4gICAgICBzZWxmLnlpZWxkKHZhbHVlKVxuXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgdG9fcHJvY1xuICAgICAgcHJvYyBkbyB8KnZhbHVlc3xcbiAgICAgICAgc2VsZi55aWVsZCgqdmFsdWVzKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpZaWVsZGVyPiIsImluaXRpYWxpemUiLCJAYmxvY2siLCJibG9jayIsInNlbGYiLCJ5aWVsZCIsIjw8IiwidmFsdWUiLCJ0b19wcm9jIiwicHJvYyIsImJsb2NrIGluIHRvX3Byb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX3Byb2MiLCJ2YWx1ZXMiXSwibWFwcGluZ3MiOiJBQUFBQSw2REFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7O0FBQ0VDLE1BQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFDRUMsYUFBU0M7UUFFVEYsT0FBQUc7TUFIRkgsQ0FBQUEsR0FBQUE7O0FBT0FJLE1BQUFBLHFCQUFBQSwwQkFYSixFQVdJQTtBQUFBQSxRQUFBQTs7OztRQVhKOztRQVdjOztBQUVkQSxnQ0FBa0NILFVBQU9HOztBQUV6Q0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO01BVElBLENBQUFBLElBQUFBOztBQVlBQyxNQUFBQSxrQkFBQUEsMkJBQU9DLEtBQVBEO0FBQUFBLFFBQUFBOzs7UUFDRUYsSUFBSUMsT0FBQUEsQ0FBT0UsS0FBUEY7UUFFSkMsT0FBQUY7TUFIRkUsQ0FBQUEsR0FBQUE7TUFNQU4sT0FBQVEsdUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsTUFBQUwsSUFBQUssUUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsYUE5Qk4sRUE4Qk1BLEVBQUFDOzs7O1VBOUJOOztVQThCZTtVQUNQQSxPQUFJTixNQUFKRCxJQUFJQyxTQUFBQSxFQUFPLE1BQUNPLE1BQUQsQ0FBUFAsRUFETkssQ0FBQUEsR0FBQUEsc0JBQUFBLENBQUFEO01BREZELENBQUFBLEdBQUFBO0lBMUJGUixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQURGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTIwNTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZSwgY29lcmNlX3RvXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgOjpFbnVtZXJhdG9yXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19lbnVtZXJhdG9yID0gdHJ1ZWBcblxuICBkZWYgc2VsZi5mb3Iob2JqZWN0LCBtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvYmogPSAje2FsbG9jYXRlfTtcblxuICAgICAgb2JqLm9iamVjdCA9IG9iamVjdDtcbiAgICAgIG9iai5zaXplICAgPSBibG9jaztcbiAgICAgIG9iai5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBvYmouYXJncyAgID0gYXJncztcbiAgICAgIG9iai5jdXJzb3IgPSAwO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKiwgJmJsb2NrKVxuICAgIEBjdXJzb3IgPSAwXG4gICAgaWYgYmxvY2tcbiAgICAgIEBvYmplY3QgPSBHZW5lcmF0b3IubmV3KCZibG9jaylcbiAgICAgIEBtZXRob2QgPSA6ZWFjaFxuICAgICAgQGFyZ3MgICA9IFtdXG4gICAgICBAc2l6ZSAgID0gYGFyZ3VtZW50c1swXSB8fCBuaWxgXG5cbiAgICAgIGlmIEBzaXplICYmICFAc2l6ZS5yZXNwb25kX3RvPyg6Y2FsbClcbiAgICAgICAgQHNpemUgPSBgJGNvZXJjZV90bygje0BzaXplfSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBAb2JqZWN0ID0gYGFyZ3VtZW50c1swXWBcbiAgICAgIEBtZXRob2QgPSBgYXJndW1lbnRzWzFdIHx8IFwiZWFjaFwiYFxuICAgICAgQGFyZ3MgICA9IGAkc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpYFxuICAgICAgQHNpemUgICA9IG5pbFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBzZWxmIGlmIGJsb2NrLm5pbD8gJiYgYXJncy5lbXB0eT9cblxuICAgIGFyZ3MgPSBAYXJncyArIGFyZ3NcblxuICAgIHJldHVybiBzZWxmLmNsYXNzLm5ldyhAb2JqZWN0LCBAbWV0aG9kLCAqYXJncykgaWYgYmxvY2submlsP1xuXG4gICAgQG9iamVjdC5fX3NlbmRfXyhAbWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc2l6ZVxuICAgIEBzaXplLnJlc3BvbmRfdG8/KDpjYWxsKSA/IEBzaXplLmNhbGwoKkBhcmdzKSA6IEBzaXplXG4gIGVuZFxuXG4gIGRlZiB3aXRoX2luZGV4KG9mZnNldCA9IDAsICZibG9jaylcbiAgICBvZmZzZXQgPSBpZiBvZmZzZXRcbiAgICAgICAgICAgICAgIGAkY29lcmNlX3RvKG9mZnNldCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIGVudW1fZm9yKDp3aXRoX2luZGV4LCBvZmZzZXQpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LCBpbmRleCA9IG9mZnNldDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGVhY2goKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfaW5kZXgoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX2luZGV4KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzdXBlclxuICAgIEBvYmplY3RcbiAgZW5kXG5cbiAgZGVmIHJld2luZFxuICAgIEBjdXJzb3IgPSAwXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwZWVrX3ZhbHVlc1xuICAgIEB2YWx1ZXMgfHw9IG1hcCB7IHwqaXwgaSB9XG4gICAgOjpLZXJuZWwucmFpc2UgOjpTdG9wSXRlcmF0aW9uLCAnaXRlcmF0aW9uIHJlYWNoZWQgYW4gZW5kJyBpZiBAY3Vyc29yID49IEB2YWx1ZXMubGVuZ3RoXG4gICAgQHZhbHVlc1tAY3Vyc29yXVxuICBlbmRcblxuICBkZWYgcGVla1xuICAgIHZhbHVlcyA9IHBlZWtfdmFsdWVzXG4gICAgdmFsdWVzLmxlbmd0aCA8PSAxID8gdmFsdWVzWzBdIDogdmFsdWVzXG4gIGVuZFxuXG4gIGRlZiBuZXh0X3ZhbHVlc1xuICAgIG91dCA9IHBlZWtfdmFsdWVzXG4gICAgQGN1cnNvciArPSAxXG4gICAgb3V0XG4gIGVuZFxuXG4gIGRlZiBuZXh0XG4gICAgdmFsdWVzID0gbmV4dF92YWx1ZXNcbiAgICB2YWx1ZXMubGVuZ3RoIDw9IDEgPyB2YWx1ZXNbMF0gOiB2YWx1ZXNcbiAgZW5kXG5cbiAgZGVmIGZlZWQoYXJnKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIFwiT3BhbCBkb2Vzbid0IHN1cHBvcnQgRW51bWVyYXRvciNmZWVkXCJcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgOjpFbnVtZXJhdG9yOjpDaGFpbi5uZXcoc2VsZiwgb3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgcmVzdWx0ID0gXCIjPCN7c2VsZi5jbGFzc306ICN7QG9iamVjdC5pbnNwZWN0fToje0BtZXRob2R9XCJcblxuICAgIGlmIEBhcmdzLmFueT9cbiAgICAgIHJlc3VsdCArPSBcIigje0BhcmdzLmluc3BlY3RbOjpSYW5nZS5uZXcoMSwgLTIpXX0pXCJcbiAgICBlbmRcblxuICAgIHJlc3VsdCArICc+J1xuICBlbmRcblxuICBhbGlhcyB3aXRoX29iamVjdCBlYWNoX3dpdGhfb2JqZWN0XG5cbiAgYXV0b2xvYWQgOkFyaXRobWV0aWNTZXF1ZW5jZSwgJ2NvcmVsaWIvZW51bWVyYXRvci9hcml0aG1ldGljX3NlcXVlbmNlJ1xuICBhdXRvbG9hZCA6Q2hhaW4sICdjb3JlbGliL2VudW1lcmF0b3IvY2hhaW4nXG4gIGF1dG9sb2FkIDpHZW5lcmF0b3IsICdjb3JlbGliL2VudW1lcmF0b3IvZ2VuZXJhdG9yJ1xuICBhdXRvbG9hZCA6TGF6eSwgJ2NvcmVsaWIvZW51bWVyYXRvci9sYXp5J1xuICBhdXRvbG9hZCA6WWllbGRlciwgJ2NvcmVsaWIvZW51bWVyYXRvci95aWVsZGVyJ1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJmb3IiLCJvYmplY3QiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJAY3Vyc29yIiwiMCIsImJsb2NrIiwiQG9iamVjdCIsIm5ldyIsIkdlbmVyYXRvciIsInRvX3Byb2MiLCJAbWV0aG9kIiwiQGFyZ3MiLCJAc2l6ZSIsInJlc3BvbmRfdG8/IiwiSW50ZWdlciIsImVhY2giLCJuaWw/IiwiYXJncyIsImVtcHR5PyIsIisiLCJjbGFzcyIsIl9fc2VuZF9fIiwic2l6ZSIsImNhbGwiLCJ3aXRoX2luZGV4Iiwib2Zmc2V0IiwiZW51bV9mb3IiLCJibG9jayBpbiB3aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB3aXRoX2luZGV4IiwiT3BhbCIsImRlc3RydWN0dXJlIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2tfZ2l2ZW4/IiwiYmxvY2sgaW4gZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3dpdGhfaW5kZXgiLCJyZXdpbmQiLCJwZWVrX3ZhbHVlcyIsIkB2YWx1ZXMiLCIkcmV0X29yXzEiLCJtYXAiLCJibG9jayBpbiBwZWVrX3ZhbHVlcyIsImJsb2NrICgyIGxldmVscykgaW4gcGVla192YWx1ZXMiLCJpIiwiPj0iLCJsZW5ndGgiLCJLZXJuZWwiLCJyYWlzZSIsIlN0b3BJdGVyYXRpb24iLCJbXSIsInBlZWsiLCJ2YWx1ZXMiLCI8PSIsIjEiLCJuZXh0X3ZhbHVlcyIsIm91dCIsIm5leHQiLCJmZWVkIiwiYXJnIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsIm90aGVyIiwiRW51bWVyYXRvcjo6Q2hhaW4iLCJFbnVtZXJhdG9yIiwiaW5zcGVjdCIsInJlc3VsdCIsImFueT8iLCJSYW5nZSIsIi0yIiwiYXV0b2xvYWQiXSwibWFwcGluZ3MiOiJBQUFBQSxxREFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBRUNEO0lBRURHLE1BQUlMLElBQUpLLFVBQUFBLDJCQUFhQyxNQUFELEVBVGQsRUFTYyxFQVRkLEVBU0VEO0FBQUFBLE1BQUFBOztNQUFBQTs7OztNQVRGOztNQVN1QjtNQUFBLDZCQUFTLE1BQVQ7O01BQWdCOztBQUV2Q0EsZ0JBQWtCTCxJQUFBTyxVQUFBQSxDQUFBQSxDQUFTRjs7QUFFM0JBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQVhFQSxDQUFBQSxJQUFBQTs7QUFjQUcsSUFBQUEsMEJBQUFBLHNCQXZCRixFQXVCRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7O01BdkJGOztNQXVCaUI7TUFDYkMsY0FBVUM7TUFDVixJQUFBLFFBQUdDLEtBQUgsQ0FBQTs7UUFDRUMsY0FBbUJDLE1BQVRDLGVBQVNELE9BQUFBLEVBQUFBLEVBQUFBLEVBQU1GLEtBQURJLFNBQUFBLENBQUFBLENBQUxGO1FBQ25CRyxjQUFVO1FBQ1ZDLFlBQVU7UUFDVkMsWUFBV1Y7UUFFWCxJQUFHLENBQUEsUUFBQVUsU0FBQSxDQUFBLElBQUEsQ0FBQSxLQUFVQSxTQUFLQyxnQkFBQUEsQ0FBYSxNQUFiQSxDQUFmLENBQUEsQ0FBQSxDQUFIO1VBQ0VYLE9BQUFVLENBQUFBLFlBQVNWLFdBQWFVLFNBQU1WLEVBQUlZLGNBQVVaLFdBQTFDVTtRQURGO1VBL0JOVixPQUFBO1FBK0JNO01BTkY7O1FBVUVJLGNBQVdKO1FBQ1hRLGNBQVdSO1FBQ1hTLFlBQVdUO1FBQ1hBLE9BQUFVLENBQUFBLFlBQVUsR0FBVkE7TUFiRjtJQUZGVixDQUFBQSxJQUFBQTs7QUFtQkFhLElBQUFBLG9CQUFBQSxnQkExQ0YsRUEwQ0VBO0FBQUFBLE1BQUFBOztNQUFBQTs7OztNQTFDRjs7TUEwQ1c7TUFDUCxJQUFlLENBQUEsUUFBQVYsS0FBS1csU0FBQUEsQ0FBQUEsQ0FBTCxDQUFBLElBQUEsQ0FBQSxRQUFjQyxJQUFJQyxXQUFBQSxDQUFBQSxDQUFsQixDQUFBLENBQUEsQ0FBZjtRQUFBLE9BQU94QjtNQUFQO01BRUF1QixPQUFhRSxTQUFOUixTQUFNUSxFQUFFRixJQUFGRTtNQUViLElBQUEsUUFBa0RkLEtBQUtXLFNBQUFBLENBQUFBLENBQXZELENBQUE7UUFBQSxPQUFpQlQsTUFBVmIsSUFBSTBCLE9BQUFBLENBQUFBLENBQU1iLE9BQUFBLEVBQVYsQ0FBZUQsV0FBZixFQUF3QkksV0FBeEIsQ0FBQSxRQUFpQyxNQUFDTyxJQUFELENBQWpDLENBQVVWO01BQWpCO01BRUFRLE9BQU9NLE1BQVBmLFdBQU9lLFlBQUFBLEVBQVAsQ0FBaUJYLFdBQWpCLENBQUEsUUFBMEIsTUFBQ08sSUFBRCxDQUExQixDQUFPSSxFQUEyQmhCLEtBQURJLFNBQUFBLENBQUFBLENBQTFCWTtJQVBUTixDQUFBQSxJQUFBQTs7QUFVQU8sSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFWLFNBQUtDLGdCQUFBQSxDQUFhLE1BQWJBLENBQUwsQ0FBQTtRQUEyQlMsT0FBS0MsTUFBTFgsU0FBS1csUUFBQUEsRUFBTSxNQUFDWixTQUFELENBQU5ZO01BQWhDO1FBQWdERCxPQUFBVjtNQUFoRDtJQURGVSxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEsMEJBQUFBLHNCQUFlQyxNQUFmRDtBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7TUFBZSw2QkFBU3BCLENBQVQ7TUFDYnFCLFNBQVMsQ0FBQSxRQUFHQSxNQUFILENBQUEsR0FBQSxDQUNHRCxtQkFBcUJWLGNBQVVVLFdBRGxDLElBQUEsQ0FHRXBCLENBSEYsQ0FBQTtNQU1ULEtBQUEsUUFBcURDLEtBQXJELENBQUE7UUFBQSxPQUFPcUIsTUFBQWhDLElBQUFnQyxZQUFBQSxFQUFBQSxDQUFTLFlBQVQsRUFBc0JELE1BQXRCQyxDQUFBQSxFQUFBQyxhQUFBQSxFQUFBQzs7VUFBZ0NBLE9BQUFsQyxJQUFBNEIsTUFBQUEsQ0FBQUEsQ0FBaENLLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRDtNQUFQOztBQUdKRjs7QUFFQUE7QUFDQUEsb0JBQXNCSyxLQUFNQyxhQUFBQSxDQUFjTixTQUFkTSxDQUEwQk47QUFDdERBOztBQUVBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBdEJFQSxDQUFBQSxJQUFBQTs7QUF5QkFPLElBQUFBLCtCQUFBQSwyQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRSxLQUFrREMsZUFBbEQ7UUFBQSxPQUFPTixNQUFBaEMsSUFBQWdDLFlBQUFBLEVBQUFBLENBQVMsaUJBQVRBLENBQUFBLEVBQUFPLGFBQUFBLEVBQUFDOztVQUE2QkEsT0FBQXhDLElBQUE0QixNQUFBQSxDQUFBQSxDQUE3QlcsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFQO01BQVA7TUFFQSxPQUFBaEMsSUFBQSxFQUFBLG9FQUFBLG1CQUFBLEVBQUEsRUFBQSxFQUFBLEtBQUE7TUFDQXFDLE9BQUF6QjtJQUpGeUIsQ0FBQUEsR0FBQUE7O0FBT0FJLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFaEMsY0FBVUM7TUFFVitCLE9BQUF6QztJQUhGeUMsQ0FBQUEsR0FBQUE7O0FBTUFDLElBQUFBLDJCQUFBQSx1QkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFQyxjQS9GSixDQUFBLFFBQUFDLENBQUFBLFlBK0ZJRCxXQS9GSkMsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0ErRmdCQyxNQUFBN0MsSUFBQTZDLE9BQUFBLEVBQUFBLEVBQUFBLEVBQUFDLGFBL0ZoQixFQStGZ0JBLEVBQUFDOzs7O1FBL0ZoQjs7UUErRnVCO1FBQUlBLE9BQUFDLEVBQVhGLENBQUFBLElBQUFELENBL0ZoQixDQUFBO01BZ0dJLElBQUEsUUFBc0VJLE9BQVJ4QyxXQUFRd0MsRUFBR04sV0FBT08sUUFBQUEsQ0FBQUEsQ0FBVkQsQ0FBdEUsQ0FBQTtRQUFBRSxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ1gsMEJBQXhCVTtNQUFSO01BQ0FWLE9BQUFDLFdBQU9XLE9BQUFBLENBQUM3QyxXQUFENkM7SUFIVFosQ0FBQUEsR0FBQUE7O0FBTUFhLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFQyxTQUFTeEQsSUFBQTBDLGFBQUFBLENBQUFBO01BQ1QsSUFBQSxRQUFjZSxPQUFkRCxNQUFNTixRQUFBQSxDQUFBQSxDQUFRTyxFQUFHQyxDQUFIRCxDQUFkLENBQUE7UUFBcUJGLE9BQUFDLE1BQU1GLE9BQUFBLENBQUM1QyxDQUFENEM7TUFBM0I7UUFBaUNDLE9BQUFDO01BQWpDO0lBRkZELENBQUFBLEdBQUFBOztBQUtBSSxJQUFBQSwyQkFBQUEsdUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsTUFBTTVELElBQUEwQyxhQUFBQSxDQUFBQTtNQUNOakMsY0FBUWdCLFNBQVJoQixXQUFRZ0IsRUFBR2lDLENBQUhqQztNQUNSa0MsT0FBQUM7SUFIRkQsQ0FBQUEsR0FBQUE7O0FBTUFFLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFTCxTQUFTeEQsSUFBQTJELGFBQUFBLENBQUFBO01BQ1QsSUFBQSxRQUFjRixPQUFkRCxNQUFNTixRQUFBQSxDQUFBQSxDQUFRTyxFQUFHQyxDQUFIRCxDQUFkLENBQUE7UUFBcUJJLE9BQUFMLE1BQU1GLE9BQUFBLENBQUM1QyxDQUFENEM7TUFBM0I7UUFBaUNPLE9BQUFMO01BQWpDO0lBRkZLLENBQUFBLEdBQUFBOztBQUtBQyxJQUFBQSxvQkFBQUEsZ0JBQVNDLEdBQVREO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBOUQsSUFBQW9ELE9BQUFBLENBQU1ZLHlCQUFOLEVBQTJCRixzQ0FBM0JWO0lBREZVLENBQUFBLEdBQUFBOztBQUlBckMsSUFBQUEsaUJBQUFBLDZCQUFNd0MsS0FBTnhDO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBeUMsSUFBQUMsaUJBQUFELFVBQW1CckQsS0FBQUEsQ0FBS2IsSUFBeEIsRUFBOEJpRSxLQUFYcEQ7SUFEckJZLENBQUFBLEdBQUFBOztBQUlBMkMsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0VDLFNBQVVELElBQUQsR0FBQSxDQUFLcEUsSUFBSTBCLE9BQUFBLENBQUFBLENBQVQsQ0FBQSxHQUFnQjBDLElBQWhCLEdBQUEsQ0FBb0J4RCxXQUFPd0QsU0FBQUEsQ0FBQUEsQ0FBM0IsQ0FBQSxHQUFvQ0EsR0FBcEMsR0FBQSxDQUF1Q3BELFdBQXZDO01BRVQsSUFBQSxRQUFHQyxTQUFLcUQsU0FBQUEsQ0FBQUEsQ0FBUixDQUFBO1FBQ0VELFNBQU81QyxTQUFQNEMsTUFBTzVDLEVBQUkyQyxHQUFELEdBQUEsQ0FBSW5ELFNBQUttRCxTQUFBQSxDQUFBQSxDQUFRZCxPQUFBQSxDQUFDaUIsWUFBTzFELEtBQUFBLENBQUs2QyxDQUFaLEVBQWVjLEVBQVIzRCxDQUFSeUMsQ0FBakIsQ0FBQSxHQUFzQ2MsR0FBekMzQztNQURUO01BSUEyQyxPQUFPM0MsU0FBUDRDLE1BQU81QyxFQUFFMkMsR0FBRjNDO0lBUFQyQyxDQUFBQSxHQUFBQTtJQVVBLGFBQU0sYUFBTixFQUFrQixrQkFBbEI7SUFFQXBFLElBQUF5RSxVQUFBQSxDQUFTLG9CQUFULEVBQThCdkUsd0NBQTlCdUU7SUFDQXpFLElBQUF5RSxVQUFBQSxDQUFTLE9BQVQsRUFBaUJ2RSwwQkFBakJ1RTtJQUNBekUsSUFBQXlFLFVBQUFBLENBQVMsV0FBVCxFQUFxQnZFLDhCQUFyQnVFO0lBQ0F6RSxJQUFBeUUsVUFBQUEsQ0FBUyxNQUFULEVBQWdCdkUseUJBQWhCdUU7SUFDQXZFLE9BQUFGLElBQUF5RSxVQUFBQSxDQUFTLFNBQVQsRUFBbUJ2RSw0QkFBbkJ1RTtFQXhJRnZFLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFKQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyMjk0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1lcmljLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgOjpOdW1lcmljXG4gIGluY2x1ZGUgOjpDb21wYXJhYmxlXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBpZiBvdGhlci5pbnN0YW5jZV9vZj8gc2VsZi5jbGFzc1xuICAgICAgcmV0dXJuIFtvdGhlciwgc2VsZl1cbiAgICBlbmRcblxuICAgIFs6Oktlcm5lbC5GbG9hdChvdGhlciksIDo6S2VybmVsLkZsb2F0KHNlbGYpXVxuICBlbmRcblxuICBkZWYgX19jb2VyY2VkX18obWV0aG9kLCBvdGhlcilcbiAgICBpZiBvdGhlci5yZXNwb25kX3RvPyg6Y29lcmNlKVxuICAgICAgYSwgYiA9IG90aGVyLmNvZXJjZShzZWxmKVxuICAgICAgYS5fX3NlbmRfXyBtZXRob2QsIGJcbiAgICBlbHNlXG4gICAgICBjYXNlIG1ldGhvZFxuICAgICAgd2hlbiA6KywgOi0sIDoqLCA6LywgOiUsIDomLCA6fCwgOl4sIDoqKlxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gTnVtZXJpY1wiXG4gICAgICB3aGVuIDo+LCA6Pj0sIDo8LCA6PD0sIDo8PT5cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7b3RoZXIuY2xhc3N9IGZhaWxlZFwiXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBlcXVhbD8gb3RoZXJcbiAgICAgIHJldHVybiAwXG4gICAgZW5kXG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmICtAXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgLUBcbiAgICAwIC0gc2VsZlxuICBlbmRcblxuICBkZWYgJShvdGhlcilcbiAgICBzZWxmIC0gb3RoZXIgKiBkaXYob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICBzZWxmIDwgMCA/IC1zZWxmIDogc2VsZlxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIHNlbGYgKiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIHNlbGYgPCAwID8gOjpNYXRoOjpQSSA6IDBcbiAgZW5kXG5cbiAgZGVmIGNlaWwobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5jZWlsKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiBjb25qXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICB0b19yLmRlbm9taW5hdG9yXG4gIGVuZFxuXG4gIGRlZiBkaXYob3RoZXIpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgbycgaWYgb3RoZXIgPT0gMFxuXG4gICAgKHNlbGYgLyBvdGhlcikuZmxvb3JcbiAgZW5kXG5cbiAgZGVmIGRpdm1vZChvdGhlcilcbiAgICBbZGl2KG90aGVyKSwgc2VsZiAlIG90aGVyXVxuICBlbmRcblxuICBkZWYgZmRpdihvdGhlcilcbiAgICB0b19mIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZsb29yKG5kaWdpdHMgPSAwKVxuICAgIHRvX2YuZmxvb3IobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGlcbiAgICA6Oktlcm5lbC5Db21wbGV4KDAsIHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBpbWFnXG4gICAgMFxuICBlbmRcblxuICBkZWYgaW50ZWdlcj9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgbm9uemVybz9cbiAgICB6ZXJvPyA/IG5pbCA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIHRvX3IubnVtZXJhdG9yXG4gIGVuZFxuXG4gIGRlZiBwb2xhclxuICAgIFthYnMsIGFyZ11cbiAgZW5kXG5cbiAgZGVmIHF1byhvdGhlcilcbiAgICA6Ok9wYWwuY29lcmNlX3RvIShzZWxmLCA6OlJhdGlvbmFsLCA6dG9fcikgLyBvdGhlclxuICBlbmRcblxuICBkZWYgcmVhbFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgcmVjdFxuICAgIFtzZWxmLCAwXVxuICBlbmRcblxuICBkZWYgcm91bmQoZGlnaXRzID0gdW5kZWZpbmVkKVxuICAgIHRvX2Yucm91bmQoZGlnaXRzKVxuICBlbmRcblxuICBkZWYgc3RlcChsaW1pdCA9IHVuZGVmaW5lZCwgc3RlcCA9IHVuZGVmaW5lZCwgdG86IHVuZGVmaW5lZCwgYnk6IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgdG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RvIGlzIGdpdmVuIHR3aWNlJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXAgIT09IHVuZGVmaW5lZCAmJiBieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnc3RlcCBpcyBnaXZlbiB0d2ljZSd9XG4gICAgICB9XG5cbiAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbWl0ID0gdG87XG4gICAgICB9XG5cbiAgICAgIGlmIChieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0ZXAgPSBieTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSBuaWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHN0ZXAgPT09IG5pbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdzdGVwIG11c3QgYmUgbnVtZXJpYyd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCAhPSBudWxsICYmICN7c3RlcCA9PSAwfSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgMFwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgPT09IG5pbCB8fCBzdGVwID09IG51bGwpIHtcbiAgICAgICAgICBzdGVwID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWduID0gI3tzdGVwIDw9PiAwfTtcblxuICAgICAgICBpZiAoc2lnbiA9PT0gbmlsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiMCBjYW4ndCBiZSBjb2VyY2VkIGludG8gI3tzdGVwLmNsYXNzfVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbWl0ID09PSBuaWwgfHwgbGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgIGxpbWl0ID0gc2lnbiA+IDAgPyAjezo6RmxvYXQ6OklORklOSVRZfSA6ICN7LTo6RmxvYXQ6OklORklOSVRZfTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7OjpPcGFsLmNvbXBhcmUoc2VsZiwgbGltaXQpfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwRmxvYXRTaXplKCkge1xuICAgICAgICBpZiAoKHN0ZXAgPiAwICYmIHNlbGYgPiBsaW1pdCkgfHwgKHN0ZXAgPCAwICYmIHNlbGYgPCBsaW1pdCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSBJbmZpbml0eSB8fCBzdGVwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgICAgICAgZXJyID0gKGFicyhzZWxmKSArIGFicyhsaW1pdCkgKyBhYnMobGltaXQgLSBzZWxmKSkgLyBhYnMoc3RlcCkgKiAjezo6RmxvYXQ6OkVQU0lMT059O1xuXG4gICAgICAgICAgaWYgKGVyciA9PT0gSW5maW5pdHkgfHwgZXJyID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXJyID4gMC41KSB7XG4gICAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZsb29yKChsaW1pdCAtIHNlbGYpIC8gc3RlcCArIGVycikgKyAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXBTaXplKCkge1xuICAgICAgICB2YWxpZGF0ZVBhcmFtZXRlcnMoKTtcblxuICAgICAgICBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwICUgMSAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBzdGVwRmxvYXRTaXplKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHN0ZXAgPiAwICYmIHNlbGYgPiBsaW1pdCkgfHwgKHN0ZXAgPCAwICYmIHNlbGYgPCBsaW1pdCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCwgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgICAgIGxocyA9IGFicyhzZWxmIC0gbGltaXQpICsgMSxcbiAgICAgICAgICAgICAgcmhzID0gYWJzKHN0ZXApO1xuXG4gICAgICAgICAgcmV0dXJuIGNlaWwobGhzIC8gcmhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgaWYgKCFsaW1pdCB8fCBsaW1pdC5pc19hPyg6Ok51bWVyaWMpKSAmJlxuICAgICAgICAgKCFzdGVwIHx8IHN0ZXAuaXNfYT8oOjpOdW1lcmljKSlcblxuICAgICAgICByZXR1cm4gOjpFbnVtZXJhdG9yOjpBcml0aG1ldGljU2VxdWVuY2UubmV3KFxuICAgICAgICAgIFtsaW1pdCwgc3RlcCwgKCd0bzogJyBpZiB0byksICgnYnk6ICcgaWYgYnkpXSwgc2VsZlxuICAgICAgICApXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBlbnVtX2Zvcig6c3RlcCwgbGltaXQsIHN0ZXAsICZgc3RlcFNpemVgKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICB2YXIgaXNEZXNjID0gI3tzdGVwLm5lZ2F0aXZlP30sXG4gICAgICAgICAgaXNJbmYgPSAje3N0ZXAgPT0gMH0gfHxcbiAgICAgICAgICAgICAgICAgIChsaW1pdCA9PT0gSW5maW5pdHkgJiYgIWlzRGVzYykgfHxcbiAgICAgICAgICAgICAgICAgIChsaW1pdCA9PT0gLUluZmluaXR5ICYmIGlzRGVzYyk7XG5cbiAgICAgIGlmIChzZWxmLiQkaXNfbnVtYmVyICYmIHN0ZXAuJCRpc19udW1iZXIgJiYgbGltaXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlbGYgJSAxID09PSAwICYmIChpc0luZiB8fCBsaW1pdCAlIDEgPT09IDApICYmIHN0ZXAgJSAxID09PSAwKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc2VsZjtcblxuICAgICAgICAgIGlmIChpc0luZikge1xuICAgICAgICAgICAgZm9yICg7OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVzYykge1xuICAgICAgICAgICAgZm9yICg7IHZhbHVlID49IGxpbWl0OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICg7IHZhbHVlIDw9IGxpbWl0OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYmVnaW4gPSAje3RvX2Z9LnZhbHVlT2YoKTtcbiAgICAgICAgICBzdGVwID0gI3tzdGVwLnRvX2Z9LnZhbHVlT2YoKTtcbiAgICAgICAgICBsaW1pdCA9ICN7bGltaXQudG9fZn0udmFsdWVPZigpO1xuXG4gICAgICAgICAgdmFyIG4gPSBzdGVwRmxvYXRTaXplKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRmluaXRlKHN0ZXApKSB7XG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgYmxvY2soYmVnaW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgYmxvY2soYmVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZCA9IGkgKiBzdGVwICsgc2VsZjtcbiAgICAgICAgICAgICAgaWYgKHN0ZXAgPj0gMCA/IGxpbWl0IDwgZCA6IGxpbWl0ID4gZCkge1xuICAgICAgICAgICAgICAgIGQgPSBsaW1pdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBibG9jayhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvdW50ZXIgPSBzZWxmXG5cbiAgICB3aGlsZSBgaXNEZXNjID8gI3tjb3VudGVyID49IGxpbWl0fSA6ICN7Y291bnRlciA8PSBsaW1pdH1gXG4gICAgICB5aWVsZCBjb3VudGVyXG4gICAgICBjb3VudGVyICs9IHN0ZXBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICA6Oktlcm5lbC5Db21wbGV4KHNlbGYsIDApXG4gIGVuZFxuXG4gIGRlZiB0b19pbnRcbiAgICB0b19pXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcbiAgICB0b19mLnRydW5jYXRlKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIHNlbGYgPT0gMFxuICBlbmRcblxuICBkZWYgcG9zaXRpdmU/XG4gICAgc2VsZiA+IDBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIHNlbGYgPCAwXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIG5pbFxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcbiAgYWxpYXMgY29uanVnYXRlIGNvbmpcbiAgYWxpYXMgaW1hZ2luYXJ5IGltYWdcbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuICBhbGlhcyBtb2R1bG8gJVxuICBhbGlhcyBwaGFzZSBhcmdcbiAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOk51bWVyaWM+IiwiaW5jbHVkZSIsIkNvbXBhcmFibGUiLCJjb2VyY2UiLCJvdGhlciIsImluc3RhbmNlX29mPyIsImNsYXNzIiwiS2VybmVsIiwiRmxvYXQiLCJfX2NvZXJjZWRfXyIsIm1ldGhvZCIsInJlc3BvbmRfdG8/IiwiYSIsImIiLCJfX3NlbmRfXyIsIiRyZXRfb3JfMSIsInJhaXNlIiwiVHlwZUVycm9yIiwiQXJndW1lbnRFcnJvciIsIjw9PiIsImVxdWFsPyIsIjAiLCIrQCIsIi1AIiwiLSIsIiUiLCIqIiwiZGl2IiwiYWJzIiwiPCIsImFiczIiLCJhbmdsZSIsIk1hdGg6OlBJIiwiTWF0aCIsImNlaWwiLCJuZGlnaXRzIiwidG9fZiIsImNvbmoiLCJkZW5vbWluYXRvciIsInRvX3IiLCJaZXJvRGl2aXNpb25FcnJvciIsIi8iLCJmbG9vciIsImRpdm1vZCIsImZkaXYiLCJpIiwiQ29tcGxleCIsImltYWciLCJpbnRlZ2VyPyIsIm5vbnplcm8/IiwiemVybz8iLCJudW1lcmF0b3IiLCJwb2xhciIsImFyZyIsInF1byIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiUmF0aW9uYWwiLCJyZWFsIiwicmVhbD8iLCJyZWN0Iiwicm91bmQiLCJkaWdpdHMiLCJzdGVwIiwiPT0iLCJGbG9hdDo6SU5GSU5JVFkiLCJjb21wYXJlIiwibGltaXQiLCJGbG9hdDo6RVBTSUxPTiIsImJsb2NrX2dpdmVuPyIsImlzX2E/IiwiTnVtZXJpYyIsIkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZSIsIkVudW1lcmF0b3IiLCJuZXciLCJ0byIsImJ5IiwiZW51bV9mb3IiLCJ0b19wcm9jIiwibmVnYXRpdmU/IiwiY291bnRlciIsIj49IiwiPD0iLCIrIiwidG9fYyIsInRvX2ludCIsInRvX2kiLCJ0cnVuY2F0ZSIsInBvc2l0aXZlPyIsIj4iLCJkdXAiLCJjbG9uZSIsIiRrd2FyZ3MiLCJmaW5pdGU/IiwiaW5maW5pdGU/Il0sIm1hcHBpbmdzIjoiQUFBQUEsa0RBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOzs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFFQUUsSUFBQUEsc0JBQUFBLGtCQUFXQyxLQUFYRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFHQyxLQUFLQyxpQkFBQUEsQ0FBY1AsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBbEJELENBQVIsQ0FBQTtRQUNFLE9BQU8sQ0FBQ0QsS0FBRCxFQUFRTixJQUFSO01BRFQ7TUFJQUssT0FBQSxDQUFDSSxPQUFRQyxPQUFBQSxDQUFPSixLQUFQSSxDQUFULEVBQXdCRCxPQUFRQyxPQUFBQSxDQUFPVixJQUFQVSxDQUFoQztJQUxGTCxDQUFBQSxHQUFBQTs7QUFRQU0sSUFBQUEsMkJBQUFBLHVCQUFnQkMsTUFBRCxFQUFTTixLQUF4Qks7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFHTCxLQUFLTyxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFSLENBQUE7O1FBQ0UsS0FBT1AsS0FBS0QsUUFBQUEsQ0FBUUwsSUFBUkssQ0FBWixrQkFBQSxFQUFBUyxDQUFBQSxJQUFBLDZCQUFBQSxDQUFBLEVBQUdDLENBQUFBLElBQUgsNkJBQUdBLENBQUg7UUFDQUosT0FBQUcsQ0FBQ0UsVUFBQUEsQ0FBVUosTUFBWCxFQUFtQkcsQ0FBbEJDO01BRkgsT0FLRSxJQW5CTixDQUFBLFFBbUJXLEdBbkJYLEVBa0JNQyxDQUFBQSxZQUFLTCxNQUFMSyxDQWxCTixDQUFBLElBQUEsQ0FBQSxDQUFBLFFBbUJlLEdBbkJmLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLFFBbUJtQixHQW5CbkIsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsUUFtQnVCLEdBbkJ2QixFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxRQW1CMkIsR0FuQjNCLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLFFBbUIrQixHQW5CL0IsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsUUFtQm1DLEdBbkJuQyxFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxRQW1CdUMsR0FuQnZDLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxRQW1CMkMsSUFuQjNDLEVBQUEsU0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBbUJNO1FBQ0VOLE9BQUFGLE9BQVFTLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCLEVBQUEsR0FBQSxDQUFHYixLQUFLRSxPQUFBQSxDQUFBQSxDQUFSLENBQUEsR0FBZUcsZ0NBQW5DTztNQURWLE9BRUEsSUFyQk4sQ0FBQSxRQXFCVyxHQXJCWCxFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxRQXFCZSxJQXJCZixFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxRQXFCb0IsR0FyQnBCLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLFFBcUJ3QixJQXJCeEIsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLFFBcUI2QixLQXJCN0IsRUFBQSxTQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQXFCTTtRQUNFUCxPQUFBRixPQUFRUyxPQUFBQSxDQUFPRSxvQkFBZixFQUFpQ1QsZ0JBQUQsR0FBQSxDQUFpQlgsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBckIsQ0FBQSxHQUE0QkcsUUFBNUIsR0FBQSxDQUFvQ0wsS0FBS0UsT0FBQUEsQ0FBQUEsQ0FBekMsQ0FBQSxHQUFnREcsU0FBeEVPO01BRFY7UUFIQVAsT0FBQTtNQUdBO0lBUkpBLENBQUFBLEdBQUFBOztBQWNBVSxJQUFBQSxtQkFBQUEsOEJBQVFmLEtBQVJlO0FBQUFBLE1BQUFBOzs7TUFDRSxJQUFBLFFBQUdyQixJQUFBc0IsV0FBQUEsQ0FBT2hCLEtBQVBnQixDQUFILENBQUE7UUFDRSxPQUFPQztNQURUO01BSUFGLE9BQUE7SUFMRkEsQ0FBQUEsR0FBQUE7O0FBUUFHLElBQUFBLGtCQUFBQSwyQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF4QjtJQURGd0IsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLGtCQUFBQSw0QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUVDLFVBQUZILENBQUVHLEVBQUUxQixJQUFGMEI7SUFESkQsQ0FBQUEsR0FBQUE7O0FBSUFFLElBQUFBLGlCQUFBQSw2QkFBTXJCLEtBQU5xQjtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBS0QsVUFBTDFCLElBQUswQixFQUFRRSxVQUFOdEIsS0FBTXNCLEVBQUU1QixJQUFBNkIsS0FBQUEsQ0FBSXZCLEtBQUp1QixDQUFGRCxDQUFSRjtJQURQQyxDQUFBQSxHQUFBQTs7QUFJQUcsSUFBQUEsbUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUtDLE9BQUwvQixJQUFLK0IsRUFBRVIsQ0FBRlEsQ0FBTDtRQUFXRCxPQUFDOUIsSUFBRHlCLE9BQUFBLENBQUFBO01BQVg7UUFBbUJLLE9BQUE5QjtNQUFuQjtJQURGOEIsQ0FBQUEsR0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUtKLFVBQUw1QixJQUFLNEIsRUFBRTVCLElBQUY0QjtJQURQSSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFLRixPQUFML0IsSUFBSytCLEVBQUVSLENBQUZRLENBQUw7UUFBV0UsT0FBQUMsSUFBQUMsV0FBQUQ7TUFBWDtRQUF3QkQsT0FBQVY7TUFBeEI7SUFERlUsQ0FBQUEsR0FBQUE7O0FBSUFHLElBQUFBLG9CQUFBQSxnQkFBU0MsT0FBVEQ7QUFBQUEsTUFBQUE7Ozs7TUFBUywrQkFBVWIsQ0FBVjtNQUNQYSxPQUFBcEMsSUFBQXNDLE1BQUFBLENBQUFBLENBQUlGLE1BQUFBLENBQU1DLE9BQU5EO0lBRE5BLENBQUFBLElBQUFBOztBQUlBRyxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBdkM7SUFERnVDLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSwyQkFBQUEsdUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBeEMsSUFBQXlDLE1BQUFBLENBQUFBLENBQUlELGFBQUFBLENBQUFBO0lBRE5BLENBQUFBLEdBQUFBOztBQUlBWCxJQUFBQSxtQkFBQUEsZUFBUXZCLEtBQVJ1QjtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxNQUFzRHZCLEtBQXRELEVBQStEaUIsQ0FBL0QsQ0FBQTtRQUFBZCxPQUFRUyxPQUFBQSxDQUFPd0Isd0JBQWYsRUFBb0NiLGNBQTVCWDtNQUFSO01BRUFXLE9BQU1jLFdBQUwzQyxJQUFLMkMsRUFBRXJDLEtBQUZxQyxDQUFRQyxPQUFBQSxDQUFBQTtJQUhoQmYsQ0FBQUEsR0FBQUE7O0FBTUFnQixJQUFBQSxzQkFBQUEsa0JBQVd2QyxLQUFYdUM7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQzdDLElBQUE2QixLQUFBQSxDQUFJdkIsS0FBSnVCLENBQUQsRUFBYTdCLElBQUsyQixNQUFBQSxDQUFFckIsS0FBRnFCLENBQWxCO0lBREZrQixDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFTeEMsS0FBVHdDO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFLSCxXQUFMM0MsSUFBQXNDLE1BQUFBLENBQUFBLENBQUtLLEVBQUVyQyxLQUFGcUM7SUFEUEcsQ0FBQUEsR0FBQUE7O0FBSUFGLElBQUFBLHFCQUFBQSxpQkFBVVAsT0FBVk87QUFBQUEsTUFBQUE7Ozs7TUFBVSwrQkFBVXJCLENBQVY7TUFDUnFCLE9BQUE1QyxJQUFBc0MsTUFBQUEsQ0FBQUEsQ0FBSU0sT0FBQUEsQ0FBT1AsT0FBUE87SUFETkEsQ0FBQUEsSUFBQUE7O0FBSUFHLElBQUFBLGlCQUFBQSxhQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXRDLE9BQVF1QyxTQUFBQSxDQUFTekIsQ0FBakIsRUFBb0J2QixJQUFaZ0Q7SUFEVkQsQ0FBQUEsR0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQTFCO0lBREYwQixDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsd0JBQUFBLGlDQUFBQTtBQUFBQTtNQUNFQSxPQUFBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSx3QkFBQUEsaUNBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBQW5ELElBQUFvRCxVQUFBQSxDQUFBQSxDQUFBLENBQUE7UUFBUUQsT0FBQTtNQUFSO1FBQWNBLE9BQUFuRDtNQUFkO0lBREZtRCxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEseUJBQUFBLHFCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXJELElBQUF5QyxNQUFBQSxDQUFBQSxDQUFJWSxXQUFBQSxDQUFBQTtJQUROQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxDQUFDdEQsSUFBQThCLEtBQUFBLENBQUFBLENBQUQsRUFBTTlCLElBQUF1RCxLQUFBQSxDQUFBQSxDQUFOO0lBREZELENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxtQkFBQUEsZUFBUWxELEtBQVJrRDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBMkNiLFdBQTNDYyxLQUFNQyxlQUFBQSxDQUFZMUQsSUFBbEIsRUFBd0IyRCxlQUF4QixFQUFvQyxNQUE5QkQsQ0FBcUNmLEVBQUVyQyxLQUFGcUM7SUFEN0NhLENBQUFBLEdBQUFBOztBQUlBSSxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBNUQ7SUFERjRELENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxxQkFBQUEsOEJBQUFBO0FBQUFBO01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQzlELElBQUQsRUFBT3VCLENBQVA7SUFERnVDLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxxQkFBQUEsaUJBQVVDLE1BQVZEO0FBQUFBLE1BQUFBOzs7O01BQ0VBLE9BQUEvRCxJQUFBc0MsTUFBQUEsQ0FBQUEsQ0FBSXlCLE9BQUFBLENBQU9DLE1BQVBEO0lBRE5BLENBQUFBLElBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsZ0JBcklGLEVBcUlVLEVBcklWLEVBcUlVLEVBcklWLEVBcUlFQTtBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7TUFySUY7O01BQUE7O01BQUE7TUFBQTtNQUFBO01BQUE7TUFBQTs7TUFxSVc7O01BQW1COztNQUFrQjs7TUFBZTs7QUFFL0RBO0FBQ0FBLFFBQVV4RCxPQUFRUyxPQUFBQSxDQUFPRSxvQkFBZixFQUFnQzZDLG1CQUF4Qi9DO0FBQ2xCK0M7O0FBRUFBO0FBQ0FBLFFBQVV4RCxPQUFRUyxPQUFBQSxDQUFPRSxvQkFBZixFQUFnQzZDLHFCQUF4Qi9DO0FBQ2xCK0M7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLFVBQVl4RCxPQUFRUyxPQUFBQSxDQUFPQyxnQkFBZixFQUE0QjhDLHNCQUFwQi9DO0FBQ3BCK0M7O0FBRUFBLDRCQUE4QkEsSUFBS0MsT0FBQUEsQ0FBRzNDLENBQUgyQyxDQUFLRDtBQUN4Q0EsVUFBWXhELE9BQVFTLE9BQUFBLENBQU9FLG9CQUFmLEVBQWdDNkMsaUJBQXhCL0M7QUFDcEIrQzs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBLG1CQUFxQkEsSUFBSzVDLFFBQUFBLENBQUlFLENBQUpGLENBQU00Qzs7QUFFaENBO0FBQ0FBLFVBQVl4RCxPQUFRUyxPQUFBQSxDQUFPRSxvQkFBZixFQUFpQzZDLDBCQUFELEdBQUEsQ0FBMkJBLElBQUl6RCxPQUFBQSxDQUFBQSxDQUEvQixDQUF4QlU7QUFDcEIrQzs7QUFFQUE7QUFDQUEsNkJBQStCRSxJQUFBekQsWUFBQXlELGFBQWtCRixHQUFNRSxJQUFBekQsWUFBQXlELGFBQUQxQyxPQUFBQSxDQUFBQSxDQUFtQndDO0FBQ3pFQTs7QUFFQUEsUUFBVVIsS0FBTVcsU0FBQUEsQ0FBU3BFLElBQWYsRUFBcUJxRSxLQUFmRDtBQUNoQkg7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLCtFQUFpRkssSUFBQTVELFlBQUE0RCxZQUFpQkw7O0FBRWxHQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtNQUVJLEtBQU9NLGVBQVA7UUFDRSxJQUFHLENBQUMsQ0FBQSxLQUFDRixLQUFELENBQUEsSUFBQSxDQUFBLFFBQVVBLEtBQUtHLFVBQUFBLENBQU9DLGNBQVBELENBQWYsQ0FBQSxDQUFBLENBQUQsSUFBQSxDQUNDLENBQUEsS0FBQ1AsSUFBRCxDQUFBLElBQUEsQ0FBQSxRQUFTQSxJQUFJTyxVQUFBQSxDQUFPQyxjQUFQRCxDQUFiLENBQUEsQ0FBQSxDQURELENBQUEsQ0FBSDtVQUdFLE9BQU9FLElBQUFDLGlCQUFBRCx1QkFBZ0NFLEtBQUFBLENBQ3JDLENBQUNQLEtBQUQsRUFBUUosSUFBUixFQUFlLENBQUEsUUFBVVksRUFBVixDQUFBLEdBQUEsQ0FBQVosTUFBQSxJQUFBLEdBQUEsQ0FBZixFQUErQixDQUFBLFFBQVVhLEVBQVYsQ0FBQSxHQUFBLENBQUFiLE1BQUEsSUFBQSxHQUFBLENBQS9CLENBREssRUFDMENqRSxJQURWNEU7UUFIekM7VUFPRSxPQUFPRyxNQUFBL0UsSUFBQStFLFlBQUFBLEVBQUFBLENBQVMsTUFBVCxFQUFnQlYsS0FBaEIsRUFBdUJKLElBQXZCYyxDQUFBQSxFQUE4QmQsQ0FBQ0EsUUFBREEsQ0FBRGUsU0FBQUEsQ0FBQUEsQ0FBN0JEO1FBUFQ7TUFERjs7QUFhSmQ7O0FBRUFBLG1CQUFxQkEsSUFBSWdCLGNBQUFBLENBQUFBLENBQVdoQjtBQUNwQ0Esa0JBQW9CQSxJQUFLQyxPQUFBQSxDQUFHM0MsQ0FBSDJDLENBQUtEO0FBQzlCQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSxzQkFBd0JqRSxJQUFBc0MsTUFBQUEsQ0FBQUEsQ0FBSzJCO0FBQzdCQSxpQkFBbUJBLElBQUkzQixNQUFBQSxDQUFBQSxDQUFNMkI7QUFDN0JBLGtCQUFvQkksS0FBSy9CLE1BQUFBLENBQUFBLENBQU0yQjs7QUFFL0JBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7TUFFSWlCLFVBQVVsRjtNQUVWLE9BQUEsUUFBT2lFLFNBQW1Ca0IsT0FBUkQsT0FBUUMsRUFBR2QsS0FBSGMsQ0FBU2xCLEdBQWFtQixPQUFSRixPQUFRRSxFQUFHZixLQUFIZSxDQUFoRCxDQUFBOztRQUNFLG1CQUFNRixPQUFOO1FBQ0FBLFVBQVFHLFNBQVJILE9BQVFHLEVBQUdwQixJQUFIb0I7TUFGVjtJQWhLRnBCLENBQUFBLElBQUFBOztBQXNLQXFCLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE3RSxPQUFRdUMsU0FBQUEsQ0FBU2hELElBQWpCLEVBQXVCdUIsQ0FBZnlCO0lBRFZzQyxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXZGLElBQUF3RixNQUFBQSxDQUFBQTtJQURGRCxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEsd0JBQUFBLG9CQUFhcEQsT0FBYm9EO0FBQUFBLE1BQUFBOzs7O01BQWEsK0JBQVVsRSxDQUFWO01BQ1hrRSxPQUFBekYsSUFBQXNDLE1BQUFBLENBQUFBLENBQUltRCxVQUFBQSxDQUFVcEQsT0FBVm9EO0lBRE5BLENBQUFBLElBQUFBOztBQUlBckMsSUFBQUEscUJBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXBELElBQUtrRSxPQUFBQSxDQUFHM0MsQ0FBSDJDO0lBRFBkLENBQUFBLEdBQUFBOztBQUlBc0MsSUFBQUEseUJBQUFBLGtDQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBS0MsT0FBTDNGLElBQUsyRixFQUFFcEUsQ0FBRm9FO0lBRFBELENBQUFBLEdBQUFBOztBQUlBVCxJQUFBQSx5QkFBQUEsbUNBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFLbEQsT0FBTC9CLElBQUsrQixFQUFFUixDQUFGUTtJQURQa0QsQ0FBQUEsR0FBQUE7O0FBSUFXLElBQUFBLG1CQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTVGO0lBREY0RixDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQXZVRkMsT0F1VUVEO0FBQUFBLE1BQUFBOzs7O01BdlVGO01BQUE7TUFBQTtNQUFBO01BQUE7O01BdVVZO01BQUEsNkJBQVE7TUFDaEJBLE9BQUE3RjtJQURGNkYsQ0FBQUEsSUFBQUE7O0FBSUFFLElBQUFBLHVCQUFBQSxpQ0FBQUE7QUFBQUE7TUFDRUEsT0FBQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEseUJBQUFBLG1DQUFBQTtBQUFBQTtNQUNFQSxPQUFBO0lBREZBLENBQUFBLEdBQUFBO0lBSUEsYUFBTSxLQUFOLEVBQVUsT0FBVjtJQUNBLGFBQU0sV0FBTixFQUFnQixNQUFoQjtJQUNBLGFBQU0sV0FBTixFQUFnQixNQUFoQjtJQUNBLGFBQU0sV0FBTixFQUFnQixLQUFoQjtJQUNBLGFBQU0sUUFBTixFQUFhLEdBQWI7SUFDQSxhQUFNLE9BQU4sRUFBWSxLQUFaO0lBQ0E5RixPQUFBLGFBQU0sYUFBTixFQUFrQixNQUFsQjtFQXZWRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTI3NzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2FycmF5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBmYWxzeSwgaGFzaF9pZHMsIHlpZWxkMSwgaGFzaF9nZXQsIGhhc2hfcHV0LCBoYXNoX2RlbGV0ZSwgY29lcmNlX3RvLCByZXNwb25kX3RvXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcblxuY2xhc3MgOjpBcnJheSA8IGBBcnJheWBcbiAgaW5jbHVkZSA6OkVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGphdmFzY3JpcHQgYXJyYXlzIGFzIGJlaW5nIHZhbGlkIHJ1YnkgYXJyYXlzXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfYXJyYXknLCB0cnVlKWBcblxuICAleHtcbiAgICAvLyBSZWNlbnQgdmVyc2lvbnMgb2YgVjggKD4gNy4xKSBvbmx5IHVzZSBhbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gd2hlbiBBcnJheS5wcm90b3R5cGUgaXMgdW5tb2RpZmllZC5cbiAgICAvLyBGb3IgaW5zdGFuY2UsIFwiYXJyYXktc3BsaWNlLnRxXCIgaGFzIGEgXCJmYXN0IHBhdGhcIiAoRXh0cmFjdEZhc3RKU0FycmF5LCBkZWZpbmVkIGluIFwic3JjL2NvZGVnZW4vY29kZS1zdHViLWFzc2VtYmxlci5jY1wiKVxuICAgIC8vIGJ1dCBpdCdzIG9ubHkgZW5hYmxlZCB3aGVuIFwiSXNQcm90b3R5cGVJbml0aWFsQXJyYXlQcm90b3R5cGUoKVwiIGlzIHRydWUuXG4gICAgLy9cbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBWOCB3ZXJlIHVzaW5nIHJlbGF0aXZlbHkgZmFzdCBKUy13aXRoLWV4dGVuc2lvbnMgY29kZSBldmVuIHdoZW4gQXJyYXkucHJvdG90eXBlIGlzIG1vZGlmaWVkOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzcuMC4xL3NyYy9qcy9hcnJheS5qcyNMNTk5LUw2NDJcbiAgICAvL1xuICAgIC8vIEluIHNob3J0LCBBcnJheSBvcGVyYXRpb25zIGFyZSBzbG93IGluIHJlY2VudCB2ZXJzaW9ucyBvZiBWOCB3aGVuIHRoZSBBcnJheS5wcm90b3R5cGUgaGFzIGJlZW4gdGFtcGVyZWQuXG4gICAgLy8gU28sIHdoZW4gcG9zc2libGUsIHdlIGFyZSB1c2luZyBmYXN0ZXIgb3Blbi1jb2RlZCB2ZXJzaW9uIHRvIGJvb3N0IHRoZSBwZXJmb3JtYW5jZS5cblxuICAgIC8vIEFzIG9mIFY4IDguNCwgZGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIHRoZSBhcnJheSwgdGhpcyBpcyB1cCB0byB+MjV4IHRpbWVzIGZhc3RlciB0aGFuIEFycmF5I3NoaWZ0KClcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBpcyBoZWF2aWx5IGluc3BpcmVkIGJ5OiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iYTY4NDgwNWI2YzBlZGVkNzZlNWNkODllZTAwMzI4YWM3YTU5MzY1L2xpYi9pbnRlcm5hbC91dGlsLmpzI0wzNDEtTDM0N1xuICAgIGZ1bmN0aW9uIHNoaWZ0Tm9BcmcobGlzdCkge1xuICAgICAgdmFyIHIgPSBsaXN0WzBdO1xuICAgICAgdmFyIGluZGV4ID0gMTtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBsaXN0W2luZGV4IC0gMV0gPSBsaXN0W2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGxpc3QucG9wKCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5U3ViY2xhc3Mob2JqLCBrbGFzcykge1xuICAgICAgaWYgKGtsYXNzLiQkbmFtZSA9PT0gT3BhbC5BcnJheSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtsYXNzLiRhbGxvY2F0ZSgpLiRyZXBsYWNlKCN7YG9iamAudG9fYX0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEEgaGVscGVyIGZvciBrZWVwX2lmIGFuZCBkZWxldGVfaWYsIGZpbHRlciBpcyBlaXRoZXIgT3BhbC50cnV0aHlcbiAgICAvLyBvciBPcGFsLmZhbHN5LlxuICAgIGZ1bmN0aW9uIGZpbHRlcklmKHNlbGYsIGZpbHRlciwgYmxvY2spIHtcbiAgICAgIHZhciB2YWx1ZSwgcmFpc2VkID0gbnVsbCwgdXBkYXRlZCA9IG5ldyBBcnJheShzZWxmLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpMiA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFyYWlzZWQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKVxuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIHJhaXNlZCA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyYWlzZWQgfHwgZmlsdGVyKHZhbHVlKSkge1xuICAgICAgICAgIHVwZGF0ZWRbaTJdID0gc2VsZltpXVxuICAgICAgICAgIGkyICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGkyICE9PSBpKSB7XG4gICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFswLCB1cGRhdGVkLmxlbmd0aF0uY29uY2F0KHVwZGF0ZWQpKTtcbiAgICAgICAgc2VsZi5zcGxpY2UoaTIsIHVwZGF0ZWQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhaXNlZCkgdGhyb3cgcmFpc2VkO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBzZWxmLltdKCpvYmplY3RzKVxuICAgIGB0b0FycmF5U3ViY2xhc3Mob2JqZWN0cywgc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKHNpemUgPSBuaWwsIG9iaiA9IG5pbCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKG9iaiAhPT0gbmlsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC53YXJuKCd3YXJuaW5nOiBibG9jayBzdXBlcnNlZGVzIGRlZmF1bHQgdmFsdWUgYXJndW1lbnQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpemUgPiAjezo6SW50ZWdlcjo6TUFYfSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2FycmF5IHNpemUgdG9vIGJpZyd9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjIpXCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChzaXplLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAje3JlcGxhY2Uoc2l6ZS50b19hKX1cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSBlbHNlIGlmICgje3NpemUucmVzcG9uZF90bz8gOnRvX2FyeX0pIHtcbiAgICAgICAgICAje3JlcGxhY2Uoc2l6ZS50b19hcnkpfVxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNpemUgPSAkY29lcmNlX3RvKHNpemUsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ31cbiAgICAgIH1cblxuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCB2YWx1ZTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soaSk7XG4gICAgICAgICAgc2VsZltpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqKVxuICAgIDo6T3BhbC5jb2VyY2VfdG8/IG9iaiwgOjpBcnJheSwgOnRvX2FyeVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBvdGhlciA9IGlmIDo6QXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGlmICgkaGFzaF9kZWxldGUoaGFzaCwgaXRlbSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICBvdGhlciA9IGlmIDo6QXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgc2VsZltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoLiRrZXlzKCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICByZXR1cm4gam9pbihvdGhlci50b19zdHIpIGlmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19zdHJcblxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYG90aGVyIDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgY29udmVydGVkID0gI3t0b19hfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlcjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY29udmVydGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgIGBzZWxmLmNvbmNhdChvdGhlcilgXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG4gICAgcmV0dXJuIGBzZWxmLnNsaWNlKClgIGlmIGBvdGhlci5sZW5ndGggPT09IDBgXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwgaXRlbSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPDwob2JqZWN0KVxuICAgIGBzZWxmLnB1c2gob2JqZWN0KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiA6OkFycmF5ID09PSBvdGhlclxuICAgICAgb3RoZXIgPSBvdGhlci50b19hXG4gICAgZWxzaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgb3RoZXIgPSBvdGhlci50b19hcnkudG9fYVxuICAgIGVsc2VcbiAgICAgIHJldHVyblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoI3toYXNofSA9PT0gI3tvdGhlci5oYXNofSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4oc2VsZi5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgdG1wID0gI3tgc2VsZltpXWAgPD0+IGBvdGhlcltpXWB9O1xuXG4gICAgICAgIGlmICh0bXAgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje2BzZWxmLmxlbmd0aGAgPD0+IGBvdGhlci5sZW5ndGhgfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZCA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoYXJyYXkgPT09IG90aGVyKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmICghb3RoZXIuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmICgkcmVzcG9uZF90byhvdGhlciwgJyR0b19hcnknKSkge1xuICAgICAgICAgICAgcmV0dXJuICN7YG90aGVyYCA9PSBgYXJyYXlgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJheS4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcbiAgICAgICAgICBhcnJheSA9ICN7YGFycmF5YC50b19hfTtcbiAgICAgICAgaWYgKG90aGVyLiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIG90aGVyID0gI3tgb3RoZXJgLnRvX2F9O1xuXG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhID0gYXJyYXlbaV07XG4gICAgICAgICAgYiA9IG90aGVyW2ldO1xuICAgICAgICAgIGlmIChhLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGV4Y2x1ZGUgPSBpbmRleC5leGNsO1xuICAgICAgZnJvbSAgICA9IGluZGV4LmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhpbmRleC5iZWdpbiwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG4gICAgICB0byAgICAgID0gaW5kZXguZW5kID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8oaW5kZXguZW5kLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGZyb20gKz0gc2l6ZTtcblxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleC5leGNsX3JldiAmJiBpbmRleC5iZWdpbiAhPT0gbmlsKSB7XG4gICAgICAgIGZyb20gKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgdG8gKz0gc2l6ZTtcblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhjbHVkZSB8fCBpbmRleC5lbmQgPT09IG5pbCkge1xuICAgICAgICB0byArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGZyb20sIHRvKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2FyaXRobWV0aWNfc2VxKHNlbGYsIGluZGV4KSB7XG4gICAgICB2YXIgYXJyYXksIG91dCA9IFtdLCBpID0gMCwgcHNldWRvcmFuZ2U7XG5cbiAgICAgIGlmIChpbmRleC5zdGVwIDwgMCkge1xuICAgICAgICBwc2V1ZG9yYW5nZSA9IHtcbiAgICAgICAgICBiZWdpbjogaW5kZXgucmFuZ2UuZW5kLFxuICAgICAgICAgIGVuZDogaW5kZXgucmFuZ2UuYmVnaW4sXG4gICAgICAgICAgZXhjbDogZmFsc2UsXG4gICAgICAgICAgZXhjbF9yZXY6IGluZGV4LnJhbmdlLmV4Y2xcbiAgICAgICAgfTtcbiAgICAgICAgYXJyYXkgPSAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgcHNldWRvcmFuZ2UpLiRyZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJyYXkgPSAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgaW5kZXgucmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICBvdXQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIGkgKz0gTWF0aC5hYnMoaW5kZXguc3RlcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpbmRleC4kJGlzX2FyaXRobWV0aWNfc2VxKSB7XG4gICAgICAgIHJldHVybiAkYXJyYXlfc2xpY2VfYXJpdGhtZXRpY19zZXEoc2VsZiwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAkYXJyYXlfc2xpY2VfaW5kZXhfbGVuZ3RoKHNlbGYsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShpbmRleCwgdmFsdWUsIGV4dHJhID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGksIHNpemUgPSBzZWxmLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiA6OlJhbmdlID09PSBpbmRleFxuICAgICAgZGF0YSA9IGlmIDo6QXJyYXkgPT09IHZhbHVlXG4gICAgICAgICAgICAgICB2YWx1ZS50b19hXG4gICAgICAgICAgICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgICAgICAgICAgdmFsdWUudG9fYXJ5LnRvX2FcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICBbdmFsdWVdXG4gICAgICAgICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgZXhjbHVkZSA9IGluZGV4LmV4Y2wsXG4gICAgICAgICAgICBmcm9tICAgID0gaW5kZXguYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKSxcbiAgICAgICAgICAgIHRvICAgICAgPSBpbmRleC5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhpbmRleC5lbmQsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIGZyb20gKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiI3tpbmRleC5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHRvICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUgfHwgaW5kZXguZW5kID09PSBuaWwpIHtcbiAgICAgICAgICB0byArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGZyb207IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIDBdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIHRvIC0gZnJvbV0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpZiBgZXh0cmEgPT09IHVuZGVmaW5lZGBcbiAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgZWxzZVxuICAgICAgICBsZW5ndGggPSB2YWx1ZVxuICAgICAgICB2YWx1ZSAgPSBleHRyYVxuXG4gICAgICAgIGRhdGEgPSBpZiA6OkFycmF5ID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgICB2YWx1ZS50b19hXG4gICAgICAgICAgICAgICBlbHNpZiB2YWx1ZS5yZXNwb25kX3RvPyA6dG9fYXJ5XG4gICAgICAgICAgICAgICAgIHZhbHVlLnRvX2FyeS50b19hXG4gICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgIFt2YWx1ZV1cbiAgICAgICAgICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgb2xkO1xuXG4gICAgICAgIGluZGV4ICA9ICRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIG9sZCAgICA9IGluZGV4O1xuICAgICAgICAgIGluZGV4ICs9IHNpemU7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJpbmRleCAje2BvbGRgfSB0b28gc21hbGwgZm9yIGFycmF5OyBtaW5pbXVtICN7YC1zZWxmLmxlbmd0aGB9XCJ9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwibmVnYXRpdmUgbGVuZ3RoICgje2xlbmd0aH0pXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxmW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgbGVuZ3RoXS5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgYGlmIChzZWxmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbSA9IHNlbGZbaV0sIGl0ZW0ubGVuZ3RoICYmICN7YGl0ZW1bMF1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0KGluZGV4KVxuICAgICV4e1xuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKVxuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2hfaW5kZXggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gMCxcbiAgICAgICAgICBtYXggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBtaWQsXG4gICAgICAgICAgdmFsLFxuICAgICAgICAgIHJldCxcbiAgICAgICAgICBzbWFsbGVyID0gZmFsc2UsXG4gICAgICAgICAgc2F0aXNmaWVkID0gbmlsO1xuXG4gICAgICB3aGlsZSAobWluIDwgbWF4KSB7XG4gICAgICAgIG1pZCA9IG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyAyKTtcbiAgICAgICAgdmFsID0gc2VsZlttaWRdO1xuICAgICAgICByZXQgPSAkeWllbGQxKGJsb2NrLCB2YWwpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgICBzYXRpc2ZpZWQgPSBtaWQ7XG4gICAgICAgICAgc21hbGxlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmV0ID09PSBmYWxzZSB8fCByZXQgPT09IG5pbCkge1xuICAgICAgICAgIHNtYWxsZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAocmV0ID09PSAwKSB7IHJldHVybiBtaWQ7IH1cbiAgICAgICAgICBzbWFsbGVyID0gKHJldCA8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2ByZXRgLmNsYXNzfSAobXVzdCBiZSBudW1lcmljLCB0cnVlLCBmYWxzZSBvciBuaWwpXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc21hbGxlcikgeyBtYXggPSBtaWQ7IH0gZWxzZSB7IG1pbiA9IG1pZCArIDE7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNhdGlzZmllZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaW5kZXggPSBic2VhcmNoX2luZGV4KCZibG9jaylcblxuICAgICV4e1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwgJiYgaW5kZXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN5Y2xlKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmN5Y2xlLCBuKSBkb1xuICAgICAgICBpZiBuLm5pbD9cbiAgICAgICAgICA6OkZsb2F0OjpJTkZJTklUWVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgICBuID4gMCA/IGVudW1lcmF0b3Jfc2l6ZSAqIG4gOiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXR1cm4gaWYgZW1wdHk/IHx8IG4gPT0gMFxuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbiA9ICN7OjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICBgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY291bnQob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYG9iamVjdCAhPT0gdW5kZWZpbmVkYCB8fCBibG9ja1xuICAgICAgc3VwZXJcbiAgICBlbHNlXG4gICAgICBzaXplXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gICAgcmVwbGFjZSBvdGhlclxuICBlbmRcblxuICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgc2VsZltpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gYmlub21pYWxfY29lZmZpY2llbnQobiwgaykge1xuICAgICAgaWYgKG4gPT09IGsgfHwgayA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGsgPiAwICYmIG4gPiBrKSB7XG4gICAgICAgIHJldHVybiBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayAtIDEpICsgYmlub21pYWxfY29lZmZpY2llbnQobiAtIDEsIGspO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICBkZWYgY29tYmluYXRpb24obilcbiAgICBudW0gPSA6Ok9wYWwuY29lcmNlX3RvISBuLCA6OkludGVnZXIsIDp0b19pbnRcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KCN7c2VsZn0ubGVuZ3RoLCBudW0pYCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgc3RhY2ssIGNob3NlbiwgbGV2LCBkb25lLCBuZXh0O1xuXG4gICAgICBpZiAobnVtID09PSAwKSB7XG4gICAgICAgICN7eWllbGQgW119XG4gICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3t5aWVsZCBgW3NlbGZbaV1dYH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAje3lpZWxkIGBzZWxmLnNsaWNlKClgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID49IDAgJiYgbnVtIDwgc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2sgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSBudW0gKyAxOyBpKyspIHtcbiAgICAgICAgICBzdGFjay5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hvc2VuID0gW107XG4gICAgICAgIGxldiA9IDA7XG4gICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgc3RhY2tbMF0gPSAtMTtcblxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICBjaG9zZW5bbGV2XSA9IHNlbGZbc3RhY2tbbGV2KzFdXTtcbiAgICAgICAgICB3aGlsZSAobGV2IDwgbnVtIC0gMSkge1xuICAgICAgICAgICAgbGV2Kys7XG4gICAgICAgICAgICBuZXh0ID0gc3RhY2tbbGV2KzFdID0gc3RhY2tbbGV2XSArIDE7XG4gICAgICAgICAgICBjaG9zZW5bbGV2XSA9IHNlbGZbbmV4dF07XG4gICAgICAgICAgfVxuICAgICAgICAgICN7IHlpZWxkIGBjaG9zZW4uc2xpY2UoKWAgfVxuICAgICAgICAgIGxldisrO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRvbmUgPSAobGV2ID09PSAwKTtcbiAgICAgICAgICAgIHN0YWNrW2xldl0rKztcbiAgICAgICAgICAgIGxldi0tO1xuICAgICAgICAgIH0gd2hpbGUgKCBzdGFja1tsZXYrMV0gKyBudW0gPT09IHNlbGYubGVuZ3RoICsgbGV2ICsgMSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlcGVhdGVkX2NvbWJpbmF0aW9uKG4pXG4gICAgbnVtID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX2NvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KHNlbGYubGVuZ3RoICsgbnVtIC0gMSwgbnVtKWAgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgZnJvbSwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBpLCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgaXRlcmF0ZShudW0sIDAsIFtdLCBzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKGl0ZW0gPSBzZWxmW2ldKSAhPT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0IVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmW2ldID09PSBuaWwpIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25jYXQoKm90aGVycylcbiAgICBvdGhlcnMgPSBvdGhlcnMubWFwIGRvIHxvdGhlcnxcbiAgICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgICBpZiBvdGhlci5lcXVhbD8oc2VsZilcbiAgICAgICAgb3RoZXIgPSBvdGhlci5kdXBcbiAgICAgIGVuZFxuXG4gICAgICBvdGhlclxuICAgIGVuZFxuXG4gICAgb3RoZXJzLmVhY2ggZG8gfG90aGVyfFxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvdGhlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShvYmplY3QpXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsKSB7XG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgICByZXR1cm4gI3t5aWVsZH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2F0KGluZGV4KVxuICAgICV4e1xuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZltpbmRleF07XG5cbiAgICAgIHNlbGYuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7ZmlsdGVySWYoc2VsZiwgJGZhbHN5LCBibG9jayl9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGlmZmVyZW5jZSgqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodG9fYS5kdXApIHsgfGEsIGJ8IGEgLSBiIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhpZHgsICppZHhzKVxuICAgIGl0ZW0gPSBzZWxmW2lkeF1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBpZHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcbiAgICBlbmRcblxuICAgIGl0ZW0uZGlnKCppZHhzKVxuICBlbmRcblxuICBkZWYgZHJvcChudW1iZXIpXG4gICAgJXh7XG4gICAgICBudW1iZXIgPSAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShudW1iZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSAmJlxuICAgICAgICAgIHNlbGYuJCRjbGFzcy4kYWxsb2NhdGUuJCRwcmlzdGluZSAmJlxuICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2luZGV4KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxbChhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoIW90aGVyLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9ICN7b3RoZXIudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWwoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZldGNoKGluZGV4LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gaW5kZXg7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhvcmlnaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IDAuLi4wXCJ9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tgb3JpZ2luYWxgfSBvdXRzaWRlIG9mIGFycmF5IGJvdW5kczogLSN7YHNlbGYubGVuZ3RoYH0uLi4je2BzZWxmLmxlbmd0aGB9XCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIGJsb2NrXG4gICAgICBpZiBgYXJncy5sZW5ndGggPiAyYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDAuLjIpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvbmUsIHR3byA9IGFyZ3NcbiAgICBlbHNlXG4gICAgICBpZiBgYXJncy5sZW5ndGggPT0gMGBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknXG4gICAgICBlbHNpZiBgYXJncy5sZW5ndGggPiAzYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDEuLjMpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvYmosIG9uZSwgdHdvID0gYXJnc1xuICAgIGVuZFxuXG4gICAgaWYgOjpSYW5nZSA9PT0gb25lXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2xlbmd0aCBpbnZhbGlkIHdpdGggcmFuZ2UnIGlmIHR3b1xuXG4gICAgICBsZWZ0ICAgPSBgb25lLmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhvbmUuYmVnaW4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYGxlZnQgKz0gdGhpcy5sZW5ndGhgIGlmIGBsZWZ0IDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCIje29uZS5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIiBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIHJpZ2h0ID0gYG9uZS5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhvbmUuZW5kLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGByaWdodCArPSB0aGlzLmxlbmd0aGAgaWYgYHJpZ2h0IDwgMGBcbiAgICAgIGByaWdodCArPSAxYCB1bmxlc3Mgb25lLmV4Y2x1ZGVfZW5kP1xuXG4gICAgICByZXR1cm4gc2VsZiBpZiBgcmlnaHQgPD0gbGVmdGBcbiAgICBlbHNpZiBvbmVcbiAgICAgIGxlZnQgICA9IGAkY29lcmNlX3RvKG9uZSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgbGVmdCArPSB0aGlzLmxlbmd0aGAgaWYgYGxlZnQgPCAwYFxuICAgICAgbGVmdCAgID0gMCBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIGlmIHR3b1xuICAgICAgICByaWdodCA9IGAkY29lcmNlX3RvKHR3bywgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0ID09IDBgXG5cbiAgICAgICAgYHJpZ2h0ICs9IGxlZnRgXG4gICAgICBlbHNlXG4gICAgICAgIHJpZ2h0ID0gYHRoaXMubGVuZ3RoYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgbGVmdCAgPSAwXG4gICAgICByaWdodCA9IGB0aGlzLmxlbmd0aGBcbiAgICBlbmRcblxuICAgIGlmIGBsZWZ0ID4gdGhpcy5sZW5ndGhgXG4gICAgICAleHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGg7IGkgPCByaWdodDsgaSsrKSB7XG4gICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgaWYgYHJpZ2h0ID4gdGhpcy5sZW5ndGhgXG4gICAgICBgdGhpcy5sZW5ndGggPSByaWdodGBcbiAgICBlbmRcblxuICAgIGlmIGJsb2NrXG4gICAgICAleHtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGxlZnQpO1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSAje29ian07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZpcnN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZlswXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4obGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBfZmxhdHRlbihhcnJheSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuZ3RoLFxuICAgICAgICAgICAgaXRlbSwgYXJ5O1xuXG4gICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGFycmF5W2ldO1xuXG4gICAgICAgICAgaWYgKCEkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScsIHRydWUpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFyeSA9ICN7YGl0ZW1gLnRvX2FyeX07XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFyeSA9PT0gc2VsZikge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoX2ZsYXR0ZW4oYXJ5KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX2ZsYXR0ZW4oYXJ5LCBsZXZlbCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwgPSAkY29lcmNlX3RvKGxldmVsLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9mbGF0dGVuKHNlbGYsIGxldmVsKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuIShsZXZlbCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBmbGF0dGVuZWQgPSAje2ZsYXR0ZW4gbGV2ZWx9O1xuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT0gZmxhdHRlbmVkLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzZWxmW2ldICE9PSBmbGF0dGVuZWRbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID09IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3tyZXBsYWNlIGBmbGF0dGVuZWRgfTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKCRoYXNoX2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICByZXN1bHQgPSBbJ0EnXSxcbiAgICAgICAgICBoYXNoX2lkID0gc2VsZi4kb2JqZWN0X2lkKCksXG4gICAgICAgICAgaXRlbSwgaSwga2V5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgJGhhc2hfaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBlYXJseSBmb3IgcmVjdXJzaXZlIHN0cnVjdHVyZXNcbiAgICAgICAgaWYgKCRoYXNoX2lkc1toYXNoX2lkXSkge1xuICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiAkaGFzaF9pZHMpIHtcbiAgICAgICAgICBpdGVtID0gJGhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkaGFzaF9pZHNbaGFzaF9pZF0gPSBzZWxmO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbS4kaGFzaCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignLCcpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICRoYXNoX2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1lbWJlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBtZW1iZXJ9KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6aW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc2VydChpbmRleCwgKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAjeyA6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiI3tpbmRleH0gaXMgb3V0IG9mIGJvdW5kc1wiIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYubGVuZ3RoOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5wdXNoKG5pbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCAwXS5jb25jYXQob2JqZWN0cykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYHZhciBpbnNwZWN0X3N0YWNrID0gW11gXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGlkID0gI3tfX2lkX199LFxuICAgICAgcHVzaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBiZWdpblxuICAgICAgJXh7XG4gICAgICAgIGlmIChpbnNwZWN0X3N0YWNrLmluZGV4T2YoaWQpICE9PSAtMSkge1xuICAgICAgICAgIHB1c2hlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiAnWy4uLl0nO1xuICAgICAgICB9XG4gICAgICAgIGluc3BlY3Rfc3RhY2sucHVzaChpZClcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gI3tzZWxmW2BpYF19O1xuXG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tPcGFsLmluc3BlY3QoYGl0ZW1gKX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdbJyArIHJlc3VsdC5qb2luKCcsICcpICsgJ10nO1xuICAgICAgfVxuICAgICAgbmlsXG4gICAgZW5zdXJlXG4gICAgICBgaWYgKHB1c2hlZCkgaW5zcGVjdF9zdGFjay5wb3AoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGludGVyc2VjdGlvbigqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodG9fYS5kdXApIHsgfGEsIGJ8IGEgJiBiIH1cbiAgZW5kXG5cbiAgZGVmIGludGVyc2VjdD8ob3RoZXIpXG4gICAgIWludGVyc2VjdGlvbihvdGhlcikuZW1wdHk/XG4gIGVuZFxuXG4gIGRlZiBqb2luKHNlcCA9IG5pbClcbiAgICByZXR1cm4gJycgaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgaWYgYHNlcCA9PT0gbmlsYFxuICAgICAgc2VwID0gJCxcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGksIGxlbmd0aCwgaXRlbSwgdG1wO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX3N0cicpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc3RyfTtcblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC50b19zfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fYXJ5fTtcblxuICAgICAgICAgIGlmICh0bXAgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YHRtcGAuam9pbihzZXApfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX3MnKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX3N9O1xuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0bXApO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcoXCIje09wYWwuaW5zcGVjdChpdGVtKX0gZG9lc24ndCByZXNwb25kIHRvICN0b19zdHIsICN0b19hcnkgb3IgI3RvX3NcIiwgJ3RvX3N0cicpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlcCA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCN7OjpPcGFsLmNvZXJjZV90byEoc2VwLCA6OlN0cmluZywgOnRvX3N0cikudG9fc30pO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e2ZpbHRlcklmKHNlbGYsICR0cnV0aHksIGJsb2NrKX1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsYXN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZltzZWxmLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICBjb3VudCA9ICRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBlYWNoLm1heChuLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtaW4oJmJsb2NrKVxuICAgIGVhY2gubWluKCZibG9jaylcbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gUmV0dXJucyB0aGUgcHJvZHVjdCBvZiBmcm9tLCBmcm9tLTEsIC4uLiwgZnJvbSAtIGhvd19tYW55ICsgMS5cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nX2ZhY3RvcmlhbChmcm9tLCBob3dfbWFueSkge1xuICAgICAgdmFyIGNvdW50ID0gaG93X21hbnkgPj0gMCA/IDEgOiAwO1xuICAgICAgd2hpbGUgKGhvd19tYW55KSB7XG4gICAgICAgIGNvdW50ICo9IGZyb207XG4gICAgICAgIGZyb20tLTtcbiAgICAgICAgaG93X21hbnktLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIH1cblxuICBkZWYgcGVybXV0YXRpb24obnVtID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpwZXJtdXRhdGlvbiwgbnVtKSBkb1xuICAgICAgICBgZGVzY2VuZGluZ19mYWN0b3JpYWwoc2VsZi5sZW5ndGgsIG51bSA9PT0gdW5kZWZpbmVkID8gc2VsZi5sZW5ndGggOiBudW0pYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBwZXJtdXRlLCBvZmZlbnNpdmUsIG91dHB1dDtcblxuICAgICAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG51bSA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG51bSA9ICRjb2VyY2VfdG8obnVtLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bSA8IDAgfHwgc2VsZi5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgLy8gbm8gcGVybXV0YXRpb25zLCB5aWVsZCBub3RoaW5nXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW0gPT09IDApIHtcbiAgICAgICAgLy8gZXhhY3RseSBvbmUgcGVybXV0YXRpb246IHRoZSB6ZXJvLWxlbmd0aCBhcnJheVxuICAgICAgICAjeyB5aWVsZCBbXSB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwsIGVhc3kgY2FzZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAjeyB5aWVsZCBgW3NlbGZbaV1dYCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBnZW5lcmFsIGNhc2VcbiAgICAgICAgI3sgcGVybSA9IEFycmF5Lm5ldyhudW0pIH07XG4gICAgICAgICN7IHVzZWQgPSBBcnJheS5uZXcoYHNlbGYubGVuZ3RoYCwgZmFsc2UpIH07XG5cbiAgICAgICAgcGVybXV0ZSA9IGZ1bmN0aW9uKG51bSwgcGVybSwgaW5kZXgsIHVzZWQsIGJsaykge1xuICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGlmKCN7ICF1c2VkW2BpYF0gfSkge1xuICAgICAgICAgICAgICBwZXJtW2luZGV4XSA9IGk7XG4gICAgICAgICAgICAgIGlmKGluZGV4IDwgbnVtIC0gMSkge1xuICAgICAgICAgICAgICAgIHVzZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBlcm11dGUuY2FsbChzZWxmLCBudW0sIHBlcm0sIGluZGV4ICsgMSwgdXNlZCwgYmxrKTtcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwZXJtLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzZWxmW3Blcm1bal1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHlpZWxkMShibGssIG91dHB1dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XG4gICAgICAgICAgLy8gb2ZmZW5zaXZlIChib3RoIGRlZmluaXRpb25zKSBjb3B5LlxuICAgICAgICAgIG9mZmVuc2l2ZSA9IHNlbGYuc2xpY2UoKTtcbiAgICAgICAgICBwZXJtdXRlLmNhbGwob2ZmZW5zaXZlLCBudW0sIHBlcm0sIDAsIHVzZWQsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCAwLCB1c2VkLCBibG9jayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBlYXRlZF9wZXJtdXRhdGlvbihuKVxuICAgIG51bSA9IDo6T3BhbC5jb2VyY2VfdG8hIG4sIDo6SW50ZWdlciwgOnRvX2ludFxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVwZWF0ZWRfcGVybXV0YXRpb24sIG51bSkgeyBudW0gPj0gMCA/IHNpemUqKm51bSA6IDAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdGUobWF4LCBidWZmZXIsIHNlbGYpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbWF4KSB7XG4gICAgICAgICAgdmFyIGNvcHkgPSBidWZmZXIuc2xpY2UoKTtcbiAgICAgICAgICAje3lpZWxkIGBjb3B5YH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goc2VsZltpXSk7XG4gICAgICAgICAgaXRlcmF0ZShtYXgsIGJ1ZmZlciwgc2VsZik7XG4gICAgICAgICAgYnVmZmVyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGUobnVtLCBbXSwgc2VsZi5zbGljZSgpKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwb3AoY291bnQgPSB1bmRlZmluZWQpXG4gICAgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG4gICAgICByZXR1cm4gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgICAgcmV0dXJuIGBzZWxmLnBvcCgpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgY291bnQgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBpZiBgY291bnQgPT09IDFgXG4gICAgICBgW3NlbGYucG9wKCldYFxuICAgIGVsc2lmIGBjb3VudCA+IHNlbGYubGVuZ3RoYFxuICAgICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcbiAgICBlbHNlXG4gICAgICBgc2VsZi5zcGxpY2Uoc2VsZi5sZW5ndGggLSBjb3VudCwgc2VsZi5sZW5ndGgpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcHJvZHVjdCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICN7YmxvY2tfZ2l2ZW4/fSA/IG51bGwgOiBbXSxcbiAgICAgICAgICBuID0gYXJncy5sZW5ndGggKyAxLFxuICAgICAgICAgIGNvdW50ZXJzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGxlbmd0aHMgID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGFycmF5cyAgID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGksIG0sIHN1YmFycmF5LCBsZW4sIHJlc3VsdGxlbiA9IDE7XG5cbiAgICAgIGFycmF5c1swXSA9IHNlbGY7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXSA9ICRjb2VyY2VfdG8oYXJnc1tpIC0gMV0sICN7OjpBcnJheX0sICd0b19hcnknKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZW4gPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdGxlbiAqPSBsZW47XG4gICAgICAgIGlmIChyZXN1bHRsZW4gPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICd0b28gYmlnIHRvIHByb2R1Y3QnfVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aHNbaV0gPSBsZW47XG4gICAgICAgIGNvdW50ZXJzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgb3V0ZXJfbG9vcDogZm9yICg7Oykge1xuICAgICAgICBzdWJhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgc3ViYXJyYXkucHVzaChhcnJheXNbaV1bY291bnRlcnNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3ViYXJyYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7eWllbGQgYHN1YmFycmF5YH1cbiAgICAgICAgfVxuICAgICAgICBtID0gbiAtIDE7XG4gICAgICAgIGNvdW50ZXJzW21dKys7XG4gICAgICAgIHdoaWxlIChjb3VudGVyc1ttXSA9PT0gbGVuZ3Roc1ttXSkge1xuICAgICAgICAgIGNvdW50ZXJzW21dID0gMDtcbiAgICAgICAgICBpZiAoLS1tIDwgMCkgYnJlYWsgb3V0ZXJfbG9vcDtcbiAgICAgICAgICBjb3VudGVyc1ttXSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwdXNoKCpvYmplY3RzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5wdXNoKG9iamVjdHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoaXRlbS5sZW5ndGggJiYgaXRlbVsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCN7YGl0ZW1bMV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIG9yaWdpbmFsID0gbGVuZ3RoXG4gICAgZGVsZXRlX2lmKCZibG9jaylcblxuICAgIHVubGVzcyBsZW5ndGggPT0gb3JpZ2luYWxcbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgb3RoZXIgPSBpZiA6OkFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAjezo6QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICBzZWxmLnB1c2guYXBwbHkoc2VsZiwgb3RoZXIpO1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VcbiAgICBgc2VsZi5zbGljZSgwKS5yZXZlcnNlKClgXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlIVxuICAgIGBzZWxmLnJldmVyc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXZlcnNlX2VhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJldmVyc2UuZWFjaCgmYmxvY2spXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gYG9iamVjdGB9KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChpID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDpyaW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZShuID0gMSlcbiAgICAleHtcbiAgICAgIHZhciBhcnksIGlkeCwgZmlyc3RQYXJ0LCBsYXN0UGFydDtcblxuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3s6OkludGVnZXJ9LCAndG9faW50JylcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XG4gICAgICBpZHggPSBuICUgYXJ5Lmxlbmd0aDtcblxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XG4gICAgICBsYXN0UGFydCA9IGFyeS5zbGljZSgwLCBpZHgpO1xuICAgICAgcmV0dXJuIGZpcnN0UGFydC5jb25jYXQobGFzdFBhcnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGNudCA9ICRjb2VyY2VfdG8oY250LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG4gICAgYXJ5ID0gcm90YXRlKGNudClcbiAgICByZXBsYWNlIGFyeVxuICBlbmRcblxuICBjbGFzcyBzZWxmOjpTYW1wbGVSYW5kb21cbiAgICBkZWYgaW5pdGlhbGl6ZShybmcpXG4gICAgICBAcm5nID0gcm5nXG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZChzaXplKVxuICAgICAgcmFuZG9tID0gYCRjb2VyY2VfdG8oI3tAcm5nLnJhbmQoc2l6ZSl9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlID49IDAnIGlmIGByYW5kb20gPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIEFycmF5IHNpemUnIHVubGVzcyBgcmFuZG9tIDwgc2l6ZWBcblxuICAgICAgcmFuZG9tXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzYW1wbGUoY291bnQgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGF0IDo6S2VybmVsLnJhbmQoYHNlbGYubGVuZ3RoYCkgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG5cbiAgICBpZiBgb3B0aW9ucyA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgKG8gPSA6Ok9wYWwuY29lcmNlX3RvPyBjb3VudCwgOjpIYXNoLCA6dG9faGFzaClcbiAgICAgICAgb3B0aW9ucyA9IG9cbiAgICAgICAgY291bnQgPSBuaWxcbiAgICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucyA9IG5pbFxuICAgICAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgb3B0aW9ucyA9IGAkY29lcmNlX3RvKG9wdGlvbnMsICN7OjpIYXNofSwgJ3RvX2hhc2gnKWBcbiAgICBlbmRcblxuICAgIGlmIGNvdW50ICYmIGBjb3VudCA8IDBgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJ1xuICAgIGVuZFxuXG4gICAgcm5nID0gb3B0aW9uc1s6cmFuZG9tXSBpZiBvcHRpb25zXG4gICAgcm5nID0gaWYgcm5nICYmIHJuZy5yZXNwb25kX3RvPyg6cmFuZClcbiAgICAgICAgICAgIFNhbXBsZVJhbmRvbS5uZXcgcm5nXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgOjpLZXJuZWxcbiAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBgc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1gIHVubGVzcyBjb3VudFxuXG4gICAgJXh7XG5cbiAgICAgIHZhciBhYmFuZG9uLCBzcGluLCByZXN1bHQsIGksIGosIGssIHRhcmdldEluZGV4LCBvbGRWYWx1ZTtcblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFtzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaiA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICBqID0gaSA9PT0gMCA/IGkgKyAxIDogaSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbc2VsZltpXSwgc2VsZltqXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHNlbGYubGVuZ3RoIC8gY291bnQgPiAzKSB7XG4gICAgICAgICAgICBhYmFuZG9uID0gZmFsc2U7XG4gICAgICAgICAgICBzcGluID0gMDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gI3sgQXJyYXkubmV3KGNvdW50KSB9O1xuICAgICAgICAgICAgaSA9IDE7XG5cbiAgICAgICAgICAgIHJlc3VsdFswXSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICBrID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgaSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChrID09PSByZXN1bHRbal0pIHtcbiAgICAgICAgICAgICAgICAgIHNwaW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzcGluID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYW5kb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaztcblxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWJhbmRvbikge1xuICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGZbcmVzdWx0W2ldXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzdWx0W2NdO1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gcmVzdWx0W3RhcmdldEluZGV4XTtcbiAgICAgICAgICAgIHJlc3VsdFt0YXJnZXRJbmRleF0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY291bnQgPT09IHNlbGYubGVuZ3RoID8gcmVzdWx0IDogI3tgcmVzdWx0YFswLCBjb3VudF19O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW0sIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBpdGVtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcbiAgICAgICN7IGtlZXBfaWYoJmJsb2NrKSB9O1xuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2hpZnQoY291bnQgPSB1bmRlZmluZWQpXG4gICAgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG4gICAgICByZXR1cm4gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgICAgcmV0dXJuIGBzaGlmdE5vQXJnKHNlbGYpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgY291bnQgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBgc2VsZi5zcGxpY2UoMCwgY291bnQpYFxuICBlbmRcblxuICBkZWYgc2h1ZmZsZShybmcgPSB1bmRlZmluZWQpXG4gICAgZHVwLnRvX2Euc2h1ZmZsZSEocm5nKVxuICBlbmRcblxuICBkZWYgc2h1ZmZsZSEocm5nID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHJhbmRnZW4sIGkgPSBzZWxmLmxlbmd0aCwgaiwgdG1wO1xuXG4gICAgICBpZiAocm5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm5nID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhybmcsIDo6SGFzaCwgOnRvX2hhc2gpfTtcblxuICAgICAgICBpZiAocm5nICE9PSBuaWwpIHtcbiAgICAgICAgICBybmcgPSAje3JuZ1s6cmFuZG9tXX07XG5cbiAgICAgICAgICBpZiAocm5nICE9PSBuaWwgJiYgI3tybmcucmVzcG9uZF90bz8oOnJhbmQpfSkge1xuICAgICAgICAgICAgcmFuZGdlbiA9IHJuZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgaWYgKHJhbmRnZW4pIHtcbiAgICAgICAgICBqID0gcmFuZGdlbi4kcmFuZChpKS4kdG9faW50KCk7XG5cbiAgICAgICAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcInJhbmRvbSBudW1iZXIgdG9vIHNtYWxsICN7YGpgfVwifVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChqID49IGkpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcInJhbmRvbSBudW1iZXIgdG9vIGJpZyAje2BqYH1cIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaiA9ICN7cmFuZChgaWApfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCA9IHNlbGZbLS1pXTtcbiAgICAgICAgc2VsZltpXSA9IHNlbGZbal07XG4gICAgICAgIHNlbGZbal0gPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNsaWNlIShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgIHJlc3VsdCA9IG5pbFxuXG4gICAgaWYgYGxlbmd0aCA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgOjpSYW5nZSA9PT0gaW5kZXhcbiAgICAgICAgcmFuZ2UgPSBpbmRleFxuICAgICAgICByZXN1bHQgPSBzZWxmW3JhbmdlXVxuXG4gICAgICAgIHJhbmdlX3N0YXJ0ID0gYHJhbmdlLmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhyYW5nZS5iZWdpbiwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHJhbmdlX2VuZCA9IGByYW5nZS5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhyYW5nZS5lbmQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX3N0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9lbmQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZV9lbmQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCA9IHNlbGYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XG4gICAgICAgICAgICAgIHJhbmdlX2VuZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZV9sZW5ndGggPSByYW5nZV9lbmQgLSByYW5nZV9zdGFydDtcbiAgICAgICAgICBpZiAocmFuZ2UuZXhjbCAmJiByYW5nZS5lbmQgIT09IG5pbCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kIC09IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlX2xlbmd0aCArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX3N0YXJ0ID49IDAgJiYgcmFuZ2VfZW5kIDwgc2VsZi5sZW5ndGggJiYgcmFuZ2VfZW5kID49IDAgJiYgcmFuZ2VfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2UocmFuZ2Vfc3RhcnQsIHJhbmdlX2xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGZbc3RhcnRdO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBzZWxmLnNoaWZ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3BsaWNlKHN0YXJ0LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgbGVuZ3RoID0gYCRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgJXh7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgICByZXN1bHQgPSAje3NlbGZbc3RhcnQsIGxlbmd0aF19O1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCArIGxlbmd0aCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IHNlbGYubGVuZ3RoICYmIHN0YXJ0ID49IDApIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgc29ydCgmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgdW5sZXNzIGBzZWxmLmxlbmd0aCA+IDFgXG5cbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGJsb2NrID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiAje2BhYCA8PT4gYGJgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJldCA9IGJsb2NrKHgsIHkpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IG5pbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgeGAuaW5zcGVjdH0gd2l0aCAje2B5YC5pbnNwZWN0fSBmYWlsZWRcIn07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI3tgcmV0YCA+IDB9ID8gMSA6ICgje2ByZXRgIDwgMH0gPyAtMSA6IDApO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydCEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICByZXN1bHQgPSAje2BzZWxmLnNsaWNlKClgLnNvcnQoJmJsb2NrKX07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0fTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5sZW5ndGggPSAwO1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucHVzaChyZXN1bHRbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzb3J0X2J5ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgcmVwbGFjZSBzb3J0X2J5KCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRha2UoY291bnQpXG4gICAgJXh7XG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRha2Vfd2hpbGUoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW0sIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgdmFsdWUgPSBibG9jayhpdGVtKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5BcnJheS4kbmV3KHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2FyeVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX2goJmJsb2NrKVxuICAgIGFycmF5ID0gc2VsZlxuICAgIGFycmF5ID0gYXJyYXkubWFwKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW4gPSBhcnJheS5sZW5ndGgsIGFyeSwga2V5LCB2YWwsIGhhc2ggPSAje3t9fTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFyeSA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYGFycmF5W2ldYCwgOjpBcnJheSwgOnRvX2FyeSl9O1xuICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBlbGVtZW50IHR5cGUgI3tgYXJ5YC5jbGFzc30gYXQgI3tgaWB9IChleHBlY3RlZCBhcnJheSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJ5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIGFycmF5IGxlbmd0aCBhdCAje2BpYH0gKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zcG9zZVxuICAgIHJldHVybiBbXSBpZiBlbXB0eT9cblxuICAgIHJlc3VsdCA9IFtdXG4gICAgbWF4ICAgID0gbmlsXG5cbiAgICBlYWNoIGRvIHxyb3d8XG4gICAgICByb3cgPSBpZiA6OkFycmF5ID09PSByb3dcbiAgICAgICAgICAgICAgcm93LnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ocm93LCAjezo6QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgICBtYXggfHw9IGByb3cubGVuZ3RoYFxuXG4gICAgICBpZiBgcm93Lmxlbmd0aGAgIT0gbWF4XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJlbGVtZW50IHNpemUgZGlmZmVycyAoI3tgcm93Lmxlbmd0aGB9IHNob3VsZCBiZSAje21heH0pXCJcbiAgICAgIGVuZFxuXG4gICAgICBgcm93Lmxlbmd0aGAudGltZXMgZG8gfGl8XG4gICAgICAgIGVudHJ5ID0gKHJlc3VsdFtpXSB8fD0gW10pXG4gICAgICAgIGVudHJ5IDw8IHJvdy5hdChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIHVuaW9uKCphcnJheXMpXG4gICAgYXJyYXlzLnJlZHVjZSh1bmlxKSB7IHxhLCBifCBhIHwgYiB9XG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbSwga2V5O1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBpdGVtKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwgaXRlbSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGtleSA9ICR5aWVsZDEoYmxvY2ssIGl0ZW0pO1xuICAgICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YGhhc2hgLnZhbHVlc307XG4gICAgfVxuICBlbmRcblxuICBkZWYgdW5pcSEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsX2xlbmd0aCA9IHNlbGYubGVuZ3RoLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbSwga2V5O1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvcmlnaW5hbF9sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAga2V5ID0gKGJsb2NrID09PSBuaWwgPyBpdGVtIDogJHlpZWxkMShibG9jaywgaXRlbSkpO1xuXG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgaXRlbSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbF9sZW5ndGggPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVuc2hpZnQoKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICB2YXIgc2VsZkxlbmd0aCA9IHNlbGYubGVuZ3RoXG4gICAgICB2YXIgb2JqZWN0c0xlbmd0aCA9IG9iamVjdHMubGVuZ3RoXG4gICAgICBpZiAob2JqZWN0c0xlbmd0aCA9PSAwKSByZXR1cm4gc2VsZjtcbiAgICAgIHZhciBpbmRleCA9IHNlbGZMZW5ndGggLSBvYmplY3RzTGVuZ3RoXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHNMZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2goc2VsZltpbmRleCArIGldKVxuICAgICAgfVxuICAgICAgdmFyIGxlbiA9IHNlbGZMZW5ndGggLSAxXG4gICAgICB3aGlsZSAobGVuIC0gb2JqZWN0c0xlbmd0aCA+PSAwKSB7XG4gICAgICAgIHNlbGZbbGVuXSA9IHNlbGZbbGVuIC0gb2JqZWN0c0xlbmd0aF1cbiAgICAgICAgbGVuLS1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0c0xlbmd0aDsgaisrKSB7XG4gICAgICAgIHNlbGZbal0gPSBvYmplY3RzW2pdXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgb3V0ID0gW11cblxuICAgIGFyZ3MuZWFjaCBkbyB8ZWxlbXxcbiAgICAgIGlmIGVsZW0uaXNfYT8gOjpSYW5nZVxuICAgICAgICBmaW5pc2ggPSBgI3tlbGVtLmVuZH0gPT09IG5pbCA/IC0xIDogJGNvZXJjZV90bygje2VsZW0uZW5kfSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHN0YXJ0ID0gYCN7ZWxlbS5iZWdpbn0gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKCN7ZWxlbS5iZWdpbn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyBzZWxmLmxlbmd0aDtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKGZpbmlzaCA8IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCA9IGZpbmlzaCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tlbGVtLmV4Y2x1ZGVfZW5kP30gJiYgI3tlbGVtLmVuZH0gIT09IG5pbCkge1xuICAgICAgICAgICAgZmluaXNoLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaW5pc2ggPCBzdGFydCkge1xuICAgICAgICAgICAgI3tuZXh0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydC51cHRvKGZpbmlzaCkgeyB8aXwgb3V0IDw8IGF0KGkpIH1cbiAgICAgIGVsc2VcbiAgICAgICAgaSA9IGAkY29lcmNlX3RvKGVsZW0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICBvdXQgPDwgYXQoaSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgb3V0XG4gIGVuZFxuXG4gIGRlZiB6aXAoKm90aGVycywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBzaXplID0gc2VsZi5sZW5ndGgsIHBhcnQsIG8sIGksIGosIGpqO1xuXG4gICAgICBmb3IgKGogPSAwLCBqaiA9IG90aGVycy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIG8gPSBvdGhlcnNbal07XG4gICAgICAgIGlmIChvLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby4kJGlzX3JhbmdlIHx8IG8uJCRpc19lbnVtZXJhdG9yKSB7XG4gICAgICAgICAgb3RoZXJzW2pdID0gby4kdGFrZShzaXplKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcnNbal0gPSAjeyhcbiAgICAgICAgICA6Ok9wYWwuY29lcmNlX3RvPyhgb2AsIDo6QXJyYXksIDp0b19hcnkpIHx8XG4gICAgICAgICAgOjpPcGFsLmNvZXJjZV90byEoYG9gLCA6OkVudW1lcmF0b3IsIDp0b19lbnVtLCA6ZWFjaClcbiAgICAgICAgKS50b19hfTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBwYXJ0ID0gW3NlbGZbaV1dO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICBvID0gb3RoZXJzW2pdW2ldO1xuXG4gICAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0W2ogKyAxXSA9IG87XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbaV0gPSBwYXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHJlc3VsdFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5oZXJpdGVkKGtsYXNzKVxuICAgICV4e1xuICAgICAga2xhc3MuJCRwcm90b3R5cGUuJHRvX2EgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIHN1cGVyLnJlamVjdCB7IHxpdmFyfCBgL15AXFxkKyQvLnRlc3QoI3tpdmFyfSlgIHx8IGl2YXIgPT0gJ0BsZW5ndGgnIH1cbiAgZW5kXG5cbiAgZGVmIHBhY2soKmFyZ3MpXG4gICAgOjpLZXJuZWwucmFpc2UgXCJUbyB1c2UgQXJyYXkjcGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9hcnJheS9wYWNrJy5cIlxuICBlbmRcblxuICBhbGlhcyBhcHBlbmQgcHVzaFxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuICBhbGlhcyBtYXAgY29sbGVjdFxuICBhbGlhcyBtYXAhIGNvbGxlY3QhXG4gIGFsaWFzIHByZXBlbmQgdW5zaGlmdFxuICBhbGlhcyBzaXplIGxlbmd0aFxuICBhbGlhcyBzbGljZSBbXVxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICA6Ok9wYWwucHJpc3RpbmUgc2luZ2xldG9uX2NsYXNzLCA6YWxsb2NhdGVcbiAgOjpPcGFsLnByaXN0aW5lIHNlbGYsIDpjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcywgOmluaXRpYWxpemVfZHVwXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6QXJyYXk+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJ0b19hIiwiW10iLCJpbml0aWFsaXplIiwic2l6ZSIsIm9iaiIsIktlcm5lbCIsIndhcm4iLCJJbnRlZ2VyOjpNQVgiLCJJbnRlZ2VyIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwicmVwbGFjZSIsInJlc3BvbmRfdG8/IiwidG9fYXJ5IiwidHJ5X2NvbnZlcnQiLCJPcGFsIiwiY29lcmNlX3RvPyIsIkFycmF5IiwiJiIsIm90aGVyIiwifCIsIioiLCJqb2luIiwidG9fc3RyIiwiKyIsIi0iLCI8PCIsIm9iamVjdCIsIjw9PiIsImhhc2giLCI9PSIsIm9iamVjdF9pZCIsImluZGV4IiwibGVuZ3RoIiwiW109IiwidmFsdWUiLCJleHRyYSIsIlJhbmdlIiwiZGF0YSIsIlJhbmdlRXJyb3IiLCJpbnNwZWN0IiwiMSIsIkluZGV4RXJyb3IiLCJhbnk/IiwicGF0dGVybiIsImFzc29jIiwiYXQiLCJic2VhcmNoX2luZGV4IiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJUeXBlRXJyb3IiLCJjbGFzcyIsImJzZWFyY2giLCJibG9jayIsInRvX3Byb2MiLCJjeWNsZSIsIm4iLCJibG9jayBpbiBjeWNsZSIsImJsb2NrICgyIGxldmVscykgaW4gY3ljbGUiLCJuaWw/IiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJjb2VyY2VfdG8hIiwiPiIsIjAiLCJlbnVtZXJhdG9yX3NpemUiLCJlbXB0eT8iLCJjbGVhciIsImNvdW50IiwiaW5pdGlhbGl6ZV9jb3B5IiwiY29sbGVjdCIsImJsb2NrIGluIGNvbGxlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QiLCJjb2xsZWN0ISIsImJsb2NrIGluIGNvbGxlY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0ISIsImNvbWJpbmF0aW9uIiwibnVtIiwiYmxvY2sgaW4gY29tYmluYXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbWJpbmF0aW9uIiwicmVwZWF0ZWRfY29tYmluYXRpb24iLCJibG9jayBpbiByZXBlYXRlZF9jb21iaW5hdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcmVwZWF0ZWRfY29tYmluYXRpb24iLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb25jYXQiLCJvdGhlcnMiLCJtYXAiLCJibG9jayBpbiBjb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbmNhdCIsImVxdWFsPyIsImR1cCIsImVhY2giLCJkZWxldGUiLCJkZWxldGVfYXQiLCJkZWxldGVfaWYiLCJibG9jayBpbiBkZWxldGVfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZV9pZiIsImRpZmZlcmVuY2UiLCJyZWR1Y2UiLCJhcnJheXMiLCJibG9jayBpbiBkaWZmZXJlbmNlIiwiYSIsImIiLCJibG9jayAoMiBsZXZlbHMpIGluIGRpZmZlcmVuY2UiLCJkaWciLCJpZHgiLCJpdGVtIiwiaWR4cyIsImRyb3AiLCJudW1iZXIiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9pbmRleCIsImJsb2NrIGluIGVhY2hfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfaW5kZXgiLCJlcWw/IiwiZmV0Y2giLCJkZWZhdWx0cyIsImZpbGwiLCJhcmdzIiwib25lIiwidHdvIiwibGVmdCIsInJpZ2h0IiwiZXhjbHVkZV9lbmQ/IiwiZmlyc3QiLCJmbGF0dGVuIiwibGV2ZWwiLCJmbGF0dGVuISIsImluY2x1ZGU/IiwibWVtYmVyIiwiaW5zZXJ0IiwiX19pZF9fIiwiaW50ZXJzZWN0aW9uIiwiYmxvY2sgaW4gaW50ZXJzZWN0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3Q/IiwiISIsInNlcCIsIiQsIiwidG9fcyIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJTdHJpbmciLCJrZWVwX2lmIiwiYmxvY2sgaW4ga2VlcF9pZiIsImJsb2NrICgyIGxldmVscykgaW4ga2VlcF9pZiIsImxhc3QiLCJtYXgiLCJtaW4iLCJwZXJtdXRhdGlvbiIsImJsb2NrIGluIHBlcm11dGF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwZXJtdXRhdGlvbiIsInBlcm0iLCJ1c2VkIiwicmVwZWF0ZWRfcGVybXV0YXRpb24iLCJibG9jayBpbiByZXBlYXRlZF9wZXJtdXRhdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcmVwZWF0ZWRfcGVybXV0YXRpb24iLCI+PSIsIioqIiwicG9wIiwicHJvZHVjdCIsInB1c2giLCJyYXNzb2MiLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInJlamVjdCEiLCJibG9jayBpbiByZWplY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QhIiwib3JpZ2luYWwiLCJyZXZlcnNlIiwicmV2ZXJzZSEiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXZlcnNlX2VhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHJldmVyc2VfZWFjaCIsInJpbmRleCIsInJvdGF0ZSIsInJvdGF0ZSEiLCJjbnQiLCJhcnkiLCI8Y2xhc3M6c2VsZjo6U2FtcGxlUmFuZG9tPiIsInJuZyIsIkBybmciLCJyYW5kIiwicmFuZG9tIiwic2FtcGxlIiwib3B0aW9ucyIsIm8iLCJIYXNoIiwiU2FtcGxlUmFuZG9tIiwic2VsZWN0IiwiYmxvY2sgaW4gc2VsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QiLCJzZWxlY3QhIiwiYmxvY2sgaW4gc2VsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0ISIsInNoaWZ0Iiwic2h1ZmZsZSIsInNodWZmbGUhIiwic2xpY2UhIiwicmVzdWx0IiwicmFuZ2UiLCJyYW5nZV9zdGFydCIsInJhbmdlX2VuZCIsInN0YXJ0Iiwic29ydCIsIjwiLCJzb3J0ISIsInNvcnRfYnkhIiwiYmxvY2sgaW4gc29ydF9ieSEiLCJibG9jayAoMiBsZXZlbHMpIGluIHNvcnRfYnkhIiwic29ydF9ieSIsInRha2UiLCJ0YWtlX3doaWxlIiwidG9faCIsImFycmF5IiwidHJhbnNwb3NlIiwiYmxvY2sgaW4gdHJhbnNwb3NlIiwicm93IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc3Bvc2UiLCIkcmV0X29yXzEiLCJ0aW1lcyIsImkiLCJibG9jayAoMyBsZXZlbHMpIGluIHRyYW5zcG9zZSIsImVudHJ5IiwiJHdyaXRlciIsInVuaW9uIiwidW5pcSIsImJsb2NrIGluIHVuaW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB1bmlvbiIsInZhbHVlcyIsInVuaXEhIiwidW5zaGlmdCIsInZhbHVlc19hdCIsIm91dCIsImJsb2NrIGluIHZhbHVlc19hdCIsImVsZW0iLCJibG9jayAoMiBsZXZlbHMpIGluIHZhbHVlc19hdCIsImlzX2E/IiwiZmluaXNoIiwiZW5kIiwiYmVnaW4iLCJ1cHRvIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiB2YWx1ZXNfYXQiLCJ6aXAiLCJFbnVtZXJhdG9yIiwiaW5oZXJpdGVkIiwia2xhc3MiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJibG9jayBpbiBpbnN0YW5jZV92YXJpYWJsZXMiLCJpdmFyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnN0YW5jZV92YXJpYWJsZXMiLCJwYWNrIiwicHJpc3RpbmUiLCJzaW5nbGV0b25fY2xhc3MiXSwibWFwcGluZ3MiOiJBQUFBQSxnREFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDtJQUdDRDs7QUFHSEE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSwwQ0FBNENBLENBQUNBLEdBQURBLENBQUtHLE1BQUFBLENBQUFBLENBQU1IO0FBQ3ZEQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FB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TSxJQUFBLFFBQUEvQixDQUFBQSxZQUFDK0IsY0FBZ0JELElBQUtDLENBQXRCL0IsQ0FBQSxDQUFBO1VBQUErQixPQUFBO1FBQUE7VUFBNEJBLE9BQUFELElBQUs5TixPQUFBQSxDQUFHK04sU0FBSC9OO1FBQWpDLEVBQXRCNk4sQ0FBQUEsR0FBS3RGO0lBRFBxRixDQUFBQSxHQUFBQTs7QUFJQUksSUFBQUEsb0JBQUFBLGdCQXo0RUYsRUF5NEVFQTtBQUFBQSxNQUFBQTs7OztNQXo0RUY7O01BeTRFVztNQUNQQSxPQUFBelAsT0FBUUksT0FBQUEsQ0FBT3FQLGlFQUFQclA7SUFEVnFQLENBQUFBLElBQUFBO0lBSUEsYUFBTSxRQUFOLEVBQWEsTUFBYjtJQUNBLGFBQU0sUUFBTixFQUFhLFFBQWI7SUFDQSxhQUFNLFNBQU4sRUFBYyxTQUFkO0lBQ0EsYUFBTSxLQUFOLEVBQVUsU0FBVjtJQUNBLGFBQU0sTUFBTixFQUFXLFVBQVg7SUFDQSxhQUFNLFNBQU4sRUFBYyxTQUFkO0lBQ0EsYUFBTSxNQUFOLEVBQVcsUUFBWDtJQUNBLGFBQU0sT0FBTixFQUFZLElBQVo7SUFDQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0lBRUEvTyxLQUFNZ1AsVUFBQUEsQ0FBVXBRLElBQUFxUSxpQkFBQUEsQ0FBQUEsQ0FBaEIsRUFBaUMsVUFBM0JEO0lBQ05sUSxPQUFBa0IsS0FBTWdQLFVBQUFBLENBQVVwUSxJQUFoQixFQUFzQix5QkFBdEIsRUFBZ0QsZ0JBQTFDb1E7RUFuNUVSbFEsR0FBTSxJQUFOQSxFQUFpQkgsS0FBakJHO0FBTEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNTcwMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvaGFzaC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHlpZWxkMSwgaGFzaCwgaGFzaF9pbml0LCBoYXNoX2dldCwgaGFzaF9wdXQsIGhhc2hfZGVsZXRlXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuIyAtLS1cbiMgSW50ZXJuYWwgcHJvcGVydGllczpcbiNcbiMgLSAkJG1hcCAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBvcmRpbmFyeSBrZXlzXG4jIC0gJCRzbWFwICAgICAgICBbSlM6Ok9iamVjdDxTdHJpbmcgPT4gaGFzaC1idWNrZXQ+XSB0aGUgaGFzaCB0YWJsZSBmb3Igc3RyaW5nIGtleXNcbiMgLSAkJGtleXMgICAgICAgIFtBcnJheTxoYXNoLWJ1Y2tldD5dIHRoZSBsaXN0IG9mIGFsbCBrZXlzXG4jIC0gJCRwcm9jICAgICAgICBbUHJvYyxudWxsLG5pbF0gdGhlIGRlZmF1bHQgcHJvYyB1c2VkIGZvciBtaXNzaW5nIGtleXNcbiMgLSBoYXNoLWJ1Y2tldCAgIFtKUzo6T2JqZWN0XSBhbiBlbGVtZW50IG9mIGEgbGlua2VkIGxpc3QgdGhhdCBob2xkcyBoYXNoIHZhbHVlcywga2V5cyBhcmUgYHtrZXk6LGtleV9oYXNoOix2YWx1ZTosbmV4dDp9YFxuY2xhc3MgOjpIYXNoXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgIyBNYXJrIGFsbCBoYXNoIGluc3RhbmNlcyBhcyB2YWxpZCBoYXNoZXMgKHVzZWQgdG8gY2hlY2sga2V5d29yZCBhcmdzLCBldGMpXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfaGFzaCA9IHRydWVgXG5cbiAgZGVmIHNlbGYuW10oKmFyZ3YpXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCwgYXJnYyA9IGFyZ3YubGVuZ3RoLCBpO1xuXG4gICAgICBpZiAoYXJnYyA9PT0gMSkge1xuICAgICAgICBoYXNoID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhhcmd2WzBdLCA6Okhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIGlmIChoYXNoICE9PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gI3thbGxvY2F0ZS5tZXJnZSEoYGhhc2hgKX07XG4gICAgICAgIH1cblxuICAgICAgICBhcmd2ID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhhcmd2WzBdLCA6OkFycmF5LCA6dG9fYXJ5KX07XG4gICAgICAgIGlmIChhcmd2ID09PSBuaWwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcbiAgICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWFyZ3ZbaV0uJCRpc19hcnJheSkgY29udGludWU7XG4gICAgICAgICAgc3dpdGNoKGFyZ3ZbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXVswXSwgbmlsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIGFyZ3ZbaV1bMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgbnVtYmVyIG9mIGVsZW1lbnRzICgje2Bhcmd2W2ldLmxlbmd0aGB9IGZvciAxLi4yKVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJnYyAlIDIgIT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaCd9XG4gICAgICB9XG5cbiAgICAgIGhhc2ggPSAje2FsbG9jYXRlfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkgKz0gMikge1xuICAgICAgICBoYXNoLiRzdG9yZShhcmd2W2ldLCBhcmd2W2kgKyAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuXG4gICAgICAkaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgICBoYXNoLiQkbm9uZSA9IG5pbDtcbiAgICAgIGhhc2guJCRwcm9jID0gbmlsO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyhvYmosIDo6SGFzaCwgOnRvX2hhc2gpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMCknfVxuICAgICAgfVxuICAgICAgc2VsZi4kJG5vbmUgPSAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCA/IG5pbCA6IGRlZmF1bHRzKTtcbiAgICAgIHNlbGYuJCRwcm9jID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggIT09IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9ICRoYXNoX2dldChvdGhlciwga2V5LmtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3RoZXJfdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhdmFsdWVbJyRlcWw/J10ob3RoZXJfdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIG90aGVyID0gOjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPCBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRydWVcblxuICAgIG90aGVyLmVhY2ggZG8gfG90aGVyX2tleSwgb3RoZXJfdmFsfFxuICAgICAgdmFsID0gZmV0Y2gob3RoZXJfa2V5LCBgbnVsbGApXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsICE9PSBvdGhlcl92YWwpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoIDw9IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZiA+PSBvdGhlclxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxuICAgIG90aGVyID4gc2VsZlxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+PSBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXShrZXkpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSAkaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGVmYXVsdChrZXkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShrZXksIHZhbHVlKVxuICAgICV4e1xuICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICBpZiAoI3tga2V5YCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgc2VsZi4kJHNtYXBba2V5XV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgje2BrZXkua2V5YCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleS5rZXksIGtleS52YWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICAleHtcbiAgICAgICRoYXNoX2luaXQoc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNsYXNzKCk7XG5cbiAgICAgICRoYXNoX2luaXQoaGFzaCk7XG4gICAgICBPcGFsLmhhc2hfY2xvbmUoc2VsZiwgaGFzaCk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3RcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIGlmICgkaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzX3dlcmVfbWFkZSA9IHRydWU7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZXNfd2VyZV9tYWRlID8gc2VsZiA6IG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYXJlX2J5X2lkZW50aXR5XG4gICAgJXh7XG4gICAgICB2YXIgaSwgaWksIGtleSwga2V5cyA9IHNlbGYuJCRrZXlzLCBpZGVudGl0eV9oYXNoO1xuXG4gICAgICBpZiAoc2VsZi4kJGJ5X2lkZW50aXR5KSByZXR1cm4gc2VsZjtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJGJ5X2lkZW50aXR5ID0gdHJ1ZVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWRlbnRpdHlfaGFzaCA9ICN7IHt9LmNvbXBhcmVfYnlfaWRlbnRpdHkgfTtcbiAgICAgIGZvcihpID0gMCwgaWkgPSBrZXlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFrZXkuJCRpc19zdHJpbmcpIGtleSA9IGtleS5rZXk7XG4gICAgICAgICRoYXNoX3B1dChpZGVudGl0eV9oYXNoLCBrZXksICRoYXNoX2dldChzZWxmLCBrZXkpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kJGJ5X2lkZW50aXR5ID0gdHJ1ZTtcbiAgICAgIHNlbGYuJCRtYXAgPSBpZGVudGl0eV9oYXNoLiQkbWFwO1xuICAgICAgc2VsZi4kJHNtYXAgPSBpZGVudGl0eV9oYXNoLiQkc21hcDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHk/XG4gICAgYHNlbGYuJCRieV9pZGVudGl0eSA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQoa2V5ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmIHNlbGYuJCRwcm9jICE9PSBuaWwgJiYgc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2MuJGNhbGwoc2VsZiwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLiQkbm9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJG5vbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdD0ob2JqZWN0KVxuICAgICV4e1xuICAgICAgc2VsZi4kJHByb2MgPSBuaWw7XG4gICAgICBzZWxmLiQkbm9uZSA9IG9iamVjdDtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0X3Byb2NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkcHJvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkcHJvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jPShkZWZhdWx0X3Byb2MpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvYyA9IGRlZmF1bHRfcHJvYztcblxuICAgICAgaWYgKHByb2MgIT09IG5pbCkge1xuICAgICAgICBwcm9jID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgcHJvY2AsIDo6UHJvYywgOnRvX3Byb2MpfTtcblxuICAgICAgICBpZiAoI3tgcHJvY2AubGFtYmRhP30gJiYgI3tgcHJvY2AuYXJpdHkuYWJzfSAhPT0gMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdkZWZhdWx0X3Byb2MgdGFrZXMgdHdvIGFyZ3VtZW50cyd9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRub25lID0gbmlsO1xuICAgICAgc2VsZi4kJHByb2MgPSBwcm9jO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdF9wcm9jO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShrZXksICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9ICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAje3lpZWxkIGtleX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmRlbGV0ZV9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkaWcoa2V5LCAqa2V5cylcbiAgICBpdGVtID0gc2VsZltrZXldXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICAkeWllbGQxKGJsb2NrLCBba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2tleSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2tleSkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGJsb2NrKGtleS4kJGlzX3N0cmluZyA/IGtleSA6IGtleS5rZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX3ZhbHVlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfdmFsdWUpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBzZWxmLiQkc21hcFtrZXldIDoga2V5LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdCgqa2V5cylcbiAgICBkdXAuZXhjZXB0ISgqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdCEoKmtleXMpXG4gICAga2V5cy5lYWNoIHsgfGtleXwgZGVsZXRlKGtleSkgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZldGNoKGtleSwgZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhrZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpLZXlFcnJvci5uZXcoXCJrZXkgbm90IGZvdW5kOiAje2tleS5pbnNwZWN0fVwiLCBrZXk6IGtleSwgcmVjZWl2ZXI6IHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBmZXRjaF92YWx1ZXMoKmtleXMsICZibG9jaylcbiAgICBrZXlzLm1hcCB7IHxrZXl8IGZldGNoKGtleSwgJmJsb2NrKSB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gMSlcbiAgICBsZXZlbCA9IDo6T3BhbC5jb2VyY2VfdG8hKGxldmVsLCA6OkludGVnZXIsIDp0b19pbnQpXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoI3tgdmFsdWVgLmZsYXR0ZW4oYGxldmVsIC0gMmApfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzX2tleT8oa2V5KVxuICAgIGAkaGFzaF9nZXQoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkYFxuICBlbmRcblxuICBkZWYgaGFzX3ZhbHVlPyh2YWx1ZSlcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmICgje2Aoa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSlgID09IHZhbHVlfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKE9wYWwuaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnSGFzaCddLFxuICAgICAgICAgIGtleSwgaXRlbTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9wYWxbaGFzaF9pZF0pIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gT3BhbC5oYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSBPcGFsLmhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHNlbGYuJCRzbWFwW2tleV0uJGhhc2goKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LmtleV9oYXNoLCBrZXkudmFsdWUuJGhhc2goKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuc29ydCgpLmpvaW4oKTtcblxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4ZXMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGFyZ3NbaV07XG4gICAgICAgIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje2RlZmF1bHR9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGB2YXIgaW5zcGVjdF9pZHNgXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoaW5zcGVjdF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIH1cblxuICAgIGJlZ2luXG4gICAgICAleHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIGluc3BlY3RfaWRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zcGVjdF9pZHMuaGFzT3duUHJvcGVydHkoaGFzaF9pZCkpIHtcbiAgICAgICAgICByZXR1cm4gJ3suLi59JztcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3BlY3RfaWRzW2hhc2hfaWRdID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleSA9ICN7T3BhbC5pbnNwZWN0KGBrZXlgKX1cbiAgICAgICAgICB2YWx1ZSA9ICN7T3BhbC5pbnNwZWN0KGB2YWx1ZWApfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5ICsgJz0+JyArIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAneycgKyByZXN1bHQuam9pbignLCAnKSArICd9JztcbiAgICAgIH1cbiAgICAgIG5pbFxuICAgIGVuc3VyZVxuICAgICAgYGlmICh0b3ApIGluc3BlY3RfaWRzID0gdW5kZWZpbmVkYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW52ZXJ0XG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICRoYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgdmFsdWUsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZXlzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleS5rZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIG1lcmdlKCpvdGhlcnMsICZibG9jaylcbiAgICBkdXAubWVyZ2UhKCpvdGhlcnMsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1lcmdlISgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgaiwgb3RoZXIsIG90aGVyX2tleXMsIGxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG90aGVyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgb3RoZXJzW2ldYCwgOjpIYXNoLCA6dG9faGFzaCl9O1xuICAgICAgICBvdGhlcl9rZXlzID0gb3RoZXIuJCRrZXlzLCBsZW5ndGggPSBvdGhlcl9rZXlzLmxlbmd0aDtcblxuICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAga2V5ID0gb3RoZXJfa2V5c1tqXTtcblxuICAgICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IG90aGVyLiQkc21hcFtrZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2pdO1xuXG4gICAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSAkaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgb3RoZXJfdmFsdWUpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgYmxvY2soa2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVoYXNoXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfcmVoYXNoKHNlbGYpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGNoYW5nZXNfd2VyZV9tYWRlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXNfd2VyZV9tYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlc193ZXJlX21hZGUgPyBzZWxmIDogbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcblxuICAgICV4e1xuICAgICAgJGhhc2hfaW5pdChzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvdGhlcl92YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IG90aGVyX2tleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBvdGhlci5kZWZhdWx0X3Byb2NcbiAgICAgIHNlbGYuZGVmYXVsdF9wcm9jID0gb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgZWxzZVxuICAgICAgc2VsZi5kZWZhdWx0ID0gb3RoZXIuZGVmYXVsdFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5pbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaGlmdFxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBzZWxmLiQka2V5cyxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBrZXkgPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5O1xuXG4gICAgICAgIHJldHVybiBba2V5LCAkaGFzaF9kZWxldGUoc2VsZiwga2V5KV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRkZWZhdWx0KG5pbCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2xpY2UoKmtleXMpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAkaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2ggaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuSGFzaCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG5cbiAgICAgICRoYXNoX2luaXQoaGFzaCk7XG4gICAgICBPcGFsLmhhc2hfY2xvbmUoc2VsZiwgaGFzaCk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2hhc2hcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgcHJvYyBkbyB8a2V5ID0gdW5kZWZpbmVkfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8ga2V5IGdpdmVuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmW2tleV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV9rZXlzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV9rZXlzKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICRoYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSAkeWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgICRoYXNoX3B1dChyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV9rZXlzISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fa2V5cyEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIga2V5cyA9IE9wYWwuc2xpY2UuY2FsbChzZWxmLiQka2V5cyksXG4gICAgICAgICAgaSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG5ld19rZXk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld19rZXkgPSAkeWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuICAgICAgICAkaGFzaF9wdXQoc2VsZiwgbmV3X2tleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fdmFsdWVzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV92YWx1ZXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICRoYXNoX3B1dChyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV92YWx1ZXMhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdmFsdWVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmLiQkc21hcFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBkdXAgY2xvbmVcbiAgYWxpYXMgZWFjaF9wYWlyIGVhY2hcbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuICBhbGlhcyBpbmNsdWRlPyBoYXNfa2V5P1xuICBhbGlhcyBpbmRpY2VzIGluZGV4ZXNcbiAgYWxpYXMga2V5IGluZGV4XG4gIGFsaWFzIGtleT8gaGFzX2tleT9cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuICBhbGlhcyBzaXplIGxlbmd0aFxuICBhbGlhcyBzdG9yZSBbXT1cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG4gIGFsaWFzIHVwZGF0ZSBtZXJnZSFcbiAgYWxpYXMgdmFsdWU/IGhhc192YWx1ZT9cbiAgYWxpYXMgdmFsdWVzX2F0IGluZGV4ZXNcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpIYXNoPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiW10iLCJPcGFsIiwiY29lcmNlX3RvPyIsImFyZ3YiLCIwIiwiSGFzaCIsImFsbG9jYXRlIiwibWVyZ2UhIiwiQXJyYXkiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0cnlfY29udmVydCIsIm9iaiIsImluaXRpYWxpemUiLCJkZWZhdWx0cyIsIj09Iiwib3RoZXIiLCI+PSIsImNvZXJjZV90byEiLCJyZXN1bHQiLCJlYWNoIiwiYmxvY2sgaW4gPj0iLCJvdGhlcl9rZXkiLCJvdGhlcl92YWwiLCJibG9jayAoMiBsZXZlbHMpIGluID49IiwidmFsIiwiZmV0Y2giLCI+IiwiPCIsIjw9Iiwia2V5IiwiW109IiwidmFsdWUiLCJhc3NvYyIsIm9iamVjdCIsImNsZWFyIiwiY2xvbmUiLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCJkZWZhdWx0IiwiZGVmYXVsdD0iLCJkZWZhdWx0X3Byb2MiLCJkZWZhdWx0X3Byb2M9IiwiUHJvYyIsImxhbWJkYT8iLCJhcml0eSIsImFicyIsIlR5cGVFcnJvciIsImRlbGV0ZSIsImRlbGV0ZV9pZiIsImJsb2NrIiwiZW51bV9mb3IiLCJibG9jayBpbiBkZWxldGVfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZV9pZiIsInNpemUiLCJkaWciLCJpdGVtIiwicmVzcG9uZF90bz8iLCJjbGFzcyIsImtleXMiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9rZXkiLCJibG9jayBpbiBlYWNoX2tleSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9rZXkiLCJlYWNoX3ZhbHVlIiwiYmxvY2sgaW4gZWFjaF92YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF92YWx1ZSIsImVtcHR5PyIsImV4Y2VwdCIsImV4Y2VwdCEiLCJkdXAiLCJibG9jayBpbiBleGNlcHQhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBleGNlcHQhIiwiS2V5RXJyb3IiLCJuZXciLCJpbnNwZWN0IiwiZmV0Y2hfdmFsdWVzIiwibWFwIiwiYmxvY2sgaW4gZmV0Y2hfdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmZXRjaF92YWx1ZXMiLCJ0b19wcm9jIiwiZmxhdHRlbiIsImxldmVsIiwiMSIsIkludGVnZXIiLCJoYXNfa2V5PyIsImhhc192YWx1ZT8iLCJoYXNoIiwiZXFsPyIsImluZGV4IiwiaW5kZXhlcyIsImludmVydCIsImtlZXBfaWYiLCJibG9jayBpbiBrZWVwX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBrZWVwX2lmIiwibGVuZ3RoIiwibWVyZ2UiLCJvdGhlcnMiLCJyYXNzb2MiLCJyZWhhc2giLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInJlamVjdCEiLCJibG9jayBpbiByZWplY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QhIiwicmVwbGFjZSIsIiR3cml0ZXIiLCItIiwic2VsZWN0IiwiYmxvY2sgaW4gc2VsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QiLCJzZWxlY3QhIiwiYmxvY2sgaW4gc2VsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0ISIsInNoaWZ0Iiwic2xpY2UiLCJ0b19hIiwidG9faCIsImJsb2NrX2dpdmVuPyIsInRvX2hhc2giLCJwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInRyYW5zZm9ybV9rZXlzIiwiYmxvY2sgaW4gdHJhbnNmb3JtX2tleXMiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV9rZXlzIiwidHJhbnNmb3JtX2tleXMhIiwiYmxvY2sgaW4gdHJhbnNmb3JtX2tleXMhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fa2V5cyEiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwiYmxvY2sgaW4gdHJhbnNmb3JtX3ZhbHVlcyIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX3ZhbHVlcyIsInRyYW5zZm9ybV92YWx1ZXMhIiwiYmxvY2sgaW4gdHJhbnNmb3JtX3ZhbHVlcyEiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV92YWx1ZXMhIiwidmFsdWVzIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBVUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDtJQUdDRDtJQUVERyxNQUFJTCxJQUFKSyxTQUFBQSxvQkFsQkYsRUFrQkVBO0FBQUFBLE1BQUFBOzs7O01BbEJGOztNQWtCYzs7QUFFZEE7O0FBRUFBO0FBQ0FBLGVBQWlCQyxLQUFNQyxlQUFBQSxDQUFZQyxJQUFJSCxPQUFBQSxD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LElBQUE4RCxNQUFBQSxDQUFBQSxDQUEvQmlGLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBcEY7TUFBUDs7QUFHSm1GO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQXBCRUEsQ0FBQUEsR0FBQUE7O0FBdUJBRyxJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFmRUEsQ0FBQUEsR0FBQUE7SUFrQkEsYUFBTSxLQUFOLEVBQVUsT0FBVjtJQUNBLGFBQU0sV0FBTixFQUFnQixNQUFoQjtJQUNBLGFBQU0sTUFBTixFQUFXLElBQVg7SUFDQSxhQUFNLFFBQU4sRUFBYSxRQUFiO0lBQ0EsYUFBTSxTQUFOLEVBQWMsU0FBZDtJQUNBLGFBQU0sVUFBTixFQUFlLFVBQWY7SUFDQSxhQUFNLFNBQU4sRUFBYyxTQUFkO0lBQ0EsYUFBTSxLQUFOLEVBQVUsT0FBVjtJQUNBLGFBQU0sTUFBTixFQUFXLFVBQVg7SUFDQSxhQUFNLFNBQU4sRUFBYyxVQUFkO0lBQ0EsYUFBTSxNQUFOLEVBQVcsUUFBWDtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsUUFBYjtJQUNBLGFBQU0sUUFBTixFQUFhLFlBQWI7SUFDQS9JLE9BQUEsYUFBTSxXQUFOLEVBQWdCLFNBQWhCO0VBMXFDRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQVpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTcxOTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL251bWJlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIDo6TnVtYmVyIDwgOjpOdW1lcmljXG4gIDo6T3BhbC5icmlkZ2UoYE51bWJlcmAsIHNlbGYpXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbnVtYmVyJywgdHJ1ZSlgXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlciA9PT0gbmlsKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje290aGVyLmNsYXNzfSBpbnRvIEZsb2F0XCJ9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFsjezo6S2VybmVsLkZsb2F0KG90aGVyKX0sIHNlbGZdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyg6dG9fZil9KSB7XG4gICAgICAgIHJldHVybiBbI3s6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpGbG9hdCwgOnRvX2YpfSwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gW290aGVyLCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tvdGhlci5jbGFzc30gaW50byBGbG9hdFwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBfX2lkX19cbiAgICBgKHNlbGYgKiAyKSArIDFgXG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmICsgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOissIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIC0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOi0sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmICogb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiosIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIC8gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOi8sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAlKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPT0gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyIDwgMCB8fCBzZWxmIDwgMCkge1xuICAgICAgICAgIHJldHVybiAoc2VsZiAlIG90aGVyICsgb3RoZXIpICUgb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYgJSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDolLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAmIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDomLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiB8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDp8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiBeIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDpeLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPD0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjw9LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA+IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPj0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOj49LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICAjIENvbXB1dGUgdGhlIHJlc3VsdCBvZiB0aGUgc3BhY2VzaGlwIG9wZXJhdG9yIGluc2lkZSBpdHMgb3duIGZ1bmN0aW9uIHNvIGl0XG4gICMgY2FuIGJlIG9wdGltaXplZCBkZXNwaXRlIGEgdHJ5L2ZpbmFsbHkgY29uc3RydWN0LlxuICAleHtcbiAgICB2YXIgc3BhY2VzaGlwX29wZXJhdG9yID0gZnVuY3Rpb24oc2VsZiwgb3RoZXIpIHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoaXNOYU4oc2VsZikgfHwgaXNOYU4ob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmID4gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmIDwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PD0+LCBgb3RoZXJgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGBzcGFjZXNoaXBfb3BlcmF0b3Ioc2VsZiwgb3RoZXIpYFxuICByZXNjdWUgOjpBcmd1bWVudEVycm9yXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiA8PChjb3VudClcbiAgICBjb3VudCA9IDo6T3BhbC5jb2VyY2VfdG8hIGNvdW50LCA6OkludGVnZXIsIDp0b19pbnRcblxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmIDw8ICN7Y291bnR9IDogc2VsZiA+PiAtI3tjb3VudH1gXG4gIGVuZFxuXG4gIGRlZiA+Pihjb3VudClcbiAgICBjb3VudCA9IDo6T3BhbC5jb2VyY2VfdG8hIGNvdW50LCA6OkludGVnZXIsIDp0b19pbnRcblxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmID4+ICN7Y291bnR9IDogc2VsZiA8PCAtI3tjb3VudH1gXG4gIGVuZFxuXG4gIGRlZiBbXShiaXQpXG4gICAgYml0ID0gOjpPcGFsLmNvZXJjZV90byEgYml0LCA6OkludGVnZXIsIDp0b19pbnRcblxuICAgICV4e1xuICAgICAgaWYgKCN7Yml0fSA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoI3tiaXR9ID49IDMyKSB7XG4gICAgICAgIHJldHVybiAjeyBzZWxmIH0gPCAwID8gMSA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHNlbGYgPj4gI3tiaXR9KSAmIDE7XG4gICAgfVxuICBlbmRcblxuICBkZWYgK0BcbiAgICBgK3NlbGZgXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIGAtc2VsZmBcbiAgZW5kXG5cbiAgZGVmIH5cbiAgICBgfnNlbGZgXG4gIGVuZFxuXG4gIGRlZiAqKihvdGhlcilcbiAgICBpZiA6OkludGVnZXIgPT09IG90aGVyXG4gICAgICBpZiAhKDo6SW50ZWdlciA9PT0gc2VsZikgfHwgb3RoZXIgPiAwXG4gICAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgICBlbHNlXG4gICAgICAgIDo6UmF0aW9uYWwubmV3KHNlbGYsIDEpKipvdGhlclxuICAgICAgZW5kXG4gICAgZWxzaWYgc2VsZiA8IDAgJiYgKDo6RmxvYXQgPT09IG90aGVyIHx8IDo6UmF0aW9uYWwgPT09IG90aGVyKVxuICAgICAgOjpDb21wbGV4Lm5ldyhzZWxmLCAwKSoqb3RoZXIudG9fZlxuICAgIGVsc2lmIGBvdGhlci4kJGlzX251bWJlciAhPSBudWxsYFxuICAgICAgYE1hdGgucG93KHNlbGYsIG90aGVyKWBcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/IDo9PX0pIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyA6PT19KSB7XG4gICAgICAgIHJldHVybiAje290aGVyID09IHNlbGZ9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICBgTWF0aC5hYnMoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgYE1hdGguYWJzKHNlbGYgKiBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFsbGJpdHM/KG1hc2spXG4gICAgbWFzayA9IDo6T3BhbC5jb2VyY2VfdG8hIG1hc2ssIDo6SW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IG1hc2tgXG4gIGVuZFxuXG4gIGRlZiBhbnliaXRzPyhtYXNrKVxuICAgIG1hc2sgPSA6Ok9wYWwuY29lcmNlX3RvISBtYXNrLCA6OkludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSAhPT0gMGBcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgcmV0dXJuIHNlbGYgaWYgbmFuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgIGlmICgxIC8gc2VsZiA+IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZiA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYml0X2xlbmd0aFxuICAgIHVubGVzcyA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBiaXRfbGVuZ3RoYCBmb3IgI3tzZWxmfTpGbG9hdFwiLCAnYml0X2xlbmd0aCcpXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSAwIHx8IHNlbGYgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICB2YWx1ZSAgPSBzZWxmIDwgMCA/IH5zZWxmIDogc2VsZjtcblxuICAgICAgd2hpbGUgKHZhbHVlICE9IDApIHtcbiAgICAgICAgcmVzdWx0ICAgKz0gMTtcbiAgICAgICAgdmFsdWUgID4+Pj0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZWlsKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IE1hdGguY2VpbChmICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaHIoZW5jb2RpbmcgPSB1bmRlZmluZWQpXG4gICAgYE9wYWwuZW5jKFN0cmluZy5mcm9tQ2hhckNvZGUoc2VsZiksIGVuY29kaW5nIHx8IFwiQklOQVJZXCIpYFxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgMVxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkb3dudG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZG93bnRvLCBzdG9wKSBkb1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIiB1bmxlc3MgOjpOdW1lcmljID09PSBzdG9wXG4gICAgICAgIHN0b3AgPiBzZWxmID8gMCA6IHNlbGYgLSBzdG9wICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghc3RvcC4kJGlzX251bWJlcikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwifVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHNlbGY7IGkgPj0gc3RvcDsgaS0tKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBzZWxmID09IG90aGVyIHx8IGBpc05hTihzZWxmKSAmJiBpc05hTihvdGhlcilgXG4gIGVuZFxuXG4gIGRlZiBldmVuP1xuICAgIGBzZWxmICUgMiA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGZsb29yKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IE1hdGguZmxvb3IoZiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2NkKG90aGVyKVxuICAgIHVubGVzcyA6OkludGVnZXIgPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vdCBhbiBpbnRlZ2VyJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gTWF0aC5hYnMoc2VsZiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMob3RoZXIpO1xuXG4gICAgICB3aGlsZSAobWluID4gMCkge1xuICAgICAgICB2YXIgdG1wID0gbWluO1xuXG4gICAgICAgIG1pbiA9IG1heCAlIG1pbjtcbiAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZGxjbShvdGhlcilcbiAgICBbZ2NkKG90aGVyKSwgbGNtKG90aGVyKV1cbiAgZW5kXG5cbiAgZGVmIGludGVnZXI/XG4gICAgYHNlbGYgJSAxID09PSAwYFxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6SW50ZWdlciAmJiA6OkludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkZsb2F0ICYmIDo6RmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6SW50ZWdlciAmJiA6OkludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkZsb2F0ICYmIDo6RmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBsY20ob3RoZXIpXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGFuIGludGVnZXInXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDAgfHwgb3RoZXIgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2VsZiAqIG90aGVyIC8gI3tnY2Qob3RoZXIpfSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgIGBzZWxmICsgMWBcbiAgZW5kXG5cbiAgZGVmIG5vYml0cz8obWFzaylcbiAgICBtYXNrID0gOjpPcGFsLmNvZXJjZV90byEgbWFzaywgOjpJbnRlZ2VyLCA6dG9faW50XG4gICAgYChzZWxmICYgbWFzaykgPT0gMGBcbiAgZW5kXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgYHNlbGYgPT0gMCA/IG5pbCA6IHNlbGZgXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBvZGQ/XG4gICAgYHNlbGYgJSAyICE9PSAwYFxuICBlbmRcblxuICBkZWYgb3JkXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG93KGIsIG0gPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICN7c2VsZioqYn07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISgjezo6SW50ZWdlciA9PT0gYn0pKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMm5kIGFyZ3VtZW50IG5vdCBhbGxvd2VkIHVubGVzcyBhIDFzdCBhcmd1bWVudCBpcyBpbnRlZ2VyJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDFzdCBhcmd1bWVudCBjYW5ub3QgYmUgbmVnYXRpdmUgd2hlbiAybmQgYXJndW1lbnQgc3BlY2lmaWVkJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKCN7OjpJbnRlZ2VyID09PSBtfSkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAybmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGFsbCBhcmd1bWVudHMgYXJlIGludGVnZXJzJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID09PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAjeyhzZWxmKipiKSAlIG19XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJlZFxuICAgIGBzZWxmIC0gMWBcbiAgZW5kXG5cbiAgZGVmIHF1byhvdGhlcilcbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIHN1cGVyXG4gICAgZWxzZVxuICAgICAgc2VsZiAvIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIDo6UmF0aW9uYWwubmV3KHNlbGYsIDEpXG4gICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICBlbHNpZiBuYW4/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgZWxzaWYgYGVwcyA9PSBudWxsYFxuICAgICAgZiwgbiAgPSA6Ok1hdGguZnJleHAgc2VsZlxuICAgICAgZiAgICAgPSA6Ok1hdGgubGRleHAoZiwgOjpGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIG4gICAgLT0gOjpGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgOjpSYXRpb25hbC5uZXcoMiAqIGYsIDEgPDwgKDEgLSBuKSkucmF0aW9uYWxpemUoOjpSYXRpb25hbC5uZXcoMSwgMSA8PCAoMSAtIG4pKSlcbiAgICBlbHNlXG4gICAgICB0b19yLnJhdGlvbmFsaXplKGVwcylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlbWFpbmRlcih5KVxuICAgIHNlbGYgLSB5ICogKHNlbGYgLyB5KS50cnVuY2F0ZVxuICBlbmRcblxuICBkZWYgcm91bmQobmRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIGlmIGBuZGlnaXRzID09IG51bGxgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgOjpGbG9hdCA9PT0gbmRpZ2l0cyAmJiBuZGlnaXRzLmluZmluaXRlP1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdJbmZpbml0eSdcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gOjpPcGFsLmNvZXJjZV90byEobmRpZ2l0cywgOjpJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDwgOjpJbnRlZ2VyOjpNSU5cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnb3V0IG9mIGJvdW5kcydcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbmRpZ2l0cyA+PSAwYFxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSAtbmRpZ2l0c1xuXG4gICAgICAleHtcbiAgICAgICAgaWYgKDAuNDE1MjQxICogbmRpZ2l0cyAtIDAuMTI1ID4gI3tzaXplfSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoTWF0aC5hYnMoc2VsZikgKyBmIC8gMikgLyBmKSAqIGY7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYgPCAwID8gLXggOiB4O1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGlmIG5hbj8gJiYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSA6Ok9wYWwuY29lcmNlX3RvIShgbmRpZ2l0cyB8fCAwYCwgOjpJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDw9IDBcbiAgICAgICAgaWYgbmFuP1xuICAgICAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ05hTidcbiAgICAgICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgbmRpZ2l0cyA9PSAwXG4gICAgICAgIHJldHVybiBgTWF0aC5yb3VuZChzZWxmKWBcbiAgICAgIGVsc2lmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgXywgZXhwID0gOjpNYXRoLmZyZXhwKHNlbGYpXG5cbiAgICAgIGlmIG5kaWdpdHMgPj0gKDo6RmxvYXQ6OkRJRyArIDIpIC0gKGV4cCA+IDAgPyBleHAgLyA0IDogZXhwIC8gMyAtIDEpXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgbmRpZ2l0cyA8IC0oZXhwID4gMCA/IGV4cCAvIDMgKyAxIDogZXhwIC8gNClcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIGVuZFxuXG4gICAgICBgTWF0aC5yb3VuZChzZWxmICogTWF0aC5wb3coMTAsIG5kaWdpdHMpKSAvIE1hdGgucG93KDEwLCBuZGlnaXRzKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRpbWVzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRpbWVzKSB7IHNlbGYgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICBgc2VsZiA8IDAgPyBNYXRoLmNlaWwoc2VsZikgOiBNYXRoLmZsb29yKHNlbGYpYFxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIGlmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgOjpSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNlXG4gICAgICBmLCBlICA9IDo6TWF0aC5mcmV4cChzZWxmKVxuICAgICAgZiAgICAgPSA6Ok1hdGgubGRleHAoZiwgOjpGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIGUgICAgLT0gOjpGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgKGYgKiAoOjpGbG9hdDo6UkFESVgqKmUpKS50b19yXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19zKGJhc2UgPSAxMClcbiAgICBiYXNlID0gOjpPcGFsLmNvZXJjZV90byEgYmFzZSwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBiYXNlIDwgMiB8fCBiYXNlID4gMzZcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIlxuICAgIGVuZFxuXG4gICAgIyBEb24ndCBsb3NlIHRoZSBuZWdhdGl2ZSB6ZXJvXG4gICAgaWYgc2VsZiA9PSAwICYmIGAxL3NlbGYgPT09IC1JbmZpbml0eWBcbiAgICAgIHJldHVybiAnLTAuMCdcbiAgICBlbmRcblxuICAgIGBzZWxmLnRvU3RyaW5nKGJhc2UpYFxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoZiAqIGZhY3RvciwgMTApIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpZ2l0cyhiYXNlID0gMTApXG4gICAgaWYgc2VsZiA8IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TWF0aDo6RG9tYWluRXJyb3IsICdvdXQgb2YgZG9tYWluJ1xuICAgIGVuZFxuXG4gICAgYmFzZSA9IDo6T3BhbC5jb2VyY2VfdG8hIGJhc2UsIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiAhPSBwYXJzZUludChzZWxmKSkgI3s6Oktlcm5lbC5yYWlzZSA6Ok5vTWV0aG9kRXJyb3IsIFwidW5kZWZpbmVkIG1ldGhvZCBgZGlnaXRzJyBmb3IgI3tpbnNwZWN0fVwifVxuXG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLCByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKHNlbGYgPT0gMCkge1xuICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodmFsdWUgIT0gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSAlIGJhc2UpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlIC8gYmFzZSwgMTApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpdm1vZChvdGhlcilcbiAgICBpZiBuYW4/IHx8IG90aGVyLm5hbj9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnVwdG8sIHN0b3ApIGRvXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwiIHVubGVzcyA6Ok51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA8IHNlbGYgPyAwIDogc3RvcCAtIHNlbGYgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgemVybz9cbiAgICBgc2VsZiA9PSAwYFxuICBlbmRcblxuICAjIFNpbmNlIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgMzIgYml0LCBkZWNsYXJlIGl0IHRvIGJlIHNvLlxuICBkZWYgc2l6ZVxuICAgIDRcbiAgZW5kXG5cbiAgZGVmIG5hbj9cbiAgICBgaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgYHNlbGYgIT0gSW5maW5pdHkgJiYgc2VsZiAhPSAtSW5maW5pdHkgJiYgIWlzTmFOKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gKzE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBgc2VsZiAhPSAwICYmIChzZWxmID09IEluZmluaXR5IHx8IDEgLyBzZWxmID4gMClgXG4gIGVuZFxuXG4gIGRlZiBuZWdhdGl2ZT9cbiAgICBgc2VsZiA9PSAtSW5maW5pdHkgfHwgMSAvIHNlbGYgPCAwYFxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBmZGl2IC9cbiAgYWxpYXMgaW5zcGVjdCB0b19zXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcbiAgYWxpYXMgbW9kdWxvICVcbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuICBhbGlhcyBwaGFzZSBhbmdsZVxuICBhbGlhcyBzdWNjIG5leHRcbiAgYWxpYXMgdG9faW50IHRvX2lcbmVuZFxuXG46OkZpeG51bSA9IDo6TnVtYmVyXG5cbmNsYXNzIDo6SW50ZWdlciA8IDo6TnVtZXJpY1xuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG4gIGBzZWxmLiQkaXNfaW50ZWdlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG5cbiAgICBkZWYgc3FydChuKVxuICAgICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICAgICV4e1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TWF0aDo6RG9tYWluRXJyb3IsICdOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFwiaXNxcnRcIid9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoTWF0aC5zcXJ0KG4pLCAxMCk7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgdHJ5X2NvbnZlcnQob2JqZWN0KVxuICAgICAgT3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgc2VsZiwgOnRvX2ludClcbiAgICBlbmRcbiAgZW5kXG5cbiAgc2VsZjo6TUFYID0gYE1hdGgucG93KDIsIDMwKSAtIDFgXG4gIHNlbGY6Ok1JTiA9IGAtTWF0aC5wb3coMiwgMzApYFxuZW5kXG5cbmNsYXNzIDo6RmxvYXQgPCA6Ok51bWVyaWNcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuXG4gICAgZGVmID09PShvdGhlcilcbiAgICAgIGAhIW90aGVyLiQkaXNfbnVtYmVyYFxuICAgIGVuZFxuICBlbmRcblxuICBzZWxmOjpJTkZJTklUWSA9IGBJbmZpbml0eWBcbiAgc2VsZjo6TUFYICAgICAgPSBgTnVtYmVyLk1BWF9WQUxVRWBcbiAgc2VsZjo6TUlOICAgICAgPSBgTnVtYmVyLk1JTl9WQUxVRWBcbiAgc2VsZjo6TkFOICAgICAgPSBgTmFOYFxuXG4gIHNlbGY6OkRJRyAgICAgID0gMTVcbiAgc2VsZjo6TUFOVF9ESUcgPSA1M1xuICBzZWxmOjpSQURJWCAgICA9IDJcblxuICBzZWxmOjpFUFNJTE9OID0gYE51bWJlci5FUFNJTE9OIHx8IDIuMjIwNDQ2MDQ5MjUwMzEzMDgwODQ3MjYzMzM2MTgxNkUtMTZgXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6TnVtYmVyPiIsIk9wYWwiLCJicmlkZ2UiLCJhbGxvY2F0ZSIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwibmFtZSIsImNvZXJjZSIsIm90aGVyIiwiY2xhc3MiLCJGbG9hdCIsInJlc3BvbmRfdG8/IiwiY29lcmNlX3RvISIsIl9faWRfXyIsIisiLCJfX2NvZXJjZWRfXyIsIi0iLCIqIiwiLyIsIiUiLCJaZXJvRGl2aXNpb25FcnJvciIsIiYiLCJ8IiwiXiIsIjwiLCI8PSIsIj4iLCI+PSIsIjw9PiIsIkFyZ3VtZW50RXJyb3IiLCI8PCIsImNvdW50IiwiSW50ZWdlciIsIj4+IiwiW10iLCJiaXQiLCIrQCIsIi1AIiwifiIsIioqIiwiPT09IiwiMCIsIlJhdGlvbmFsIiwibmV3IiwiMSIsIkNvbXBsZXgiLCJ0b19mIiwiPT0iLCJhYnMiLCJhYnMyIiwiYWxsYml0cz8iLCJtYXNrIiwiYW55Yml0cz8iLCJhbmdsZSIsIm5hbj8iLCJiaXRfbGVuZ3RoIiwiTm9NZXRob2RFcnJvciIsImNlaWwiLCJuZGlnaXRzIiwiY2hyIiwiZW5jb2RpbmciLCJkZW5vbWluYXRvciIsImluZmluaXRlPyIsImRvd250byIsInN0b3AiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImJsb2NrIGluIGRvd250byIsImJsb2NrICgyIGxldmVscykgaW4gZG93bnRvIiwiTnVtZXJpYyIsImVxdWFsPyIsIiRyZXRfb3JfMSIsImV2ZW4/IiwiZmxvb3IiLCJnY2QiLCJnY2RsY20iLCJsY20iLCJpbnRlZ2VyPyIsImlzX2E/Iiwia2xhc3MiLCJpbnN0YW5jZV9vZj8iLCJuZXh0Iiwibm9iaXRzPyIsIm5vbnplcm8/IiwibnVtZXJhdG9yIiwib2RkPyIsIm9yZCIsInBvdyIsImIiLCJtIiwicHJlZCIsInF1byIsInJhdGlvbmFsaXplIiwiZXBzIiwiRmxvYXREb21haW5FcnJvciIsIk1hdGgiLCJmcmV4cCIsImYiLCJuIiwibGRleHAiLCJGbG9hdDo6TUFOVF9ESUciLCJ0b19pIiwiMiIsInRvX3IiLCJyZW1haW5kZXIiLCJ5IiwidHJ1bmNhdGUiLCJyb3VuZCIsIlJhbmdlRXJyb3IiLCJJbnRlZ2VyOjpNSU4iLCJzaXplIiwiXyIsImV4cCIsIkZsb2F0OjpESUciLCI0IiwiMyIsInRpbWVzIiwiYmxvY2siLCJibG9jayBpbiB0aW1lcyIsImJsb2NrICgyIGxldmVscykgaW4gdGltZXMiLCJlIiwiRmxvYXQ6OlJBRElYIiwidG9fcyIsImJhc2UiLCIxMCIsIjM2IiwiZGlnaXRzIiwiTWF0aDo6RG9tYWluRXJyb3IiLCJpbnNwZWN0IiwiZGl2bW9kIiwidXB0byIsImJsb2NrIGluIHVwdG8iLCJibG9jayAoMiBsZXZlbHMpIGluIHVwdG8iLCJ6ZXJvPyIsImZpbml0ZT8iLCJwb3NpdGl2ZT8iLCJuZWdhdGl2ZT8iLCJOdW1iZXIiLCI8Y2xhc3M6SW50ZWdlcj4iLCJzcXJ0IiwidHJ5X2NvbnZlcnQiLCJvYmplY3QiLCJjb2VyY2VfdG8/IiwiPGNsYXNzOkZsb2F0PiIsIjE1IiwiNTMiXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsS0FBTUMsUUFBQUEsQ0FBU0YsTUFBZixFQUF3QkYsSUFBbEJJO0lBQ0xGO0lBQ0FBO0lBRUQ7Ozs7QUFDRUcsTUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNkJILDBCQUFELEdBQUEsQ0FBMkJMLElBQUFTLE1BQUFBLENBQUFBLENBQTNCLENBQXBCRjtNQURWRixDQUFBQSxHQUFBQTs7O01BSUEsc0JBQU0sS0FBTjtNQVpKLE9BQUE7SUFPRSw0QkFBU0wsSUFBVDs7QUFRQVUsSUFBQUEsc0JBQUFBLGtCQUFXQyxLQUFYRDtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBLFFBQVVKLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTZCRSxnQkFBRCxHQUFBLENBQWlCQyxLQUFLQyxPQUFBQSxDQUFBQSxDQUF0QixDQUFBLEdBQTZCRixhQUFqREgsQ0FBOERHO0FBQ2hGQTtBQUNBQTtBQUNBQSxnQkFBa0JKLE9BQVFPLE9BQUFBLENBQU9GLEtBQVBFLENBQWNIO0FBQ3hDQTtBQUNBQSxlQUFp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SUFDQUEsT0FBQSxXQUFBN0ksSUFBQSxTQUFhNkksZ0JBQWI7RUE1QkZBLEdBQU0sSUFBTkEsRUFBa0JyRSxjQUFsQnFFO0VBK0JBOUksT0FBQW1KO0VBQUFBOztJQUFBQTs7O0lBQ0dBO0lBRUQ7Ozs7QUFDRTdJLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTZCSCwwQkFBRCxHQUFBLENBQTJCTCxJQUFBUyxNQUFBQSxDQUFBQSxDQUEzQixDQUFwQkY7TUFEVkYsQ0FBQUEsR0FBQUE7O01BSUEsc0JBQU0sS0FBTjtNQUVBLE9BQUFzQyxtQkFBQUEsc0JBQVFoQyxLQUFSZ0M7QUFBQUE7UUFDRUEsT0FBQ0EsbUJBQURBO01BREZBLENBQUFBLEdBQUFBO0lBUEYsNEJBQVMzQyxJQUFUO0lBWUEsV0FBQUEsSUFBQSxjQUFrQmtKLFFBQWxCO0lBQ0EsV0FBQWxKLElBQUEsU0FBa0JrSixnQkFBbEI7SUFDQSxXQUFBbEosSUFBQSxTQUFrQmtKLGdCQUFsQjtJQUNBLFdBQUFsSixJQUFBLFNBQWtCa0osR0FBbEI7SUFFQSxXQUFBbEosSUFBQSxTQUFpQm1KLEVBQWpCO0lBQ0EsV0FBQW5KLElBQUEsY0FBaUJvSixFQUFqQjtJQUNBLFdBQUFwSixJQUFBLFdBQWlCeUcsQ0FBakI7SUFFQXlDLE9BQUEsV0FBQWxKLElBQUEsYUFBaUJrSix1REFBakI7RUF4QkZBLEdBQU0sSUFBTkEsRUFBZ0IxRSxjQUFoQjBFO0FBajJCQW5KOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODMxMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyA6OlJhbmdlXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19yYW5nZSA9IHRydWVgXG5cbiAgYXR0cl9yZWFkZXIgOmJlZ2luLCA6ZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZmlyc3QsIGxhc3QsIGV4Y2x1ZGUgPSBmYWxzZSlcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvciwgXCInaW5pdGlhbGl6ZScgY2FsbGVkIHR3aWNlXCIgaWYgQGJlZ2luXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYmFkIHZhbHVlIGZvciByYW5nZScgdW5sZXNzIGZpcnN0IDw9PiBsYXN0IHx8IGZpcnN0Lm5pbD8gfHwgbGFzdC5uaWw/XG5cbiAgICBAYmVnaW4gPSBmaXJzdFxuICAgIEBlbmQgICA9IGxhc3RcbiAgICBAZXhjbCAgPSBleGNsdWRlXG4gIGVuZFxuXG4gIGRlZiA9PT0odmFsdWUpXG4gICAgaW5jbHVkZT8gdmFsdWVcbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gaXNfaW5maW5pdGUoc2VsZikge1xuICAgICAgaWYgKHNlbGYuYmVnaW4gPT09IG5pbCB8fCBzZWxmLmVuZCA9PT0gbmlsIHx8XG4gICAgICAgICAgc2VsZi5iZWdpbiA9PT0gLUluZmluaXR5IHx8IHNlbGYuZW5kID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IEluZmluaXR5IHx8IHNlbGYuZW5kID09PSAtSW5maW5pdHkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBjb3VudCgmYmxvY2spXG4gICAgaWYgIWJsb2NrX2dpdmVuPyAmJiBgaXNfaW5maW5pdGUoc2VsZilgXG4gICAgICByZXR1cm4gOjpGbG9hdDo6SU5GSU5JVFlcbiAgICBlbmRcbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgZW5kbGVzcyByYW5nZSB0byBhbiBhcnJheScgaWYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBjb3Zlcj8odmFsdWUpXG4gICAgYmVnX2NtcCA9IChAYmVnaW4ubmlsPyAmJiAtMSkgfHwgKEBiZWdpbiA8PT4gdmFsdWUpIHx8IGZhbHNlXG4gICAgZW5kX2NtcCA9IChAZW5kLm5pbD8gJiYgLTEpIHx8ICh2YWx1ZSA8PT4gQGVuZCkgfHwgZmFsc2VcbiAgICBpZiBAZXhjbFxuICAgICAgZW5kX2NtcCAmJiBlbmRfY21wIDwgMFxuICAgIGVsc2VcbiAgICAgIGVuZF9jbXAgJiYgZW5kX2NtcCA8PSAwXG4gICAgZW5kICYmIGJlZ19jbXAgJiYgYmVnX2NtcCA8PSAwXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxpbWl0O1xuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfbnVtYmVyICYmICN7QGVuZH0uJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufSAlIDEgIT09IDAgfHwgI3tAZW5kfSAlIDEgIT09IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGl0ZXJhdGUgZnJvbSBGbG9hdFwifVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gI3tAYmVnaW59LCBsaW1pdCA9ICN7QGVuZH0gKyAje0BleGNsID8gMCA6IDF9OyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgICAgIGJsb2NrKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAje0BiZWdpbi51cHRvKEBlbmQsIEBleGNsLCAmYmxvY2spfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50ID0gQGJlZ2luXG4gICAgbGFzdCAgICA9IEBlbmRcblxuICAgIHVubGVzcyBjdXJyZW50LnJlc3BvbmRfdG8/KDpzdWNjKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgaXRlcmF0ZSBmcm9tICN7Y3VycmVudC5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgd2hpbGUgQGVuZC5uaWw/IHx8IChjdXJyZW50IDw9PiBsYXN0KSA8IDBcbiAgICAgIHlpZWxkIGN1cnJlbnRcblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQuc3VjY1xuICAgIGVuZFxuXG4gICAgeWllbGQgY3VycmVudCBpZiAhQGV4Y2wgJiYgY3VycmVudCA9PSBsYXN0XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgOjpSYW5nZSA9PT0gb3RoZXJcblxuICAgIEBleGNsID09PSBvdGhlci5leGNsdWRlX2VuZD8gJiZcbiAgICAgIEBiZWdpbi5lcWw/KG90aGVyLmJlZ2luKSAmJlxuICAgICAgQGVuZC5lcWw/KG90aGVyLmVuZClcbiAgZW5kXG5cbiAgZGVmIGV4Y2x1ZGVfZW5kP1xuICAgIEBleGNsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChuID0gdW5kZWZpbmVkKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1pbmltdW0gb2YgYmVnaW5sZXNzIHJhbmdlJyBpZiBAYmVnaW4ubmlsP1xuICAgIHJldHVybiBAYmVnaW4gaWYgYG4gPT0gbnVsbGBcbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgbGFzdChuID0gdW5kZWZpbmVkKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZScgaWYgQGVuZC5uaWw/XG4gICAgcmV0dXJuIEBlbmQgaWYgYG4gPT0gbnVsbGBcbiAgICB0b19hLmxhc3QobilcbiAgZW5kXG5cbiAgIyBGSVhNRTogY3VycmVudGx5IGhhcmRjb2RlZCB0byBhc3N1bWUgcmFuZ2UgaG9sZHMgbnVtZXJpY3NcbiAgZGVmIG1heFxuICAgIGlmIEBlbmQubmlsP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnY2Fubm90IGdldCB0aGUgbWF4aW11bSBvZiBlbmRsZXNzIHJhbmdlJ1xuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgc3VwZXJcbiAgICBlbHNpZiAhQGJlZ2luLm5pbD8gJiYgKEBiZWdpbiA+IEBlbmQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgYCN7QGV4Y2x9ID8gI3tAZW5kfSAtIDEgOiAje0BlbmR9YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWluXG4gICAgaWYgQGJlZ2luLm5pbD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1pbmltdW0gb2YgYmVnaW5sZXNzIHJhbmdlJ1xuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgc3VwZXJcbiAgICBlbHNpZiAhQGVuZC5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgQGV4Y2wgJiYgQGJlZ2luID09IEBlbmQpXG4gICAgICBuaWxcbiAgICBlbHNlXG4gICAgICBAYmVnaW5cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNpemVcbiAgICBpbmZpbml0eSA9IDo6RmxvYXQ6OklORklOSVRZXG5cbiAgICByZXR1cm4gMCBpZiAoQGJlZ2luID09IGluZmluaXR5ICYmICFAZW5kLm5pbD8pIHx8IChAZW5kID09IC1pbmZpbml0eSAmJiAhQGJlZ2luLm5pbD8pXG4gICAgcmV0dXJuIGluZmluaXR5IGlmIGBpc19pbmZpbml0ZShzZWxmKWBcbiAgICByZXR1cm4gbmlsIHVubGVzcyA6Ok51bWVyaWMgPT09IEBiZWdpbiAmJiA6Ok51bWVyaWMgPT09IEBlbmRcblxuICAgIHJhbmdlX2JlZ2luID0gQGJlZ2luXG4gICAgcmFuZ2VfZW5kICAgPSBAZW5kXG4gICAgcmFuZ2VfZW5kICAtPSAxIGlmIEBleGNsXG5cbiAgICByZXR1cm4gMCBpZiByYW5nZV9lbmQgPCByYW5nZV9iZWdpblxuXG4gICAgYE1hdGguYWJzKHJhbmdlX2VuZCAtIHJhbmdlX2JlZ2luKSArIDFgLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHN0ZXAobiA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIGNvZXJjZVN0ZXBTaXplKCkge1xuICAgICAgICBpZiAobiA9PSBudWxsKSB7XG4gICAgICAgICAgbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW4uJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBuID0gI3s6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSBuZWdhdGl2ZVwifVxuICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbnVtZXJhdG9yU2l6ZSgpIHtcbiAgICAgICAgaWYgKCEje0BiZWdpbi5yZXNwb25kX3RvPyg6c3VjYyl9KSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiAlIDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gI3soc2l6ZSAvIG4pLmNlaWx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG4gaXMgYSBmbG9hdFxuICAgICAgICAgIHZhciBiZWdpbiA9IHNlbGYuYmVnaW4sIGVuZCA9IHNlbGYuZW5kLFxuICAgICAgICAgICAgICBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKGJlZ2luKSArIGFicyhlbmQpICsgYWJzKGVuZCAtIGJlZ2luKSkgLyBhYnMobikgKiAjezo6RmxvYXQ6OkVQU0lMT059LFxuICAgICAgICAgICAgICBzaXplO1xuXG4gICAgICAgICAgaWYgKGVyciA+IDAuNSkge1xuICAgICAgICAgICAgZXJyID0gMC41O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLmV4Y2wpIHtcbiAgICAgICAgICAgIHNpemUgPSBmbG9vcigoZW5kIC0gYmVnaW4pIC8gbiAtIGVycik7XG4gICAgICAgICAgICBpZiAoc2l6ZSAqIG4gKyBiZWdpbiA8IGVuZCkge1xuICAgICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSBmbG9vcigoZW5kIC0gYmVnaW4pIC8gbiArIGVycikgKyAxXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICBpZiAoQGJlZ2luLmlzX2E/KE51bWVyaWMpIHx8IEBiZWdpbi5uaWw/KSAmJlxuICAgICAgICAgKEBlbmQuaXNfYT8oTnVtZXJpYykgfHwgQGVuZC5uaWw/KSAmJlxuICAgICAgICAgIShAYmVnaW4ubmlsPyAmJiBAZW5kLm5pbD8pXG5cbiAgICAgICAgcmV0dXJuIDo6RW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlLm5ldyhzZWxmLCBuLCA6c3RlcClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBuKSBkb1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgY29lcmNlU3RlcFNpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBlbnVtZXJhdG9yU2l6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGBjb2VyY2VTdGVwU2l6ZSgpYFxuXG4gICAgaWYgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXG4gICAgICBpID0gMFxuICAgICAgbG9vcCBkb1xuICAgICAgICBjdXJyZW50ID0gQGJlZ2luICsgaSAqIG5cbiAgICAgICAgaWYgQGV4Y2xcbiAgICAgICAgICBicmVhayBpZiBjdXJyZW50ID49IEBlbmRcbiAgICAgICAgZWxzaWYgY3VycmVudCA+IEBlbmRcbiAgICAgICAgICBicmVha1xuICAgICAgICBlbmRcbiAgICAgICAgeWllbGQoY3VycmVudClcbiAgICAgICAgaSArPSAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nICYmIG4gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gZmxvYXQgZnJvbSBzdHJpbmcnfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlYWNoX3dpdGhfaW5kZXggZG8gfHZhbHVlLCBpZHh8XG4gICAgICAgIHlpZWxkKHZhbHVlKSBpZiBpZHggJSBuID09IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmICUobilcbiAgICBpZiBAYmVnaW4uaXNfYT8oTnVtZXJpYykgJiYgQGVuZC5pc19hPyhOdW1lcmljKVxuICAgICAgOjpFbnVtZXJhdG9yOjpBcml0aG1ldGljU2VxdWVuY2UubmV3KHNlbGYsIG4sIDolKVxuICAgIGVsc2VcbiAgICAgIHN0ZXAobilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6YnNlYXJjaCkgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaWYgYGlzX2luZmluaXRlKHNlbGYpICYmIChzZWxmLmJlZ2luLiQkaXNfbnVtYmVyIHx8IHNlbGYuZW5kLiQkaXNfbnVtYmVyKWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvciwgXCJDYW4ndCAjYnNlYXJjaCBhbiBpbmZpbml0ZSByYW5nZVwiXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBkbyBiaW5hcnkgc2VhcmNoIGZvciAje0BiZWdpbi5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgdG9fYS5ic2VhcmNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QGJlZ2luIHx8ICcnfSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kIHx8ICcnfVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIje0BiZWdpbiAmJiBAYmVnaW4uaW5zcGVjdH0je0BleGNsID8gJy4uLicgOiAnLi4nfSN7QGVuZCAmJiBAZW5kLmluc3BlY3R9XCJcbiAgZW5kXG5cbiAgZGVmIG1hcnNoYWxfbG9hZChhcmdzKVxuICAgIEBiZWdpbiA9IGFyZ3NbOmJlZ2luXVxuICAgIEBlbmQgPSBhcmdzWzplbmRdXG4gICAgQGV4Y2wgPSBhcmdzWzpleGNsXVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFtAYmVnaW4sIEBlbmQsIEBleGNsXS5oYXNoXG4gIGVuZFxuXG4gIGFsaWFzID09IGVxbD9cbiAgYWxpYXMgaW5jbHVkZT8gY292ZXI/XG4gIGFsaWFzIG1lbWJlcj8gY292ZXI/XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UmFuZ2U+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJmaXJzdCIsImxhc3QiLCJleGNsdWRlIiwiQGJlZ2luIiwiS2VybmVsIiwicmFpc2UiLCJOYW1lRXJyb3IiLCI8PT4iLCJuaWw/IiwiQXJndW1lbnRFcnJvciIsIkBlbmQiLCJAZXhjbCIsIj09PSIsInZhbHVlIiwiaW5jbHVkZT8iLCJjb3VudCIsImJsb2NrX2dpdmVuPyIsIkZsb2F0OjpJTkZJTklUWSIsIkZsb2F0IiwidG9fYSIsIlR5cGVFcnJvciIsImNvdmVyPyIsImJlZ19jbXAiLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCItMSIsImVuZF9jbXAiLCI8IiwiMCIsIjw9IiwiZWFjaCIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsInNpemUiLCIxIiwidXB0byIsImJsb2NrIiwidG9fcHJvYyIsImN1cnJlbnQiLCJyZXNwb25kX3RvPyIsImNsYXNzIiwic3VjYyIsImVxbD8iLCJvdGhlciIsIlJhbmdlIiwiZXhjbHVkZV9lbmQ/IiwiYmVnaW4iLCJlbmQiLCJuIiwiUmFuZ2VFcnJvciIsIm1heCIsIj4iLCJtaW4iLCJpbmZpbml0eSIsIi1AIiwiTnVtZXJpYyIsInJhbmdlX2JlZ2luIiwicmFuZ2VfZW5kIiwiLSIsInRvX2kiLCJzdGVwIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiLyIsImNlaWwiLCJGbG9hdDo6RVBTSUxPTiIsImlzX2E/IiwiRW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlIiwiRW51bWVyYXRvciIsIm5ldyIsImJsb2NrIGluIHN0ZXAiLCJibG9jayAoMiBsZXZlbHMpIGluIHN0ZXAiLCJpIiwibG9vcCIsIisiLCIqIiwiPj0iLCJlYWNoX3dpdGhfaW5kZXgiLCJpZHgiLCIlIiwiYnNlYXJjaCIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ0b19zIiwiaW5zcGVjdCIsIm1hcnNoYWxfbG9hZCIsImFyZ3MiLCJbXSIsImhhc2giXSwibWFwcGluZ3MiOiJBQUFBQSxnREFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBRUNEO0lBRURGLElBQUFLLGFBQUFBLENBQVksT0FBWixFQUFvQixLQUFwQkE7O0FBRUFDLElBQUFBLDBCQUFBQSxzQkFBZUMsS0FBRCxFQUFRQyxJQUFSLEVBQWNDLE9BQTVCSDtBQUFBQSxNQUFBQTs7OztNQUE0QiwrQkFBVSxLQUFWO01BQzFCLElBQUEsUUFBMkRJLFVBQTNELENBQUE7UUFBQUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNEJQLDJCQUFwQk07TUFBUjtNQUNBLEtBQTZELENBQUEsQ0FBQSxRQUFBTCxLQUFNTyxRQUFBQSxDQUFJTixJQUFKTSxDQUFOLENBQUEsSUFBQSxDQUFBLFFBQWtCUCxLQUFLUSxTQUFBQSxDQUFBQSxDQUF2QixDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsUUFBZ0NQLElBQUlPLFNBQUFBLENBQUFBLENBQXBDLENBQUEsQ0FBQSxDQUE3RDtRQUFBSixPQUFRQyxPQUFBQSxDQUFPSSxvQkFBZixFQUFnQ1YscUJBQXhCTTtNQUFSO01BRUFGLGFBQVNIO01BQ1RVLFdBQVNUO01BQ1RGLE9BQUFZLENBQUFBLFlBQVNULE9BQVRTO0lBTkZaLENBQUFBLElBQUFBOztBQVNBYSxJQUFBQSxtQkFBQUEsNEJBQVFDLEtBQVJEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBbkIsSUFBQXFCLGFBQUFBLENBQVNELEtBQVRDO0lBREZGLENBQUFBLEdBQUFB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L0QsQ0FBQUEsWUFBQWIsUUFBQWEsQ0FBQSxDQUFBLEdBQUEsQ0FBUWIsUUFBSTRFLFNBQUFBLENBQUFBLENBQVosSUFBQSxDQUFBLFNBQUEsQ0FBQSxDQUFyRDtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsNEJBQUFBLHdCQUFpQkMsSUFBakJEO0FBQUFBLE1BQUFBOzs7TUFDRXBGLGFBQVNxRixJQUFJQyxPQUFBQSxDQUFDLE9BQURBO01BQ2IvRSxXQUFPOEUsSUFBSUMsT0FBQUEsQ0FBQyxLQUFEQTtNQUNYRixPQUFBNUUsQ0FBQUEsWUFBUTZFLElBQUlDLE9BQUFBLENBQUMsTUFBREEsQ0FBWjlFO0lBSEY0RSxDQUFBQSxHQUFBQTs7QUFNQUcsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxDQUFDdkYsVUFBRCxFQUFTTyxRQUFULEVBQWVDLFNBQWYsQ0FBcUIrRSxNQUFBQSxDQUFBQTtJQUR2QkEsQ0FBQUEsR0FBQUE7SUFJQSxhQUFNLElBQU4sRUFBUyxNQUFUO0lBQ0EsYUFBTSxVQUFOLEVBQWUsUUFBZjtJQUNBL0YsT0FBQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0VBMVNGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODcyMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlXG5cbmNsYXNzIDo6UHJvYyA8IGBGdW5jdGlvbmBcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19wcm9jJywgdHJ1ZSlgXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbGFtYmRhJywgZmFsc2UpYFxuXG4gIGRlZiBzZWxmLm5ldygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgYSBQcm9jIG9iamVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgZW5kXG5cbiAgICBibG9ja1xuICBlbmRcblxuICBkZWYgY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kJHAgPSBibG9jaztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCwgJGJyayA9IHNlbGYuJCRicms7XG5cbiAgICAgIGlmICgkYnJrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHNlbGYuJCRpc19sYW1iZGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyID09PSAkYnJrKSB7XG4gICAgICAgICAgICByZXR1cm4gJGJyay4kdlxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBPcGFsLnlpZWxkWChzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID4+KG90aGVyKVxuICAgIDo6S2VybmVsLnByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICBvdXQgPSBjYWxsKCphcmdzLCAmYmxvY2spXG4gICAgICBvdGhlci5jYWxsKG91dClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw8KG90aGVyKVxuICAgIDo6S2VybmVsLnByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICBvdXQgPSBvdGhlci5jYWxsKCphcmdzLCAmYmxvY2spXG4gICAgICBjYWxsKG91dClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsYW1iZGE/XG4gICAgIyBUaGlzIG1ldGhvZCBzaG91bGQgdGVsbCB0aGUgdXNlciBpZiB0aGUgcHJvYyB0cmlja3MgYXJlIHVuYXZhaWxhYmxlLFxuICAgICMgKHNlZSBQcm9jI2xhbWJkYT8gb24gcnVieSBkb2NzIHRvIGZpbmQgb3V0IG1vcmUpLlxuICAgIGAhIXNlbGYuJCRpc19sYW1iZGFgXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkYXJpdHk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc291cmNlX2xvY2F0aW9uXG4gICAgYGlmIChzZWxmLiQkaXNfY3VycmllZCkgeyByZXR1cm4gbmlsOyB9YFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgYmluZGluZ1xuICAgIGBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiQ2FuJ3QgY3JlYXRlIEJpbmRpbmdcIn0gfWBcblxuICAgIGlmIGRlZmluZWQ/IDo6QmluZGluZ1xuICAgICAgOjpCaW5kaW5nLm5ldyhuaWwsIFtdLCBgc2VsZi4kJHNgLCBzb3VyY2VfbG9jYXRpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBwYXJhbWV0ZXJzXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHtcbiAgICAgICAgcmV0dXJuICN7W1s6cmVzdF1dfTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi4kJHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKHNlbGYuJCRpc19sYW1iZGEpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJHBhcmFtZXRlcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLiQkcGFyYW1ldGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHNlbGYuJCRwYXJhbWV0ZXJzW2ldO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyWzBdID09PSAncmVxJykge1xuICAgICAgICAgICAgICAvLyByZXF1aXJlZCBhcmd1bWVudHMgYWx3YXlzIGhhdmUgbmFtZVxuICAgICAgICAgICAgICBwYXJhbWV0ZXIgPSBbJ29wdCcsIHBhcmFtZXRlclsxXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtZXRlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN1cnJ5KGFyaXR5ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXJpdHkgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhcml0eSA9ICN7OjpPcGFsLmNvZXJjZV90byEoYXJpdHksIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBhcml0eSAhPT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcml0eWB9IGZvciAje2BzZWxmLmxlbmd0aGB9KVwifVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGN1cnJpZWQgKCkge1xuICAgICAgICB2YXIgYXJncyA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgICBpZiAobGVuZ3RoID4gYXJpdHkgJiYgc2VsZi4kJGlzX2xhbWJkYSAmJiAhc2VsZi4kJGlzX2N1cnJpZWQpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2BsZW5ndGhgfSBmb3IgI3tgYXJpdHlgfSlcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPj0gYXJpdHkpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kY2FsbC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmllZC5hcHBseShudWxsLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoJHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC4kJGlzX2xhbWJkYSA9IHNlbGYuJCRpc19sYW1iZGE7XG4gICAgICAgIHJlc3VsdC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBjdXJyaWVkLiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgIGN1cnJpZWQuJCRpc19jdXJyaWVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjdXJyaWVkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsX3Byb2MgPSBzZWxmLiQkb3JpZ2luYWxfcHJvYyB8fCBzZWxmLFxuICAgICAgICAgIHByb2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxfcHJvYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIHByb2NbcHJvcF0gPSBzZWxmW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9jO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgPT09IGNhbGxcbiAgYWxpYXMgY2xvbmUgZHVwXG4gIGFsaWFzIHlpZWxkIGNhbGxcbiAgYWxpYXMgW10gY2FsbFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQcm9jPiIsIm5ldyIsInNlbGYiLCJibG9jayIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImNhbGwiLCI+PiIsIm90aGVyIiwicHJvYyIsImJsb2NrIGluID4+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA+PiIsIm91dCIsImFyZ3MiLCJ0b19wcm9jIiwiPDwiLCJibG9jayBpbiA8PCIsImJsb2NrICgyIGxldmVscykgaW4gPDwiLCJsYW1iZGE/IiwiYXJpdHkiLCJzb3VyY2VfbG9jYXRpb24iLCJiaW5kaW5nIiwiQmluZGluZyIsInBhcmFtZXRlcnMiLCJjdXJyeSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsImR1cCJdLCJtYXBwaW5ncyI6IkFBQUFBLCtDQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7Ozs7SUFDR0E7SUFDQUE7SUFFREMsTUFBSUMsSUFBSkQsVUFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0UsS0FBQSxRQUFPRSxLQUFQLENBQUE7UUFDRUMsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NMLCtDQUF4Qkk7TUFEVjtNQUlBSixPQUFBRTtJQUxGRixDQUFBQSxHQUFBQTs7QUFRQU0sSUFBQUEsb0JBQUFBLGdCQWRGLEVBY0VBO0FBQUFBLE1BQUFBOztNQUFBQTs7OztNQWRGOztNQWNXOztBQUVYQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQW5DRUEsQ0FBQUEsSUFBQUE7O0FBc0NBQyxJQUFBQSxrQkFBQUEsd0JBQU9DLEtBQVBEO0FBQUFBLE1BQUFBOztNQUFBQTtNQUNFQSxPQUFRRSxNQUFSTixPQUFRTSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFSQyxhQXJESixFQXFESUEsRUFBQUM7O1FBQUFBOzs7O1FBckRKOztRQXFEc0I7UUFDaEJDLE1BQU1OLE1BQUFMLElBQUFLLFFBQUFBLEVBQUssTUFBQ08sSUFBRCxDQUFMUCxFQUFhSixLQUFEWSxTQUFBQSxDQUFBQSxDQUFaUjtRQUNOSyxPQUFBSCxLQUFLRixNQUFBQSxDQUFNTSxHQUFOTixFQUZQSSxDQUFBQSxHQUFBQSxzQkFBQUEsQ0FBUUQ7SUFEVkYsQ0FBQUEsR0FBQUE7O0FBT0FRLElBQUFBLGtCQUFBQSx3QkFBT1AsS0FBUE87QUFBQUEsTUFBQUE7O01BQUFBO01BQ0VBLE9BQVFOLE1BQVJOLE9BQVFNLFFBQUFBLEVBQUFBLEVBQUFBLEVBQVJPLGFBNURKLEVBNERJQSxFQUFBQzs7UUFBQUE7Ozs7UUE1REo7O1FBNERzQjtRQUNoQkwsTUFBV04sTUFBTEUsS0FBS0YsUUFBQUEsRUFBTSxNQUFDTyxJQUFELENBQU5QLEVBQWNKLEtBQURZLFNBQUFBLENBQUFBLENBQWJSO1FBQ1hXLE9BQUFoQixJQUFBSyxNQUFBQSxDQUFLTSxHQUFMTixFQUZGVSxDQUFBQSxHQUFBQSxzQkFBQUEsQ0FBUVA7SUFEVk0sQ0FBQUEsR0FBQUE7O0FBT0FELElBQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFiO0lBREZhLENBQUFBLEdBQUFBOztBQUlBSSxJQUFBQSx1QkFBQUEsNkJBQUFBO0FBQUFBLE1BQUFBOztNQUdFQSxPQUFDQSxrQkFBREE7SUFIRkEsQ0FBQUEsR0FBQUE7O0FBTUFDLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVBFQSxDQUFBQSxHQUFBQTs7QUFVQUMsSUFBQUEsK0JBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0dBO01BQ0RBLE9BQUE7SUFGRkEsQ0FBQUEsR0FBQUE7O0FBS0FDLElBQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNHQSx5QkFBMkJsQixPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2dCLHNCQUF4QmpCLENBQStDaUI7TUFFbkYsSUFBQSxRQUFHLENBQUEseUNBQUEsb0JBQUgsQ0FBQTtRQUNFQSxPQUFBQyxjQUFTdEIsS0FBQUEsQ0FBSyxHQUFkLEVBQW1CLEVBQW5CLEVBQXdCcUIsUUFBeEIsRUFBbUNwQixJQUFBbUIsaUJBQUFBLENBQUFBLENBQTFCcEI7TUFEWDtRQTlGSnFCLE9BQUE7TUE4Rkk7SUFIRkEsQ0FBQUEsR0FBQUE7O0FBUUFFLElBQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxlQUFpQixDQUFDLENBQUMsTUFBRCxDQUFELENBQVVBO0FBQzNCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUExQkVBLENBQUFBLEdBQUFBOztBQTZCQUMsSUFBQUEscUJBQUFBLGlCQUFVTCxLQUFWSztBQUFBQSxNQUFBQTs7Ozs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsZ0JBQWtCQyxLQUFNQyxlQUFBQSxDQUFZUCxLQUFsQixFQUF5QlEsY0FBekIsRUFBb0MsUUFBOUJELENBQXVDRjtBQUMvREE7QUFDQUEsVUFBWXJCLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDbUIsNkJBQUQsR0FBQSxDQUErQkEsS0FBL0IsQ0FBQSxHQUFzQ0EsT0FBdEMsR0FBQSxDQUE4Q0EsV0FBOUMsQ0FBQSxHQUEyREEsR0FBbkZwQjtBQUNwQm9CO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsVUFBWXJCLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDbUIsNkJBQUQsR0FBQSxDQUErQkEsTUFBL0IsQ0FBQSxHQUF1Q0EsT0FBdkMsR0FBQSxDQUErQ0EsS0FBL0MsQ0FBQSxHQUFzREEsR0FBOUVwQjtBQUNwQm9COztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQXRDRUEsQ0FBQUEsSUFBQUE7O0FBeUNBSSxJQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBZEVBLENBQUFBLEdBQUFBO0lBaUJBLGFBQU0sS0FBTixFQUFVLE1BQVY7SUFDQSxhQUFNLE9BQU4sRUFBWSxLQUFaO0lBQ0EsYUFBTSxPQUFOLEVBQVksTUFBWjtJQUNBN0IsT0FBQSxhQUFNLElBQU4sRUFBUyxNQUFUO0VBM0xGQSxHQUFNLElBQU5BLEVBQWdCRCxRQUFoQkM7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4OTcwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tZXRob2QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpNZXRob2RcbiAgYXR0cl9yZWFkZXIgOm93bmVyLCA6cmVjZWl2ZXIsIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUocmVjZWl2ZXIsIG93bmVyLCBtZXRob2QsIG5hbWUpXG4gICAgQHJlY2VpdmVyID0gcmVjZWl2ZXJcbiAgICBAb3duZXIgICAgPSBvd25lclxuICAgIEBuYW1lICAgICA9IG5hbWVcbiAgICBAbWV0aG9kICAgPSBtZXRob2RcbiAgZW5kXG5cbiAgZGVmIGFyaXR5XG4gICAgQG1ldGhvZC5hcml0eVxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgIGAje0BtZXRob2R9LiQkcGFyYW1ldGVyc2BcbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGAje0BtZXRob2R9LiQkc291cmNlX2xvY2F0aW9uYCB8fCBbJyhldmFsKScsIDBdXG4gIGVuZFxuXG4gIGRlZiBjb21tZW50c1xuICAgIGAje0BtZXRob2R9LiQkY29tbWVudHNgIHx8IFtdXG4gIGVuZFxuXG4gIGRlZiBjYWxsKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAje0BtZXRob2R9LiQkcCA9IGJsb2NrO1xuXG4gICAgICByZXR1cm4gI3tAbWV0aG9kfS5hcHBseSgje0ByZWNlaXZlcn0sIGFyZ3MpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN1cnJ5KGFyaXR5ID0gdW5kZWZpbmVkKVxuICAgIEBtZXRob2QuY3VycnkoYXJpdHkpXG4gIGVuZFxuXG4gIGRlZiA+PihvdGhlcilcbiAgICBAbWV0aG9kID4+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PChvdGhlcilcbiAgICBAbWV0aG9kIDw8IG90aGVyXG4gIGVuZFxuXG4gIGRlZiB1bmJpbmRcbiAgICA6OlVuYm91bmRNZXRob2QubmV3KEByZWNlaXZlci5jbGFzcywgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSlcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICAleHtcbiAgICAgIHZhciBwcm9jID0gc2VsZi4kY2FsbC5iaW5kKHNlbGYpO1xuICAgICAgcHJvYy4kJHVuYm91bmQgPSAje0BtZXRob2R9O1xuICAgICAgcHJvYy4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgICBwcm9jLiQkYXJpdHkgPSAje0BtZXRob2R9LiQkYXJpdHk7XG4gICAgICBwcm9jLiQkcGFyYW1ldGVycyA9ICN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0ByZWNlaXZlci5jbGFzc30jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcbiAgYWxpYXMgPT09IGNhbGxcbmVuZFxuXG5jbGFzcyA6OlVuYm91bmRNZXRob2RcbiAgYXR0cl9yZWFkZXIgOnNvdXJjZSwgOm93bmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHNvdXJjZSwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAc291cmNlID0gc291cmNlXG4gICAgQG93bmVyICA9IG93bmVyXG4gICAgQG1ldGhvZCA9IG1ldGhvZFxuICAgIEBuYW1lICAgPSBuYW1lXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgYmluZChvYmplY3QpXG4gICAgJXh7XG4gICAgICBpZiAoI3tAb3duZXJ9LiQkaXNfbW9kdWxlIHx8IE9wYWwuaXNfYSgje29iamVjdH0sICN7QG93bmVyfSkpIHtcbiAgICAgICAgcmV0dXJuICN7OjpNZXRob2QubmV3KG9iamVjdCwgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgYmluZCBzaW5nbGV0b24gbWV0aG9kIHRvIGEgZGlmZmVyZW50IGNsYXNzIChleHBlY3RlZCAje29iamVjdH0ua2luZF9vZj8oI3tAb3duZXJ9IHRvIGJlIHRydWUpXCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJpbmRfY2FsbChvYmplY3QsICphcmdzLCAmYmxvY2spXG4gICAgYmluZChvYmplY3QpLmNhbGwoKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAc291cmNlfSMje0BuYW1lfSAoZGVmaW5lZCBpbiAje0Bvd25lcn0gaW4gI3tzb3VyY2VfbG9jYXRpb24uam9pbignOicpfSk+XCJcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk1ldGhvZD4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwicmVjZWl2ZXIiLCJvd25lciIsIm1ldGhvZCIsIm5hbWUiLCJAcmVjZWl2ZXIiLCJAb3duZXIiLCJAbmFtZSIsIkBtZXRob2QiLCJhcml0eSIsInBhcmFtZXRlcnMiLCJzb3VyY2VfbG9jYXRpb24iLCIkcmV0X29yXzEiLCIwIiwiY29tbWVudHMiLCJjYWxsIiwiY3VycnkiLCI+PiIsIm90aGVyIiwiPDwiLCJ1bmJpbmQiLCJVbmJvdW5kTWV0aG9kIiwibmV3IiwiY2xhc3MiLCJ0b19wcm9jIiwiaW5zcGVjdCIsImpvaW4iLCI8Y2xhc3M6VW5ib3VuZE1ldGhvZD4iLCJzb3VyY2UiLCJAc291cmNlIiwiYmluZCIsIm9iamVjdCIsIk1ldGhvZCIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwiYmluZF9jYWxsIiwiYXJncyIsImJsb2NrIl0sIm1hcHBpbmdzIjoiQUFBQUEsaURBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsSUFBQUMsYUFBQUEsQ0FBWSxPQUFaLEVBQW9CLFVBQXBCLEVBQStCLE1BQS9CQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxRQUFELEVBQVdDLEtBQVgsRUFBa0JDLE1BQWxCLEVBQTBCQyxJQUF4Q0o7QUFBQUEsTUFBQUE7OztNQUNFSyxnQkFBWUo7TUFDWkssYUFBWUo7TUFDWkssWUFBWUg7TUFDWkosT0FBQVEsQ0FBQUEsY0FBWUwsTUFBWks7SUFKRlIsQ0FBQUEsR0FBQUE7O0FBT0FTLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFELFdBQU9DLE9BQUFBLENBQUFBO0lBRFRBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFHRixXQUFRRTtJQURiQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsK0JBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFDLENBQUFBLFlBQUdKLFdBQVFHLGtCQUFYQyxDQUFBLENBQUE7UUFBQUQsT0FBQTtNQUFBO1FBQWtDQSxPQUFBLENBQUNBLFFBQUQsRUFBV0UsQ0FBWDtNQUFsQztJQURGRixDQUFBQSxHQUFBQTs7QUFJQUcsSUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFGLENBQUFBLFlBQUdKLFdBQVFNLFdBQVhGLENBQUEsQ0FBQTtRQUFBRSxPQUFBO01BQUE7UUFBMkJBLE9BQUE7TUFBM0I7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkExQkYsRUEwQkVBO0FBQUFBLE1BQUFBOztNQUFBQTs7OztNQTFCRjs7TUEwQlc7O0FBRVhBLE1BQVFQLFdBQVFPOztBQUVoQkEsYUFBZVAsV0FBUU8sT0FBU1YsYUFBVVU7QUFDMUNBO0lBTEVBLENBQUFBLElBQUFBOztBQVFBQyxJQUFBQSxxQkFBQUEsaUJBQVVQLEtBQVZPO0FBQUFBLE1BQUFBOzs7O01BQ0VBLE9BQUFSLFdBQU9RLE9BQUFBLENBQU9QLEtBQVBPO0lBRFRBLENBQUFBLElBQUFBOztBQUlBQyxJQUFBQSxrQkFBQUEsMEJBQU9DLEtBQVBEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBVCxXQUFRUyxPQUFBQSxDQUFHQyxLQUFIRDtJQURWQSxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEsa0JBQUFBLDBCQUFPRCxLQUFQQztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQVgsV0FBUVcsT0FBQUEsQ0FBR0QsS0FBSEM7SUFEVkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFDLG9CQUFlQyxLQUFBQSxDQUFLakIsYUFBU2tCLE9BQUFBLENBQUFBLENBQTdCLEVBQXFDakIsVUFBckMsRUFBNkNFLFdBQTdDLEVBQXNERCxTQUF2Q2U7SUFEakJGLENBQUFBLEdBQUFBOztBQUlBSSxJQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUEsdUJBQXlCaEIsV0FBUWdCO0FBQ2pDQTtBQUNBQSxxQkFBdUJoQixXQUFRZ0I7QUFDL0JBLDBCQUE0QmhCLFdBQVFnQjtBQUNwQ0E7QUFDQUE7SUFSRUEsQ0FBQUEsR0FBQUE7O0FBV0FDLElBQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLElBQUQsR0FBQSxDQUFLM0IsSUFBSXlCLE9BQUFBLENBQUFBLENBQVQsQ0FBQSxHQUFnQkUsSUFBaEIsR0FBQSxDQUFvQnBCLGFBQVNrQixPQUFBQSxDQUFBQSxDQUE3QixDQUFBLEdBQW9DRSxHQUFwQyxHQUFBLENBQXVDbEIsU0FBdkMsQ0FBQSxHQUE2Q2tCLGVBQTdDLEdBQUEsQ0FBNERuQixVQUE1RCxDQUFBLEdBQW1FbUIsTUFBbkUsR0FBQSxDQUF5RTNCLElBQUFhLGlCQUFBQSxDQUFBQSxDQUFlZSxNQUFBQSxDQUFNRCxHQUFOQyxDQUF4RixDQUFBLEdBQW1HRDtJQURyR0EsQ0FBQUEsR0FBQUE7SUFJQSxhQUFNLElBQU4sRUFBUyxNQUFUO0lBQ0E1QixPQUFBLGFBQU0sS0FBTixFQUFVLE1BQVY7RUFsRUZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUFxRUFELE9BQUErQjtFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFN0IsSUFBQUMsYUFBQUEsQ0FBWSxRQUFaLEVBQXFCLE9BQXJCLEVBQTZCLE1BQTdCQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlNEIsTUFBRCxFQUFTMUIsS0FBVCxFQUFnQkMsTUFBaEIsRUFBd0JDLElBQXRDSjtBQUFBQSxNQUFBQTs7O01BQ0U2QixjQUFVRDtNQUNWdEIsYUFBVUo7TUFDVk0sY0FBVUw7TUFDVkgsT0FBQU8sQ0FBQUEsWUFBVUgsSUFBVkc7SUFKRlAsQ0FBQUEsR0FBQUE7O0FBT0FTLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFELFdBQU9DLE9BQUFBLENBQUFBO0lBRFRBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFHRixXQUFRRTtJQURiQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsK0JBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFDLENBQUFBLFlBQUdKLFdBQVFHLGtCQUFYQyxDQUFBLENBQUE7UUFBQUQsT0FBQTtNQUFBO1FBQWtDQSxPQUFBLENBQUNBLFFBQUQsRUFBV0UsQ0FBWDtNQUFsQztJQURGRixDQUFBQSxHQUFBQTs7QUFJQUcsSUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFGLENBQUFBLFlBQUdKLFdBQVFNLFdBQVhGLENBQUEsQ0FBQTtRQUFBRSxPQUFBO01BQUE7UUFBMkJBLE9BQUE7TUFBM0I7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFnQixJQUFBQSxvQkFBQUEsZ0JBQVNDLE1BQVREO0FBQUFBLE1BQUFBOzs7QUFFRkEsVUFBWXhCLFVBQU93QiwwQkFBNEJDLE1BQU9ELEVBQUl4QixVQUFPd0I7QUFDakVBLGVBQWlCRSxhQUFRVixLQUFBQSxDQUFLUyxNQUFiLEVBQXFCekIsVUFBckIsRUFBNkJFLFdBQTdCLEVBQXNDRCxTQUE5QmUsQ0FBcUNRO0FBQzlEQTtBQUNBQTtBQUNBQSxRQUFVRyxPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE2QkwsNkRBQUQsR0FBQSxDQUE4REMsTUFBOUQsQ0FBQSxHQUFxRUQsWUFBckUsR0FBQSxDQUFpRnhCLFVBQWpGLENBQUEsR0FBd0Z3QixjQUE1R0ksQ0FBMEhKO0FBQzVJQTtBQUNBQTtJQVJFQSxDQUFBQSxHQUFBQTs7QUFXQU0sSUFBQUEseUJBQUFBLHFCQUFjTCxNQUFELEVBMUdmLEVBMEdFSztBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7TUExR0Y7O01BMEd3QjtNQUNwQkEsT0FBWXJCLE1BQVpqQixJQUFBZ0MsTUFBQUEsQ0FBS0MsTUFBTEQsQ0FBWWYsUUFBQUEsRUFBTSxNQUFDc0IsSUFBRCxDQUFOdEIsRUFBY3VCLEtBQURkLFNBQUFBLENBQUFBLENBQWJUO0lBRGRxQixDQUFBQSxJQUFBQTtJQUlBVCxPQUFBRix1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxJQUFELEdBQUEsQ0FBSzNCLElBQUl5QixPQUFBQSxDQUFBQSxDQUFULENBQUEsR0FBZ0JFLElBQWhCLEdBQUEsQ0FBb0JJLFdBQXBCLENBQUEsR0FBNEJKLEdBQTVCLEdBQUEsQ0FBK0JsQixTQUEvQixDQUFBLEdBQXFDa0IsZUFBckMsR0FBQSxDQUFvRG5CLFVBQXBELENBQUEsR0FBMkRtQixNQUEzRCxHQUFBLENBQWlFM0IsSUFBQWEsaUJBQUFBLENBQUFBLENBQWVlLE1BQUFBLENBQU1ELEdBQU5DLENBQWhGLENBQUEsR0FBMkZEO0lBRDdGQSxDQUFBQSxHQUFBQTtFQXpDRkUsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQXJFQS9COyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTE3NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvdmFyaWFibGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgcmVnZXhwIG1hdGNoZXNcbiV4eyRndmFyc1snJiddID0gJGd2YXJzWyd+J10gPSAkZ3ZhcnNbJ2AnXSA9ICRndmFyc1tcIidcIl0gPSBuaWx9XG5cbiMgcmVxdWlyZXNcbiRMT0FERURfRkVBVFVSRVMgPSAkXCIgPSBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgXG4kTE9BRF9QQVRIICAgICAgID0gJDogPSBbXVxuXG4jIHNwbGl0IGxpbmVzXG4kLyA9IFwiXFxuXCJcbiQsID0gbmlsXG5cbjo6QVJHViA9IFtdXG46OkFSR0YgPSA6Ok9iamVjdC5uZXdcbjo6RU5WICA9IHt9XG5cbiRWRVJCT1NFID0gZmFsc2VcbiRERUJVRyAgID0gZmFsc2VcbiRTQUZFICAgID0gMFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCIkTE9BREVEX0ZFQVRVUkVTIiwiJFwiIiwiJExPQURfUEFUSCIsIiQ6IiwiJC8iLCIkLCIsIk9iamVjdCIsIm5ldyIsIiRWRVJCT1NFIiwiJERFQlVHIiwiJFNBRkUiLCIwIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0RBQUFBO0VBQUFBOztFQUFBQTs7RUFDR0E7RUFHSEMseUJBQW1CQyxDQUFBQSxlQUFNRixvQkFBTkU7RUFDbkJDLG1CQUFtQkMsQ0FBQUEsY0FBSyxFQUFMQTtFQUduQkMsY0FBS0w7RUFDTE0sY0FBSztFQUVMLFdBQUEsSUFBQSxVQUFTLEVBQVQ7RUFDQSxXQUFBLElBQUEsVUFBU0MsT0FBUUMsS0FBQUEsQ0FBQUEsQ0FBakI7RUFDQSxXQUFBLElBQUEsU0FBUyxZQUFBLEVBQVQ7RUFFQUMsaUJBQVc7RUFDWEMsZUFBVztFQUNYVixPQUFBVyxDQUFBQSxjQUFXQyxDQUFYRDtBQWpCQVg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5MTkyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6OklPXG4gIHNlbGY6OlNFRUtfU0VUID0gMFxuICBzZWxmOjpTRUVLX0NVUiA9IDFcbiAgc2VsZjo6U0VFS19FTkQgPSAyXG4gIHNlbGY6OlNFRUtfREFUQSA9IDNcbiAgc2VsZjo6U0VFS19IT0xFID0gNFxuXG4gIHNlbGY6OlJFQURBQkxFID0gMVxuICBzZWxmOjpXUklUQUJMRSA9IDRcblxuICBhdHRyX3JlYWRlciA6ZW9mXG5cbiAgYXR0cl9hY2Nlc3NvciA6cmVhZF9wcm9jLCAgOnN5bmMsIDp0dHksIDp3cml0ZV9wcm9jXG5cbiAgZGVmIGluaXRpYWxpemUoZmQsIGZsYWdzID0gJ3InKVxuICAgIEBmZCA9IGZkXG4gICAgQGZsYWdzID0gZmxhZ3NcbiAgICBAZW9mID0gZmFsc2VcblxuICAgIGlmIGZsYWdzLmluY2x1ZGU/KCdyJykgJiYgIWZsYWdzLm1hdGNoPygvW3dhK10vKVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVsc2lmIGZsYWdzLm1hdGNoPygvW3dhXS8pICYmICFmbGFncy5tYXRjaD8oL1tyK10vKVxuICAgICAgQGNsb3NlZCA9IDpyZWFkXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBmaWxlbm9cbiAgICBAZmRcbiAgZW5kXG5cbiAgZGVmIHR0eT9cbiAgICBgc2VsZi50dHkgPT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIHdyaXRlKHN0cmluZylcbiAgICBgc2VsZi53cml0ZV9wcm9jKHN0cmluZylgXG4gICAgc3RyaW5nLnNpemVcbiAgZW5kXG5cbiAgZGVmIGZsdXNoXG4gICAgIyBub29wXG4gIGVuZFxuXG4gIGRlZiA8PChzdHJpbmcpXG4gICAgd3JpdGUoc3RyaW5nKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByaW50KCphcmdzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSAjezo6S2VybmVsLlN0cmluZyhgYXJnc1tpXWApfVxuICAgICAgfVxuICAgICAgc2VsZi4kd3JpdGUoYXJncy5qb2luKCN7JCx9KSk7XG4gICAgfVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcHV0cygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBsaW5lXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3t3cml0ZSBcIlxcblwifTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGlmIChhcmdzW2ldLiQkaXNfYXJyYXkpe1xuICAgICAgICAgICAgdmFyIGFyeSA9ICN7YGFyZ3NbaV1gLmZsYXR0ZW59XG4gICAgICAgICAgICBpZiAoYXJ5Lmxlbmd0aCA+IDApICN7cHV0cygqYGFyeWApfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnc1tpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICBsaW5lID0gYXJnc1tpXS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsaW5lID0gI3s6Oktlcm5lbC5TdHJpbmcoYGFyZ3NbaV1gKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxpbmUuZW5kc1dpdGgoXCJcXG5cIikpIGxpbmUgKz0gXCJcXG5cIlxuICAgICAgICAgICAgI3t3cml0ZSBgbGluZWB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5pbFxuICBlbmRcblxuICAjIFJlYWRpbmdcblxuICBkZWYgZ2V0Y1xuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcbiAgICBwYXJ0cyA9ICcnXG5cbiAgICAjIFdpbGwgZXhlY3VyZSBhdCBtb3N0IHR3aWNlIC0gb25lIHRpbWUgcmVhZGluZyBmcm9tIGEgYnVmZmVyXG4gICAgIyBzZWNvbmQgdGltZVxuICAgIGJlZ2luXG4gICAgICBAcmVhZF9idWZmZXIgKz0gcGFydHNcbiAgICAgIGlmIEByZWFkX2J1ZmZlciAhPSAnJ1xuICAgICAgICByZXQgPSBAcmVhZF9idWZmZXJbMF1cbiAgICAgICAgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyWzEuLi0xXVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgICBlbmRcbiAgICBlbmQgd2hpbGUgcGFydHMgPSBzeXNyZWFkX25vcmFpc2UoMSlcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZ2V0Ynl0ZVxuICAgIGdldGMmLm9yZFxuICBlbmRcblxuICBkZWYgcmVhZGJ5dGVcbiAgICByZWFkY2hhci5vcmRcbiAgZW5kXG5cbiAgZGVmIHJlYWRjaGFyXG4gICAgZ2V0YyB8fCA6Oktlcm5lbC5yYWlzZSg6OkVPRkVycm9yLCAnZW5kIG9mIGZpbGUgcmVhY2hlZCcpXG4gIGVuZFxuXG4gIGRlZiByZWFkbGluZSgqYXJncylcbiAgICBnZXRzKCphcmdzKSB8fCA6Oktlcm5lbC5yYWlzZSg6OkVPRkVycm9yLCAnZW5kIG9mIGZpbGUgcmVhY2hlZCcpXG4gIGVuZFxuXG4gIGRlZiBnZXRzKHNlcCA9IGZhbHNlLCBsaW1pdCA9IG5pbCwgb3B0cyA9IHt9KVxuICAgIGlmIGBzZXAuJCRpc19udW1iZXJgICYmICFsaW1pdFxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IGZhbHNlLCBzZXAsIGxpbWl0XG4gICAgZW5kXG4gICAgaWYgYHNlcC4kJGlzX2hhc2hgICYmICFsaW1pdCAmJiBvcHRzID09IHt9XG4gICAgICBzZXAsIGxpbWl0LCBvcHRzID0gZmFsc2UsIG5pbCwgc2VwXG4gICAgZWxzaWYgYGxpbWl0LiQkaXNfaGFzaGAgJiYgb3B0cyA9PSB7fVxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IHNlcCwgbmlsLCBsaW1pdFxuICAgIGVuZFxuXG4gICAgb3JpZ19zZXAgPSBzZXBcblxuICAgIHNlcCA9ICQvIGlmIHNlcCA9PSBmYWxzZVxuICAgIHNlcCA9IC9cXHI/XFxuXFxyP1xcbi8gaWYgc2VwID09ICcnXG4gICAgc2VwIHx8PSAnJ1xuICAgIHNlcCA9IHNlcC50b19zdHIgdW5sZXNzIG9yaWdfc2VwID09ICcnXG5cbiAgICAjIFRyeSB0byBkZWR1Y2UgbGVuZ3RoIG9mIGEgcmVnZXhwXG4gICAgc2VwbGVuID0gb3JpZ19zZXAgPT0gJycgPyAyIDogc2VwLmxlbmd0aFxuXG4gICAgc2VwID0gLyAvIGlmIHNlcCA9PSAnICcgIyBXVEYgaXMgdGhpcywgU3RyaW5nI3NwbGl0KFwiIFwiKSBtYXRjaGVzIGFsbCB3aGl0ZXNwYWNlcz8/P1xuXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xuICAgIGRhdGEgPSAnJ1xuICAgIHJldCA9IG5pbFxuXG4gICAgYmVnaW5cbiAgICAgIEByZWFkX2J1ZmZlciArPSBkYXRhXG4gICAgICBpZiBzZXAgIT0gJycgJiYgKGBzZXAuJCRpc19yZWdleHBgID8gQHJlYWRfYnVmZmVyLm1hdGNoPyhzZXApIDogQHJlYWRfYnVmZmVyLmluY2x1ZGU/KHNlcCkpXG4gICAgICAgIG9yaWdfYnVmZmVyID0gQHJlYWRfYnVmZmVyXG4gICAgICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyLnNwbGl0KHNlcCwgMilcbiAgICAgICAgcmV0ICs9IG9yaWdfYnVmZmVyW3JldC5sZW5ndGgsIHNlcGxlbl0gaWYgcmV0ICE9IG9yaWdfYnVmZmVyXG4gICAgICAgIGJyZWFrXG4gICAgICBlbmRcbiAgICBlbmQgd2hpbGUgZGF0YSA9IHN5c3JlYWRfbm9yYWlzZShzZXAgPT0gJycgPyA2NV81MzYgOiAxKVxuXG4gICAgdW5sZXNzIHJldFxuICAgICAgcmV0LCBAcmVhZF9idWZmZXIgPSAoQHJlYWRfYnVmZmVyIHx8ICcnKSwgJydcbiAgICAgIHJldCA9IG5pbCBpZiByZXQgPT0gJydcbiAgICBlbmRcblxuICAgIGlmIHJldFxuICAgICAgaWYgbGltaXRcbiAgICAgICAgcmV0ID0gcmV0WzAuLi5saW1pdF1cbiAgICAgICAgQHJlYWRfYnVmZmVyID0gcmV0W2xpbWl0Li4tMV0gKyBAcmVhZF9idWZmZXJcbiAgICAgIGVuZFxuICAgICAgcmV0ID0gcmV0LnN1YigvXFxyP1xcblxcei8sICcnKSBpZiBvcHRzWzpjaG9tcF1cbiAgICAgIHJldCA9IHJldC5zdWIoL1xcQVtcXHJcXG5dKy8sICcnKSBpZiBvcmlnX3NlcCA9PSAnJ1xuICAgIGVuZFxuXG4gICAgJF8gPSByZXQgaWYgb3JpZ19zZXAgPT0gZmFsc2VcbiAgICByZXRcbiAgZW5kXG5cbiAgIyBUaGlzIG1ldGhvZCBpcyB0byBiZSBvdmVybG9hZGVkLCBvciByZWFkX3Byb2MgY2FuIGJlIGNoYW5nZWRcbiAgZGVmIHN5c3JlYWQoaW50ZWdlcilcbiAgICBgc2VsZi5yZWFkX3Byb2MoaW50ZWdlcilgIHx8IGJlZ2luXG4gICAgICBAZW9mID0gdHJ1ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpFT0ZFcnJvciwgJ2VuZCBvZiBmaWxlIHJlYWNoZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIHN5c3JlYWRfbm9yYWlzZShpbnRlZ2VyKVxuICAgIHN5c3JlYWQoaW50ZWdlcilcbiAgcmVzY3VlIDo6RU9GRXJyb3JcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIHJlYWRwYXJ0aWFsKGludGVnZXIpXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xuICAgIHBhcnQgPSBzeXNyZWFkKGludGVnZXIpXG4gICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIgKyAocGFydCB8fCAnJyksICcnXG4gICAgcmV0ID0gbmlsIGlmIHJldCA9PSAnJ1xuICAgIHJldFxuICBlbmRcblxuICBkZWYgcmVhZChpbnRlZ2VyID0gbmlsKVxuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcbiAgICBwYXJ0cyA9ICcnXG4gICAgcmV0ID0gbmlsXG5cbiAgICBiZWdpblxuICAgICAgQHJlYWRfYnVmZmVyICs9IHBhcnRzXG4gICAgICBpZiBpbnRlZ2VyICYmIEByZWFkX2J1ZmZlci5sZW5ndGggPiBpbnRlZ2VyXG4gICAgICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyWzAuLi5pbnRlZ2VyXSwgQHJlYWRfYnVmZmVyW2ludGVnZXIuLi0xXVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgICBlbmRcbiAgICBlbmQgd2hpbGUgcGFydHMgPSBzeXNyZWFkX25vcmFpc2UoaW50ZWdlciB8fCA2NV81MzYpXG5cbiAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlciwgJydcbiAgICByZXRcbiAgZW5kXG5cbiAgIyBFYWNoZXNcblxuICBkZWYgcmVhZGxpbmVzKHNlcGFyYXRvciA9ICQvKVxuICAgIGVhY2hfbGluZShzZXBhcmF0b3IpLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGVhY2goc2VwID0gJC8sICphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoLCBzZXAsICphcmdzIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0cyhzZXAsICphcmdzKSlcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9ieXRlIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0Ynl0ZSlcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9jaGFyIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0YylcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQ2xvc2VkbmVzc1xuXG4gIGRlZiBjbG9zZVxuICAgIEBjbG9zZWQgPSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VfcmVhZFxuICAgIGlmIEBjbG9zZWQgPT0gOndyaXRlXG4gICAgICBAY2xvc2VkID0gOmJvdGhcbiAgICBlbHNlXG4gICAgICBAY2xvc2VkID0gOnJlYWRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNsb3NlX3dyaXRlXG4gICAgaWYgQGNsb3NlZCA9PSA6cmVhZFxuICAgICAgQGNsb3NlZCA9IDpib3RoXG4gICAgZWxzZVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xvc2VkP1xuICAgIEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZF9yZWFkP1xuICAgIEBjbG9zZWQgPT0gOnJlYWQgfHwgQGNsb3NlZCA9PSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VkX3dyaXRlP1xuICAgIEBjbG9zZWQgPT0gOndyaXRlIHx8IEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgY2hlY2tfd3JpdGFibGVcbiAgICBpZiBjbG9zZWRfd3JpdGU/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OklPRXJyb3IsICdub3Qgb3BlbmVkIGZvciB3cml0aW5nJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBjaGVja19yZWFkYWJsZVxuICAgIGlmIGNsb3NlZF9yZWFkP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJT0Vycm9yLCAnbm90IG9wZW5lZCBmb3IgcmVhZGluZydcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZWFjaF9saW5lIGVhY2hcbiAgYWxpYXMgZW9mPyBlb2ZcbmVuZFxuXG46OlNURElOICA9ICRzdGRpbiAgPSA6OklPLm5ldygwLCAncicpXG46OlNURE9VVCA9ICRzdGRvdXQgPSA6OklPLm5ldygxLCAndycpXG46OlNUREVSUiA9ICRzdGRlcnIgPSA6OklPLm5ldygyLCAndycpXG5cbmB2YXIgY29uc29sZSA9IE9wYWwuZ2xvYmFsLmNvbnNvbGVgXG46OlNURE9VVC53cml0ZV9wcm9jID0gYHR5cGVvZihwcm9jZXNzKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKHByb2Nlc3Muc3Rkb3V0KSA9PT0gJ29iamVjdCcgPyBmdW5jdGlvbihzKXtwcm9jZXNzLnN0ZG91dC53cml0ZShzKX0gOiBmdW5jdGlvbihzKXtjb25zb2xlLmxvZyhzKX1gXG46OlNUREVSUi53cml0ZV9wcm9jID0gYHR5cGVvZihwcm9jZXNzKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKHByb2Nlc3Muc3RkZXJyKSA9PT0gJ29iamVjdCcgPyBmdW5jdGlvbihzKXtwcm9jZXNzLnN0ZGVyci53cml0ZShzKX0gOiBmdW5jdGlvbihzKXtjb25zb2xlLndhcm4ocyl9YFxuXG46OlNURElOLnJlYWRfcHJvYyA9IGBmdW5jdGlvbihzKSB7IHZhciBwID0gcHJvbXB0KCk7IGlmIChwICE9PSBudWxsKSByZXR1cm4gcCArIFwiXFxuXCI7IHJldHVybiBuaWw7IH1gXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpJTz4iLCJzZWxmIiwiMCIsIjEiLCIyIiwiMyIsIjQiLCJhdHRyX3JlYWRlciIsImF0dHJfYWNjZXNzb3IiLCJpbml0aWFsaXplIiwiZmQiLCJmbGFncyIsIkBmZCIsIkBmbGFncyIsIkBlb2YiLCJpbmNsdWRlPyIsIm1hdGNoPyIsIkBjbG9zZWQiLCJmaWxlbm8iLCJ0dHk/Iiwid3JpdGUiLCJzdHJpbmciLCJzaXplIiwiZmx1c2giLCI8PCIsInByaW50IiwiS2VybmVsIiwiU3RyaW5nIiwiJCwiLCJwdXRzIiwiZmxhdHRlbiIsImdldGMiLCJAcmVhZF9idWZmZXIiLCIkcmV0X29yXzEiLCJwYXJ0cyIsIisiLCJyZXQiLCJbXSIsIi0xIiwic3lzcmVhZF9ub3JhaXNlIiwiZ2V0Ynl0ZSIsInJlYWRieXRlIiwicmVhZGNoYXIiLCJvcmQiLCJyYWlzZSIsIkVPRkVycm9yIiwicmVhZGxpbmUiLCJnZXRzIiwiYXJncyIsInNlcCIsImxpbWl0Iiwib3B0cyIsIm9yaWdfc2VwIiwiJC8iLCJ0b19zdHIiLCJzZXBsZW4iLCJsZW5ndGgiLCJkYXRhIiwib3JpZ19idWZmZXIiLCJzcGxpdCIsIjY1NTM2Iiwic3ViIiwiJF8iLCJzeXNyZWFkIiwiaW50ZWdlciIsInJlYWRwYXJ0aWFsIiwicGFydCIsInJlYWQiLCI+IiwicmVhZGxpbmVzIiwic2VwYXJhdG9yIiwiZWFjaF9saW5lIiwidG9fYSIsImVhY2giLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInMiLCJlYWNoX2J5dGUiLCJlYWNoX2NoYXIiLCJjbG9zZSIsImNsb3NlX3JlYWQiLCJjbG9zZV93cml0ZSIsImNsb3NlZD8iLCI9PSIsImNsb3NlZF9yZWFkPyIsImNsb3NlZF93cml0ZT8iLCJjaGVja193cml0YWJsZSIsIklPRXJyb3IiLCJjaGVja19yZWFkYWJsZSIsIiRzdGRpbiIsIklPIiwibmV3IiwiJHN0ZG91dCIsIiRzdGRlcnIiLCIkd3JpdGVyIiwid3JpdGVfcHJvYz0iLCJTVERPVVQiLCItIiwiU1RERVJSIiwicmVhZF9wcm9jPSIsIlNURElOIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRSxXQUFBQyxJQUFBLGNBQWlCQyxDQUFqQjtJQUNBLFdBQUFELElBQUEsY0FBaUJFLENBQWpCO0lBQ0EsV0FBQUYsSUFBQSxjQUFpQkcsQ0FBakI7SUFDQSxXQUFBSCxJQUFBLGVBQWtCSSxDQUFsQjtJQUNBLFdBQUFKLElBQUEsZUFB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LENBQUFBLGdCQUFVSCxTQUFJQyxLQUFBQSxDQUFLdkYsQ0FBVCxFQUFZTCxHQUFSNEYsQ0FBZEUsQ0FBWDtFQUVDOUY7O0VBbFREK0YsVUFBQSxDQW1UdUIvRix3SUFuVHZCO0VBbVRRZ0csTUFBUkMsYUFBUUQsZUFBQUEsRUFuVFIsTUFBQUQsT0FBQSxDQW1UUUM7RUFuVFJELE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBL0YsUUFBQSxDQUFBa0csRUFBQTlGLENBQUE4RixDQUFBOztFQUFBSCxVQUFBLENBb1R1Qi9GLHlJQXBUdkI7RUFvVFFnRyxNQUFSRyxhQUFRSCxlQUFBQSxFQXBUUixNQUFBRCxPQUFBLENBb1RRQztFQXBUUkQsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUEvRixRQUFBLENBQUFrRyxFQUFBOUYsQ0FBQThGLENBQUE7O0VBQUFILFVBQUEsQ0FzVHFCL0YsOEVBdFRyQjtFQXNUT29HLE1BQVBDLFlBQU9ELGNBQUFBLEVBdFRQLE1BQUFMLE9BQUEsQ0FzVE9LO0VBdFRQcEcsT0FBQStGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBL0YsUUFBQSxDQUFBa0csRUFBQTlGLENBQUE4RixDQUFBO0FBQUFsRzsifX0seyJvZmZzZXQiOnsibGluZSI6MTk2NjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL3JlZ2V4cF9hbmNob3JzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbm1vZHVsZSBPcGFsXG4gIHNlbGY6OlJFR0VYUF9TVEFSVCA9IFJVQllfRU5HSU5FID09ICdvcGFsJyA/ICdeJyA6ICdcXEEnXG4gIHNlbGY6OlJFR0VYUF9FTkQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnJCcgOiAnXFx6J1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDJGIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSArICFcIiMkJSYnKCkqKywtLi8gY2hhcnMpXG4gICMgXFx1MDAzQSAtIFxcdTAwNDAgKDo7PD0+P0AgY2hhcnMpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgYmVnZ2luaW5nIG9yIG1pZGRsZSBvZiBpdHMgbmFtZVxuICBzZWxmOjpGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMkZcXHUwMDNBLVxcdTAwNDBcXHUwMDVCLVxcdTAwNUVcXHUwMDYwXFx1MDA3Qi1cXHUwMDdGJ1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDIwIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSlcbiAgIyBcXHUwMDIyIC0gXFx1MDAyRiAoXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDNFICg6Ozw9PiBjaGFycylcbiAgIyBcXHUwMDQwICAgICAgICAgIChAIGNoYXIpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgZW5kIG9mIGl0cyBuYW1lXG4gICMgSW4gZmFjdCwgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSBGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgKyBcXHUwMDIxICgnPycpICsgXFx1MDAzRiAoJyEnKVxuICBzZWxmOjpGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgICA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIyLVxcdTAwMkZcXHUwMDNBLVxcdTAwM0VcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgc2VsZjo6SU5MSU5FX0lERU5USUZJRVJfUkVHRVhQID0gUmVnZXhwLm5ldyhcIlteI3tzZWxmOjpGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSU31dKlteI3tzZWxmOjpGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlN9XVwiKVxuXG4gICMgRm9yIGNvbnN0YW50cyBydWxlcyBhcmUgcHJldHR5IG11Y2ggdGhlIHNhbWUsIGJ1dCAnOicgaXMgYWxsb3dlZCBhbmQgJz8hJyBhcmUgbm90LlxuICAjIFBsdXMgaXQgbWF5IHN0YXJ0IHdpdGggYSAnOjonIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBjb25zdGFudCBjb21lcyBmcm9tIHRvcGxldmVsLlxuICBzZWxmOjpGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIxLVxcdTAwMkZcXHUwMDNCLVxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgc2VsZjo6Q09OU1RfTkFNRV9SRUdFWFAgPSBSZWdleHAubmV3KFwiI3tzZWxmOjpSRUdFWFBfU1RBUlR9KDo6KT9bQS1aXVteI3tzZWxmOjpGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSU31dKiN7c2VsZjo6UkVHRVhQX0VORH1cIilcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+Iiwic2VsZiIsIlJlZ2V4cCIsIm5ldyIsInNlbGY6OkZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTIiwic2VsZjo6Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTIiwic2VsZjo6UkVHRVhQX1NUQVJUIiwic2VsZjo6Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMiLCJzZWxmOjpSRUdFWFBfRU5EIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0RBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLFdBQUFDLElBQUEsa0JBQTZDRCxHQUE3QztJQUNBLFdBQUFDLElBQUEsZ0JBQTJDRCxHQUEzQztJQVNBLFdBQUFDLElBQUEseUNBQTRDRCxxRUFBNUM7SUFZQSxXQUFBQyxJQUFBLHVDQUE0Q0QsMkZBQTVDO0lBQ0EsV0FBQUMsSUFBQSw4QkFBaUNDLFlBQU1DLEtBQUFBLENBQU1ILElBQUQsR0FBQSxDQUFLSSxJQUFBSCxJQUFBRyx3Q0FBTCxDQUFBLEdBQStDSixNQUEvQyxHQUFBLENBQXFESyxJQUFBSixJQUFBSSxzQ0FBckQsQ0FBQSxHQUE2RkwsR0FBbEdHLENBQXZDO0lBSUEsV0FBQUYsSUFBQSxnQ0FBbUNELDJGQUFuQztJQUNBQSxPQUFBLFdBQUFDLElBQUEsdUJBQTBCQyxZQUFNQyxLQUFBQSxDQUFLLEVBQUEsR0FBQSxDQUFHRyxJQUFBTCxJQUFBSyxpQkFBSCxDQUFBLEdBQXNCTixjQUF0QixHQUFBLENBQW9DTyxJQUFBTixJQUFBTSwrQkFBcEMsQ0FBQSxHQUFxRVAsSUFBckUsR0FBQSxDQUF5RVEsSUFBQVAsSUFBQU8sZUFBekUsQ0FBTEwsQ0FBaEM7RUE3QkZILEdBQUFBLFdBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTY4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvbWluaS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyI6Ok9iamVjdC5yZXF1aXJlICdvcGFsL2Jhc2UnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvbmlsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9ib29sZWFuJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2VudW1lcmF0b3InXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2FycmF5J1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9oYXNoJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9udW1iZXInXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JhbmdlJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9wcm9jJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9tZXRob2QnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JlZ2V4cCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvdmFyaWFibGVzJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9pbydcbjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvcmVnZXhwX2FuY2hvcnMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIk9iamVjdCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQSw0Q0FBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixXQUFURTtFQUVSRCxPQUFRQyxTQUFBQSxDQUFTRixhQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixpQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLG9CQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixvQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0Ysb0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGVBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGNBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixlQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixjQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLG1CQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixZQUFURTtFQUNSRixPQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixxQkFBVEU7QUFqQlJGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTcwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIva2VybmVsL2Zvcm1hdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90b1xuXG5tb2R1bGUgOjpLZXJuZWxcbiAgZGVmIGZvcm1hdChmb3JtYXRfc3RyaW5nLCAqYXJncylcbiAgICBpZiBhcmdzLmxlbmd0aCA9PSAxICYmIGFyZ3NbMF0ucmVzcG9uZF90bz8oOnRvX2FyeSlcbiAgICAgIGFyeSA9IDo6T3BhbC5jb2VyY2VfdG8/KGFyZ3NbMF0sIDo6QXJyYXksIDp0b19hcnkpXG4gICAgICBhcmdzID0gYXJ5LnRvX2EgdW5sZXNzIGFyeS5uaWw/XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAvL3VzZWQgZm9yIHNsaWNpbmc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSAwLFxuICAgICAgICAgIGVuZF9zbGljZSxcbiAgICAgICAgICAvL3VzZWQgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBmb3JtYXQgc3RyaW5nOlxuICAgICAgICAgIGksXG4gICAgICAgICAgbGVuID0gZm9ybWF0X3N0cmluZy5sZW5ndGgsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nIGZpZWxkIHZhbHVlczpcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgc3RyLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAlZyBhbmQgJUcgZmllbGRzOlxuICAgICAgICAgIGV4cG9uZW50LFxuICAgICAgICAgIC8vdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiB3aWR0aCBhbmQgcHJlY2lzaW9uOlxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAvL3VzZWQgZm9yIGhvbGRpbmcgdGVtcG9yYXJ5IHZhbHVlczpcbiAgICAgICAgICB0bXBfbnVtLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAle30gYW5kICU8PiBmaWxlZHM6XG4gICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5LFxuICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhcixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWIsICVCLCAlbywgJXgsIGFuZCAlWCBmaWVsZHM6XG4gICAgICAgICAgYmFzZV9udW1iZXIsXG4gICAgICAgICAgYmFzZV9wcmVmaXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCxcbiAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0LFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgbmV4dF9hcmcsXG4gICAgICAgICAgc2VxX2FyZ19udW0gPSAxLFxuICAgICAgICAgIHBvc19hcmdfbnVtID0gMCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgZmxhZ3M6XG4gICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgRk5PTkUgID0gMCxcbiAgICAgICAgICBGU0hBUlAgPSAxLFxuICAgICAgICAgIEZNSU5VUyA9IDIsXG4gICAgICAgICAgRlBMVVMgID0gNCxcbiAgICAgICAgICBGWkVSTyAgPSA4LFxuICAgICAgICAgIEZTUEFDRSA9IDE2LFxuICAgICAgICAgIEZXSURUSCA9IDMyLFxuICAgICAgICAgIEZQUkVDICA9IDY0LFxuICAgICAgICAgIEZQUkVDMCA9IDEyODtcblxuICAgICAgZnVuY3Rpb24gQ0hFQ0tfRk9SX0ZMQUdTKCkge1xuICAgICAgICBpZiAoZmxhZ3MmRldJRFRIKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnZmxhZyBhZnRlciB3aWR0aCd9IH1cbiAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBDSEVDS19GT1JfV0lEVEgoKSB7XG4gICAgICAgIGlmIChmbGFncyZGV0lEVEgpIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3aWR0aCBnaXZlbiB0d2ljZSd9IH1cbiAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dpZHRoIGFmdGVyIHByZWNpc2lvbid9IH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX05USF9BUkcobnVtKSB7XG4gICAgICAgIGlmIChudW0gPj0gYXJncy5sZW5ndGgpIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0b28gZmV3IGFyZ3VtZW50cyd9IH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbbnVtXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX05FWFRfQVJHKCkge1xuICAgICAgICBzd2l0Y2ggKHBvc19hcmdfbnVtKSB7XG4gICAgICAgIGNhc2UgLTE6ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBudW1iZXJlZFwifSAvLyByYWlzZVxuICAgICAgICBjYXNlIC0yOiAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ1bm51bWJlcmVkKCN7YHNlcV9hcmdfbnVtYH0pIG1peGVkIHdpdGggbmFtZWRcIn0gLy8gcmFpc2VcbiAgICAgICAgfVxuICAgICAgICBwb3NfYXJnX251bSA9IHNlcV9hcmdfbnVtKys7XG4gICAgICAgIHJldHVybiBHRVRfTlRIX0FSRyhwb3NfYXJnX251bSAtIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfUE9TX0FSRyhudW0pIHtcbiAgICAgICAgaWYgKHBvc19hcmdfbnVtID4gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciBuYW1lZFwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW0gPCAxKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBpbmRleCAtICN7YG51bWB9JFwifVxuICAgICAgICB9XG4gICAgICAgIHBvc19hcmdfbnVtID0gLTE7XG4gICAgICAgIHJldHVybiBHRVRfTlRIX0FSRyhudW0gLSAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX0FSRygpIHtcbiAgICAgICAgcmV0dXJuIChuZXh0X2FyZyA9PT0gdW5kZWZpbmVkID8gR0VUX05FWFRfQVJHKCkgOiBuZXh0X2FyZyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFJFQURfTlVNKGxhYmVsKSB7XG4gICAgICAgIHZhciBudW0sIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlKlswLTldJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA8IDQ4IHx8IGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA+IDU3KSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBudW0gPSBwYXJzZUludChzdHIsIDEwKSB8fCAwO1xuICAgICAgICAgICAgaWYgKG51bSA+IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiI3tgbGFiZWxgfSB0b28gYmlnXCJ9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU1fQUZURVJfQVNURVIobGFiZWwpIHtcbiAgICAgICAgdmFyIGFyZywgbnVtID0gUkVBRF9OVU0obGFiZWwpO1xuICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgYXJnID0gR0VUX1BPU19BUkcobnVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmcgPSBHRVRfTkVYVF9BUkcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tgYXJnYC50b19pbnR9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnKTsgaSAhPT0gLTE7IGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnLCBpKSkge1xuICAgICAgICBzdHIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZmxhZ3MgPSBGTk9ORTtcbiAgICAgICAgd2lkdGggPSAtMTtcbiAgICAgICAgcHJlY2lzaW9uID0gLTE7XG4gICAgICAgIG5leHRfYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGVuZF9zbGljZSA9IGk7XG5cbiAgICAgICAgaSsrO1xuXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSBpO1xuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xcMCc6XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0X3NlcXVlbmNlOiBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuXG4gICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZTUEFDRTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGU0hBUlA7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlBMVVM7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRk1JTlVTO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZaRVJPO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgY2FzZSAnNic6XG4gICAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICB0bXBfbnVtID0gUkVBRF9OVU0oJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgaWYgKGkgKyAyID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnJSc7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmV4dF9hcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInZhbHVlIGdpdmVuIHR3aWNlIC0gJSN7YHRtcF9udW1gfSRcIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXh0X2FyZyA9IEdFVF9QT1NfQVJHKHRtcF9udW0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgICB3aWR0aCA9IHRtcF9udW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXNlICdcXHsnOlxuICAgICAgICAgICAgY2xvc2luZ19icmFjZV9jaGFyID0gKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSAnPCcgPyAnPicgOiAnXFx9Jyk7XG4gICAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXkgPSAnJztcblxuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgbmFtZSAtIHVubWF0Y2hlZCBwYXJlbnRoZXNpcyd9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBjbG9zaW5nX2JyYWNlX2NoYXIpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NfYXJnX251bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm5hbWVkICN7YGhhc2hfcGFyYW1ldGVyX2tleWB9IGFmdGVyIHVubnVtYmVyZWQoI3tgcG9zX2FyZ19udW1gfSlcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgbnVtYmVyZWRcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zX2FyZ19udW0gPSAtMjtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSB1bmRlZmluZWQgfHwgIWFyZ3NbMF0uJCRpc19oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ29uZSBoYXNoIHJlcXVpcmVkJ31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXh0X2FyZyA9ICN7YGFyZ3NbMF1gLmZldGNoKGBoYXNoX3BhcmFtZXRlcl9rZXlgKX07XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ19icmFjZV9jaGFyID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gbmV4dF9hcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXkgKz0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByYWlzZVxuXG4gICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgIHdpZHRoID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcbiAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGlmIChmbGFncyZGUFJFQzApIHtcbiAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdwcmVjaXNpb24gZ2l2ZW4gdHdpY2UnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZ3MgfD0gRlBSRUN8RlBSRUMwO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIGZsYWdzICY9IH5GUFJFQztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBSRUFEX05VTSgncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIGFyZyA9ICN7OjpLZXJuZWwuSW50ZWdlcihgR0VUX0FSRygpYCl9O1xuICAgICAgICAgICAgaWYgKGFyZyA+PSAwKSB7XG4gICAgICAgICAgICAgIHN0ciA9IGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDI7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzBiJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMSsvO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0ID0gJzEnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDg7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzAnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL14zPzcrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICc3JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDE2O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcweCc7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXmYrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICdmJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmcgPSAjezo6S2VybmVsLkludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSAtICgoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgPyBiYXNlX3ByZWZpeC5sZW5ndGggOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxIC0gKGZsYWdzJkZTSEFSUCA/IDIgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKGFyZyA+Pj4gMCkudG9TdHJpbmcoYmFzZV9udW1iZXIpLnJlcGxhY2UoYmFzZV9uZWdfemVyb19yZWdleCwgYmFzZV9uZWdfemVyb19kaWdpdCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24gLSAyKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtIDIgLSAoZmxhZ3MmRlNIQVJQID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gYmFzZV9uZWdfemVyb19kaWdpdCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIGFyZyA9ICN7OjpLZXJuZWwuRmxvYXQoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCB8fCBpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIGlmIChhcmcgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSBJbmZpbml0eSAmJiAhaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnSW5mJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9GaXhlZChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gcGFyc2VJbnQoc3RyLnNwbGl0KCdlJylbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgIGlmICghKGV4cG9uZW50IDwgLTQgfHwgZXhwb25lbnQgPj0gKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvUHJlY2lzaW9uKHByZWNpc2lvbiA9PT0gLTEgPyAoZmxhZ3MmRlNIQVJQID8gNiA6IHVuZGVmaW5lZCkgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgYXJnICE9PSAtSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFtlRV1bLStdPykoWzAtOV0pJC8sICckMTAkMicpO1xuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBOb3QgaW1wbGVtZW50ZWQgYmVjYXVzZSB0aGVyZSBhcmUgbm8gc3BlY3MgZm9yIHRoaXMgZmllbGQgdHlwZS5cbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCAnYEFgIGFuZCBgYWAgZm9ybWF0IGZpZWxkIHR5cGVzIGFyZSBub3QgaW1wbGVtZW50ZWQgaW4gT3BhbCB5ZXQnfVxuICAgICAgICAgICAgLy8gcmFpc2VcblxuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgYXJnID0gR0VUX0FSRygpO1xuICAgICAgICAgICAgaWYgKCN7YGFyZ2AucmVzcG9uZF90bz8oOnRvX2FyeSl9KSB7IGFyZyA9ICN7YGFyZ2AudG9fYXJ5fVswXTsgfVxuICAgICAgICAgICAgaWYgKCN7YGFyZ2AucmVzcG9uZF90bz8oOnRvX3N0cil9KSB7XG4gICAgICAgICAgICAgIHN0ciA9ICN7YGFyZ2AudG9fc3RyfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJGNvZXJjZV90byhhcmcsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnJWMgcmVxdWlyZXMgYSBjaGFyYWN0ZXInfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgc3RyID0gI3tgR0VUX0FSRygpYC5pbnNwZWN0fTtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLnRvX3N9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlI3tgZm9ybWF0X3N0cmluZy5jaGFyQXQoaSlgfVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBmb3JtYXRfc3RyaW5nLnNsaWNlKGJlZ2luX3NsaWNlLCBlbmRfc2xpY2UpICsgc3RyO1xuICAgICAgICBiZWdpbl9zbGljZSA9IGkgKyAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3skREVCVUd9ICYmIHBvc19hcmdfbnVtID49IDAgJiYgc2VxX2FyZ19udW0gPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RvbyBtYW55IGFyZ3VtZW50cyBmb3IgZm9ybWF0IHN0cmluZyd9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgKyBmb3JtYXRfc3RyaW5nLnNsaWNlKGJlZ2luX3NsaWNlKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNwcmludGYgZm9ybWF0XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiZm9ybWF0IiwiZm9ybWF0X3N0cmluZyIsImFyZ3MiLCJsZW5ndGgiLCIxIiwiW10iLCIwIiwicmVzcG9uZF90bz8iLCJhcnkiLCJPcGFsIiwiY29lcmNlX3RvPyIsIkFycmF5IiwibmlsPyIsInRvX2EiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0b19pbnQiLCJmZXRjaCIsIkludGVnZXIiLCJGbG9hdCIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ0b19hcnkiLCJ0b19zdHIiLCJpbnNwZWN0IiwidG9fcyIsIiRERUJVRyJdLCJtYXBwaW5ncyI6IkFBQUFBLHdEQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7Ozs7O0FBQ0VDLElBQUFBLHNCQUFBQSxrQkFBV0MsYUFBRCxFQUhaLEVBR0VEO0FBQUFBLE1BQUFBO0FBQUFBOzs7O01BSEY7O01BRzRCO01BQ3hCLElBQUcsQ0FBQSxNQUFBRSxJQUFJQyxRQUFBQSxDQUFBQSxDQUFKLEVBQWVDLENBQWYsQ0FBQSxJQUFBLENBQUEsUUFBb0JGLElBQUlHLE9BQUFBLENBQUNDLENBQURELENBQUdFLGdCQUFBQSxDQUFhLFFBQWJBLENBQTNCLENBQUEsQ0FBQSxDQUFIOztRQUNFQyxNQUFNQyxLQUFNQyxlQUFBQSxDQUFZUixJQUFJRyxPQUFBQSxDQUFDQyxDQUFERCxDQUF0QixFQUEyQk0sWUFBM0IsRUFBb0MsUUFBOUJEO1FBQ1osS0FBQSxRQUF1QkYsR0FBR0ksU0FBQUEsQ0FBQUEsQ0FBMUIsQ0FBQTtVQUFBVixPQUFPTSxHQUFHSyxNQUFBQSxDQUFBQTtRQUFWO01BRkY7O0FBTUpiO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSw0QkFBOEJjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIsa0JBQXhCZSxDQUEyQ2Y7QUFDakZBLDRCQUE4QmMsT0FBUUMsT0FBQUEsQ0FB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QTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0JBQW9CYyxPQUFRSyxTQUFBQSxDQUFVbkIsU0FBVm1CLENBQXNCbkI7QUFDbERBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxrQkFBb0JjLE9BQVFNLE9BQUFBLENBQVFwQixTQUFSb0IsQ0FBb0JwQjtBQUNoREE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFlBQWNjLE9BQVFDLE9BQUFBLENBQU9NLDBCQUFmLEVBQXNDckIsZ0VBQTlCZTtBQUN0QmY7O0FBRUFBO0FBQ0FBO0FBQ0FBLGdCQUFrQkEsQ0FBQ0EsR0FBREEsQ0FBS08sZ0JBQUFBLENBQWEsUUFBYkEsQ0FBc0JQLFVBQVlBLENBQUNBLEdBQURBLENBQUtzQixRQUFBQSxDQUFBQSxDQUFRdEI7QUFDdEVBLGdCQUFrQkEsQ0FBQ0EsR0FBREEsQ0FBS08sZ0JBQUFBLENBQWEsUUFBYkEsQ0FBc0JQO0FBQzdDQSxvQkFBc0JBLENBQUNBLEdBQURBLENBQUt1QixRQUFBQSxDQUFBQSxDQUFRdkI7QUFDbkNBO0FBQ0FBLHdEQUEwRG1CLGNBQVVuQjtBQUNwRUE7QUFDQUE7QUFDQUEsY0FBZ0JjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIseUJBQXhCZTtBQUN4QmY7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsU0FBREEsQ0FBV3dCLFNBQUFBLENBQUFBLENBQVN4QjtBQUN4Q0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsU0FBREEsQ0FBV3lCLE1BQUFBLENBQUFBLENBQU16QjtBQUNyQ0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFlBQWNjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDaEIsNkJBQUQsR0FBQSxDQUErQkEsdUJBQS9CLENBQXhCZTtBQUN0QmY7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVljLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIsNkJBQXhCZTtBQUNwQmY7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQSxVQUFZMEIsWUFBTzFCO0FBQ25CQSxRQUFVYyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2hCLHNDQUF4QmU7QUFDbEJmOztBQUVBQTtBQUNBQTtJQTdoQkVBLENBQUFBLElBQUFBO0lBZ2lCQUQsT0FBQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0VBamlCRkEsR0FBTyxJQUFQQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjAyNzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cmluZy9lbmNvZGluZy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL3N0cmluZydcblxuY2xhc3MgOjpFbmNvZGluZ1xuICBkZWYgc2VsZi5yZWdpc3RlcihuYW1lLCBvcHRpb25zID0ge30sICZibG9jaylcbiAgICBuYW1lcyA9IFtuYW1lXSArIChvcHRpb25zWzphbGlhc2VzXSB8fCBbXSlcbiAgICBhc2NpaSA9IG9wdGlvbnNbOmFzY2lpXSB8fCBmYWxzZVxuICAgIGR1bW15ID0gb3B0aW9uc1s6ZHVtbXldIHx8IGZhbHNlXG5cbiAgICBpZiBvcHRpb25zWzppbmhlcml0c11cbiAgICAgIGVuY29kaW5nID0gb3B0aW9uc1s6aW5oZXJpdHNdLmNsb25lXG4gICAgICBlbmNvZGluZy5pbml0aWFsaXplKG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgZWxzZVxuICAgICAgZW5jb2RpbmcgPSBuZXcobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcbiAgICBlbmRcbiAgICBlbmNvZGluZy5pbnN0YW5jZV9ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICByZWdpc3RlciA9IGBPcGFsLmVuY29kaW5nc2BcbiAgICBuYW1lcy5lYWNoIGRvIHxlbmNvZGluZ19uYW1lfFxuICAgICAgY29uc3Rfc2V0IGVuY29kaW5nX25hbWUudHIoJy0nLCAnXycpLCBlbmNvZGluZ1xuICAgICAgcmVnaXN0ZXIuSlNbZW5jb2RpbmdfbmFtZV0gPSBlbmNvZGluZ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5maW5kKG5hbWUpXG4gICAgcmV0dXJuIGRlZmF1bHRfZXh0ZXJuYWwgaWYgbmFtZSA9PSA6ZGVmYXVsdF9leHRlcm5hbFxuICAgIGByZXR1cm4gT3BhbC5maW5kX2VuY29kaW5nKG5hbWUpYFxuICBlbmRcblxuICBzaW5nbGV0b25fY2xhc3MuYXR0cl9hY2Nlc3NvciA6ZGVmYXVsdF9leHRlcm5hbFxuXG4gIGF0dHJfcmVhZGVyIDpuYW1lLCA6bmFtZXNcblxuICBkZWYgaW5pdGlhbGl6ZShuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIEBuYW1lICA9IG5hbWVcbiAgICBAbmFtZXMgPSBuYW1lc1xuICAgIEBhc2NpaSA9IGFzY2lpXG4gICAgQGR1bW15ID0gZHVtbXlcbiAgZW5kXG5cbiAgZGVmIGFzY2lpX2NvbXBhdGlibGU/XG4gICAgQGFzY2lpXG4gIGVuZFxuXG4gIGRlZiBkdW1teT9cbiAgICBAZHVtbXlcbiAgZW5kXG5cbiAgZGVmIGJpbmFyeT9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIEBuYW1lXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPEVuY29kaW5nOiN7QG5hbWV9I3snIChkdW1teSknIGlmIEBkdW1teX0+XCJcbiAgZW5kXG5cbiAgIyBtZXRob2RzIHRvIGltcGxlbWVudCBwZXIgZW5jb2RpbmdcbiAgZGVmIGNoYXJzaXplKHN0cmluZylcbiAgICAleHtcbiAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKCEoY2hhcmNvZGUgPj0gMHhEODAwICYmIGNoYXJjb2RlIDw9IDB4REJGRikpIHtcbiAgICAgICAgICBsZW4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgbG93X3N1cnJvZ2F0ZSA9IFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgY2hyID0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNoYXJjb2RlID49IDB4REMwMCAmJiBjaGFyY29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICBsb3dfc3Vycm9nYXRlID0gY2hyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlID49IDB4RDgwMCAmJiBjaGFyY29kZSA8PSAweERCRkYpIHtcbiAgICAgICAgICBjaHIgPSBsb3dfc3Vycm9nYXRlICsgY2hyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmcuZW5jb2RpbmcubmFtZSAhPSBcIlVURi04XCIpIHtcbiAgICAgICAgICBjaHIgPSBuZXcgU3RyaW5nKGNocik7XG4gICAgICAgICAgY2hyLmVuY29kaW5nID0gc3RyaW5nLmVuY29kaW5nO1xuICAgICAgICB9XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBjaHIpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZSgqKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoKilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgY2xhc3MgOjpFbmNvZGluZ0Vycm9yIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbiAgY2xhc3MgOjpDb21wYXRpYmlsaXR5RXJyb3IgPCA6OkVuY29kaW5nRXJyb3I7IGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi04JywgYWxpYXNlczogWydDUDY1MDAxJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAvLyBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iL2Y1MmRmZmQ5ZGYwNDQ1YjkzYzBjOTA2NWMyZjhmMGY0NmIyYzcyOWEvaW5kZXguanMjTDE5NTQtTDIwMzJcbiAgICAgIHZhciB1bml0cyA9IEluZmluaXR5O1xuICAgICAgdmFyIGNvZGVQb2ludDtcbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkRgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gZW5jb2RlIHV0ZjhcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50YH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiB8IDB4QzBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4QyB8IDB4RTBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW52YWxpZCBjb2RlIHBvaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgc3RyaW5nLmJ5dGVzLmxlbmd0aFxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMTZMRScgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgYHN0cmluZy5sZW5ndGggKiAyYFxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMTZCRScsIGluaGVyaXRzOiA6OkVuY29kaW5nOjpVVEZfMTZMRSBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTMyTEUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICAgICN7eWllbGQgMH07XG4gICAgICAgICN7eWllbGQgMH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoICogNGBcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTMyQkUnLCBpbmhlcml0czogOjpFbmNvZGluZzo6VVRGXzMyTEUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ0FTQ0lJLThCSVQnLCBhbGlhc2VzOiBbJ0JJTkFSWSddLCBhc2NpaTogdHJ1ZSBkb1xuICBkZWYgZWFjaF9jaGFyKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hyID0gbmV3IFN0cmluZyhzdHJpbmcuY2hhckF0KGkpKTtcbiAgICAgICAgY2hyLmVuY29kaW5nID0gc3RyaW5nLmVuY29kaW5nO1xuICAgICAgICAje3lpZWxkIGBjaHJgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaGFyc2l6ZShzdHJpbmcpXG4gICAgYHN0cmluZy5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgYmluYXJ5P1xuICAgIHRydWVcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnSVNPLTg4NTktMScsIGFsaWFzZXM6IFsnSVNPODg1OS0xJ10sIGFzY2lpOiB0cnVlLCBpbmhlcml0czogOjpFbmNvZGluZzo6QVNDSUlfOEJJVFxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVMtQVNDSUknLCBhbGlhc2VzOiBbJ0FTQ0lJJ10sIGFzY2lpOiB0cnVlLCBpbmhlcml0czogOjpFbmNvZGluZzo6QVNDSUlfOEJJVFxuXG5jbGFzcyA6OlN0cmluZ1xuICBhdHRyX3JlYWRlciA6ZW5jb2RpbmdcbiAgYXR0cl9yZWFkZXIgOmludGVybmFsX2VuY29kaW5nXG4gIGBPcGFsLnByb3AoU3RyaW5nLnByb3RvdHlwZSwgJ2J5dGVzJywgbmlsKWBcbiAgYE9wYWwucHJvcChTdHJpbmcucHJvdG90eXBlLCAnZW5jb2RpbmcnLCAjezo6RW5jb2Rpbmc6OlVURl84fSlgXG4gIGBPcGFsLnByb3AoU3RyaW5nLnByb3RvdHlwZSwgJ2ludGVybmFsX2VuY29kaW5nJywgI3s6OkVuY29kaW5nOjpVVEZfOH0pYFxuXG4gIGRlZiBiXG4gICAgZHVwLmZvcmNlX2VuY29kaW5nKCdiaW5hcnknKVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemVcbiAgICBAaW50ZXJuYWxfZW5jb2RpbmcuYnl0ZXNpemUoc2VsZilcbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2J5dGUpIHsgYnl0ZXNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAaW50ZXJuYWxfZW5jb2RpbmcuZWFjaF9ieXRlKHNlbGYsICZibG9jaylcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzXG4gICAgIyBSRU1JTkQ6IHJlcXVpcmVkIHdoZW4gcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgb3RoZXJ3aXNlIHRoZSBmb2xsb3dpbmcgZXJyb3Igd2lsbCBiZSB0aHJvd246XG4gICAgIyBDYW5ub3QgY3JlYXRlIHByb3BlcnR5ICdieXRlcycgb24gc3RyaW5nICdhYmMnXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAje2BuZXcgU3RyaW5nKHNlbGYpYC5lYWNoX2J5dGUudG9fYX07XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGJ5dGVzIHx8PSBlYWNoX2J5dGUudG9fYVxuICAgIEBieXRlcy5kdXBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2NoYXIpIHsgbGVuZ3RoIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgQGVuY29kaW5nLmVhY2hfY2hhcihzZWxmLCAmYmxvY2spXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjaGFycygmYmxvY2spXG4gICAgcmV0dXJuIGVhY2hfY2hhci50b19hIHVubGVzcyBibG9ja1xuXG4gICAgZWFjaF9jaGFyKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29kZXBvaW50KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfY29kZXBvaW50IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICN7eWllbGQgYHNlbGYuY29kZVBvaW50QXQoaSlgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29kZXBvaW50cygmYmxvY2spXG4gICAgIyBJZiBhIGJsb2NrIGlzIGdpdmVuLCB3aGljaCBpcyBhIGRlcHJlY2F0ZWQgZm9ybSwgd29ya3MgdGhlIHNhbWUgYXMgZWFjaF9jb2RlcG9pbnQuXG4gICAgcmV0dXJuIGVhY2hfY29kZXBvaW50KCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgZWFjaF9jb2RlcG9pbnQudG9fYVxuICBlbmRcblxuICBkZWYgZW5jb2RlKGVuY29kaW5nKVxuICAgIGBPcGFsLmVuYyhzZWxmLCBlbmNvZGluZylgXG4gIGVuZFxuXG4gIGRlZiBmb3JjZV9lbmNvZGluZyhlbmNvZGluZylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHN0ci5lbmNvZGluZykgeyByZXR1cm4gc3RyOyB9XG5cbiAgICAgIGVuY29kaW5nID0gI3s6Ok9wYWwuY29lcmNlX3RvIShlbmNvZGluZywgOjpTdHJpbmcsIDp0b19zKX07XG4gICAgICBlbmNvZGluZyA9ICN7OjpFbmNvZGluZy5maW5kKGVuY29kaW5nKX07XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc3RyLmVuY29kaW5nKSB7IHJldHVybiBzdHI7IH1cblxuICAgICAgc3RyID0gT3BhbC5zZXRfZW5jb2Rpbmcoc3RyLCBlbmNvZGluZyk7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2V0Ynl0ZShpZHgpXG4gICAgc3RyaW5nX2J5dGVzID0gYnl0ZXNcbiAgICBpZHggPSA6Ok9wYWwuY29lcmNlX3RvIShpZHgsIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICByZXR1cm4gaWYgc3RyaW5nX2J5dGVzLmxlbmd0aCA8IGlkeFxuXG4gICAgc3RyaW5nX2J5dGVzW2lkeF1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICAle1xuICAgICAgc2VsZi5lbmNvZGluZyA9IG90aGVyLmVuY29kaW5nO1xuICAgICAgc2VsZi5pbnRlcm5hbF9lbmNvZGluZyA9IG90aGVyLmludGVybmFsX2VuY29kaW5nO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGBzZWxmLmxlbmd0aGBcbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICAjIHN0dWJcbiAgZGVmIHZhbGlkX2VuY29kaW5nP1xuICAgIHRydWVcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5kZWZhdWx0X2V4dGVybmFsID0gX19FTkNPRElOR19fXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkVuY29kaW5nPiIsInJlZ2lzdGVyIiwibmFtZSIsIm9wdGlvbnMiLCJuYW1lcyIsIisiLCIkcmV0X29yXzEiLCJbXSIsImFzY2lpIiwiZHVtbXkiLCJlbmNvZGluZyIsImNsb25lIiwiaW5pdGlhbGl6ZSIsIm5ldyIsImJsb2NrX2dpdmVuPyIsImluc3RhbmNlX2V2YWwiLCJibG9jayIsInRvX3Byb2MiLCJlYWNoIiwiYmxvY2sgaW4gcmVnaXN0ZXIiLCJlbmNvZGluZ19uYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWdpc3RlciIsImNvbnN0X3NldCIsInRyIiwiZmluZCIsImRlZmF1bHRfZXh0ZXJuYWwiLCJzaW5nbGV0b25fY2xhc3MiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJAbmFtZSIsIkBuYW1lcyIsIkBhc2NpaSIsIkBkdW1teSIsImFzY2lpX2NvbXBhdGlibGU/IiwiZHVtbXk/IiwiYmluYXJ5PyIsInRvX3MiLCJpbnNwZWN0IiwiY2hhcnNpemUiLCJzdHJpbmciLCJlYWNoX2NoYXIiLCJlYWNoX2J5dGUiLCJLZXJuZWwiLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJieXRlc2l6ZSIsIjxjbGFzczpFbmNvZGluZ0Vycm9yPiIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6Q29tcGF0aWJpbGl0eUVycm9yPiIsIkVuY29kaW5nRXJyb3IiLCJFbmNvZGluZyIsImJsb2NrIGluIDx0b3AgKHJlcXVpcmVkKT4iLCJibG9jayAoMiBsZXZlbHMpIGluIDx0b3AgKHJlcXVpcmVkKT4iLCJieXRlcyIsImxlbmd0aCIsIkVuY29kaW5nOjpVVEZfMTZMRSIsIjAiLCJFbmNvZGluZzo6VVRGXzMyTEUiLCJFbmNvZGluZzo6QVNDSUlfOEJJVCIsIjxjbGFzczpTdHJpbmc+IiwiRW5jb2Rpbmc6OlVURl84IiwiYiIsImR1cCIsImZvcmNlX2VuY29kaW5nIiwiQGludGVybmFsX2VuY29kaW5nIiwiZW51bV9mb3IiLCJibG9jayBpbiBlYWNoX2J5dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfYnl0ZSIsInRvX2EiLCJAYnl0ZXMiLCJibG9jayBpbiBlYWNoX2NoYXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfY2hhciIsIkBlbmNvZGluZyIsImNoYXJzIiwiZWFjaF9jb2RlcG9pbnQiLCJjb2RlcG9pbnRzIiwiZW5jb2RlIiwiT3BhbCIsImNvZXJjZV90byEiLCJTdHJpbmciLCJnZXRieXRlIiwiaWR4Iiwic3RyaW5nX2J5dGVzIiwiSW50ZWdlciIsIjwiLCJpbml0aWFsaXplX2NvcHkiLCJvdGhlciIsInZhbGlkX2VuY29kaW5nPyIsIiR3cml0ZXIiLCJkZWZhdWx0X2V4dGVybmFsPSIsIi0iLCIxIl0sIm1hcHBpbmdzIjoiQUFBQUEsMERBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBRUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlILElBQUpHLGVBQUFBLG9CQUFrQkMsSUFBRCxFQUFPQyxPQUF4QkY7QUFBQUEsTUFBQUE7O01BQUFBOzs7O01BQXdCLCtCQUFVLFlBQUEsRUFBVjtNQUN0QkcsUUFBZUMsU0FBUCxDQUFDSCxJQUFELENBQU9HLEVBQUcsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBSCxPQUFPSSxPQUFBQSxDQUFDLFNBQURBLENBQVBELENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQXFCLEVBQXJCLENBQUEsQ0FBSEQ7TUFDZkcsUUFBUSxDQUFBLFFBQUFGLENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsT0FBREEsQ0FBUEQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxTQUFBLENBQUE7TUFDUkcsUUFBUSxDQUFBLFFBQUFILENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsT0FBREEsQ0FBUEQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxTQUFBLENBQUE7TUFFUixJQUFBLFFBQUdILE9BQU9JLE9BQUFBLENBQUMsVUFBREEsQ0FBVixDQUFBOztRQUNFRyxXQUFXUCxPQUFPSSxPQUFBQSxDQUFDLFVBQURBLENBQVdJLE9BQUFBLENBQUFBO1FBQzdCRCxRQUFRRSxZQUFBQSxDQUFZVixJQUFwQixFQUEwQkUsS0FBMUIsRUFBaUNJLEtBQWpDLEVBQXdD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QSxRQUE4Qk0sT0FBcEJGLFlBQVk1QixRQUFBQSxDQUFBQSxDQUFROEIsRUFBRUgsR0FBRkcsQ0FBOUIsQ0FBQTtRQUFBLE9BQUE7TUFBQTtNQUVBSixPQUFBRSxZQUFZM0UsT0FBQUEsQ0FBQzBFLEdBQUQxRTtJQUxkeUUsQ0FBQUEsR0FBQUE7O0FBUUFLLElBQUFBLCtCQUFBQSwyQkFBb0JDLEtBQXBCRDtBQUFBQTtNQUNFQSxPQUFFQSxJQUFGLEdBQ0pBLHlDQURJLEdBRUpBLDJEQUZJLEdBR0pBO0lBSkVBLENBQUFBLEdBQUFBOztBQU9BL0IsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsV0FBREE7SUFERkEsQ0FBQUEsR0FBQUE7SUFJQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBR0FLLE9BQUE0QiwrQkFBQUEsd0NBQUFBO0FBQUFBO01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsR0FBQUE7RUE3R0Y1QixHQUFNLElBQU5BLEVBQUFBLElBQUFBOztFQS9TQTZCLFVBQUEsQ0FpYThCNUIsSUFqYTlCVixjQWlhOEJVLFVBamE5QjtFQWlhVTZCLE1BQVZ2QyxlQUFVdUMscUJBQUFBLEVBamFWLE1BQUFELE9BQUEsQ0FpYVVDO0VBamFWNUYsT0FBQTJGLE9BQUEsQ0FBQUUsVUFBQUYsT0FBQSxDQUFBM0YsUUFBQSxDQUFBNkYsRUFBQUMsQ0FBQUQsQ0FBQTtBQUFBN0Y7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwODM3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYXRoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvclxuXG5tb2R1bGUgOjpNYXRoXG4gIHNlbGY6OkUgID0gYE1hdGguRWBcbiAgc2VsZjo6UEkgPSBgTWF0aC5QSWBcblxuICBzZWxmOjpEb21haW5FcnJvciA9IDo6Q2xhc3MubmV3KDo6U3RhbmRhcmRFcnJvcilcblxuICBkZWYgc2VsZi5jaGVja2VkKG1ldGhvZCwgKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNOYU4oYXJnc1sxXSkpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBNYXRoW21ldGhvZF0uYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgRG9tYWluRXJyb3IsIFwiTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcXFwiI3ttZXRob2R9XFxcIlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZsb2F0ISh2YWx1ZSlcbiAgICA6Oktlcm5lbC5GbG9hdCh2YWx1ZSlcbiAgcmVzY3VlIDo6QXJndW1lbnRFcnJvclxuICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih2YWx1ZSwgI3s6OkZsb2F0fSlgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmludGVnZXIhKHZhbHVlKVxuICAgIDo6S2VybmVsLkludGVnZXIodmFsdWUpXG4gIHJlc2N1ZSA6OkFyZ3VtZW50RXJyb3JcbiAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IodmFsdWUsICN7OjpJbnRlZ2VyfSlgXG4gIGVuZFxuXG4gIG1vZHVsZV9mdW5jdGlvblxuXG4gIGRlZiBhY29zKHgpXG4gICAgOjpNYXRoLmNoZWNrZWQgOmFjb3MsIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmFjb3NoYClcbiAgICAleHtcbiAgICAgIE1hdGguYWNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4IC0gMSkpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFjb3NoKHgpXG4gICAgOjpNYXRoLmNoZWNrZWQgOmFjb3NoLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBhc2luKHgpXG4gICAgOjpNYXRoLmNoZWNrZWQgOmFzaW4sIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmFzaW5oYClcbiAgICAleHtcbiAgICAgIE1hdGguYXNpbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXNpbmgoeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6YXNpbmgsIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGF0YW4oeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6YXRhbiwgOjpNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgYXRhbjIoeSwgeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6YXRhbjIsIDo6TWF0aC5mbG9hdCEoeSksIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmF0YW5oYClcbiAgICAleHtcbiAgICAgIE1hdGguYXRhbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAwLjUgKiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXRhbmgoeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6YXRhbmgsIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmNicnRgKVxuICAgICV4e1xuICAgICAgTWF0aC5jYnJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gLU1hdGguY2JydCgteCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciAgPSB4LFxuICAgICAgICAgICAgZXggPSAwO1xuXG4gICAgICAgIHdoaWxlIChyIDwgMC4xMjUpIHtcbiAgICAgICAgICByICo9IDg7XG4gICAgICAgICAgZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyID4gMS4wKSB7XG4gICAgICAgICAgciAqPSAwLjEyNTtcbiAgICAgICAgICBleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgciA9ICgtMC40Njk0NjExNiAqIHIgKyAxLjA3MjMwMikgKiByICsgMC4zODEyNTEzO1xuXG4gICAgICAgIHdoaWxlIChleCA8IDApIHtcbiAgICAgICAgICByICo9IDAuNTtcbiAgICAgICAgICBleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGV4ID4gMCkge1xuICAgICAgICAgIHIgKj0gMjtcbiAgICAgICAgICBleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuICAgICAgICByID0gKDIuMCAvIDMuMCkgKiByICsgKDEuMCAvIDMuMCkgKiB4IC8gKHIgKiByKTtcbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2JydCh4KVxuICAgIDo6TWF0aC5jaGVja2VkIDpjYnJ0LCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBjb3MoeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6Y29zLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5jb3NoYClcbiAgICAleHtcbiAgICAgIE1hdGguY29zaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvc2goeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6Y29zaCwgOjpNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguZXJmYClcbiAgICAleHtcbiAgICAgIE9wYWwucHJvcChNYXRoLCAnZXJmJywgZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgQTEgPSAgMC4yNTQ4Mjk1OTIsXG4gICAgICAgICAgICBBMiA9IC0wLjI4NDQ5NjczNixcbiAgICAgICAgICAgIEEzID0gIDEuNDIxNDEzNzQxLFxuICAgICAgICAgICAgQTQgPSAtMS40NTMxNTIwMjcsXG4gICAgICAgICAgICBBNSA9ICAxLjA2MTQwNTQyOSxcbiAgICAgICAgICAgIFAgID0gIDAuMzI3NTkxMTtcblxuICAgICAgICB2YXIgc2lnbiA9IDE7XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gTWF0aC5hYnMoeCk7XG5cbiAgICAgICAgdmFyIHQgPSAxLjAgLyAoMS4wICsgUCAqIHgpO1xuICAgICAgICB2YXIgeSA9IDEuMCAtICgoKCgoQTUgKiB0ICsgQTQpICogdCkgKyBBMykgKiB0ICsgQTIpICogdCArIEExKSAqIHQgKiBNYXRoLmV4cCgteCAqIHgpO1xuXG4gICAgICAgIHJldHVybiBzaWduICogeTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVyZih4KVxuICAgIDo6TWF0aC5jaGVja2VkIDplcmYsIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmVyZmNgKVxuICAgICV4e1xuICAgICAgT3BhbC5wcm9wKE1hdGgsICdlcmZjJywgZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgeiA9IE1hdGguYWJzKHgpLFxuICAgICAgICAgICAgdCA9IDEuMCAvICgwLjUgKiB6ICsgMS4wKTtcblxuICAgICAgICB2YXIgQTEgPSB0ICogMC4xNzA4NzI3NyArIC0wLjgyMjE1MjIzLFxuICAgICAgICAgICAgQTIgPSB0ICogQTEgKyAxLjQ4ODUxNTg3LFxuICAgICAgICAgICAgQTMgPSB0ICogQTIgKyAtMS4xMzUyMDM5OCxcbiAgICAgICAgICAgIEE0ID0gdCAqIEEzICsgMC4yNzg4NjgwNyxcbiAgICAgICAgICAgIEE1ID0gdCAqIEE0ICsgLTAuMTg2Mjg4MDYsXG4gICAgICAgICAgICBBNiA9IHQgKiBBNSArIDAuMDk2Nzg0MTgsXG4gICAgICAgICAgICBBNyA9IHQgKiBBNiArIDAuMzc0MDkxOTYsXG4gICAgICAgICAgICBBOCA9IHQgKiBBNyArIDEuMDAwMDIzNjgsXG4gICAgICAgICAgICBBOSA9IHQgKiBBOCxcbiAgICAgICAgICAgIEExMCA9IC16ICogeiAtIDEuMjY1NTEyMjMgKyBBOTtcblxuICAgICAgICB2YXIgYSA9IHQgKiBNYXRoLmV4cChBMTApO1xuXG4gICAgICAgIGlmICh4IDwgMC4wKSB7XG4gICAgICAgICAgcmV0dXJuIDIuMCAtIGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVyZmMoeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6ZXJmYywgOjpNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgZXhwKHgpXG4gICAgOjpNYXRoLmNoZWNrZWQgOmV4cCwgOjpNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgZnJleHAoeClcbiAgICB4ID0gTWF0aC5mbG9hdCEoeClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiBbTmFOLCAwXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ICAgPSBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHgpKSAvIE1hdGgubG9nKDIpKSArIDEsXG4gICAgICAgICAgZnJhYyA9IHggLyBNYXRoLnBvdygyLCBleCk7XG5cbiAgICAgIHJldHVybiBbZnJhYywgZXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdhbW1hKG4pXG4gICAgbiA9IE1hdGguZmxvYXQhKG4pXG5cbiAgICAleHtcbiAgICAgIHZhciBpLCB0LCB4LCB2YWx1ZSwgcmVzdWx0LCB0d29OLCB0aHJlZU4sIGZvdXJOLCBmaXZlTjtcblxuICAgICAgdmFyIEcgPSA0Ljc0MjE4NzU7XG5cbiAgICAgIHZhciBQID0gW1xuICAgICAgICAgMC45OTk5OTk5OTk5OTk5OTcwOTE4MixcbiAgICAgICAgIDU3LjE1NjIzNTY2NTg2MjkyMzUxNyxcbiAgICAgICAgLTU5LjU5Nzk2MDM1NTQ3NTQ5MTI0OCxcbiAgICAgICAgIDE0LjEzNjA5Nzk3NDc0MTc0NzE3NCxcbiAgICAgICAgLTAuNDkxOTEzODE2MDk3NjIwMTk5NzgsXG4gICAgICAgICAwLjMzOTk0NjQ5OTg0ODExODg4Njk5ZS00LFxuICAgICAgICAgMC40NjUyMzYyODkyNzA0ODU3NTY2NWUtNCxcbiAgICAgICAgLTAuOTgzNzQ0NzUzMDQ4Nzk1NjQ2NzdlLTQsXG4gICAgICAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLFxuICAgICAgICAtMC4yMTAyNjQ0NDE3MjQxMDQ4ODMxOWUtMyxcbiAgICAgICAgIDAuMjE3NDM5NjE4MTE1MjEyNjQzMjBlLTMsXG4gICAgICAgIC0wLjE2NDMxODEwNjUzNjc2Mzg5MDIyZS0zLFxuICAgICAgICAgMC44NDQxODIyMzk4Mzg1Mjc0MzI5M2UtNCxcbiAgICAgICAgLTAuMjYxOTA4Mzg0MDE1ODE0MDg2NzBlLTQsXG4gICAgICAgICAwLjM2ODk5MTgyNjU5NTMxNjIyNzA0ZS01XG4gICAgICBdO1xuXG5cbiAgICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcbiAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IC0xIHx8IG4gPT09IC1JbmZpbml0eSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIERvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImdhbW1hXCInfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7SW50ZWdlciA9PT0gbn0pIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpc0Zpbml0ZShuKSA/IEluZmluaXR5IDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPiAxNzEpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAgPSBuIC0gMjtcbiAgICAgICAgcmVzdWx0ID0gbiAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlID4gMSkge1xuICAgICAgICAgIHJlc3VsdCAqPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PSAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuIDwgMC41KSB7XG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiBuKSAqICN7OjpNYXRoLmdhbW1hKDEgLSBuKX0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA+PSAxNzEuMzUpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA+IDg1LjApIHtcbiAgICAgICAgdHdvTiAgID0gbiAqIG47XG4gICAgICAgIHRocmVlTiA9IHR3b04gKiBuO1xuICAgICAgICBmb3VyTiAgPSB0aHJlZU4gKiBuO1xuICAgICAgICBmaXZlTiAgPSBmb3VyTiAqIG47XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSAvIG4pICogTWF0aC5wb3coKG4gLyBNYXRoLkUpLCBuKSAqXG4gICAgICAgICAgKDEgKyAxIC8gKDEyICogbikgKyAxIC8gKDI4OCAqIHR3b04pIC0gMTM5IC8gKDUxODQwICogdGhyZWVOKSAtXG4gICAgICAgICAgNTcxIC8gKDI0ODgzMjAgKiBmb3VyTikgKyAxNjM4NzkgLyAoMjA5MDE4ODgwICogZml2ZU4pICtcbiAgICAgICAgICA1MjQ2ODE5IC8gKDc1MjQ2Nzk2ODAwICogZml2ZU4gKiBuKSk7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gMTtcbiAgICAgIHggID0gUFswXTtcblxuICAgICAgZm9yIChpID0gMTsgaSA8IFAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeCArPSBQW2ldIC8gKG4gKyBpKTtcbiAgICAgIH1cblxuICAgICAgdCA9IG4gKyBHICsgMC41O1xuXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKSAqIE1hdGgucG93KHQsIG4gKyAwLjUpICogTWF0aC5leHAoLXQpICogeDtcbiAgICB9XG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5oeXBvdGApXG4gICAgJXh7XG4gICAgICBNYXRoLmh5cG90ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaHlwb3QoeCwgeSlcbiAgICA6Ok1hdGguY2hlY2tlZCA6aHlwb3QsIDo6TWF0aC5mbG9hdCEoeCksIDo6TWF0aC5mbG9hdCEoeSlcbiAgZW5kXG5cbiAgZGVmIGxkZXhwKG1hbnRpc3NhLCBleHBvbmVudClcbiAgICBtYW50aXNzYSA9IE1hdGguZmxvYXQhKG1hbnRpc3NhKVxuICAgIGV4cG9uZW50ID0gTWF0aC5pbnRlZ2VyIShleHBvbmVudClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKGV4cG9uZW50KSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Zsb2F0IE5hTiBvdXQgb2YgcmFuZ2Ugb2YgaW50ZWdlcid9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGdhbW1hKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiA9PSAtMSkge1xuICAgICAgICByZXR1cm4gW0luZmluaXR5LCAxXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW01hdGgubG9nKE1hdGguYWJzKCN7OjpNYXRoLmdhbW1hKG4pfSkpLCAjezo6TWF0aC5nYW1tYShuKX0gPCAwID8gLTEgOiAxXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2coeCwgYmFzZSA9IHVuZGVmaW5lZClcbiAgICBpZiA6OlN0cmluZyA9PT0geFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgaWYgYGJhc2UgPT0gbnVsbGBcbiAgICAgIDo6TWF0aC5jaGVja2VkIDpsb2csIDo6TWF0aC5mbG9hdCEoeClcbiAgICBlbHNlXG4gICAgICBpZiA6OlN0cmluZyA9PT0gYmFzZVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IoYmFzZSwgI3s6OkZsb2F0fSlgXG4gICAgICBlbmRcblxuICAgICAgOjpNYXRoLmNoZWNrZWQoOmxvZywgOjpNYXRoLmZsb2F0ISh4KSkgLyA6Ok1hdGguY2hlY2tlZCg6bG9nLCA6Ok1hdGguZmxvYXQhKGJhc2UpKVxuICAgIGVuZFxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgubG9nMTBgKVxuICAgICV4e1xuICAgICAgTWF0aC5sb2cxMCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZzEwKHgpXG4gICAgaWYgOjpTdHJpbmcgPT09IHhcbiAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih4LCAjezo6RmxvYXR9KWBcbiAgICBlbmRcblxuICAgIDo6TWF0aC5jaGVja2VkIDpsb2cxMCwgOjpNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgubG9nMmApXG4gICAgJXh7XG4gICAgICBNYXRoLmxvZzIgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZzIoeClcbiAgICBpZiA6OlN0cmluZyA9PT0geFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgOjpNYXRoLmNoZWNrZWQgOmxvZzIsIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHNpbih4KVxuICAgIDo6TWF0aC5jaGVja2VkIDpzaW4sIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLnNpbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC5zaW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luaCh4KVxuICAgIDo6TWF0aC5jaGVja2VkIDpzaW5oLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBzcXJ0KHgpXG4gICAgOjpNYXRoLmNoZWNrZWQgOnNxcnQsIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHRhbih4KVxuICAgIHggPSA6Ok1hdGguZmxvYXQhKHgpXG5cbiAgICBpZiB4LmluZmluaXRlP1xuICAgICAgcmV0dXJuIDo6RmxvYXQ6Ok5BTlxuICAgIGVuZFxuXG4gICAgOjpNYXRoLmNoZWNrZWQgOnRhbiwgOjpNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgudGFuaGApXG4gICAgJXh7XG4gICAgICBNYXRoLnRhbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeCA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdGFuaCh4KVxuICAgIDo6TWF0aC5jaGVja2VkIDp0YW5oLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6TWF0aD4iLCJzZWxmIiwiQ2xhc3MiLCJuZXciLCJTdGFuZGFyZEVycm9yIiwiY2hlY2tlZCIsIm1ldGhvZCIsIktlcm5lbCIsInJhaXNlIiwiRG9tYWluRXJyb3IiLCJmbG9hdCEiLCJ2YWx1ZSIsIkZsb2F0IiwiQXJndW1lbnRFcnJvciIsImludGVnZXIhIiwiSW50ZWdlciIsIm1vZHVsZV9mdW5jdGlvbiIsImFjb3MiLCJ4IiwiTWF0aCIsImFjb3NoIiwiYXNpbiIsImFzaW5oIiwiYXRhbiIsImF0YW4yIiwieSIsImF0YW5oIiwiY2JydCIsImNvcyIsImNvc2giLCJlcmYiLCJlcmZjIiwiZXhwIiwiZnJleHAiLCJnYW1tYSIsIm4iLCI9PT0iLCItIiwiMSIsImh5cG90IiwibGRleHAiLCJtYW50aXNzYSIsImV4cG9uZW50IiwiUmFuZ2VFcnJvciIsImxnYW1tYSIsImxvZyIsImJhc2UiLCJTdHJpbmciLCIvIiwibG9nMTAiLCJsb2cyIiwic2luIiwic2luaCIsInNxcnQiLCJ0YW4iLCJpbmZpbml0ZT8iLCJGbG9hdDo6TkFOIiwidGFuaCJdLCJtYXBwaW5ncyI6IkFBQUFBLCtDQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRSxXQUFBQyxJQUFBLE9BQVlELE1BQVo7SUFDQSxXQUFBQyxJQUFBLFFBQVlELE9BQVo7SUFFQSxXQUFBQyxJQUFBLGlCQUFvQkMsTUFBT0MsS0FBQUEsQ0FBS0Msb0JBQUxELENBQTNCO0lBRUFFLE1BQUlKLElBQUpJLGNBQUFBLG1CQUFpQkMsTUFBRCxFQVJsQixFQVFFRDtBQUFBQSxNQUFBQTs7OztNQVJGOztNQVEyQjs7QUFFM0JBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUEsUUFBVUUsT0FBUUMsT0FBQUEsQ0FBT0MsaUJBQWYsRUFBNkJKLDBDQUFELEdBQUEsQ0FBMkNDLE1BQTNDLENBQUEsR0FBa0RELElBQXRFRyxDQUEwRUg7QUFDNUZBOztBQUVBQTtBQUNBQTtJQWJFQSxDQUFBQSxJQUFBQTtJQWdCQUssTUFBSVQsSUFBSlMsYUFBQUEsNEJBQWdCQyxLQUFoQkQ7QUFBQUE7TUFDRTtRQUFBQSxPQUFBSCxPQUFRSyxPQUFBQSxDQUFPRCxLQUFQQztNQUFSO1FBQ0Ysc0JBQU8sQ0FBQUMsb0JBQUEsQ0FBUDtVQUFBO1lBQ0VILE9BQUFILE9BQVFDLE9BQUFBLENBQVFFLG1CQUFxQkUsWUFBUUYsQ0FBckNGO1VBRFY7UUFBQSxDQURFO01BQUE7SUFERkUsQ0FBQUEsR0FBQUE7SUFNQUksTUFBSWIsSUFBSmEsZUFBQUEsOEJBQWtCSCxLQUFsQkc7QUFBQUE7TUFDRTtRQUFBQSxPQUFBUCxPQUFRUSxTQUFBQSxDQUFTSixLQUFUSTtNQUFSO1FBQ0Ysc0JBQU8sQ0FBQUYsb0JBQUEsQ0FBUDtVQUFB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RCxDQUFBQSxHQUFBQTtFQTljRnpELEdBQU8sSUFBUEE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxMzQzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wbGV4L2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIDo6S2VybmVsXG4gIGRlZiBDb21wbGV4KHJlYWwsIGltYWcgPSBuaWwpXG4gICAgaWYgaW1hZ1xuICAgICAgQ29tcGxleC5uZXcocmVhbCwgaW1hZylcbiAgICBlbHNlXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCAwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OlN0cmluZ1xuICBkZWYgdG9fY1xuICAgIENvbXBsZXguZnJvbV9zdHJpbmcoc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiQ29tcGxleCIsInJlYWwiLCJpbWFnIiwibmV3IiwiMCIsIjxjbGFzczpTdHJpbmc+IiwidG9fYyIsImZyb21fc3RyaW5nIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUFBLHVEQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsdUJBQUFBLG1CQUFZQyxJQUFELEVBQU9DLElBQWxCRjtBQUFBQTs7O01BQWtCLHlCQUFPLEdBQVA7TUFDaEIsSUFBQSxRQUFHRSxJQUFILENBQUE7UUFDRUYsT0FBQUEsYUFBT0csS0FBQUEsQ0FBS0YsSUFBWixFQUFrQkMsSUFBWEM7TUFEVDtRQUdFSCxPQUFBQSxhQUFPRyxLQUFBQSxDQUFLRixJQUFaLEVBQWtCRyxDQUFYRDtNQUhUO0lBREZILENBQUFBLElBQUFBO0VBREZELEdBQU8sSUFBUEE7RUFVQUQsT0FBQU87RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQyxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBTixhQUFPTyxhQUFBQSxDQUFhQyxJQUFiRDtJQURURCxDQUFBQSxHQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBVkFQOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTM3OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29tcGxleC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5yZXF1aXJlICdjb3JlbGliL2NvbXBsZXgvYmFzZSdcblxuY2xhc3MgOjpDb21wbGV4IDwgOjpOdW1lcmljXG4gIGRlZiBzZWxmLnJlY3QocmVhbCwgaW1hZyA9IDApXG4gICAgdW5sZXNzIDo6TnVtZXJpYyA9PT0gcmVhbCAmJiByZWFsLnJlYWw/ICYmIDo6TnVtZXJpYyA9PT0gaW1hZyAmJiBpbWFnLnJlYWw/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vdCBhIHJlYWwnXG4gICAgZW5kXG5cbiAgICBuZXcocmVhbCwgaW1hZylcbiAgZW5kXG5cbiAgZGVmIHNlbGYucG9sYXIociwgdGhldGEgPSAwKVxuICAgIHVubGVzcyA6Ok51bWVyaWMgPT09IHIgJiYgci5yZWFsPyAmJiA6Ok51bWVyaWMgPT09IHRoZXRhICYmIHRoZXRhLnJlYWw/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vdCBhIHJlYWwnXG4gICAgZW5kXG5cbiAgICBuZXcociAqIDo6TWF0aC5jb3ModGhldGEpLCByICogOjpNYXRoLnNpbih0aGV0YSkpXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpyZWFsLCA6aW1hZ1xuXG4gIGRlZiBpbml0aWFsaXplKHJlYWwsIGltYWcgPSAwKVxuICAgIEByZWFsID0gcmVhbFxuICAgIEBpbWFnID0gaW1hZ1xuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIFtvdGhlciwgc2VsZl1cbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBbOjpDb21wbGV4Lm5ldyhvdGhlciwgMCksIHNlbGZdXG4gICAgZWxzZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tvdGhlci5jbGFzc30gY2FuJ3QgYmUgY29lcmNlZCBpbnRvIENvbXBsZXhcIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgQHJlYWwgPT0gb3RoZXIucmVhbCAmJiBAaW1hZyA9PSBvdGhlci5pbWFnXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQHJlYWwgPT0gb3RoZXIgJiYgQGltYWcgPT0gMFxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgOjpLZXJuZWwuQ29tcGxleCgtQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCArIG90aGVyLnJlYWwsIEBpbWFnICsgb3RoZXIuaW1hZylcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsICsgb3RoZXIsIEBpbWFnKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDorLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsIC0gb3RoZXIucmVhbCwgQGltYWcgLSBvdGhlci5pbWFnKVxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgLSBvdGhlciwgQGltYWcpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi0sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKiBvdGhlci5yZWFsIC0gQGltYWcgKiBvdGhlci5pbWFnLFxuICAgICAgICBAcmVhbCAqIG90aGVyLmltYWcgKyBAaW1hZyAqIG90aGVyLnJlYWwsXG4gICAgICApXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCAqIG90aGVyLCBAaW1hZyAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICBpZiAoOjpOdW1iZXIgPT09IEByZWFsICYmIEByZWFsLm5hbj8pIHx8ICg6Ok51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHxcbiAgICAgICAgICg6Ok51bWJlciA9PT0gb3RoZXIucmVhbCAmJiBvdGhlci5yZWFsLm5hbj8pIHx8ICg6Ok51bWJlciA9PT0gb3RoZXIuaW1hZyAmJiBvdGhlci5pbWFnLm5hbj8pXG4gICAgICAgIDo6Q29tcGxleC5uZXcoOjpGbG9hdDo6TkFOLCA6OkZsb2F0OjpOQU4pXG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYgKiBvdGhlci5jb25qIC8gb3RoZXIuYWJzMlxuICAgICAgZW5kXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbC5xdW8ob3RoZXIpLCBAaW1hZy5xdW8ob3RoZXIpKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgb3RoZXIgPT0gMFxuICAgICAgcmV0dXJuIDo6Q29tcGxleC5uZXcoMSwgMClcbiAgICBlbmRcblxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIHIsIHRoZXRhID0gcG9sYXJcbiAgICAgIG9yZSAgICAgID0gb3RoZXIucmVhbFxuICAgICAgb2ltICAgICAgPSBvdGhlci5pbWFnXG4gICAgICBuciAgICAgICA9IDo6TWF0aC5leHAob3JlICogOjpNYXRoLmxvZyhyKSAtIG9pbSAqIHRoZXRhKVxuICAgICAgbnRoZXRhICAgPSB0aGV0YSAqIG9yZSArIG9pbSAqIDo6TWF0aC5sb2cocilcblxuICAgICAgOjpDb21wbGV4LnBvbGFyKG5yLCBudGhldGEpXG4gICAgZWxzaWYgOjpJbnRlZ2VyID09PSBvdGhlclxuICAgICAgaWYgb3RoZXIgPiAwXG4gICAgICAgIHggPSBzZWxmXG4gICAgICAgIHogPSB4XG4gICAgICAgIG4gPSBvdGhlciAtIDFcblxuICAgICAgICB3aGlsZSBuICE9IDBcbiAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgd2hpbGUgbW9kID09IDBcbiAgICAgICAgICAgIHggPSA6Oktlcm5lbC5Db21wbGV4KHgucmVhbCAqIHgucmVhbCAtIHguaW1hZyAqIHguaW1hZywgMiAqIHgucmVhbCAqIHguaW1hZylcbiAgICAgICAgICAgIG4gPSBkaXZcbiAgICAgICAgICAgIGRpdiwgbW9kID0gbi5kaXZtb2QoMilcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIHogKj0geFxuICAgICAgICAgIG4gLT0gMVxuICAgICAgICBlbmRcblxuICAgICAgICB6XG4gICAgICBlbHNlXG4gICAgICAgICg6OlJhdGlvbmFsLm5ldygxLCAxKSAvIHNlbGYpKiotb3RoZXJcbiAgICAgIGVuZFxuICAgIGVsc2lmIDo6RmxvYXQgPT09IG90aGVyIHx8IDo6UmF0aW9uYWwgPT09IG90aGVyXG4gICAgICByLCB0aGV0YSA9IHBvbGFyXG5cbiAgICAgIDo6Q29tcGxleC5wb2xhcihyKipvdGhlciwgdGhldGEgKiBvdGhlcilcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICA6Ok1hdGguaHlwb3QoQHJlYWwsIEBpbWFnKVxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIEByZWFsICogQHJlYWwgKyBAaW1hZyAqIEBpbWFnXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIDo6TWF0aC5hdGFuMihAaW1hZywgQHJlYWwpXG4gIGVuZFxuXG4gIGRlZiBjb25qXG4gICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCwgLUBpbWFnKVxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAcmVhbC5kZW5vbWluYXRvci5sY20oQGltYWcuZGVub21pbmF0b3IpXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIENvbXBsZXggPT09IG90aGVyICYmIEByZWFsLmNsYXNzID09IEBpbWFnLmNsYXNzICYmIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZkaXYob3RoZXIpXG4gICAgdW5sZXNzIDo6TnVtZXJpYyA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcblxuICAgIHNlbGYgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIEByZWFsLmZpbml0ZT8gJiYgQGltYWcuZmluaXRlP1xuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFwiQ29tcGxleDoje0ByZWFsfToje0BpbWFnfVwiXG4gIGVuZFxuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICBAcmVhbC5pbmZpbml0ZT8gfHwgQGltYWcuaW5maW5pdGU/XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgZCA9IGRlbm9taW5hdG9yXG5cbiAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsLm51bWVyYXRvciAqIChkIC8gQHJlYWwuZGVub21pbmF0b3IpLFxuICAgICAgQGltYWcubnVtZXJhdG9yICogKGQgLyBAaW1hZy5kZW5vbWluYXRvciksXG4gICAgKVxuICBlbmRcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBAaW1hZyAhPSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgcmVhbC5yYXRpb25hbGl6ZShlcHMpXG4gIGVuZFxuXG4gIGRlZiByZWFsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiByZWN0XG4gICAgW0ByZWFsLCBAaW1hZ11cbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEZsb2F0XCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2ZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgQHJlYWwudG9faVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgQHJlYWwudG9fclxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIHJlc3VsdCA9IEByZWFsLmluc3BlY3RcblxuICAgIHJlc3VsdCArPVxuICAgICAgaWYgKDo6TnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fCBAaW1hZy5wb3NpdGl2ZT8gfHwgQGltYWcuemVybz9cbiAgICAgICAgJysnXG4gICAgICBlbHNlXG4gICAgICAgICctJ1xuICAgICAgZW5kXG5cbiAgICByZXN1bHQgKz0gQGltYWcuYWJzLmluc3BlY3RcblxuICAgIGlmIDo6TnVtYmVyID09PSBAaW1hZyAmJiAoQGltYWcubmFuPyB8fCBAaW1hZy5pbmZpbml0ZT8pXG4gICAgICByZXN1bHQgKz0gJyonXG4gICAgZW5kXG5cbiAgICByZXN1bHQgKyAnaSdcbiAgZW5kXG5cbiAgSSA9IG5ldygwLCAxKVxuXG4gIGRlZiBzZWxmLmZyb21fc3RyaW5nKHN0cilcbiAgICAleHtcbiAgICAgIHZhciByZSA9IC9bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/KGVcXGQrKT8vLFxuICAgICAgICAgIG1hdGNoID0gc3RyLm1hdGNoKHJlKSxcbiAgICAgICAgICByZWFsLCBpbWFnLCBkZW5vbWluYXRvcjtcblxuICAgICAgZnVuY3Rpb24gaXNGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3V0RmxvYXQoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtYXRjaFswXTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKG51bWJlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGVzIGJvdGggZmxvYXRzIGFuZCByYXRpb25hbHNcbiAgICAgIGZ1bmN0aW9uIGN1dE51bWJlcigpIHtcbiAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgIHZhciBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuXG4gICAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAvLyByYXRpb25hbCByZWFsIHBhcnRcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcblxuICAgICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuICAgICAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgbnVtZXJhdG9yYCwgYGRlbm9taW5hdG9yYCl9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmV2ZXJ0aW5nICcvJ1xuICAgICAgICAgICAgICBzdHIgPSAnLycgKyBzdHI7XG4gICAgICAgICAgICAgIHJldHVybiBudW1lcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZsb2F0IHJlYWwgcGFydCwgbm8gZGVub21pbmF0b3JcbiAgICAgICAgICAgIHJldHVybiBudW1lcmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlYWwgPSBjdXROdW1iZXIoKTtcblxuICAgICAgaWYgKCFyZWFsKSB7XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICdpJykge1xuICAgICAgICAgIC8vIGkgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICctJyAmJiBzdHJbMV0gPT09ICdpJykge1xuICAgICAgICAgIC8vIC1pID0+IENvbXBsZXgoMCwgLTEpXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCAtMSl9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcrJyAmJiBzdHJbMV0gPT09ICdpJykge1xuICAgICAgICAgIC8vICtpID0+IENvbXBsZXgoMCwgMSlcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KDAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbnl0aGluZyA9PiBDb21wbGV4KDAsIDApXG4gICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgMCl9O1xuICAgICAgfVxuXG4gICAgICBpbWFnID0gY3V0TnVtYmVyKCk7XG4gICAgICBpZiAoIWltYWcpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gM2kgPT4gQ29tcGxleCgwLCAzKVxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgYHJlYWxgKX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gMyA9PiBDb21wbGV4KDMsIDApXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleChgcmVhbGAsIDApfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMysyaSA9PiBDb21wbGV4KDMsIDIpXG4gICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoYHJlYWxgLCBgaW1hZ2ApfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBjb25qdWdhdGUgY29ualxuICBhbGlhcyBkaXZpZGUgL1xuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG4gIGFsaWFzIHBoYXNlIGFyZ1xuICBhbGlhcyBxdW8gL1xuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5cbiAgdW5kZWYgbmVnYXRpdmU/XG4gIHVuZGVmIHBvc2l0aXZlP1xuICB1bmRlZiBzdGVwXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6Q29tcGxleD4iLCJyZWN0IiwicmVhbCIsImltYWciLCIwIiwiTnVtZXJpYyIsInJlYWw/IiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuZXciLCJwb2xhciIsInIiLCJ0aGV0YSIsIioiLCJNYXRoIiwiY29zIiwic2luIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQHJlYWwiLCJAaW1hZyIsImNvZXJjZSIsIm90aGVyIiwiQ29tcGxleCIsImNsYXNzIiwiPT0iLCIkcmV0X29yXzEiLCItQCIsIisiLCJfX2NvZXJjZWRfXyIsIi0iLCIvIiwiTnVtYmVyIiwibmFuPyIsIkZsb2F0OjpOQU4iLCJGbG9hdCIsImNvbmoiLCJhYnMyIiwicXVvIiwiKioiLCIxIiwib3JlIiwib2ltIiwibnIiLCJleHAiLCJsb2ciLCJudGhldGEiLCJJbnRlZ2VyIiwiPiIsIngiLCJ6IiwibiIsImRpdm1vZCIsIjIiLCJkaXYiLCJtb2QiLCJSYXRpb25hbCIsImFicyIsImh5cG90IiwiYW5nbGUiLCJhdGFuMiIsImRlbm9taW5hdG9yIiwibGNtIiwiZXFsPyIsIiRyZXRfb3JfMiIsIj09PSIsImZkaXYiLCJmaW5pdGU/IiwiaGFzaCIsImluZmluaXRlPyIsImluc3BlY3QiLCJudW1lcmF0b3IiLCJkIiwiYXJnIiwicmF0aW9uYWxpemUiLCJlcHMiLCJBcmd1bWVudEVycm9yIiwiUmFuZ2VFcnJvciIsInRvX2YiLCJ0b19pIiwidG9fciIsInRvX3MiLCJyZXN1bHQiLCJwb3NpdGl2ZT8iLCJ6ZXJvPyIsImZyb21fc3RyaW5nIiwic3RyIiwiLTEiXSwibWFwcGluZ3MiOiJBQUFBQSxrREFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsc0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlILElBQUpHLFdBQUFBLGdCQUFjQyxJQUFELEVBQU9DLElBQXBCRjtBQUFBQSxNQUFBQTs7OztNQUFvQix5QkFBT0csQ0FBUDtNQUNsQixLQUFPLENBQUEsQ0FBQSxDQUFBLFFBQUFDLGNBQUEsRUFBY0gsSUFBZCxDQUFBLElBQUEsQ0FBQSxRQUFzQkEsSUFBSUksVUFBQUEsQ0FBQUEsQ0FBMUIsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLFFBQW9DRCxjQUFwQyxFQUFrREYsSUFBbEQsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLFFBQTBEQSxJQUFJRyxVQUFBQSxDQUFBQSxDQUE5RCxDQUFBLENBQUEsQ0FBUDtRQUNFQyxPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE0QlIsWUFBcEJPO01BRFY7TUFJQVAsT0FBQUgsSUFBQVksS0FBQUEsQ0FBSVIsSUFBSixFQUFVQyxJQUFWTztJQUxGVCxDQUFBQSxJQUFBQTtJQVFBVSxNQUFJYixJQUFKYSxZQUFBQSxpQkFBZUMsQ0FBRCxFQUFJQyxLQUFsQkY7QUFBQUEsTUFBQUE7Ozs7TUFBa0IsMkJBQVFQLENBQVI7TUFDaEIsS0FBTyxDQUFBLENBQUEsQ0FBQSxRQUFBQyxjQUFBLEVBQWNPLENBQWQsQ0FBQSxJQUFBLENBQUEsUUFBbUJBLENBQUNOLFVBQUFBLENBQUFBLENBQXBCLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxRQUE4QkQsY0FBOUIsRUFBNENRLEtBQTVDLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxRQUFx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RUFBZ0IsS0FBaEI7SUFDQSxhQUFNLE9BQU4sRUFBWSxLQUFaO0lBQ0EsYUFBTSxLQUFOLEVBQVUsR0FBVjtJQUNBLGFBQU0sYUFBTixFQUFrQixNQUFsQjs7SUFFQSxzQkFBTSxXQUFOOztJQUNBLHNCQUFNLFdBQU47OztJQUNBLHNCQUFNLE1BQU47SUExV0ZFLE9BQUE7RUFHQUEsR0FBTSxJQUFOQSxFQUFrQkssY0FBbEJMO0FBSEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTgyOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgOjpLZXJuZWxcbiAgZGVmIFJhdGlvbmFsKG51bWVyYXRvciwgZGVub21pbmF0b3IgPSAxKVxuICAgIDo6UmF0aW9uYWwuY29udmVydChudW1lcmF0b3IsIGRlbm9taW5hdG9yKVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OlN0cmluZ1xuICBkZWYgdG9fclxuICAgIDo6UmF0aW9uYWwuZnJvbV9zdHJpbmcoc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiUmF0aW9uYWwiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsIjEiLCJjb252ZXJ0IiwiPGNsYXNzOlN0cmluZz4iLCJ0b19yIiwiZnJvbV9zdHJpbmciLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsd0RBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7OztJQUNFQSxPQUFBQyx3QkFBQUEsb0JBQWFDLFNBQUQsRUFBWUMsV0FBeEJGO0FBQUFBOzs7TUFBd0IsdUNBQWNHLENBQWQ7TUFDdEJILE9BQUFBLGVBQVVJLFNBQUFBLENBQVNILFNBQW5CLEVBQThCQyxXQUFwQkU7SUFEWkosQ0FBQUEsSUFBQUE7RUFERkQsR0FBTyxJQUFQQTtFQU1BRCxPQUFBTztFQUFBQTs7O0lBQ0VBLE9BQUFDLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFOLGVBQVVPLGFBQUFBLENBQWFDLElBQWJEO0lBRFpELENBQUFBLEdBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFOQVA7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxODU4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYXRpb25hbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsL2Jhc2UnXG5cbmNsYXNzIDo6UmF0aW9uYWwgPCA6Ok51bWVyaWNcbiAgZGVmIHNlbGYucmVkdWNlKG51bSwgZGVuKVxuICAgIG51bSA9IG51bS50b19pXG4gICAgZGVuID0gZGVuLnRvX2lcblxuICAgIGlmIGRlbiA9PSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ1xuICAgIGVsc2lmIGRlbiA8IDBcbiAgICAgIG51bSA9IC1udW1cbiAgICAgIGRlbiA9IC1kZW5cbiAgICBlbHNpZiBkZW4gPT0gMVxuICAgICAgcmV0dXJuIG5ldyhudW0sIGRlbilcbiAgICBlbmRcblxuICAgIGdjZCA9IG51bS5nY2QoZGVuKVxuXG4gICAgbmV3KG51bSAvIGdjZCwgZGVuIC8gZ2NkKVxuICBlbmRcblxuICBkZWYgc2VsZi5jb252ZXJ0KG51bSwgZGVuKVxuICAgIGlmIG51bS5uaWw/IHx8IGRlbi5uaWw/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2Nhbm5vdCBjb252ZXJ0IG5pbCBpbnRvIFJhdGlvbmFsJ1xuICAgIGVuZFxuXG4gICAgaWYgOjpJbnRlZ2VyID09PSBudW0gJiYgOjpJbnRlZ2VyID09PSBkZW5cbiAgICAgIHJldHVybiByZWR1Y2UobnVtLCBkZW4pXG4gICAgZW5kXG5cbiAgICBpZiA6OkZsb2F0ID09PSBudW0gfHwgOjpTdHJpbmcgPT09IG51bSB8fCA6OkNvbXBsZXggPT09IG51bVxuICAgICAgbnVtID0gbnVtLnRvX3JcbiAgICBlbmRcblxuICAgIGlmIDo6RmxvYXQgPT09IGRlbiB8fCA6OlN0cmluZyA9PT0gZGVuIHx8IDo6Q29tcGxleCA9PT0gZGVuXG4gICAgICBkZW4gPSBkZW4udG9fclxuICAgIGVuZFxuXG4gICAgaWYgZGVuLmVxdWFsPygxKSAmJiAhKDo6SW50ZWdlciA9PT0gbnVtKVxuICAgICAgOjpPcGFsLmNvZXJjZV90byEobnVtLCA6OlJhdGlvbmFsLCA6dG9fcilcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG51bSAmJiA6Ok51bWVyaWMgPT09IGRlblxuICAgICAgbnVtIC8gZGVuXG4gICAgZWxzZVxuICAgICAgcmVkdWNlKG51bSwgZGVuKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShudW0sIGRlbilcbiAgICBAbnVtID0gbnVtXG4gICAgQGRlbiA9IGRlblxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgQG51bVxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAZGVuXG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgW290aGVyLCBzZWxmXVxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIFtvdGhlci50b19yLCBzZWxmXVxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICBbb3RoZXIsIHRvX2ZdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBAbnVtID09IG90aGVyLm51bWVyYXRvciAmJiBAZGVuID09IG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgQG51bSA9PSBvdGhlciAmJiBAZGVuID09IDFcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiA9PSBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgb3RoZXIgPT0gc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIEBudW0gKiBvdGhlci5kZW5vbWluYXRvciAtIEBkZW4gKiBvdGhlci5udW1lcmF0b3IgPD0+IDBcblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICBAbnVtIC0gQGRlbiAqIG90aGVyIDw9PiAwXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YgPD0+IG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6PD0+LCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgKyBAZGVuICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSArIG90aGVyICogQGRlbiwgQGRlbilcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiArIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yIC0gQGRlbiAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0gLSBvdGhlciAqIEBkZW4sIEBkZW4pXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YgLSBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi0sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtICogb3RoZXIsIEBkZW4pXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YgKiBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLm51bWVyYXRvclxuXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICBpZiBvdGhlciA9PSAwXG4gICAgICAgIHRvX2YgLyAwLjBcbiAgICAgIGVsc2VcbiAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSwgQGRlbiAqIG90aGVyKVxuICAgICAgZW5kXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YgLyBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi8sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIGlmIHNlbGYgPT0gMCAmJiBvdGhlciA8IDBcbiAgICAgICAgOjpGbG9hdDo6SU5GSU5JVFlcbiAgICAgIGVsc2lmIG90aGVyID4gMFxuICAgICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtKipvdGhlciwgQGRlbioqb3RoZXIpXG4gICAgICBlbHNpZiBvdGhlciA8IDBcbiAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQGRlbioqLW90aGVyLCBAbnVtKiotb3RoZXIpXG4gICAgICBlbHNlXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKDEsIDEpXG4gICAgICBlbmRcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZioqb3RoZXJcblxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgaWYgb3RoZXIgPT0gMFxuICAgICAgICA6Oktlcm5lbC5SYXRpb25hbCgxLCAxKVxuICAgICAgZWxzaWYgb3RoZXIuZGVub21pbmF0b3IgPT0gMVxuICAgICAgICBpZiBvdGhlciA8IDBcbiAgICAgICAgICA6Oktlcm5lbC5SYXRpb25hbChAZGVuKipvdGhlci5udW1lcmF0b3IuYWJzLCBAbnVtKipvdGhlci5udW1lcmF0b3IuYWJzKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSoqb3RoZXIubnVtZXJhdG9yLCBAZGVuKipvdGhlci5udW1lcmF0b3IpXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgc2VsZiA9PSAwICYmIG90aGVyIDwgMFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ1xuICAgICAgZWxzZVxuICAgICAgICB0b19mKipvdGhlclxuICAgICAgZW5kXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtLmFicywgQGRlbi5hYnMpXG4gIGVuZFxuXG4gIGRlZiBjZWlsKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgICgtKC1AbnVtIC8gQGRlbikpLmNlaWxcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6Y2VpbCwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZmxvb3IocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuZmxvb3JcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6Zmxvb3IsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBcIlJhdGlvbmFsOiN7QG51bX06I3tAZGVufVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoZXBzID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG5cbiAgICAgIGlmIChlcHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSAje2Vwcy5hYnN9LFxuICAgICAgICAgIGEgPSAje3NlbGYgLSBgZWB9LFxuICAgICAgICAgIGIgPSAje3NlbGYgKyBgZWB9O1xuXG4gICAgICB2YXIgcDAgPSAwLFxuICAgICAgICAgIHAxID0gMSxcbiAgICAgICAgICBxMCA9IDEsXG4gICAgICAgICAgcTEgPSAwLFxuICAgICAgICAgIHAyLCBxMjtcblxuICAgICAgdmFyIGMsIGssIHQ7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGMgPSAje2BhYC5jZWlsfTtcblxuICAgICAgICBpZiAoI3tgY2AgPD0gYGJgfSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgayAgPSBjIC0gMTtcbiAgICAgICAgcDIgPSBrICogcDEgKyBwMDtcbiAgICAgICAgcTIgPSBrICogcTEgKyBxMDtcbiAgICAgICAgdCAgPSAjezEgLyAoYGJgIC0gYGtgKX07XG4gICAgICAgIGIgID0gI3sxIC8gKGBhYCAtIGBrYCl9O1xuICAgICAgICBhICA9IHQ7XG5cbiAgICAgICAgcDAgPSBwMTtcbiAgICAgICAgcTAgPSBxMTtcbiAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgcTEgPSBxMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYGMgKiBwMSArIHAwYCwgYGMgKiBxMSArIHEwYCl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdW5kKHByZWNpc2lvbiA9IDApXG4gICAgcmV0dXJuIHdpdGhfcHJlY2lzaW9uKDpyb3VuZCwgcHJlY2lzaW9uKSB1bmxlc3MgcHJlY2lzaW9uID09IDBcbiAgICByZXR1cm4gMCBpZiBAbnVtID09IDBcbiAgICByZXR1cm4gQG51bSBpZiBAZGVuID09IDFcblxuICAgIG51bSA9IEBudW0uYWJzICogMiArIEBkZW5cbiAgICBkZW4gPSBAZGVuICogMlxuXG4gICAgYXBwcm94ID0gKG51bSAvIGRlbikudHJ1bmNhdGVcblxuICAgIGlmIEBudW0gPCAwXG4gICAgICAtYXBwcm94XG4gICAgZWxzZVxuICAgICAgYXBwcm94XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgQG51bSAvIEBkZW5cbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB0cnVuY2F0ZVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QG51bX0vI3tAZGVufVwiXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICBAbnVtIDwgMCA/IGNlaWwgOiBmbG9vclxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDp0cnVuY2F0ZSwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgd2l0aF9wcmVjaXNpb24obWV0aG9kLCBwcmVjaXNpb24pXG4gICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYW4gSW50ZWdlcicgdW5sZXNzIDo6SW50ZWdlciA9PT0gcHJlY2lzaW9uXG5cbiAgICBwID0gMTAqKnByZWNpc2lvblxuICAgIHMgPSBzZWxmICogcFxuXG4gICAgaWYgcHJlY2lzaW9uIDwgMVxuICAgICAgKHMuc2VuZChtZXRob2QpIC8gcCkudG9faVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKHMuc2VuZChtZXRob2QpLCBwKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5mcm9tX3N0cmluZyhzdHJpbmcpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc3RyaW5nLnRyaW1MZWZ0KCksXG4gICAgICAgICAgcmUgPSAvXlsrLV0/W1xcZF9dKyhcXC5bXFxkX10rKT8vLFxuICAgICAgICAgIG1hdGNoID0gc3RyLm1hdGNoKHJlKSxcbiAgICAgICAgICBudW1lcmF0b3IsIGRlbm9taW5hdG9yO1xuXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xuICAgICAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXRGbG9hdCgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlKTtcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UobnVtYmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgbnVtZXJhdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcblxuICAgICAgICBpZiAoc3RyWzBdID09PSAnLycpIHtcbiAgICAgICAgICAvLyByYXRpb25hbCByZWFsIHBhcnRcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG5cbiAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgICBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG4gICAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgbnVtZXJhdG9yYCwgYGRlbm9taW5hdG9yYCl9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgbnVtZXJhdG9yYCwgMSl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgbnVtZXJhdG9yYCwgMSl9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbCgwLCAxKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBkaXZpZGUgL1xuICBhbGlhcyBxdW8gL1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlJhdGlvbmFsPiIsInJlZHVjZSIsIm51bSIsImRlbiIsInRvX2kiLCIwIiwiS2VybmVsIiwicmFpc2UiLCJaZXJvRGl2aXNpb25FcnJvciIsIjwiLCItQCIsIjEiLCJuZXciLCJnY2QiLCIvIiwiY29udmVydCIsIm5pbD8iLCJUeXBlRXJyb3IiLCJJbnRlZ2VyIiwiRmxvYXQiLCJTdHJpbmciLCJDb21wbGV4IiwidG9fciIsImVxdWFsPyIsIj09PSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiUmF0aW9uYWwiLCJOdW1lcmljIiwiaW5pdGlhbGl6ZSIsIkBudW0iLCJAZGVuIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJjb2VyY2UiLCJvdGhlciIsIiRyZXRfb3JfMSIsInRvX2YiLCI9PSIsIiRyZXRfb3JfMiIsIjw9PiIsIi0iLCIqIiwiX19jb2VyY2VkX18iLCIrIiwiKioiLCJGbG9hdDo6SU5GSU5JVFkiLCI+IiwiYWJzIiwiY2VpbCIsInByZWNpc2lvbiIsIndpdGhfcHJlY2lzaW9uIiwiZmxvb3IiLCJoYXNoIiwiaW5zcGVjdCIsInJhdGlvbmFsaXplIiwiZXBzIiwiQXJndW1lbnRFcnJvciIsIjw9Iiwicm91bmQiLCIyIiwiYXBwcm94IiwidHJ1bmNhdGUiLCJ0b19zIiwibWV0aG9kIiwicCIsIjEwIiwicyIsInNlbmQiLCJmcm9tX3N0cmluZyIsInN0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUFBLG1EQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix1QkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsTUFBSUgsSUFBSkcsYUFBQUEsa0JBQWdCQyxHQUFELEVBQU1DLEdBQXJCRjtBQUFBQSxNQUFBQTs7O01BQ0VDLE1BQU1BLEdBQUdFLE1BQUFBLENBQUFBO01BQ1RELE1BQU1BLEdBQUdDLE1BQUFBLENBQUFBO01BRVQsSUFBQSxNQUFHRCxHQUFILEVBQVVFLENBQVYsQ0FBQTtRQUNFQyxPQUFRQyxPQUFBQSxDQUFPQyx3QkFBZixFQUFvQ1AsY0FBNUJNO01BRFYsT0FFQSxJQUFBLFFBQVVFLE9BQUpOLEdBQUlNLEVBQUVKLENBQUZJLENBQVYsQ0FBQTs7UUFDRVAsTUFBT0EsR0FBRFEsT0FBQUEsQ0FBQUE7UUFDTlAsTUFBT0EsR0FBRE8sT0FBQUEsQ0FBQUE7TUFGUixPQUdBLElBQUEsTUFBTVAs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UXFCLFVBQUFBLENBQVV3QyxDQUFDQyxNQUFBQSxDQUFNSixNQUFOSSxDQUFuQixFQUFrQ0gsQ0FBMUJ0QztNQUhWO0lBTkZ3QixDQUFBQSxHQUFBQTtJQWFBa0IsTUFBSXZFLElBQUp1RSxrQkFBQUEsdUJBQXFCQyxNQUFyQkQ7QUFBQUE7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsbUJBQXFCL0QsT0FBUXFCLFVBQUFBLENBQVcwQyxTQUFuQixFQUFnQ0EsV0FBeEIxQyxDQUFzQzBDO0FBQ25FQTtBQUNBQSxtQkFBcUIvRCxPQUFRcUIsVUFBQUEsQ0FBVzBDLFNBQW5CLEVBQStCMUQsQ0FBdkJnQixDQUEwQjBDO0FBQ3ZEQTtBQUNBQTtBQUNBQSxpQkFBbUIvRCxPQUFRcUIsVUFBQUEsQ0FBVzBDLFNBQW5CLEVBQStCMUQsQ0FBdkJnQixDQUEwQjBDO0FBQ3JEQTtBQUNBQTtBQUNBQSxlQUFpQi9ELE9BQVFxQixVQUFBQSxDQUFVdEIsQ0FBbEIsRUFBcUJNLENBQWJnQixDQUFnQjBDO0FBQ3pDQTtBQUNBQTtJQXJDRUEsQ0FBQUEsR0FBQUE7SUF3Q0EsYUFBTSxRQUFOLEVBQWEsR0FBYjtJQUNBckUsT0FBQSxhQUFNLEtBQU4sRUFBVSxHQUFWO0VBcFlGQSxHQUFNLElBQU5BLEVBQW1CNEIsY0FBbkI1QjtBQUhBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjIzMTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3RpbWUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZVxuXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5cbmNsYXNzIDo6VGltZSA8IGBEYXRlYFxuICBpbmNsdWRlIDo6Q29tcGFyYWJsZVxuXG4gICV4e1xuICAgIHZhciBkYXlzX29mX3dlZWsgPSAjeyV3W1N1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5IFN1bmRheV19LFxuICAgICAgICBzaG9ydF9kYXlzICAgPSAjeyV3W1N1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdF19LFxuICAgICAgICBzaG9ydF9tb250aHMgPSAjeyV3W0phbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXX0sXG4gICAgICAgIGxvbmdfbW9udGhzICA9ICN7JXdbSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlcl19O1xuICB9XG5cbiAgZGVmIHNlbGYuYXQoc2Vjb25kcywgZnJhYyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgjezo6VGltZSA9PT0gc2Vjb25kc30pIHtcbiAgICAgICAgaWYgKGZyYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBUaW1lIGludG8gYW4gZXhhY3QgbnVtYmVyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoc2Vjb25kcy5nZXRUaW1lKCkpO1xuICAgICAgICByZXN1bHQuaXNfdXRjID0gc2Vjb25kcy5pc191dGM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2Vjb25kcy4kJGlzX251bWJlcikge1xuICAgICAgICBzZWNvbmRzID0gI3s6Ok9wYWwuY29lcmNlX3RvIShzZWNvbmRzLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyYWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgZnJhYyA9ICN7OjpPcGFsLmNvZXJjZV90byEoZnJhYywgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZShzZWNvbmRzICogMTAwMCArIChmcmFjIC8gMTAwMCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpIHtcbiAgICAgIGlmICh5ZWFyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHllYXIgPSBwYXJzZUludCh5ZWFyLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ZWFyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgeWVhcmAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPT09IG5pbCkge1xuICAgICAgICBtb250aCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFtb250aC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoI3tgbW9udGhgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgIG1vbnRoID0gI3tgbW9udGhgLnRvX3N0cn07XG4gICAgICAgICAgc3dpdGNoIChtb250aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnamFuJzogbW9udGggPSAgMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZmViJzogbW9udGggPSAgMjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWFyJzogbW9udGggPSAgMzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXByJzogbW9udGggPSAgNDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF5JzogbW9udGggPSAgNTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVuJzogbW9udGggPSAgNjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVsJzogbW9udGggPSAgNzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXVnJzogbW9udGggPSAgODsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VwJzogbW9udGggPSAgOTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb2N0JzogbW9udGggPSAxMDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbm92JzogbW9udGggPSAxMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGVjJzogbW9udGggPSAxMjsgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogbW9udGggPSAje2Btb250aGAudG9faX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vbnRoID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgbW9udGhgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibW9udGggb3V0IG9mIHJhbmdlOiAje2Btb250aGB9XCJ9XG4gICAgICB9XG4gICAgICBtb250aCA9IG1vbnRoIC0gMTtcblxuICAgICAgaWYgKGRheSA9PT0gbmlsKSB7XG4gICAgICAgIGRheSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGRheS4kJGlzX3N0cmluZykge1xuICAgICAgICBkYXkgPSBwYXJzZUludChkYXksIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRheSA9ICN7OjpPcGFsLmNvZXJjZV90byEoYGRheWAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF5IDwgMSB8fCBkYXkgPiAzMSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJkYXkgb3V0IG9mIHJhbmdlOiAje2BkYXlgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA9PT0gbmlsKSB7XG4gICAgICAgIGhvdXIgPSAwO1xuICAgICAgfSBlbHNlIGlmIChob3VyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGhvdXIgPSBwYXJzZUludChob3VyLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3VyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgaG91cmAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA8IDAgfHwgaG91ciA+IDI0KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImhvdXIgb3V0IG9mIHJhbmdlOiAje2Bob3VyYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA9PT0gbmlsKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1pbi4kJGlzX3N0cmluZykge1xuICAgICAgICBtaW4gPSBwYXJzZUludChtaW4sIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbiA9ICN7OjpPcGFsLmNvZXJjZV90byEoYG1pbmAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobWluIDwgMCB8fCBtaW4gPiA1OSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJtaW4gb3V0IG9mIHJhbmdlOiAje2BtaW5gfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VjID09PSBuaWwpIHtcbiAgICAgICAgc2VjID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoIXNlYy4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoc2VjLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgc2VjID0gcGFyc2VJbnQoc2VjLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VjID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgc2VjYCwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA8IDAgfHwgc2VjID4gNjApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic2VjIG91dCBvZiByYW5nZTogI3tgc2VjYH1cIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlY107XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYubmV3KHllYXIgPSB1bmRlZmluZWQsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCB1dGNfb2Zmc2V0ID0gbmlsKVxuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0Y19vZmZzZXQgIT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ09wYWwgZG9lcyBub3Qgc3VwcG9ydCBleHBsaWNpdGx5IHNwZWNpZnlpbmcgVVRDIG9mZnNldCBmb3IgVGltZSd9XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmxvY2FsKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGFyZ3MgID0gJHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgeWVhciAgPSBhcmdzWzVdO1xuICAgICAgICBtb250aCA9IGFyZ3NbNF07XG4gICAgICAgIGRheSAgID0gYXJnc1szXTtcbiAgICAgICAgaG91ciAgPSBhcmdzWzJdO1xuICAgICAgICBtaW4gICA9IGFyZ3NbMV07XG4gICAgICAgIHNlYyAgID0gYXJnc1swXTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCk7XG4gICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuZ20oeWVhciwgbW9udGggPSBuaWwsIGRheSA9IG5pbCwgaG91ciA9IG5pbCwgbWluID0gbmlsLCBzZWMgPSBuaWwsIG1pbGxpc2Vjb25kID0gbmlsLCBfZHVtbXkxID0gbmlsLCBfZHVtbXkyID0gbmlsLCBfZHVtbXkzID0gbmlsKVxuICAgICMgVGhlIF9kdW1teSBhcmdzIGFyZSB0aGVyZSBvbmx5IGJlY2F1c2UgdGhlIE1SSSB2ZXJzaW9uIGFjY2VwdHMgdXAgdG8gMTAgYXJndW1lbnRzXG4gICAgJXh7XG4gICAgICB2YXIgYXJncywgcmVzdWx0O1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgYXJncyAgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB5ZWFyICA9IGFyZ3NbNV07XG4gICAgICAgIG1vbnRoID0gYXJnc1s0XTtcbiAgICAgICAgZGF5ICAgPSBhcmdzWzNdO1xuICAgICAgICBob3VyICA9IGFyZ3NbMl07XG4gICAgICAgIG1pbiAgID0gYXJnc1sxXTtcbiAgICAgICAgc2VjICAgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKSk7XG4gICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICByZXN1bHQuc2V0VVRDRnVsbFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICByZXN1bHQuaXNfdXRjID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5ub3dcbiAgICBuZXdcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgOjpUaW1lID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd0aW1lICsgdGltZT8nXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAjezo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSArIChvdGhlciAqIDEwMDApKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSBzZWxmLmlzX3V0YztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBpZiA6OlRpbWUgPT09IG90aGVyXG4gICAgICByZXR1cm4gYChzZWxmLmdldFRpbWUoKSAtIG90aGVyLmdldFRpbWUoKSkgLyAxMDAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIG90aGVyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgLSAob3RoZXIgKiAxMDAwKSk7XG4gICAgICByZXN1bHQuaXNfdXRjID0gc2VsZi5pc191dGM7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiA6OlRpbWUgPT09IG90aGVyXG4gICAgICB0b19mIDw9PiBvdGhlci50b19mXG4gICAgZWxzZVxuICAgICAgciA9IG90aGVyIDw9PiBzZWxmXG4gICAgICBpZiByLm5pbD9cbiAgICAgICAgbmlsXG4gICAgICBlbHNpZiByID4gMFxuICAgICAgICAtMVxuICAgICAgZWxzaWYgciA8IDBcbiAgICAgICAgMVxuICAgICAgZWxzZVxuICAgICAgICAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIDo6VGltZSA9PT0gb3RoZXIgJiYgYCN7dG9fZn0gPT09ICN7b3RoZXIudG9fZn1gXG4gIGVuZFxuXG4gIGRlZiBhc2N0aW1lXG4gICAgc3RyZnRpbWUgJyVhICViICVlICVIOiVNOiVTICVZJ1xuICBlbmRcblxuICBkZWYgZGF5XG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENEYXRlKCkgOiBzZWxmLmdldERhdGUoKWBcbiAgZW5kXG5cbiAgZGVmIHlkYXlcbiAgICAjIGh0dHA6Ly9qYXZhc2NyaXB0LmFib3V0LmNvbS9saWJyYXJ5L2JsZGF5eWVhci5odG1cbiAgICAjIGFsc28gc2VlIG1vbWVudC5qcyBpbXBsZW1lbnRhdGlvbjogaHR0cDovL2dpdC5pby92Q0tORVxuXG4gICAgc3RhcnRfb2ZfeWVhciA9IFRpbWUubmV3KHllYXIpLnRvX2lcbiAgICBzdGFydF9vZl9kYXkgID0gVGltZS5uZXcoeWVhciwgbW9udGgsIGRheSkudG9faVxuICAgIG9uZV9kYXkgICAgICAgPSA4Nl80MDBcblxuICAgICgoc3RhcnRfb2ZfZGF5IC0gc3RhcnRfb2ZfeWVhcikgLyBvbmVfZGF5KS5yb3VuZCArIDFcbiAgZW5kXG5cbiAgZGVmIGlzZHN0XG4gICAgJXh7XG4gICAgICB2YXIgamFuID0gbmV3IERhdGUoc2VsZi5nZXRGdWxsWWVhcigpLCAwLCAxKSxcbiAgICAgICAgICBqdWwgPSBuZXcgRGF0ZShzZWxmLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICAgICAgcmV0dXJuIHNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IGBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSlgXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBvdGhlci5pc19hPyg6OlRpbWUpICYmIChzZWxmIDw9PiBvdGhlcikuemVybz9cbiAgZW5kXG5cbiAgZGVmIGZyaWRheT9cbiAgICBgI3t3ZGF5fSA9PSA1YFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGAnVGltZTonICsgc2VsZi5nZXRUaW1lKClgXG4gIGVuZFxuXG4gIGRlZiBob3VyXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENIb3VycygpIDogc2VsZi5nZXRIb3VycygpYFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGlmIHV0Yz9cbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyBVVEMnXG4gICAgZWxzZVxuICAgICAgc3RyZnRpbWUgJyVZLSVtLSVkICVIOiVNOiVTICV6J1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWluXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENNaW51dGVzKCkgOiBzZWxmLmdldE1pbnV0ZXMoKWBcbiAgZW5kXG5cbiAgZGVmIG1vblxuICAgIGAoc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ01vbnRoKCkgOiBzZWxmLmdldE1vbnRoKCkpICsgMWBcbiAgZW5kXG5cbiAgZGVmIG1vbmRheT9cbiAgICBgI3t3ZGF5fSA9PSAxYFxuICBlbmRcblxuICBkZWYgc2F0dXJkYXk/XG4gICAgYCN7d2RheX0gPT0gNmBcbiAgZW5kXG5cbiAgZGVmIHNlY1xuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDU2Vjb25kcygpIDogc2VsZi5nZXRTZWNvbmRzKClgXG4gIGVuZFxuXG4gIGRlZiBzdWNjXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAxMDAwKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSBzZWxmLmlzX3V0YztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXNlY1xuICAgIGBzZWxmLmdldE1pbGxpc2Vjb25kcygpICogMTAwMGBcbiAgZW5kXG5cbiAgZGVmIHpvbmVcbiAgICAleHtcbiAgICAgIHZhciBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJygnKSA9PSAtMSkge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1tBLVpdezMsNH0vKVswXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1xcKCguKylcXCkoPzpcXHN8JCkvKVsxXVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ID09IFwiR01UXCIgJiYgLyhHTVRcXFcqXFxkezR9KS8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBSZWdFeHAuJDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRnbVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnbXRpbWVcbiAgICAleHtcbiAgICAgIHNlbGYuaXNfdXRjID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdtdD9cbiAgICBgc2VsZi5pc191dGMgPT09IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBnbXRfb2Zmc2V0XG4gICAgYHNlbGYuaXNfdXRjID8gMCA6IC1zZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MGBcbiAgZW5kXG5cbiAgZGVmIHN0cmZ0aW1lKGZvcm1hdClcbiAgICAleHtcbiAgICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJShbXFwtXyNeMF0qOnswLDJ9KShcXGQrKT8oW0VPXSopKC4pL2csIGZ1bmN0aW9uKGZ1bGwsIGZsYWdzLCB3aWR0aCwgXywgY29udikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgICAgICAgIHplcm8gICA9IGZsYWdzLmluZGV4T2YoJzAnKSAhPT0gLTEsXG4gICAgICAgICAgICBwYWQgICAgPSBmbGFncy5pbmRleE9mKCctJykgPT09IC0xLFxuICAgICAgICAgICAgYmxhbmsgID0gZmxhZ3MuaW5kZXhPZignXycpICE9PSAtMSxcbiAgICAgICAgICAgIHVwY2FzZSA9IGZsYWdzLmluZGV4T2YoJ14nKSAhPT0gLTEsXG4gICAgICAgICAgICBpbnZlcnQgPSBmbGFncy5pbmRleE9mKCcjJykgIT09IC0xLFxuICAgICAgICAgICAgY29sb25zID0gKGZsYWdzLm1hdGNoKCc6JykgfHwgW10pLmxlbmd0aDtcblxuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG5cbiAgICAgICAgaWYgKHplcm8gJiYgYmxhbmspIHtcbiAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZignMCcpIDwgZmxhZ3MuaW5kZXhPZignXycpKSB7XG4gICAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNvbnYpIHtcbiAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3llYXJ9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5yb3VuZCgje3llYXJ9IC8gMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3llYXJ9ICUgMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7bW9ufTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICByZXN1bHQgKz0gbG9uZ19tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X21vbnRoc1sje21vbn0gLSAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVyb1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgd2lkdGggICA9IGlzTmFOKHdpZHRoKSA/IDMgOiB3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3lkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tob3VyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tob3VyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ICUgMTIgfHwgMTIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcInBtXCIgOiBcImFtXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21pbn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3NlY31cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgd2lkdGggICA9IGlzTmFOKHdpZHRoKSA/IDMgOiB3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyA5IDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tgc2VsZi5nZXRNaWxsaXNlY29uZHMoKS50b1N0cmluZygpYC5yanVzdCgzLCAnMCcpfTtcbiAgICAgICAgICAgIHJlc3VsdCAgPSAje2ByZXN1bHRgLmxqdXN0KGB3aWR0aGAsICcwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIHZhciBvZmZzZXQgID0gc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpLFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZnNldCkgLyA2MCksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguYWJzKG9mZnNldCkgJSA2MDtcblxuICAgICAgICAgICAgcmVzdWx0ICs9IG9mZnNldCA8IDAgPyBcIitcIiA6IFwiLVwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gaG91cnM7XG5cbiAgICAgICAgICAgIGlmIChjb2xvbnMgPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIjpcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ICs9IG1pbnV0ZXMgPCAxMCA/IFwiMFwiIDogXCJcIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBtaW51dGVzO1xuXG4gICAgICAgICAgICBpZiAoY29sb25zID4gMSkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI6MDBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3pvbmV9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBkYXlzX29mX3dlZWtbI3t3ZGF5fV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X2RheXNbI3t3ZGF5fV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3dkYXl9ICsgMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7d2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMF0udG9fcy5yanVzdCgyLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclsxXX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV1bLTIuLi0xXX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7dG9faX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx0XCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJVwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclYSAlYiAlZSAlVCAlWScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJW0vJWQvJXknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVZLSVtLSVkJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclZS0lXmItJTRZJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSTolTTolUyAlcCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUg6JU0nKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNOiVTJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBjYXNlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1tBLVpdLywgZnVuY3Rpb24oYykgeyBjLnRvTG93ZXJDYXNlKCkgfSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UoL1thLXpdLywgZnVuY3Rpb24oYykgeyBjLnRvVXBwZXJDYXNlKCkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFkICYmICh6ZXJvIHx8IGJsYW5rKSkge1xuICAgICAgICAgIHJlc3VsdCA9ICN7YHJlc3VsdGAucmp1c3QoYGlzTmFOKHdpZHRoKSA/IDIgOiB3aWR0aGAsIGBibGFuayA/IFwiIFwiIDogXCIwXCJgKX07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VuZGF5P1xuICAgIGAje3dkYXl9ID09IDBgXG4gIGVuZFxuXG4gIGRlZiB0aHVyc2RheT9cbiAgICBgI3t3ZGF5fSA9PSA0YFxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIFtzZWMsIG1pbiwgaG91ciwgZGF5LCBtb250aCwgeWVhciwgd2RheSwgeWRheSwgaXNkc3QsIHpvbmVdXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgYHNlbGYuZ2V0VGltZSgpIC8gMTAwMGBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICBgcGFyc2VJbnQoc2VsZi5nZXRUaW1lKCkgLyAxMDAwLCAxMClgXG4gIGVuZFxuXG4gIGRlZiB0dWVzZGF5P1xuICAgIGAje3dkYXl9ID09IDJgXG4gIGVuZFxuXG4gIGRlZiB3ZGF5XG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENEYXkoKSA6IHNlbGYuZ2V0RGF5KClgXG4gIGVuZFxuXG4gIGRlZiB3ZWRuZXNkYXk/XG4gICAgYCN7d2RheX0gPT0gM2BcbiAgZW5kXG5cbiAgZGVmIHllYXJcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0Z1bGxZZWFyKCkgOiBzZWxmLmdldEZ1bGxZZWFyKClgXG4gIGVuZFxuXG4gIGRlZiBjd2Vla19jeWVhclxuICAgIGphbjAxID0gOjpUaW1lLm5ldyh5ZWFyLCAxLCAxKVxuICAgIGphbjAxX3dkYXkgPSBqYW4wMS53ZGF5XG4gICAgZmlyc3RfbW9uZGF5ID0gMFxuICAgIHllYXIgPSBzZWxmLnllYXJcbiAgICBpZiBqYW4wMV93ZGF5IDw9IDQgJiYgamFuMDFfd2RheSAhPSAwXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhclxuICAgICAgb2Zmc2V0ID0gamFuMDFfd2RheSAtIDFcbiAgICBlbHNlXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgbGFzdCB3ZWVrIG9mIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICBvZmZzZXQgPSBqYW4wMV93ZGF5IC0gNyAtIDFcbiAgICAgIG9mZnNldCA9IC0xIGlmIG9mZnNldCA9PSAtOCAjIEFkanVzdCBpZiBKYW4gMDEgaXMgYSBTdW5kYXlcbiAgICBlbmRcblxuICAgIHdlZWsgPSAoKHlkYXkgKyBvZmZzZXQpIC8gNy4wMCkuY2VpbFxuXG4gICAgaWYgd2VlayA8PSAwXG4gICAgICAjIEdldCB0aGUgbGFzdCB3ZWVrIG9mIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICByZXR1cm4gOjpUaW1lLm5ldyhzZWxmLnllYXIgLSAxLCAxMiwgMzEpLmN3ZWVrX2N5ZWFyXG4gICAgZWxzaWYgd2VlayA9PSA1M1xuICAgICAgIyBGaW5kIG91dCB3aGV0aGVyIHRoaXMgaXMgYWN0dWFsbHkgd2VlayA1MyBvciBhbHJlYWR5IHdlZWsgMDEgb2YgdGhlIGZvbGxvd2luZyB5ZWFyXG4gICAgICBkZWMzMSA9IDo6VGltZS5uZXcoc2VsZi55ZWFyLCAxMiwgMzEpXG4gICAgICBkZWMzMV93ZGF5ID0gZGVjMzEud2RheVxuICAgICAgaWYgZGVjMzFfd2RheSA8PSAzICYmIGRlYzMxX3dkYXkgIT0gMFxuICAgICAgICB3ZWVrID0gMVxuICAgICAgICB5ZWFyICs9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgW3dlZWssIHllYXJdXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyBta3RpbWUgbG9jYWxcbiAgICBhbGlhcyB1dGMgZ21cbiAgZW5kXG5cbiAgYWxpYXMgY3RpbWUgYXNjdGltZVxuICBhbGlhcyBkc3Q/IGlzZHN0XG4gIGFsaWFzIGdldHV0YyBnZXRnbVxuICBhbGlhcyBnbXRvZmYgZ210X29mZnNldFxuICBhbGlhcyBtZGF5IGRheVxuICBhbGlhcyBtb250aCBtb25cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG4gIGFsaWFzIHR2X3NlYyB0b19pXG4gIGFsaWFzIHR2X3VzZWMgdXNlY1xuICBhbGlhcyB1dGMgZ210aW1lXG4gIGFsaWFzIHV0Yz8gZ210P1xuICBhbGlhcyB1dGNfb2Zmc2V0IGdtdF9vZmZzZXRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpUaW1lPiIsImluY2x1ZGUiLCJDb21wYXJhYmxlIiwiYXQiLCJzZWNvbmRzIiwiZnJhYyIsIlRpbWUiLCI9PT0iLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsInJlc3BvbmRfdG8/IiwidG9fc3RyIiwidG9faSIsIkFyZ3VtZW50RXJyb3IiLCJuZXciLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWluIiwic2VjIiwidXRjX29mZnNldCIsImxvY2FsIiwibWlsbGlzZWNvbmQiLCJfZHVtbXkxIiwiX2R1bW15MiIsIl9kdW1teTMiLCJnbSIsIm5vdyIsIisiLCJvdGhlciIsIi0iLCI8PT4iLCJ0b19mIiwiciIsIm5pbD8iLCI+IiwiMCIsIi0xIiwiPCIsIjEiLCI9PSIsIiRyZXRfb3JfMSIsImFzY3RpbWUiLCJzdHJmdGltZSIsInlkYXkiLCJzdGFydF9vZl95ZWFyIiwic3RhcnRfb2ZfZGF5Iiwib25lX2RheSIsIjg2NDAwIiwiLyIsInJvdW5kIiwiaXNkc3QiLCJkdXAiLCJjb3B5IiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJpbml0aWFsaXplX2R1cCIsImVxbD8iLCJpc19hPyIsInplcm8/IiwiZnJpZGF5PyIsIndkYXkiLCJoYXNoIiwiaW5zcGVjdCIsInV0Yz8iLCJtb24iLCJtb25kYXk/Iiwic2F0dXJkYXk/Iiwic3VjYyIsInVzZWMiLCJ6b25lIiwiZ2V0Z20iLCJnbXRpbWUiLCJnbXQ/IiwiZ210X29mZnNldCIsImZvcm1hdCIsInJqdXN0IiwiMyIsImxqdXN0IiwiY3dlZWtfY3llYXIiLCJbXSIsInRvX3MiLCIyIiwiLTIiLCJzdW5kYXk/IiwidGh1cnNkYXk/IiwidG9fYSIsInR1ZXNkYXk/Iiwid2VkbmVzZGF5PyIsImphbjAxIiwiamFuMDFfd2RheSIsImZpcnN0X21vbmRheSIsIjw9IiwiNCIsIm9mZnNldCIsIjciLCItOCIsIndlZWsiLCJjZWlsIiwiMTIiLCIzMSIsIjUzIiwiZGVjMzEiLCJkZWMzMV93ZGF5Il0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFHRkQsdUJBQXlCLENBQUdBLFFBQUgsRUFBVUEsUUFBVixFQUFpQkEsU0FBakIsRUFBeUJBLFdBQXpCLEVBQW1DQSxVQUFuQyxFQUE0Q0EsUUFBNUMsRUFBbURBLFVBQW5ELEVBQTREQSxRQUE1RCxDQUFvRUE7QUFDN0ZBLHVCQUF5QixDQUFHQSxLQUFILEVBQU9BLEtBQVAs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WSxTQUFaO0lBQ0EsYUFBTSxNQUFOLEVBQVcsT0FBWDtJQUNBLGFBQU0sUUFBTixFQUFhLE9BQWI7SUFDQSxhQUFNLFFBQU4sRUFBYSxZQUFiO0lBQ0EsYUFBTSxNQUFOLEVBQVcsS0FBWDtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsTUFBYjtJQUNBLGFBQU0sU0FBTixFQUFjLE1BQWQ7SUFDQSxhQUFNLEtBQU4sRUFBVSxRQUFWO0lBQ0EsYUFBTSxNQUFOLEVBQVcsTUFBWDtJQUNBRSxPQUFBLGFBQU0sWUFBTixFQUFpQixZQUFqQjtFQWp1QkZBLEdBQU0sSUFBTkEsRUFBZ0JILElBQWhCRztBQUpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjMxOTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cnVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIDo6U3RydWN0XG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgZGVmIHNlbGYubmV3KGNvbnN0X25hbWUsICphcmdzLCBrZXl3b3JkX2luaXQ6IGZhbHNlLCAmYmxvY2spXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgaWYgY29uc3RfbmFtZS5jbGFzcyA9PSA6OlN0cmluZyAmJiBjb25zdF9uYW1lWzBdLnVwY2FzZSAhPSBjb25zdF9uYW1lWzBdXG4gICAgICAgICMgRmFzdCB0cmFjayBzbyB0aGF0IHdlIHNraXAgbmVlZGxlc3NseSBnb2luZyB0aHJ1IGV4Y2VwdGlvbnNcbiAgICAgICAgIyBpbiBtb3N0IGNhc2VzLlxuICAgICAgICBhcmdzLnVuc2hpZnQoY29uc3RfbmFtZSlcbiAgICAgICAgY29uc3RfbmFtZSA9IG5pbFxuICAgICAgZWxzZVxuICAgICAgICBiZWdpblxuICAgICAgICAgIGNvbnN0X25hbWUgPSA6Ok9wYWwuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICAgICAgcmVzY3VlIDo6VHlwZUVycm9yLCA6Ok5hbWVFcnJvclxuICAgICAgICAgIGFyZ3MudW5zaGlmdChjb25zdF9uYW1lKVxuICAgICAgICAgIGNvbnN0X25hbWUgPSBuaWxcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFyZ3MubWFwIGRvIHxhcmd8XG4gICAgICA6Ok9wYWwuY29lcmNlX3RvIShhcmcsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGVuZFxuXG4gICAga2xhc3MgPSA6OkNsYXNzLm5ldyhzZWxmKSBkb1xuICAgICAgYXJncy5lYWNoIHsgfGFyZ3wgZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUoYXJnKSB9XG5cbiAgICAgIGNsYXNzIDw8IHNlbGZcbiAgICAgICAgZGVmIG5ldygqYXJncylcbiAgICAgICAgICBpbnN0YW5jZSA9IGFsbG9jYXRlXG4gICAgICAgICAgYCN7aW5zdGFuY2V9LiQkZGF0YSA9IHt9YFxuICAgICAgICAgIGluc3RhbmNlLmluaXRpYWxpemUoKmFyZ3MpXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYWxpYXNfbWV0aG9kIDpbXSwgOm5ld1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBrbGFzcy5tb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrXG4gICAgYGtsYXNzLiQka2V5d29yZF9pbml0ID0ga2V5d29yZF9pbml0YFxuXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgOjpTdHJ1Y3QuY29uc3Rfc2V0KGNvbnN0X25hbWUsIGtsYXNzKVxuICAgIGVuZFxuXG4gICAga2xhc3NcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUobmFtZSlcbiAgICBpZiBzZWxmID09IDo6U3RydWN0XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd5b3UgY2Fubm90IGRlZmluZSBhdHRyaWJ1dGVzIHRvIHRoZSBTdHJ1Y3QgY2xhc3MnXG4gICAgZW5kXG5cbiAgICBtZW1iZXJzIDw8IG5hbWVcblxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdYFxuICAgIGVuZFxuXG4gICAgZGVmaW5lX21ldGhvZCBcIiN7bmFtZX09XCIgZG8gfHZhbHVlfFxuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm1lbWJlcnNcbiAgICBpZiBzZWxmID09IDo6U3RydWN0XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0aGUgU3RydWN0IGNsYXNzIGhhcyBubyBtZW1iZXJzJ1xuICAgIGVuZFxuXG4gICAgQG1lbWJlcnMgfHw9IFtdXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluaGVyaXRlZChrbGFzcylcbiAgICBtZW1iZXJzID0gQG1lbWJlcnNcblxuICAgIGtsYXNzLmluc3RhbmNlX2V2YWwgZG9cbiAgICAgIEBtZW1iZXJzID0gbWVtYmVyc1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICBpZiBgI3tzZWxmLmNsYXNzfS4kJGtleXdvcmRfaW5pdGBcbiAgICAgIGt3YXJncyA9IGFyZ3MubGFzdCB8fCB7fVxuXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IDEgfHwgYChhcmdzLmxlbmd0aCA9PT0gMSAmJiAha3dhcmdzLiQkaXNfaGFzaClgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAje2FyZ3MubGVuZ3RofSwgZXhwZWN0ZWQgMClcIlxuICAgICAgZW5kXG5cbiAgICAgIGV4dHJhID0ga3dhcmdzLmtleXMgLSBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgICAgIGlmIGV4dHJhLmFueT9cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVua25vd24ga2V5d29yZHM6ICN7ZXh0cmEuam9pbignLCAnKX1cIlxuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICBzZWxmW25hbWVdID0ga3dhcmdzW25hbWVdXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnc3RydWN0IHNpemUgZGlmZmVycydcbiAgICAgIGVuZFxuXG4gICAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX2luZGV4IGRvIHxuYW1lLCBpbmRleHxcbiAgICAgICAgc2VsZltuYW1lXSA9IGFyZ3NbaW5kZXhdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShmcm9tKVxuICAgICV4e1xuICAgICAgc2VsZi4kJGRhdGEgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tLiQkZGF0YSksIGksIG1heCwgbmFtZTtcbiAgICAgIGZvciAoaSA9IDAsIG1heCA9IGtleXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgbmFtZSA9IGtleXNbaV07XG4gICAgICAgIHNlbGYuJCRkYXRhW25hbWVdID0gZnJvbS4kJGRhdGFbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5rZXl3b3JkX2luaXQ/XG4gICAgYHNlbGYuJCRrZXl3b3JkX2luaXRgXG4gIGVuZFxuXG4gIGRlZiBtZW1iZXJzXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgSGFzaC5uZXcoYHNlbGYuJCRkYXRhYCkuaGFzaFxuICBlbmRcblxuICBkZWYgW10obmFtZSlcbiAgICBpZiA6OkludGVnZXIgPT09IG5hbWVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIDo6U3RyaW5nID09PSBuYW1lXG4gICAgICAleHtcbiAgICAgICAgaWYoIXNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXWBcbiAgZW5kXG5cbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSlcbiAgICBpZiA6OkludGVnZXIgPT09IG5hbWVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIDo6U3RyaW5nID09PSBuYW1lXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKSB1bmxlc3Mgc2VsZi5jbGFzcy5tZW1iZXJzLmluY2x1ZGU/KG5hbWUudG9fc3ltKVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7OjpTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7OjpTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgLmVxbD8oYGJgKX0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIHNlbGZbbmFtZV0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfcGFpclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9wYWlyKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCB7IHxuYW1lfCB5aWVsZCBbbmFtZSwgc2VsZltuYW1lXV0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMubWFwIHsgfG5hbWV8IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBgdmFyIGluc3BlY3Rfc3RhY2sgPSBbXWBcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9ICcjPHN0cnVjdCAnXG5cbiAgICBpZiBgaW5zcGVjdF9zdGFja2AuaW5jbHVkZT8gX19pZF9fXG4gICAgICByZXN1bHQgKyAnOi4uLj4nXG4gICAgZWxzZVxuICAgICAgYGluc3BlY3Rfc3RhY2tgIDw8IF9faWRfX1xuICAgICAgcHVzaGVkID0gdHJ1ZVxuXG4gICAgICBpZiA6OlN0cnVjdCA9PT0gc2VsZiAmJiBzZWxmLmNsYXNzLm5hbWVcbiAgICAgICAgcmVzdWx0ICs9IFwiI3tzZWxmLmNsYXNzfSBcIlxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdCArPSBlYWNoX3BhaXIubWFwIGRvIHxuYW1lLCB2YWx1ZXxcbiAgICAgICAgXCIje25hbWV9PSN7T3BhbC5pbnNwZWN0KHZhbHVlKX1cIlxuICAgICAgZW5kLmpvaW4gJywgJ1xuXG4gICAgICByZXN1bHQgKz0gJz4nXG5cbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbnN1cmVcbiAgICBgaW5zcGVjdF9zdGFjay5wb3AoKWAgaWYgcHVzaGVkXG4gIGVuZFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIGFyZ3MgPSBhcmdzLm1hcCB7IHxhcmd8IGBhcmcuJCRpc19yYW5nZSA/ICN7YXJnLnRvX2F9IDogYXJnYCB9LmZsYXR0ZW5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYXJnc1tpXS4kJGlzX251bWJlcikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje2BhcmdzW2ldYC5jbGFzc30gaW50byBJbnRlZ2VyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goI3tzZWxmW2BhcmdzW2ldYF19KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGlnKGtleSwgKmtleXMpXG4gICAgaXRlbSA9IGlmIGBrZXkuJCRpc19zdHJpbmcgJiYgc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KWBcbiAgICAgICAgICAgICBgc2VsZi4kJGRhdGFba2V5XSB8fCBuaWxgXG4gICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaXRlbSA9PT0gbmlsIHx8IGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBpdGVtLnJlc3BvbmRfdG8/KDpkaWcpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmtleXMpXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuICBhbGlhcyB2YWx1ZXMgdG9fYVxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlN0cnVjdD4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsIm5ldyIsImNvbnN0X25hbWUiLCJjbGFzcyIsIlN0cmluZyIsIltdIiwiMCIsInVwY2FzZSIsImFyZ3MiLCJ1bnNoaWZ0IiwiT3BhbCIsImNvbnN0X25hbWUhIiwiVHlwZUVycm9yIiwiTmFtZUVycm9yIiwibWFwIiwiYmxvY2sgaW4gbmV3IiwiYXJnIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuZXciLCJjb2VyY2VfdG8hIiwia2xhc3MiLCJDbGFzcyIsImVhY2giLCJibG9jayAoMyBsZXZlbHMpIGluIG5ldyIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwidG9fcHJvYyIsIlN0cnVjdCIsImNvbnN0X3NldCIsIm5hbWUiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJtZW1iZXJzIiwiPDwiLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgaW4gZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwidmFsdWUiLCJAbWVtYmVycyIsIiRyZXRfb3JfMSIsImluaGVyaXRlZCIsImluc3RhbmNlX2V2YWwiLCJibG9jayBpbiBpbmhlcml0ZWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaGVyaXRlZCIsImt3YXJncyIsImxhc3QiLCI+IiwibGVuZ3RoIiwiMSIsImV4dHJhIiwiLSIsImtleXMiLCJhbnk/Iiwiam9pbiIsImJsb2NrIGluIGluaXRpYWxpemUiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCIkd3JpdGVyIiwiW109IiwiZWFjaF93aXRoX2luZGV4IiwiaW5kZXgiLCJpbml0aWFsaXplX2NvcHkiLCJmcm9tIiwia2V5d29yZF9pbml0PyIsImhhc2giLCJIYXNoIiwiSW50ZWdlciIsIjwiLCJzaXplIiwiLUAiLCJJbmRleEVycm9yIiwiPj0iLCJpbmNsdWRlPyIsInRvX3N5bSIsIj09Iiwib3RoZXIiLCJpbnN0YW5jZV9vZj8iLCJfX2lkX18iLCI9PT0iLCJlcWw/IiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9wYWlyIiwiYmxvY2sgaW4gZWFjaF9wYWlyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3BhaXIiLCJ0b19hIiwiYmxvY2sgaW4gdG9fYSIsImJsb2NrICgyIGxldmVscykgaW4gdG9fYSIsImluc3BlY3QiLCJyZXN1bHQiLCIrIiwicHVzaGVkIiwiYmxvY2sgaW4gaW5zcGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gaW5zcGVjdCIsInRvX2giLCJlYWNoX3dpdGhfb2JqZWN0IiwiYmxvY2sgaW4gdG9faCIsImgiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX2giLCJ2YWx1ZXNfYXQiLCJibG9jayBpbiB2YWx1ZXNfYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIHZhbHVlc19hdCIsImZsYXR0ZW4iLCJkaWciLCJrZXkiLCJpdGVtIiwicmVzcG9uZF90bz8iXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBRUFFLE1BQUlMLElBQUpLLFVBQUFBLHVCQUFhQyxVQUFELEVBTGQsRUFLYyxFQUxkLEVBS0VEO0FBQUFBLE1BQUFBOztNQUFBQTs7OztNQUxGOztNQUFBOztNQUFBO01BQUE7TUFBQTtNQUFBO01BQUE7O01BSzJCOztNQUFPO01BQUEseUNBQWM7TUFDNUMsSUFBQSxRQUFHQyxVQUFILENBQUE7UUFDRSxJQUFHLENBQUEsTUFBQUEsVUFBVUMsT0FBQUEsQ0FBQUEsQ0FBVixFQUFvQkMsYUFBcEIsQ0FBQSxJQUFBLENBQUEsT0FBZ0NGLFVBQVVHLE9BQUFBLENBQUNDLENBQURELENBQUdFLFFBQUFBLENBQUFBLENBQTdDLEVBQXdETCxVQUFVRyxPQUFBQSxDQUFDQyxDQUFERCxDQUFsRSxDQUFBLENBQUEsQ0FBSDs7VUFHRUcsSUFBSUMsU0FBQUEsQ0FBU1AsVUFBVE87VUFDSlAsYUFBYTtRQUpmOztVQU9JO1lBQUFBLGFB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Z0JBQWYsRUFBNkI2Riw0QkFBRCxHQUFBLENBQTZCQSxDQUFDQSxPQUFEQSxDQUFTdEcsT0FBQUEsQ0FBQUEsQ0FBdEMsQ0FBQSxHQUE2Q3NHLGVBQWpFdEU7QUFDcEJzRTtBQUNBQSxvQkFBc0I3RyxJQUFJUyxPQUFBQSxDQUFFb0csT0FBRnBHLENBQVlvRztBQUN0Q0E7QUFDQUE7QUFDQUE7SUFYRUEsQ0FBQUEsSUFBQUE7O0FBY0FJLElBQUFBLG1CQUFBQSxlQUFRQyxHQUFELEVBdFRULEVBc1RFRDtBQUFBQSxNQUFBQTs7OztNQXRURjs7TUFzVGU7TUFDWEUsT0FBTyxDQUFBLFFBQUlGLGtEQUFKLENBQUEsR0FBQSxDQUNHQSx1QkFESCxJQUFBLEdBQUE7O0FBS1hBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BRUksS0FBQSxRQUFPRSxJQUFJQyxnQkFBQUEsQ0FBYSxLQUFiQSxDQUFYLENBQUE7UUFDRTlFLE9BQVFDLE9BQUFBLENBQU92QixnQkFBZixFQUE0QixFQUFBLEdBQUEsQ0FBR21HLElBQUk1RyxPQUFBQSxDQUFBQSxDQUFQLENBQUEsR0FBYzBHLDRCQUFsQzFFO01BRFY7TUFJQTBFLE9BQUlBLE1BQUpFLElBQUlGLE9BQUFBLEVBQUssTUFBQ3JELElBQUQsQ0FBTHFEO0lBZk5BLENBQUFBLElBQUFBO0lBa0JBLGFBQU0sTUFBTixFQUFXLFFBQVg7SUFDQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0lBQ0EvRyxPQUFBLGFBQU0sUUFBTixFQUFhLE1BQWI7RUF4VUZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNjg4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9kaXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpEaXJcbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBjaGRpcihkaXIpXG4gICAgICBwcmV2X2N3ZCA9IGBPcGFsLmN1cnJlbnRfZGlyYFxuICAgICAgYE9wYWwuY3VycmVudF9kaXIgPSAje2Rpcn1gXG4gICAgICB5aWVsZFxuICAgIGVuc3VyZVxuICAgICAgYE9wYWwuY3VycmVudF9kaXIgPSAje3ByZXZfY3dkfWBcbiAgICBlbmRcblxuICAgIGRlZiBwd2RcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyIHx8ICcuJ2BcbiAgICBlbmRcblxuICAgIGRlZiBob21lXG4gICAgICA6OkVOVlsnSE9NRSddIHx8ICcuJ1xuICAgIGVuZFxuXG4gICAgYWxpYXMgZ2V0d2QgcHdkXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpEaXI+IiwiY2hkaXIiLCJkaXIiLCJwcmV2X2N3ZCIsInB3ZCIsImhvbWUiLCIkcmV0X29yXzEiLCJFTlYiLCJbXSIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFBQSw4Q0FBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQTs7OztBQUNFQyxNQUFBQSxxQkFBQUEsaUJBQVVDLEdBQVZEO0FBQUFBLFFBQUFBOztRQUFBQTtRQUNFQSxPQUFBLGNBQUE7O1FBQUFFLFdBQVlGO1FBQ1hBLG1CQUFxQkM7UUFDdEIsT0FBQSxxQkFBQSxFQUFBO1FBRkE7VUFJQ0QsbUJBQXFCRTtRQUp0QixDQUFBO01BREZGLENBQUFBLEdBQUFBOztBQVFBRyxNQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUE7UUFDRUEsT0FBQ0EsdUJBQURBO01BREZBLENBQUFBLEdBQUFBOztBQUlBQyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFBQUMsQ0FBQUEsWUFBQUMsVUFBS0MsT0FBQUEsQ0FBQ0gsTUFBREcsQ0FBTEYsQ0FBQSxDQUFBO1VBQUFELE9BQUE7UUFBQTtVQUFpQkEsT0FBQUE7UUFBakI7TUFERkEsQ0FBQUEsR0FBQUE7TUFJQSxPQUFBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFqQkYsNEJBQVNJLElBQVQ7RUFERlQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjM3MzQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2ZpbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHlcblxuY2xhc3MgOjpGaWxlIDwgOjpJT1xuICBTZXBhcmF0b3IgPSBTRVBBUkFUT1IgPSAnLydcbiAgQUxUX1NFUEFSQVRPUiA9IG5pbFxuICBQQVRIX1NFUEFSQVRPUiA9ICc6J1xuICAjIEFzc3VtaW5nIGNhc2UgaW5zZW5zdGl2ZSBmaWxlc3lzdGVtXG4gIEZOTV9TWVNDQVNFID0gMFxuICB3aW5kb3dzX3Jvb3RfcnggPSAlcnteW2EtekEtWl06KD86XFxcXHxcXC8pfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyID0gbmlsKVxuICAgICAgc2VwID0gU0VQQVJBVE9SXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgbmV3X3BhcnRzID0gW11cblxuICAgICAgcGF0aCA9IHBhdGgucmVzcG9uZF90bz8oOnRvX3BhdGgpID8gcGF0aC50b19wYXRoIDogcGF0aFxuICAgICAgcGF0aCA9IDo6T3BhbC5jb2VyY2VfdG8hKGBwYXRoYCwgOjpTdHJpbmcsIDp0b19zdHIpXG5cbiAgICAgIGJhc2VkaXIgfHw9IDo6RGlyLnB3ZFxuICAgICAgcGF0aF9hYnMgICAgPSBgcGF0aC5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKWBcbiAgICAgIGJhc2VkaXJfYWJzID0gYGJhc2VkaXIuc3Vic3RyKDAsIHNlcC5sZW5ndGgpID09PSBzZXAgfHwgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcilgXG5cbiAgICAgIGlmIHBhdGhfYWJzXG4gICAgICAgIHBhcnRzICAgICAgID0gcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKSA/ICcnIDogI3twYXRoLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSB0cnVlXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnRzICAgICAgID0gYmFzZWRpci5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKSArIHBhdGguc3BsaXQoL1sje3NlcF9jaGFyc31dLylcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcikgPyAnJyA6ICN7YmFzZWRpci5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIGFicyAgICAgICAgID0gYmFzZWRpcl9hYnNcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIHBhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocGFydCA9PT0gbmlsKSB8fFxuICAgICAgICAgICAgKHBhcnQgPT09ICcnICAmJiAoKG5ld19wYXJ0cy5sZW5ndGggPT09IDApIHx8IGFicykpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJy4nICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgbmV3X3BhcnRzLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFicyAmJiBwYXJ0c1swXSAhPT0gJy4nKSB7XG4gICAgICAgICAgI3tuZXdfcGFydHMudW5zaGlmdCAnLid9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3X3BhdGggPSBuZXdfcGFydHMuam9pbihzZXApXG4gICAgICBuZXdfcGF0aCA9IGxlYWRpbmdfc2VwICsgbmV3X3BhdGggaWYgYWJzXG4gICAgICBuZXdfcGF0aFxuICAgIGVuZFxuXG4gICAgZGVmIGV4cGFuZF9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBpZiBgcGF0aFswXSA9PT0gJ34nIHx8IChiYXNlZGlyICYmIGJhc2VkaXJbMF0gPT09ICd+JylgXG4gICAgICAgIGhvbWUgPSBEaXIuaG9tZVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSg6OkFyZ3VtZW50RXJyb3IsIFwiY291bGRuJ3QgZmluZCBIT01FIGVudmlyb25tZW50IC0tIGV4cGFuZGluZyBgfidcIikgdW5sZXNzIGhvbWVcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoaG9tZSkgPyAnJyA6ICN7aG9tZS5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgJ25vbi1hYnNvbHV0ZSBob21lJykgdW5sZXNzIGhvbWUuc3RhcnRfd2l0aD8obGVhZGluZ19zZXApXG5cbiAgICAgICAgaG9tZSAgICAgICAgICAgICs9IHNlcFxuICAgICAgICBob21lX3BhdGhfcmVnZXhwID0gL15cXH4oPzoje3NlcH18JCkvXG4gICAgICAgIHBhdGggICAgICAgICAgICAgPSBwYXRoLnN1Yihob21lX3BhdGhfcmVnZXhwLCBob21lKVxuICAgICAgICBiYXNlZGlyICAgICAgICAgID0gYmFzZWRpci5zdWIoaG9tZV9wYXRoX3JlZ2V4cCwgaG9tZSkgaWYgYmFzZWRpclxuICAgICAgZW5kXG4gICAgICBhYnNvbHV0ZV9wYXRoKHBhdGgsIGJhc2VkaXIpXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIC8vIENvZXJjZSBhIGdpdmVuIHBhdGggdG8gYSBwYXRoIHN0cmluZyB1c2luZyAjdG9fcGF0aCBhbmQgI3RvX3N0clxuICAgICAgZnVuY3Rpb24gJGNvZXJjZV90b19wYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKCR0cnV0aHkoI3tgcGF0aGAucmVzcG9uZF90bz8oOnRvX3BhdGgpfSkpIHtcbiAgICAgICAgICBwYXRoID0gcGF0aC4kdG9fcGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9ICN7OjpPcGFsLmNvZXJjZV90byEoYHBhdGhgLCA6OlN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYSBSZWdFeHAgY29tcGF0aWJsZSBjaGFyIGNsYXNzXG4gICAgICBmdW5jdGlvbiAkc2VwX2NoYXJzKCkge1xuICAgICAgICBpZiAoI3tBTFRfU0VQQVJBVE9SfSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUn0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcGFsLmVzY2FwZV9yZWdleHAoI3tTRVBBUkFUT1IgKyBBTFRfU0VQQVJBVE9SfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYgZGlybmFtZShwYXRoLCBsZXZlbCA9IDEpXG4gICAgICByZXR1cm4gcGF0aCBpZiBsZXZlbCA9PSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibGV2ZWwgY2FuJ3QgYmUgbmVnYXRpdmVcIiBpZiBsZXZlbCA8IDBcblxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIHBhdGggPSBgJGNvZXJjZV90b19wYXRoKHBhdGgpYFxuICAgICAgJXh7XG4gICAgICAgIHZhciBhYnNvbHV0ZSA9IHBhdGgubWF0Y2gobmV3IFJlZ0V4cCgje1wiXlsje3NlcF9jaGFyc31dXCJ9KSksIG91dDtcblxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlsje3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3JzXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiW14je3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBiYXNlbmFtZVxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlsje3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSBmaW5hbCB0cmFpbGluZyBzZXBhcmF0b3JzXG5cbiAgICAgICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgICAgb3V0ID0gYWJzb2x1dGUgPyAnLycgOiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb3V0ID0gcGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbCA9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gI3tkaXJuYW1lKGBvdXRgLCBsZXZlbCAtIDEpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZW5hbWUobmFtZSwgc3VmZml4ID0gbmlsKVxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIG5hbWUgPSBgJGNvZXJjZV90b19wYXRoKG5hbWUpYFxuICAgICAgJXh7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VmZml4ICE9PSBuaWwpIHtcbiAgICAgICAgICBzdWZmaXggPSAjezo6T3BhbC5jb2VyY2VfdG8hKHN1ZmZpeCwgOjpTdHJpbmcsIDp0b19zdHIpfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1ZmZpeCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIiguKVsje3NlcF9jaGFyc31dKiRcIn0pLCAnJDEnKTtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJeKD86LipbI3tzZXBfY2hhcnN9XSk/KFteI3tzZXBfY2hhcnN9XSspJFwifSksICckMScpO1xuXG4gICAgICAgIGlmIChzdWZmaXggPT09IFwiLipcIikge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLlteXFwuXSskLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYoc3VmZml4ICE9PSBudWxsKSB7XG4gICAgICAgICAgc3VmZml4ID0gT3BhbC5lc2NhcGVfcmVnZXhwKHN1ZmZpeCk7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIje3N1ZmZpeH0kXCJ9KSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgZXh0bmFtZShwYXRoKVxuICAgICAgYHBhdGggPSAkY29lcmNlX3RvX3BhdGgocGF0aClgXG4gICAgICBmaWxlbmFtZSA9IGJhc2VuYW1lKHBhdGgpXG4gICAgICByZXR1cm4gJycgaWYgZmlsZW5hbWUuZW1wdHk/XG4gICAgICBsYXN0X2RvdF9pZHggPSBmaWxlbmFtZVsxLi4tMV0ucmluZGV4KCcuJylcbiAgICAgICMgZXh0ZW5zaW9uIG5hbWUgbXVzdCBjb250YWlucyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIC4oc29tZXRoaW5nKVxuICAgICAgbGFzdF9kb3RfaWR4Lm5pbD8gfHwgbGFzdF9kb3RfaWR4ICsgMSA9PSBmaWxlbmFtZS5sZW5ndGggLSAxID8gJycgOiBmaWxlbmFtZVsobGFzdF9kb3RfaWR4ICsgMSkuLi0xXVxuICAgIGVuZFxuXG4gICAgZGVmIGV4aXN0PyhwYXRoKVxuICAgICAgYE9wYWwubW9kdWxlc1sje3BhdGh9XSAhPSBudWxsYFxuICAgIGVuZFxuXG4gICAgZGVmIGRpcmVjdG9yeT8ocGF0aClcbiAgICAgIGZpbGVzID0gW11cbiAgICAgICV4e1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgICAgI3tmaWxlc30ucHVzaChrZXkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXRoLmdzdWIoLyheLiN7U0VQQVJBVE9SfSt8I3tTRVBBUkFUT1J9KyQpLylcbiAgICAgIGZpbGUgPSBmaWxlcy5maW5kIHsgfGZ8IGYgPX4gL14je3BhdGh9LyB9XG4gICAgICBmaWxlXG4gICAgZW5kXG5cbiAgICBkZWYgam9pbigqcGF0aHMpXG4gICAgICBpZiBwYXRocy5lbXB0eT9cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICBlbmRcbiAgICAgIHJlc3VsdCA9ICcnXG4gICAgICBwYXRocyA9IHBhdGhzLmZsYXR0ZW4uZWFjaF93aXRoX2luZGV4Lm1hcCBkbyB8aXRlbSwgaW5kZXh8XG4gICAgICAgIGlmIGluZGV4ID09IDAgJiYgaXRlbS5lbXB0eT9cbiAgICAgICAgICBTRVBBUkFUT1JcbiAgICAgICAgZWxzaWYgcGF0aHMubGVuZ3RoID09IGluZGV4ICsgMSAmJiBpdGVtLmVtcHR5P1xuICAgICAgICAgIFNFUEFSQVRPUlxuICAgICAgICBlbHNlXG4gICAgICAgICAgaXRlbVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcGF0aHMgPSBwYXRocy5yZWplY3QoJjplbXB0eT8pXG4gICAgICBwYXRocy5lYWNoX3dpdGhfaW5kZXggZG8gfGl0ZW0sIGluZGV4fFxuICAgICAgICBuZXh0X2l0ZW0gPSBwYXRoc1tpbmRleCArIDFdXG4gICAgICAgIGlmIG5leHRfaXRlbS5uaWw/XG4gICAgICAgICAgcmVzdWx0ID0gXCIje3Jlc3VsdH0je2l0ZW19XCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgJiYgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnN1YigvI3tTRVBBUkFUT1J9KyQvLCAnJylcbiAgICAgICAgICBlbmRcbiAgICAgICAgICByZXN1bHQgPSBpZiBpdGVtLmVuZF93aXRoPyhTRVBBUkFUT1IpIHx8IG5leHRfaXRlbS5zdGFydF93aXRoPyhTRVBBUkFUT1IpXG4gICAgICAgICAgICAgICAgICAgICBcIiN7cmVzdWx0fSN7aXRlbX1cIlxuICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgIFwiI3tyZXN1bHR9I3tpdGVtfSN7U0VQQVJBVE9SfVwiXG4gICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXN1bHRcbiAgICBlbmRcblxuICAgIGRlZiBzcGxpdChwYXRoKVxuICAgICAgcGF0aC5zcGxpdChTRVBBUkFUT1IpXG4gICAgZW5kXG5cbiAgICBhbGlhcyByZWFscGF0aCBleHBhbmRfcGF0aFxuICAgIGFsaWFzIGV4aXN0cz8gZXhpc3Q/XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpGaWxlPiIsIjAiLCJ3aW5kb3dzX3Jvb3RfcngiLCJhYnNvbHV0ZV9wYXRoIiwicGF0aCIsImJhc2VkaXIiLCJzZXAiLCJTRVBBUkFUT1IiLCJzZXBfY2hhcnMiLCJuZXdfcGFydHMiLCJyZXNwb25kX3RvPyIsInRvX3BhdGgiLCJPcGFsIiwiY29lcmNlX3RvISIsIlN0cmluZyIsIiRyZXRfb3JfMSIsIkRpciIsInB3ZCIsInBhdGhfYWJzIiwiYmFzZWRpcl9hYnMiLCJwYXJ0cyIsInNwbGl0IiwibGVhZGluZ19zZXAiLCJzdWIiLCJhYnMiLCIrIiwidW5zaGlmdCIsIm5ld19wYXRoIiwiam9pbiIsImV4cGFuZF9wYXRoIiwiaG9tZSIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInN0YXJ0X3dpdGg/IiwiaG9tZV9wYXRoX3JlZ2V4cCIsInNlbGYiLCJBTFRfU0VQQVJBVE9SIiwiZGlybmFtZSIsImxldmVsIiwiMSIsIjwiLCItIiwiYmFzZW5hbWUiLCJuYW1lIiwic3VmZml4IiwiZXh0bmFtZSIsImZpbGVuYW1lIiwiZW1wdHk/IiwibGFzdF9kb3RfaWR4IiwiW10iLCItMSIsInJpbmRleCIsIm5pbD8iLCJsZW5ndGgiLCJleGlzdD8iLCJkaXJlY3Rvcnk/IiwiZmlsZXMiLCJnc3ViIiwiZmlsZSIsImZpbmQiLCJibG9jayBpbiBkaXJlY3Rvcnk/IiwiZiIsImJsb2NrICgyIGxldmVscykgaW4gZGlyZWN0b3J5PyIsIj1+IiwicGF0aHMiLCJyZXN1bHQiLCJtYXAiLCJmbGF0dGVuIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gam9pbiIsIml0ZW0iLCJpbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gam9pbiIsInJlamVjdCIsInRvX3Byb2MiLCJuZXh0X2l0ZW0iLCJlbmRfd2l0aD8iLCJJTyJdLCJtYXBwaW5ncyI6IkFBQUFBLCtDQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRSxxQ0FBWSxxQ0FBWUEsR0FBWixDQUFaO0lBQ0EseUNBQWdCLEdBQWhCO0lBQ0EsMENBQWlCQSxHQUFqQjtJQUVBLHVDQUFjQyxDQUFkO0lBQ0FDLGtCQUFrQjtJQUVsQkYsT0FBQTtNQUFBOzs7O0FBQ0VHLE1BQUFBLDZCQUFBQSx5QkFBa0JDLElBQUQsRUFBT0MsT0FBeEJGO0FBQUFBLFFBQUFBOzs7O1FBQXdCLCtCQUFVLEdBQVY7UUFDdEJHLE1BQU1DO1FBQ05DLFlBQWFMO1FBQ2JNLFlBQVk7UUFFWkwsT0FBTyxDQUFB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Q0FBSyxTQUFHaEIsZUFBSCxFQUFha0UsSUFBYixDQUFBLENBQVQsRUFBMkJBLEVBQXZCbEQ7WUFEYjtZQUdBa0QsT0FBQVAsQ0FBQUEsU0FBUyxDQUFHLENBQUEsUUFBQUssSUFBSU0sY0FBQUEsQ0FBV3RFLGVBQVhzRSxDQUFKLENBQUEsSUFBQSxDQUFBLFFBQTZCRCxTQUFTMUMsZ0JBQUFBLENBQWEzQixlQUFiMkIsQ0FBdEMsQ0FBQSxDQUFBLENBQUgsR0FBQSxDQUNFLEVBQUEsR0FBQSxDQUFHZ0MsTUFBSCxDQUFBLEdBQUEsQ0FBWUssSUFBWixDQURGLElBQUEsQ0FHRSxFQUFBLEdBQUEsQ0FBR0wsTUFBSCxDQUFBLEdBQUEsQ0FBWUssSUFBWixDQUFBLEdBQUEsQ0FBbUJoRSxlQUFuQixDQUhGLENBQUEsQ0FBVDJEO1VBTkYsRUFGRkksQ0FBQUEsR0FBS0Q7UUFlTHpDLE9BQUFzQztNQTlCRnRDLENBQUFBLElBQUFBOztBQWlDQVAsTUFBQUEscUJBQUFBLGlCQUFVakIsSUFBVmlCO0FBQUFBO1FBQ0VBLE9BQUFqQixJQUFJaUIsT0FBQUEsQ0FBT2QsZUFBUGM7TUFETkEsQ0FBQUEsR0FBQUE7TUFJQSxhQUFNLFVBQU4sRUFBZSxhQUFmO01BQ0EsT0FBQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0lBbk5GLDRCQUFTZSxJQUFUO0VBUkZwQyxHQUFNLElBQU5BLEVBQWU4RSxTQUFmOUU7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MDI1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jZXNzL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpTaWduYWxcbiAgZGVmIHNlbGYudHJhcCgqKVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OkdDXG4gIGRlZiBzZWxmLnN0YXJ0XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpTaWduYWw+IiwidHJhcCIsInNlbGYiLCI8Y2xhc3M6R0M+Iiwic3RhcnQiXSwibWFwcGluZ3MiOiJBQUFBQSx1REFBQUE7RUFBQUE7OztFQUFBQztFQUFBQTs7O0lBQ0VBLE9BQUFDLE1BQUlDLElBQUpELFdBQUFBLGdCQURGLEVBQ0VBO0FBQUFBLE1BQUFBOzs7O01BREY7O01BQ2dCO01BRGhCQSxPQUFBO0lBQ0VBLENBQUFBLElBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUFLQUQsT0FBQUk7RUFBQUE7OztJQUNFQSxPQUFBQyxNQUFJRixJQUFKRSxZQUFBQSxpQkFBQUE7QUFBQUE7TUFORkEsT0FBQTtJQU1FQSxDQUFBQSxHQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBTEFKOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDA1NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvY2Vzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgOjpQcm9jZXNzXG4gIEBfX2Nsb2Nrc19fID0gW11cbiAgZGVmIHNlbGYuX19yZWdpc3Rlcl9jbG9ja19fKG5hbWUsIGZ1bmMpXG4gICAgY29uc3Rfc2V0IG5hbWUsIEBfX2Nsb2Nrc19fLnNpemVcbiAgICBAX19jbG9ja3NfXyA8PCBmdW5jXG4gIGVuZFxuXG4gIF9fcmVnaXN0ZXJfY2xvY2tfXyA6Q0xPQ0tfUkVBTFRJTUUsIGBmdW5jdGlvbigpIHsgcmV0dXJuIERhdGUubm93KCkgfWBcblxuICBtb25vdG9uaWMgPSBmYWxzZVxuXG4gICV4e1xuICAgIGlmIChPcGFsLmdsb2JhbC5wZXJmb3JtYW5jZSkge1xuICAgICAgbW9ub3RvbmljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoT3BhbC5nbG9iYWwucHJvY2VzcyAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgICAgLy8gbGV0IG5vdyBiZSB0aGUgYmFzZSB0byBnZXQgc21hbGxlciBudW1iZXJzXG4gICAgICB2YXIgaHJ0aW1lX2Jhc2UgPSBwcm9jZXNzLmhydGltZSgpO1xuXG4gICAgICBtb25vdG9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lKGhydGltZV9iYXNlKTtcbiAgICAgICAgdmFyIHVzID0gKGhydGltZVsxXSAvIDEwMDApIHwgMDsgLy8gY3V0IGJlbG93IG1pY3Jvc2VjcztcbiAgICAgICAgcmV0dXJuICgoaHJ0aW1lWzBdICogMTAwMCkgKyAodXMgLyAxMDAwKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIF9fcmVnaXN0ZXJfY2xvY2tfXyg6Q0xPQ0tfTU9OT1RPTklDLCBtb25vdG9uaWMpIGlmIG1vbm90b25pY1xuXG4gIGRlZiBzZWxmLnBpZFxuICAgIDBcbiAgZW5kXG5cbiAgZGVmIHNlbGYudGltZXNcbiAgICB0ID0gOjpUaW1lLm5vdy50b19mXG4gICAgOjpCZW5jaG1hcms6OlRtcy5uZXcodCwgdCwgdCwgdCwgdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xvY2tfZ2V0dGltZShjbG9ja19pZCwgdW5pdCA9IDpmbG9hdF9zZWNvbmQpXG4gICAgKGNsb2NrID0gQF9fY2xvY2tzX19bY2xvY2tfaWRdKSB8fCA6Oktlcm5lbC5yYWlzZSg6OkVycm5vOjpFSU5WQUwsIFwiY2xvY2tfZ2V0dGltZSgje2Nsb2NrX2lkfSkgI3tAX19jbG9ja3NfX1tjbG9ja19pZF19XCIpXG4gICAgJXh7XG4gICAgICB2YXIgbXMgPSBjbG9jaygpO1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ2Zsb2F0X3NlY29uZCc6ICAgICAgcmV0dXJuICAobXMgLyAxMDAwKTsgICAgICAgICAvLyBudW1iZXIgb2Ygc2Vjb25kcyBhcyBhIGZsb2F0IChkZWZhdWx0KVxuICAgICAgICBjYXNlICdmbG9hdF9taWxsaXNlY29uZCc6IHJldHVybiAgKG1zIC8gMSk7ICAgICAgICAgICAgLy8gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhcyBhIGZsb2F0XG4gICAgICAgIGNhc2UgJ2Zsb2F0X21pY3Jvc2Vjb25kJzogcmV0dXJuICAobXMgKiAxMDAwKTsgICAgICAgICAvLyBudW1iZXIgb2YgbWljcm9zZWNvbmRzIGFzIGEgZmxvYXRcbiAgICAgICAgY2FzZSAnc2Vjb25kJzogICAgICAgICAgICByZXR1cm4gKChtcyAvIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBzZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiAgICAgICByZXR1cm4gKChtcyAvIDEpICAgICAgIHwgMCk7IC8vIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICdtaWNyb3NlY29uZCc6ICAgICAgIHJldHVybiAoKG1zICogMTAwMCkgICAgfCAwKTsgLy8gbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ25hbm9zZWNvbmQnOiAgICAgICAgcmV0dXJuICgobXMgKiAxMDAwMDAwKSB8IDApOyAvLyBudW1iZXIgb2YgbmFub3NlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBkZWZhdWx0OiAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHVuaXQ6ICN7dW5pdH1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6UHJvY2Vzcz4iLCJAX19jbG9ja3NfXyIsIl9fcmVnaXN0ZXJfY2xvY2tfXyIsInNlbGYiLCJuYW1lIiwiZnVuYyIsImNvbnN0X3NldCIsInNpemUiLCI8PCIsIm1vbm90b25pYyIsInBpZCIsIjAiLCJ0aW1lcyIsInQiLCJUaW1lIiwibm93IiwidG9fZiIsIkJlbmNobWFyazo6VG1zIiwiQmVuY2htYXJrIiwibmV3IiwiY2xvY2tfZ2V0dGltZSIsImNsb2NrX2lkIiwidW5pdCIsIiRyZXRfb3JfMSIsImNsb2NrIiwiW10iLCJLZXJuZWwiLCJyYWlzZSIsIkVycm5vOjpFSU5WQUwiLCJFcnJubyIsIkFyZ3VtZW50RXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxrREFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0VDLGtCQUFjO0lBQ2RDLE1BQUlDLElBQUpELHlCQUFBQSw4QkFBNEJFLElBQUQsRUFBT0MsSUFBbENIO0FBQUFBLE1BQUFBO0FBQUFBOzs7TUFDRUMsSUFBQUcsV0FBQUEsQ0FBVUYsSUFBVixFQUFnQkgsZUFBV00sTUFBQUEsQ0FBQUEsQ0FBM0JEO01BQ0FKLE9BQUFELGVBQVlPLE9BQUFBLENBQUdILElBQUhHO0lBRmROLENBQUFBLEdBQUFBO0lBS0FDLElBQUFELG9CQUFBQSxDQUFtQixnQkFBbkIsRUFBcUNGLGdDQUFyQ0U7SUFFQU8sWUFBWTs7QUFHZFQ7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBRUUsSUFBQSxRQUFtRFMsU0FBbkQsQ0FBQTtNQUFBTixJQUFBRCxvQkFBQUEsQ0FBbUIsaUJBQW5CLEVBQXFDTyxTQUFyQ1A7SUFBQTtJQUVBUSxNQUFJUCxJQUFKTyxVQUFBQSxlQUFBQTtBQUFBQTtNQUNFQSxPQUFBQztJQURGRCxDQUFBQSxHQUFBQTtJQUlBRSxNQUFJVCxJQUFKUyxZQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFQyxJQUFJQyxXQUFNQyxLQUFBQSxDQUFBQSxDQUFJQyxNQUFBQSxDQUFBQTtNQUNkSixPQUFBSyxJQUFBQyxnQkFBQUQsUUFBZ0JFLEtBQUFBLENBQUtOLENBQXJCLEVBQXdCQSxDQUF4QixFQUEyQkEsQ0FBM0IsRUFBOEJBLENBQTlCLEVBQWlDQSxDQUFqQk07SUFGbEJQLENBQUFBLEdBQUFBO0lBS0FaLE9BQUFvQixNQUFJakIsSUFBSmlCLG9CQUFBQSx5QkFBdUJDLFFBQUQsRUFBV0MsSUFBakNGO0FBQUFBLE1BQUFBO0FBQUFBOzs7O01BQWlDLHlCQUFPLGNBQVA7TUFDL0IsSUFBQSxRQUFBRyxDQUFBQSxZQUFDQyxDQUFBQSxRQUFRdkIsZUFBV3dCLE9BQUFBLENBQUNKLFFBQURJLENBQW5CRCxDQUFERCxDQUFBLENBQUE7UUFBQTtNQUFBO1FBQW1DRyxPQUFRQyxPQUFBQSxDQUFPQyxJQUFBQyxZQUFBRCxXQUFmLEVBQWlDUixnQkFBRCxHQUFBLENBQWlCQyxRQUFqQixDQUFBLEdBQTBCRCxJQUExQixHQUFBLENBQThCbkIsZUFBV3dCLE9BQUFBLENBQUNKLFFBQURJLENBQXpDLENBQXhCRTtNQUEzQzs7QUFFSlA7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsaUJBQW1CTSxPQUFRQyxPQUFBQSxDQUFPRyxvQkFBZixFQUFpQ1YsbUJBQUQsR0FBQSxDQUFvQkUsSUFBcEIsQ0FBeEJLO0FBQzNCUDtBQUNBQTtJQWRFQSxDQUFBQSxJQUFBQTtFQXhDRnBCLEdBQU8sSUFBUEE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MTM2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20vZm9ybWF0dGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6UmFuZG9tXG4gIG1vZHVsZSBzZWxmOjpGb3JtYXR0ZXJcbiAgICBkZWYgaGV4KGNvdW50ID0gbmlsKVxuICAgICAgY291bnQgPSA6OlJhbmRvbS5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICAgJXh7XG4gICAgICAgIHZhciBieXRlcyA9ICN7Ynl0ZXMoY291bnQpfTtcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgI3tjb3VudH07IGkrKykge1xuICAgICAgICAgIG91dCArPSBieXRlcy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje2BvdXRgLmVuY29kZSgnVVMtQVNDSUknKX07XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZG9tX2J5dGVzKGNvdW50ID0gbmlsKVxuICAgICAgYnl0ZXMoY291bnQpXG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZTY0KGNvdW50ID0gbmlsKVxuICAgICAgOjpCYXNlNjQuc3RyaWN0X2VuY29kZTY0KHJhbmRvbV9ieXRlcyhjb3VudCkpLmVuY29kZSgnVVMtQVNDSUknKVxuICAgIGVuZFxuXG4gICAgZGVmIHVybHNhZmVfYmFzZTY0KGNvdW50ID0gbmlsLCBwYWRkaW5nID0gZmFsc2UpXG4gICAgICA6OkJhc2U2NC51cmxzYWZlX2VuY29kZTY0KHJhbmRvbV9ieXRlcyhjb3VudCksIHBhZGRpbmcpLmVuY29kZSgnVVMtQVNDSUknKVxuICAgIGVuZFxuXG4gICAgZGVmIHV1aWRcbiAgICAgIHN0ciA9IGhleCgxNikuc3BsaXQoJycpXG4gICAgICBzdHJbMTJdID0gJzQnXG4gICAgICBzdHJbMTZdID0gYChwYXJzZUludCgje3N0clsxNl19LCAxNikgJiAzIHwgOCkudG9TdHJpbmcoMTYpYFxuICAgICAgc3RyID0gW3N0clswLi4uOF0sIHN0cls4Li4uMTJdLCBzdHJbMTIuLi4xNl0sIHN0clsxNi4uLjIwXSwgc3RyWzIwLi4uMzJdXVxuICAgICAgc3RyID0gc3RyLm1hcCgmOmpvaW4pXG4gICAgICBzdHIuam9pbignLScpXG4gICAgZW5kXG5cbiAgICAjIEltcGxlbWVudGVkIGluIHRlcm1zIG9mIGAjYnl0ZXNgIGZvciBTZWN1cmVSYW5kb20sIGJ1dCBSYW5kb20gb3ZlcnJpZGVzIHRoaXNcbiAgICAjIG1ldGhvZCB0byBpbXBsZW1lbnQgYCNieXRlc2AgaW4gdGVybXMgb2YgYCNyYW5kb21fZmxvYXRgLiBOb3QgcGFydCBvZiBzdGFuZGFyZFxuICAgICMgUnVieSBpbnRlcmZhY2UgLSB1c2UgcmFuZG9tX251bWJlciBmb3IgcG9ydGFiaWxpdHkuXG4gICAgZGVmIHJhbmRvbV9mbG9hdFxuICAgICAgYnMgPSBieXRlcyg0KVxuICAgICAgbnVtID0gMFxuICAgICAgNC50aW1lcyBkbyB8aXxcbiAgICAgICAgbnVtIDw8PSA4XG4gICAgICAgIG51bSB8PSBic1tpXS5vcmRcbiAgICAgIGVuZFxuICAgICAgbnVtLmFicyAvIDB4N2ZmZmZmZmZcbiAgICBlbmRcblxuICAgIGRlZiByYW5kb21fbnVtYmVyKGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICAgJXh7XG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUZsb2F0KCkge1xuICAgICAgICAgIHJldHVybiAje3JhbmRvbV9mbG9hdH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByYW5kb21JbnQobWF4KSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tRmxvYXQoKSAqIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByYW5kb21SYW5nZSgpIHtcbiAgICAgICAgICB2YXIgbWluID0gbGltaXQuYmVnaW4sXG4gICAgICAgICAgICAgIG1heCA9IGxpbWl0LmVuZDtcblxuICAgICAgICAgIGlmIChtaW4gPT09IG5pbCB8fCBtYXggPT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gbWF4IC0gbWluO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF4ICUgMSA9PT0gMCAmJiBtaW4gJSAxID09PSAwICYmICFsaW1pdC5leGNsKSB7XG4gICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxlbmd0aCkgKyBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByYW5kb21GbG9hdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbWl0LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZG9tUmFuZ2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW1pdC4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGltaXQgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCkgKiBsaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGltaXQgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGxpbWl0LCA6OkludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGFscGhhbnVtZXJpYyhjb3VudCA9IG5pbClcbiAgICAgIGNvdW50ID0gUmFuZG9tLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgICBtYXAgPSBbJzAnLi4nOScsICdhJy4uJ3onLCAnQScuLidaJ10ubWFwKCY6dG9fYSkuZmxhdHRlblxuICAgICAgOjpBcnJheS5uZXcoY291bnQpIGRvIHxpfFxuICAgICAgICBtYXBbcmFuZG9tX251bWJlcihtYXAubGVuZ3RoKV1cbiAgICAgIGVuZC5qb2luXG4gICAgZW5kXG4gIGVuZFxuXG4gIGluY2x1ZGUgOjpSYW5kb206OkZvcm1hdHRlclxuICBleHRlbmQgOjpSYW5kb206OkZvcm1hdHRlclxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSYW5kb20+IiwiPG1vZHVsZTpzZWxmOjpGb3JtYXR0ZXI+IiwiaGV4IiwiY291bnQiLCJSYW5kb20iLCJfdmVyaWZ5X2NvdW50Iiwic2VsZiIsImJ5dGVzIiwiZW5jb2RlIiwicmFuZG9tX2J5dGVzIiwiYmFzZTY0IiwiQmFzZTY0Iiwic3RyaWN0X2VuY29kZTY0IiwidXJsc2FmZV9iYXNlNjQiLCJwYWRkaW5nIiwidXJsc2FmZV9lbmNvZGU2NCIsInV1aWQiLCJzdHIiLCIxNiIsInNwbGl0IiwiJHdyaXRlciIsIjEyIiwiW109IiwiLSIsIjEiLCJbXSIsIjAiLCI4IiwiMjAiLCIzMiIsIm1hcCIsInRvX3Byb2MiLCJqb2luIiwicmFuZG9tX2Zsb2F0IiwiYnMiLCI0IiwibnVtIiwidGltZXMiLCJibG9jayBpbiByYW5kb21fZmxvYXQiLCJpIiwiPDwiLCJibG9jayAoMiBsZXZlbHMpIGluIHJhbmRvbV9mbG9hdCIsInwiLCJvcmQiLCIvIiwiYWJzIiwiMjE0NzQ4MzY0NyIsInJhbmRvbV9udW1iZXIiLCJsaW1pdCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsImFscGhhbnVtZXJpYyIsImZsYXR0ZW4iLCJuZXciLCJBcnJheSIsImJsb2NrIGluIGFscGhhbnVtZXJpYyIsImJsb2NrICgyIGxldmVscykgaW4gYWxwaGFudW1lcmljIiwibGVuZ3RoIiwiaW5jbHVkZSIsIlJhbmRvbTo6Rm9ybWF0dGVyIiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkRBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQztJQUFBQTs7TUFBQUE7Ozs7QUFDRUMsTUFBQUEsbUJBQUFBLGVBQVFDLEtBQVJEO0FBQUFBLFFBQUFBOzs7O1FBQVEsMkJBQVEsR0FBUjtRQUNOQyxRQUFRQyxhQUFRQyxlQUFBQSxDQUFlRixLQUFmRTs7QUFFdEJILG9CQUFzQkksSUFBQUMsT0FBQUEsQ0FBTUosS0FBTkksQ0FBYUw7QUFDbkNBO0FBQ0FBLDRCQUE4QkMsS0FBTUQ7QUFDcENBO0FBQ0FBO0FBQ0FBLGVBQWlCQSxDQUFDQSxHQUFEQSxDQUFLTSxRQUFBQSxDQUFRTixVQUFSTSxDQUFvQk47QUFDMUNBO01BVElBLENBQUFBLElBQUFBOztBQVlBTyxNQUFBQSw0QkFBQUEsd0JBQWlCTixLQUFqQk07QUFBQUEsUUFBQUE7Ozs7UUFBaUIsMkJBQVEsR0FBUjtRQUNmQSxPQUFBSCxJQUFBQyxPQUFBQSxDQUFNSixLQUFOSTtNQURGRSxDQUFBQSxJQUFBQTs7QUFJQUMsTUFBQUEsc0JBQUFBLGtCQUFXUCxLQUFYTztBQUFBQSxRQUFBQTs7OztRQUFXLDJCQUFRLEdBQVI7UUFDVEEsT0FBQUMsYUFBUUMsaUJBQUFBLENBQWlCTixJQUFBRyxjQUFBQSxDQUFhTixLQUFiTSxDQUFqQkcsQ0FBcUNKLFFBQUFBLENBQVFFLFVBQVJGO01BRC9DRSxDQUFBQSxJQUFBQTs7QUFJQUcsTUFBQUEsOEJBQUFBLDBCQUFtQlYsS0FBRCxFQUFjVyxPQUFoQ0Q7QUFBQUEsUUFBQUE7Ozs7UUFBbUIsMkJBQVEsR0FBUjs7UUFBYSwrQkFBVSxLQUFWO1FBQzlCQSxPQUFBRixhQUFRSSxrQkFBQUEsQ0FBa0JULElBQUFHLGNBQUFBLENBQWFOLEtBQWJNLENBQTFCLEVBQStDSyxPQUF2Q0MsQ0FBK0NQLFFBQUFBLENBQVFL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QUFmLEVBQWlDSixxQkFBRCxHQUFBLENBQXNCQyxLQUF0QixDQUF4QkU7QUFDdEJIOztBQUVBQTtBQUNBQTtBQUNBQTtNQTNESUEsQ0FBQUEsSUFBQUE7TUE4REE5QyxPQUFBc0QsNEJBQUFBLHdCQUFpQnBELEtBQWpCb0Q7QUFBQUEsUUFBQUE7Ozs7UUFBaUIsMkJBQVEsR0FBUjtRQUNmcEQsUUFBUUMsWUFBTUMsZUFBQUEsQ0FBZUYsS0FBZkU7UUFDZHlCLE1BQW9DQSxNQUE5QixDQUFDLE9BQUF5QixHQUFBLEVBQUtBLEdBQUwsUUFBRCxFQUFXLE9BQUFBLEdBQUEsRUFBS0EsR0FBTCxRQUFYLEVBQXFCLE9BQUFBLEdBQUEsRUFBS0EsR0FBTCxRQUFyQixDQUE4QnpCLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sTUFBREMsU0FBQUEsQ0FBQUEsQ0FBTEQsQ0FBWTBCLFNBQUFBLENBQUFBO1FBQ2hERCxPQUFPRSxNQUFQQyxZQUFPRCxPQUFBQSxFQUFBQSxDQUFLdEQsS0FBTHNELENBQUFBLEVBQVBFLGFBQXVCcEIsQ0FBdkJvQixFQUFBQzs7OztVQUF1QjtVQUNyQkEsT0FBQTlCLEdBQUdMLE9BQUFBLENBQUNuQixJQUFBeUMsZUFBQUEsQ0FBY2pCLEdBQUcrQixRQUFBQSxDQUFBQSxDQUFqQmQsQ0FBRHRCLEVBRExrQyxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBT0YsQ0FFSnpCLE1BQUFBLENBQUFBO01BTEx1QixDQUFBQSxJQUFBQTtJQTdHRnRELEdBQU9LLElBQVBMO0lBc0hBSyxJQUFBd0QsU0FBQUEsQ0FBUUMsSUFBQTNELGFBQUEyRCxjQUFSRDtJQUNBOUQsT0FBQU0sSUFBQTBELFFBQUFBLENBQU9ELElBQUEzRCxhQUFBMkQsY0FBUEM7RUF4SEZoRSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDMxOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBUaGlzIGlzIGJhc2VkIG9uIGFuIGFkYXB0YXRpb24gb2YgTWFrb3RvIE1hdHN1bW90byBhbmQgVGFrdWppIE5pc2hpbXVyYSdzIGNvZGVcbiMgZG9uZSBieSBTZWFuIE1jQ3VsbG91Z2ggPGJhbmtzZWFuQGdtYWlsLmNvbT4gYW5kIERhdmUgSGVpdHptYW5cbiMgPGRhdmVoZWl0em1hbkB5YWhvby5jb20+LCBzdWJzZXF1ZW50bHkgcmVhZGFwdGVkIGZyb20gYW4gdXBkYXRlZCB2ZXJzaW9uIG9mXG4jIHJ1YnkncyByYW5kb20uYyAocmV2IGMzOGExODMwMzJhNzgyNmRmMWFkYWJkOGFhMDcyNWM3MTNkNTNlMWMpLlxuI1xuIyBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IG5vdGljZSBmcm9tIHJhbmRvbS5jIGZvbGxvd3MuXG4jXG4jICAgVGhpcyBpcyBiYXNlZCBvbiB0cmltbWVkIHZlcnNpb24gb2YgTVQxOTkzNy4gIFRvIGdldCB0aGUgb3JpZ2luYWwgdmVyc2lvbixcbiMgICBjb250YWN0IDxodHRwOi8vd3d3Lm1hdGguc2NpLmhpcm9zaGltYS11LmFjLmpwL35tLW1hdC9NVC9lbXQuaHRtbD4uXG4jXG4jICAgVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZm9sbG93cy5cbiNcbiMgICAgICBBIEMtcHJvZ3JhbSBmb3IgTVQxOTkzNywgd2l0aCBpbml0aWFsaXphdGlvbiBpbXByb3ZlZCAyMDAyLzIvMTAuXG4jICAgICAgQ29kZWQgYnkgVGFrdWppIE5pc2hpbXVyYSBhbmQgTWFrb3RvIE1hdHN1bW90by5cbiMgICAgICBUaGlzIGlzIGEgZmFzdGVyIHZlcnNpb24gYnkgdGFraW5nIFNoYXduIENva3VzJ3Mgb3B0aW1pemF0aW9uLFxuIyAgICAgIE1hdHRoZSBCZWxsZXcncyBzaW1wbGlmaWNhdGlvbiwgSXNha3UgV2FkYSdzIHJlYWwgdmVyc2lvbi5cbiNcbiMgICAgICBCZWZvcmUgdXNpbmcsIGluaXRpYWxpemUgdGhlIHN0YXRlIGJ5IHVzaW5nIGluaXRfZ2VucmFuZChtdCwgc2VlZClcbiMgICAgICBvciBpbml0X2J5X2FycmF5KG10LCBpbml0X2tleSwga2V5X2xlbmd0aCkuXG4jXG4jICAgICAgQ29weXJpZ2h0IChDKSAxOTk3IC0gMjAwMiwgTWFrb3RvIE1hdHN1bW90byBhbmQgVGFrdWppIE5pc2hpbXVyYSxcbiMgICAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuI1xuIyAgICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIyAgICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuIyAgICAgIGFyZSBtZXQ6XG4jXG4jICAgICAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuIyAgICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuI1xuIyAgICAgICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiMgICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiMgICAgICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4jXG4jICAgICAgICAzLiBUaGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlXG4jICAgICAgICAgICBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW5cbiMgICAgICAgICAgIHBlcm1pc3Npb24uXG4jXG4jICAgICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuIyAgICAgIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiMgICAgICBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiMgICAgICBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcbiMgICAgICBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiMgICAgICBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4jICAgICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4jICAgICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuIyAgICAgIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4jICAgICAgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4jICAgICAgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4jXG4jXG4jICAgICAgQW55IGZlZWRiYWNrIGlzIHZlcnkgd2VsY29tZS5cbiMgICAgICBodHRwOi8vd3d3Lm1hdGgua2Vpby5hYy5qcC9tYXR1bW90by9lbXQuaHRtbFxuIyAgICAgIGVtYWlsOiBtYXR1bW90b0BtYXRoLmtlaW8uYWMuanBcbm1lcnNlbm5lX3R3aXN0ZXIgPSAleHsoZnVuY3Rpb24oKSB7XG4gIC8qIFBlcmlvZCBwYXJhbWV0ZXJzICovXG4gIHZhciBOID0gNjI0O1xuICB2YXIgTSA9IDM5NztcbiAgdmFyIE1BVFJJWF9BID0gMHg5OTA4YjBkZjsgICAgICAvKiBjb25zdGFudCB2ZWN0b3IgYSAqL1xuICB2YXIgVU1BU0sgPSAweDgwMDAwMDAwOyAgICAgICAgIC8qIG1vc3Qgc2lnbmlmaWNhbnQgdy1yIGJpdHMgKi9cbiAgdmFyIExNQVNLID0gMHg3ZmZmZmZmZjsgICAgICAgICAvKiBsZWFzdCBzaWduaWZpY2FudCByIGJpdHMgKi9cbiAgdmFyIE1JWEJJVFMgPSBmdW5jdGlvbih1LHYpIHsgcmV0dXJuICggKCh1KSAmIFVNQVNLKSB8ICgodikgJiBMTUFTSykgKTsgfTtcbiAgdmFyIFRXSVNUID0gZnVuY3Rpb24odSx2KSB7IHJldHVybiAoTUlYQklUUygodSksKHYpKSA+Pj4gMSkgXiAoKHYgJiAweDEpID8gTUFUUklYX0EgOiAweDApOyB9O1xuXG4gIGZ1bmN0aW9uIGluaXQocykge1xuICAgIHZhciBtdCA9IHtsZWZ0OiAwLCBuZXh0OiBOLCBzdGF0ZTogbmV3IEFycmF5KE4pfTtcbiAgICBpbml0X2dlbnJhbmQobXQsIHMpO1xuICAgIHJldHVybiBtdDtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemVzIG10W05dIHdpdGggYSBzZWVkICovXG4gIGZ1bmN0aW9uIGluaXRfZ2VucmFuZChtdCwgcykge1xuICAgIHZhciBqLCBpO1xuICAgIG10LnN0YXRlWzBdID0gcyA+Pj4gMDtcbiAgICBmb3IgKGo9MTsgajxOOyBqKyspIHtcbiAgICAgIG10LnN0YXRlW2pdID0gKDE4MTI0MzMyNTMgKiAoKG10LnN0YXRlW2otMV0gXiAobXQuc3RhdGVbai0xXSA+PiAzMCkgPj4+IDApKSArIGopO1xuICAgICAgLyogU2VlIEtudXRoIFRBT0NQIFZvbDIuIDNyZCBFZC4gUC4xMDYgZm9yIG11bHRpcGxpZXIuICovXG4gICAgICAvKiBJbiB0aGUgcHJldmlvdXMgdmVyc2lvbnMsIE1TQnMgb2YgdGhlIHNlZWQgYWZmZWN0ICAgKi9cbiAgICAgIC8qIG9ubHkgTVNCcyBvZiB0aGUgYXJyYXkgc3RhdGVbXS4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgLyogMjAwMi8wMS8wOSBtb2RpZmllZCBieSBNYWtvdG8gTWF0c3Vtb3RvICAgICAgICAgICAgICovXG4gICAgICBtdC5zdGF0ZVtqXSAmPSAweGZmZmZmZmZmOyAgLyogZm9yID4zMiBiaXQgbWFjaGluZXMgKi9cbiAgICB9XG4gICAgbXQubGVmdCA9IDE7XG4gICAgbXQubmV4dCA9IE47XG4gIH1cblxuICAvKiBnZW5lcmF0ZSBOIHdvcmRzIGF0IG9uZSB0aW1lICovXG4gIGZ1bmN0aW9uIG5leHRfc3RhdGUobXQpIHtcbiAgICB2YXIgcCA9IDAsIF9wID0gbXQuc3RhdGU7XG4gICAgdmFyIGo7XG5cbiAgICBtdC5sZWZ0ID0gTjtcbiAgICBtdC5uZXh0ID0gMDtcblxuICAgIGZvciAoaj1OLU0rMTsgLS1qOyBwKyspXG4gICAgICBfcFtwXSA9IF9wW3ArKE0pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbcCsoMSldKTtcblxuICAgIGZvciAoaj1NOyAtLWo7IHArKylcbiAgICAgIF9wW3BdID0gX3BbcCsoTS1OKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wW3ArKDEpXSk7XG5cbiAgICBfcFtwXSA9IF9wW3ArKE0tTildIF4gVFdJU1QoX3BbcCsoMCldLCBfcFswXSk7XG4gIH1cblxuICAvKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDB4ZmZmZmZmZmZdLWludGVydmFsICovXG4gIGZ1bmN0aW9uIGdlbnJhbmRfaW50MzIobXQpIHtcbiAgICAvKiBtdCBtdXN0IGJlIGluaXRpYWxpemVkICovXG4gICAgdmFyIHk7XG5cbiAgICBpZiAoLS1tdC5sZWZ0IDw9IDApIG5leHRfc3RhdGUobXQpO1xuICAgIHkgPSBtdC5zdGF0ZVttdC5uZXh0KytdO1xuXG4gICAgLyogVGVtcGVyaW5nICovXG4gICAgeSBePSAoeSA+Pj4gMTEpO1xuICAgIHkgXj0gKHkgPDwgNykgJiAweDlkMmM1NjgwO1xuICAgIHkgXj0gKHkgPDwgMTUpICYgMHhlZmM2MDAwMDtcbiAgICB5IF49ICh5ID4+PiAxOCk7XG5cbiAgICByZXR1cm4geSA+Pj4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludF9wYWlyX3RvX3JlYWxfZXhjbHVzaXZlKGEsIGIpIHtcbiAgICBhID4+Pj0gNTtcbiAgICBiID4+Pj0gNjtcbiAgICByZXR1cm4oYSo2NzEwODg2NC4wK2IpKigxLjAvOTAwNzE5OTI1NDc0MDk5Mi4wKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMSkgd2l0aCA1My1iaXQgcmVzb2x1dGlvblxuICBmdW5jdGlvbiBnZW5yYW5kX3JlYWwobXQpIHtcbiAgICAvKiBtdCBtdXN0IGJlIGluaXRpYWxpemVkICovXG4gICAgdmFyIGEgPSBnZW5yYW5kX2ludDMyKG10KSwgYiA9IGdlbnJhbmRfaW50MzIobXQpO1xuICAgIHJldHVybiBpbnRfcGFpcl90b19yZWFsX2V4Y2x1c2l2ZShhLCBiKTtcbiAgfVxuXG4gIHJldHVybiB7IGdlbnJhbmRfcmVhbDogZ2VucmFuZF9yZWFsLCBpbml0OiBpbml0IH07XG59KSgpfVxuXG5jbGFzcyA6OlJhbmRvbVxuICBgdmFyIE1BWF9JTlQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBNYXRoLnBvdygyLCA1MykgLSAxYFxuXG4gIHNlbGY6Ok1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SID0gYHtcbiAgICBuZXdfc2VlZDogZnVuY3Rpb24oKSB7IHJldHVybiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBNQVhfSU5UKTsgfSxcbiAgICByZXNlZWQ6IGZ1bmN0aW9uKHNlZWQpIHsgcmV0dXJuIG1lcnNlbm5lX3R3aXN0ZXIuaW5pdChzZWVkKTsgfSxcbiAgICByYW5kOiBmdW5jdGlvbihtdCkgeyByZXR1cm4gbWVyc2VubmVfdHdpc3Rlci5nZW5yYW5kX3JlYWwobXQpOyB9XG4gIH1gXG5cbiAgc2VsZi5nZW5lcmF0b3IgPSBzZWxmOjpNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUlxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIm1lcnNlbm5lX3R3aXN0ZXIiLCI8Y2xhc3M6UmFuZG9tPiIsInNlbGYiLCIkd3JpdGVyIiwic2VsZjo6TUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IiLCJnZW5lcmF0b3I9IiwiLSIsIjEiXSwibWFwcGluZ3MiOiJBQUFBQSxrRUFBQUE7RUFBQUE7O0VBQUFBOztFQXNEQUMsbUJBQXNCRDtBQUN0QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtFQUVBQSxPQUFBRTtFQUFBQTs7SUFBQUE7OztJQUNHQTtJQUVELFdBQUFDLElBQUEsZ0NBQW9DRDtBQUN0Q0E7QUFDQUE7QUFDQUE7QUFDQUEsR0FKRTs7SUEzSUZFLFVBQUEsQ0FpSm1CQyxJQUFBRixJQUFBRSwrQkFqSm5CO0lBaUpNQyxNQUFKSCxJQUFJRyxjQUFBQSxFQWpKTixNQUFBRixPQUFBLENBaUpNRTtJQWpKTkosT0FBQUUsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUFGLFFBQUEsQ0FBQUssRUFBQUMsQ0FBQUQsQ0FBQTtFQXdJQUwsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQXhJQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NDIzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHlcblxucmVxdWlyZSAnY29yZWxpYi9yYW5kb20vZm9ybWF0dGVyJ1xuXG5jbGFzcyA6OlJhbmRvbVxuICBhdHRyX3JlYWRlciA6c2VlZCwgOnN0YXRlXG5cbiAgZGVmIHNlbGYuX3ZlcmlmeV9jb3VudChjb3VudClcbiAgICAleHtcbiAgICAgIGlmICghJHRydXRoeShjb3VudCkpIGNvdW50ID0gMTY7XG4gICAgICBpZiAodHlwZW9mIGNvdW50ICE9PSBcIm51bWJlclwiKSBjb3VudCA9ICN7YGNvdW50YC50b19pbnR9O1xuICAgICAgaWYgKGNvdW50IDwgMCkgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBzdHJpbmcgc2l6ZSAob3Igc2l6ZSB0b28gYmlnKSd9O1xuICAgICAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKHNlZWQgPSA6OlJhbmRvbS5uZXdfc2VlZClcbiAgICBzZWVkID0gOjpPcGFsLmNvZXJjZV90byEoc2VlZCwgOjpJbnRlZ2VyLCA6dG9faW50KVxuICAgIEBzdGF0ZSA9IHNlZWRcbiAgICByZXNlZWQoc2VlZClcbiAgZW5kXG5cbiAgZGVmIHJlc2VlZChzZWVkKVxuICAgIEBzZWVkID0gc2VlZFxuICAgIGBzZWxmLiRybmcgPSBPcGFsLiQkcmFuZC5yZXNlZWQoc2VlZClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ld19zZWVkXG4gICAgYE9wYWwuJCRyYW5kLm5ld19zZWVkKClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgc2VsZjo6REVGQVVMVC5yYW5kKGxpbWl0KVxuICBlbmRcblxuICBkZWYgc2VsZi5zcmFuZChuID0gOjpSYW5kb20ubmV3X3NlZWQpXG4gICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcblxuICAgIHByZXZpb3VzX3NlZWQgPSBzZWxmOjpERUZBVUxULnNlZWRcbiAgICBzZWxmOjpERUZBVUxULnJlc2VlZChuKVxuICAgIHByZXZpb3VzX3NlZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudXJhbmRvbShzaXplKVxuICAgIDo6U2VjdXJlUmFuZG9tLmJ5dGVzKHNpemUpXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIDo6UmFuZG9tID09PSBvdGhlclxuXG4gICAgc2VlZCA9PSBvdGhlci5zZWVkICYmIHN0YXRlID09IG90aGVyLnN0YXRlXG4gIGVuZFxuXG4gIGRlZiBieXRlcyhsZW5ndGgpXG4gICAgbGVuZ3RoID0gOjpSYW5kb20uX3ZlcmlmeV9jb3VudChsZW5ndGgpXG5cbiAgICA6OkFycmF5Lm5ldyhsZW5ndGgpIHsgcmFuZCgyNTUpLmNociB9LmpvaW4uZW5jb2RlKCdBU0NJSS04QklUJylcbiAgZW5kXG5cbiAgZGVmIHNlbGYuYnl0ZXMobGVuZ3RoKVxuICAgIHNlbGY6OkRFRkFVTFQuYnl0ZXMobGVuZ3RoKVxuICBlbmRcblxuICBkZWYgcmFuZChsaW1pdCA9IHVuZGVmaW5lZClcbiAgICByYW5kb21fbnVtYmVyKGxpbWl0KVxuICBlbmRcblxuICAjIE5vdCBwYXJ0IG9mIHRoZSBSdWJ5IGludGVyZmFjZSAodXNlICNyYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eSksIGJ1dFxuICAjIHVzZWQgYnkgUmFuZG9tOjpGb3JtYXR0ZXIgYXMgYSBzaG9ydGN1dCwgYXMgZm9yIFJhbmRvbSBpbnRlcmZhY2UgdGhlIGZsb2F0XG4gICMgUk5HIGlzIHByaW1hcnkuXG4gIGRlZiByYW5kb21fZmxvYXRcbiAgICAleHtcbiAgICAgIHNlbGYuc3RhdGUrKztcbiAgICAgIHJldHVybiBPcGFsLiQkcmFuZC5yYW5kKHNlbGYuJHJuZyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yYW5kb21fZmxvYXRcbiAgICBzZWxmOjpERUZBVUxULnJhbmRvbV9mbG9hdFxuICBlbmRcblxuICBkZWYgc2VsZi5nZW5lcmF0b3I9KGdlbmVyYXRvcilcbiAgICBgT3BhbC4kJHJhbmQgPSAje2dlbmVyYXRvcn1gXG5cbiAgICBpZiBjb25zdF9kZWZpbmVkPyA6REVGQVVMVFxuICAgICAgc2VsZjo6REVGQVVMVC5yZXNlZWRcbiAgICBlbHNlXG4gICAgICBjb25zdF9zZXQgOkRFRkFVTFQsIG5ldyhuZXdfc2VlZClcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxucmVxdWlyZSAnY29yZWxpYi9yYW5kb20vbWVyc2VubmVfdHdpc3RlcidcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UmFuZG9tPiIsImF0dHJfcmVhZGVyIiwiX3ZlcmlmeV9jb3VudCIsImNvdW50IiwidG9faW50IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiaW5pdGlhbGl6ZSIsInNlZWQiLCJSYW5kb20iLCJuZXdfc2VlZCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsIkBzdGF0ZSIsInJlc2VlZCIsIkBzZWVkIiwicmFuZCIsImxpbWl0Iiwic2VsZjo6REVGQVVMVCIsInNyYW5kIiwibiIsInByZXZpb3VzX3NlZWQiLCJ1cmFuZG9tIiwic2l6ZSIsIlNlY3VyZVJhbmRvbSIsImJ5dGVzIiwiPT0iLCJvdGhlciIsIiRyZXRfb3JfMSIsInN0YXRlIiwibGVuZ3RoIiwibmV3IiwiQXJyYXkiLCJibG9jayBpbiBieXRlcyIsImJsb2NrICgyIGxldmVscykgaW4gYnl0ZXMiLCIyNTUiLCJjaHIiLCJqb2luIiwiZW5jb2RlIiwicmFuZG9tX251bWJlciIsInJhbmRvbV9mbG9hdCIsImdlbmVyYXRvcj0iLCJnZW5lcmF0b3IiLCJjb25zdF9kZWZpbmVkPyIsImNvbnN0X3NldCJdLCJtYXBwaW5ncyI6IkFBQUFBLGlEQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLDBCQUFSRTtFQUVBQztFQUFBQTs7OztJQUNFRixJQUFBRyxhQUFBQSxDQUFZLE1BQVosRUFBbUIsT0FBbkJBO0lBRUFDLE1BQUlKLElBQUpJLG9CQUFBQSx5QkFBdUJDLEtBQXZCRDtBQUFBQTs7QUFFRkE7QUFDQUEsNkNBQStDQSxDQUFDQSxLQUFEQSxDQUFPRSxRQUFBQSxDQUFBQSxDQUFRRjtBQUM5REEscUJBQXVCRyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ0wsd0NBQXhCSSxDQUFpRUo7QUFDaEdBO0FBQ0FBO0FBQ0FBO0lBUEVBLENBQUFBLEdBQUFBOztBQVVBTSxJQUFBQSwwQkFBQUEsc0JBQWVDLElBQWZEO0FBQUFBLE1BQUFBOzs7O01BQWUseUJBQU9FLGFBQVFDLFVBQUFBLENBQUFBLENBQWY7TUFDYkYsT0FBT0csS0FBTUMsZUFBQUEsQ0FBWUosSUFBbEIsRUFBd0JLLGNBQXhCLEVBQW1DLFFBQTdCRDtNQUNiRSxhQUFTTjtNQUNURCxPQUFBVixJQUFBa0IsUUFBQUEsQ0FBT1AsSUFBUE87SUFIRlIsQ0FBQUEsSUFBQUE7O0FBTUFRLElBQUFBLHNCQUFBQSxrQkFBV1AsSUFBWE87QUFBQUEsTUFBQUE7OztNQUNFQyxZQUFRUjtNQUNSTyxPQUFDQSxvQ0FBREE7SUFGRkEsQ0FBQUEsR0FBQUE7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QUFBQTtNQURmO1FBR0UyQixPQUFBN0MsSUFBQWdELFdBQUFBLENBQVUsU0FBVixFQUFvQmhELElBQUFtQyxLQUFBQSxDQUFJbkMsSUFBQWEsVUFBQUEsQ0FBQUEsQ0FBSnNCLENBQXBCYTtNQUhGO0lBSEZILENBQUFBLEdBQUFBO0VBOUVGM0MsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQXlGQUgsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsaUNBQVJFO0FBN0ZBRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ1NTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Vuc3VwcG9ydGVkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiV4e1xuICB2YXIgd2FybmluZ3MgPSB7fTtcblxuICBmdW5jdGlvbiBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShtZXNzYWdlKSB7XG4gICAgc3dpdGNoIChPcGFsLmNvbmZpZy51bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eSkge1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBgbWVzc2FnZWB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHdhcm4obWVzc2FnZSlcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIGlnbm9yZVxuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oc3RyaW5nKSB7XG4gICAgaWYgKHdhcm5pbmdzW3N0cmluZ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nc1tzdHJpbmddID0gdHJ1ZTtcbiAgICAje3dhcm4oYHN0cmluZ2ApfTtcbiAgfVxufVxuXG5jbGFzcyA6OlN0cmluZ1xuICBgdmFyIEVSUk9SID0gXCJTdHJpbmcjJXMgbm90IHN1cHBvcnRlZC4gTXV0YWJsZSBTdHJpbmcgbWV0aG9kcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBPcGFsLlwiYFxuXG4gICVpW1xuICAgIDw8IGNhcGl0YWxpemUhIGNob21wISBjaG9wISBkb3duY2FzZSEgZ3N1YiEgbHN0cmlwISBuZXh0ISByZXZlcnNlIVxuICAgIHNsaWNlISBzcXVlZXplISBzdHJpcCEgc3ViISBzdWNjISBzd2FwY2FzZSEgdHIhIHRyX3MhIHVwY2FzZSEgcHJlcGVuZFxuICAgIFtdPSBjbGVhciBlbmNvZGUhIHVuaWNvZGVfbm9ybWFsaXplIVxuICBdLmVhY2ggZG8gfG1ldGhvZF9uYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbWV0aG9kX25hbWUgZG8gfCp8XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSBtZXRob2RfbmFtZVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgOjpLZXJuZWxcbiAgYHZhciBFUlJPUiA9IFwiT2JqZWN0IGZyZWV6aW5nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgT3BhbFwiYFxuXG4gIGRlZiBmcmVlemVcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZyb3plbj9cbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSA6Oktlcm5lbFxuICBgdmFyIEVSUk9SID0gXCJPYmplY3QgdGFpbnRpbmcgaXMgbm90IHN1cHBvcnRlZCBieSBPcGFsXCJgXG5cbiAgZGVmIHRhaW50XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB1bnRhaW50XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0YWludGVkP1xuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgZmFsc2VcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpNb2R1bGVcbiAgZGVmIHB1YmxpYygqbWV0aG9kcylcbiAgICAleHtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1ldGhvZHMubGVuZ3RoID09PSAxKSA/IG1ldGhvZHNbMF0gOiBtZXRob2RzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfY2xhc3NfbWV0aG9kKCptZXRob2RzKVxuICAgIGByZXR1cm4gKG1ldGhvZHMubGVuZ3RoID09PSAxKSA/IG1ldGhvZHNbMF0gOiBtZXRob2RzYFxuICBlbmRcblxuICBkZWYgcHJpdmF0ZV9tZXRob2RfZGVmaW5lZD8ob2JqKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBwcml2YXRlX2NvbnN0YW50KCopXG4gIGVuZFxuXG4gIGFsaWFzIG5lc3RpbmcgcHVibGljXG4gIGFsaWFzIHByaXZhdGUgcHVibGljXG4gIGFsaWFzIHByb3RlY3RlZCBwdWJsaWNcbiAgYWxpYXMgcHJvdGVjdGVkX21ldGhvZF9kZWZpbmVkPyBwcml2YXRlX21ldGhvZF9kZWZpbmVkP1xuICBhbGlhcyBwdWJsaWNfY2xhc3NfbWV0aG9kIHByaXZhdGVfY2xhc3NfbWV0aG9kXG4gIGFsaWFzIHB1YmxpY19pbnN0YW5jZV9tZXRob2QgaW5zdGFuY2VfbWV0aG9kXG4gIGFsaWFzIHB1YmxpY19pbnN0YW5jZV9tZXRob2RzIGluc3RhbmNlX21ldGhvZHNcbiAgYWxpYXMgcHVibGljX21ldGhvZF9kZWZpbmVkPyBtZXRob2RfZGVmaW5lZD9cbmVuZFxuXG5tb2R1bGUgOjpLZXJuZWxcbiAgZGVmIHByaXZhdGVfbWV0aG9kcygqbWV0aG9kcylcbiAgICBbXVxuICBlbmRcblxuICBhbGlhcyBwcml2YXRlX2luc3RhbmNlX21ldGhvZHMgcHJpdmF0ZV9tZXRob2RzXG5lbmRcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiBldmFsKCopXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBcIlRvIHVzZSBLZXJuZWwjZXZhbCwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnb3BhbC1wYXJzZXInLiBcIlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BhbC9vcGFsL2Jsb2IvI3tSVUJZX0VOR0lORV9WRVJTSU9OfS9kb2NzL29wYWxfcGFyc2VyLm1kIGZvciBkZXRhaWxzLlwiXG4gIGVuZFxuZW5kXG5cbmRlZiBzZWxmLnB1YmxpYygqbWV0aG9kcylcbiAgYHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHNgXG5lbmRcblxuZGVmIHNlbGYucHJpdmF0ZSgqbWV0aG9kcylcbiAgYHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHNgXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiS2VybmVsIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwic2VsZiIsIndhcm4iLCI8Y2xhc3M6U3RyaW5nPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6U3RyaW5nPiIsIm1ldGhvZF9uYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6U3RyaW5nPiIsImRlZmluZV9tZXRob2QiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpTdHJpbmc+IiwiJSIsIjxtb2R1bGU6S2VybmVsPiIsImZyZWV6ZSIsImZyb3plbj8iLCJ0YWludCIsInVudGFpbnQiLCJ0YWludGVkPyIsIjxjbGFzczpNb2R1bGU+IiwicHVibGljIiwicHJpdmF0ZV9jbGFzc19tZXRob2QiLCJwcml2YXRlX21ldGhvZF9kZWZpbmVkPyIsIm9iaiIsInByaXZhdGVfY29uc3RhbnQiLCJwcml2YXRlX21ldGhvZHMiLCJldmFsIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsInByaXZhdGUiXSwibWFwcGluZ3MiOiJBQUFBQSxzREFBQUE7RUFBQUE7O0VBQUFBOzs7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLE1BQVFDLE9BQVFDLE9BQUFBLENBQU9DLDBCQUFmLEVBQXVDSCxPQUEvQkU7QUFDaEJGO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsSUFBTUksSUFBQUMsTUFBQUEsQ0FBTUwsTUFBTkssQ0FBZUw7QUFDckJBOztFQUdBTTtFQUFBQTs7OztJQUNHQTtJQUVEQSxPQUlDQyxNQUpELENBQ0UsSUFERixFQUNLLGFBREwsRUFDaUIsUUFEakIsRUFDd0IsT0FEeEIsRUFDOEIsV0FEOUIsRUFDd0MsT0FEeEMsRUFDOEMsU0FEOUMsRUFDc0QsT0FEdEQsRUFDNEQsVUFENUQsRUFFRSxRQUZGLEVBRVMsVUFGVCxFQUVrQixRQUZsQixFQUV5QixNQUZ6QixFQUU4QixPQUY5QixFQUVvQyxXQUZwQyxFQUU4QyxLQUY5QyxFQUVrRCxPQUZsRCxFQUV3RCxTQUZ4RCxFQUVnRSxTQUZoRSxFQUdFLEtBSEYsRUFHTSxPQUhOLEVBR1ksU0FIWixFQUdvQixvQkFIcEIsQ0FJQ0EsUUFBQUEsRUFBQUEsRUFBQUEsRUFKREMsbUJBSVdDLFdBSlhELEVBQUFFOzs7O01BSVc7TUFDVEEsT0FBQUMsTUFBQVAsSUFBQU8saUJBQUFBLEVBQUFBLENBQWNGLFdBQWRFLENBQUFBLEVBQUFELGFBbENKLEVBa0NJQSxFQUFBRTs7OztRQWxDSjs7UUFrQ2tDO1FBQzVCQSxPQUFBWCxPQUFRQyxPQUFBQSxDQUFPQywwQkFBZixFQUFzQ1MsQ0FBQ0EsS0FBREEsQ0FBUUMsTUFBQUEsQ0FBRUosV0FBRkksQ0FBdENYLEVBRFZRLENBQUFBLElBQUFDLEVBTEZILENBQUFBLEdBQUFBLHFCQUFBQSxDQUlDRDtFQVBIRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0VBY0FRO0VBQUFBOzs7O0lBQ0dBOztBQUVEQyxJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDR0E7TUFDREEsT0FBQVg7SUFGRlcsQ0FBQUEsR0FBQUE7SUFLQUQsT0FBQUUsdUJBQUFBLCtCQUFBQTtBQUFBQTs7TUFDR0E7TUFDREEsT0FBQTtJQUZGQSxDQUFBQSxHQUFBQTtFQVJGRixHQUFPLElBQVBBO0VBY0FBO0VBQUFBOzs7O0lBQ0dBOztBQUVERyxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDR0E7TUFDREEsT0FBQWI7SUFGRmEsQ0FBQUEsR0FBQUE7O0FBS0FDLElBQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNHQTtNQUNEQSxPQUFBZDtJQUZGYyxDQUFBQSxHQUFBQTtJQUtBSixPQUFBSyx3QkFBQUEsZ0NBQUFBO0FBQUFBOztNQUNHQTtNQUNEQSxPQUFBO0lBRkZBLENBQUFBLEdBQUFBO0VBYkZMLEdBQU8sSUFBUEE7RUFtQkFNO0VBQUFBOzs7OztBQUNFQyxJQUFBQSxzQkFBQUEsMEJBMUVGLEVBMEVFQTtBQUFBQSxNQUFBQTs7OztNQTFFRjs7TUEwRWE7O0FBRWJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBUEVBLENBQUFBLElBQUFBOztBQVVBQyxJQUFBQSxvQ0FBQUEsZ0NBcEZGLEVBb0ZFQTtBQUFBQSxNQUFBQTs7OztNQXBGRjs7TUFvRjJCO01BQ3RCQSxvREFBREE7SUFERkEsQ0FBQUEsSUFBQUE7O0FBSUFDLElBQUFBLHVDQUFBQSwrQ0FBNEJDLEdBQTVCRDtBQUFBQTtNQUNFQSxPQUFBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxnQ0FBQUEsNEJBNUZGLEVBNEZFQTtBQUFBQSxNQUFBQTs7OztNQTVGRjs7TUE0RnVCO01BNUZ2QkEsT0FBQTtJQTRGRUEsQ0FBQUEsSUFBQUE7SUFHQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0lBQ0EsYUFBTSxTQUFOLEVBQWMsUUFBZDtJQUNBLGFBQU0sV0FBTixFQUFnQixRQUFoQjtJQUNBLGFBQU0sMkJBQU4sRUFBZ0MseUJBQWhDO0lBQ0EsYUFBTSxxQkFBTixFQUEwQixzQkFBMUI7SUFDQSxhQUFNLHdCQUFOLEVBQTZCLGlCQUE3QjtJQUNBLGFBQU0seUJBQU4sRUFBOEIsa0JBQTlCO0lBQ0FMLE9BQUEsYUFBTSx3QkFBTixFQUE2QixpQkFBN0I7RUE3QkZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUFnQ0FOO0VBQUFBOzs7OztBQUNFWSxJQUFBQSwrQkFBQUEsMkJBMUdGLEVBMEdFQTtBQUFBQSxNQUFBQTs7OztNQTFHRjs7TUEwR3NCO01BQ2xCQSxPQUFBO0lBREZBLENBQUFBLElBQUFBO0lBSUFaLE9BQUEsYUFBTSwwQkFBTixFQUErQixpQkFBL0I7RUFMRkEsR0FBTyxJQUFQQTtFQVFBQTtFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFhLG9CQUFBQSx3QkFsSEYsRUFrSEVBO0FBQUFBLE1BQUFBOzs7O01BbEhGOztNQWtIVztNQUNQQSxPQUFBMUIsT0FBUUMsT0FBQUEsQ0FBT0MsMEJBQWYsRUFBc0N3Qiw0REFBQSxHQUFBLENBQ0NBLHdDQUFELEdBQUEsQ0FBeUNDLHlCQUF6QyxDQUFBLEdBQTZERCxtQ0FEN0QsQ0FBOUJ6QjtJQURWeUIsQ0FBQUEsSUFBQUE7RUFERmIsR0FBTyxJQUFQQTtFQU9BTyxNQUFJakIsSUFBSmlCLGFBQUFBLG1CQXhIQSxFQXdIQUE7QUFBQUEsSUFBQUE7Ozs7SUF4SEE7O0lBd0hnQjtJQUNiQSxvREFBREE7RUFERkEsQ0FBQUEsSUFBQUE7RUFJQXJCLE9BQUE2QixNQUFJekIsSUFBSnlCLGNBQUFBLG9CQTVIQSxFQTRIQUE7QUFBQUEsSUFBQUE7Ozs7SUE1SEE7O0lBNEhpQjtJQUNkQSxvREFBREE7RUFERkEsQ0FBQUEsSUFBQUE7QUE1SEE3QjsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ3NzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL29wYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiOjpPYmplY3QucmVxdWlyZSAnb3BhbC9iYXNlJ1xuOjpPYmplY3QucmVxdWlyZSAnb3BhbC9taW5pJ1xuXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2tlcm5lbC9mb3JtYXQnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3N0cmluZy9lbmNvZGluZydcbjo6T2JqZWN0LmF1dG9sb2FkIDpNYXRoLCAnY29yZWxpYi9tYXRoJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb21wbGV4L2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6Q29tcGxleCwgJ2NvcmVsaWIvY29tcGxleCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcmF0aW9uYWwvYmFzZSdcbjo6T2JqZWN0LmF1dG9sb2FkIDpSYXRpb25hbCwgJ2NvcmVsaWIvcmF0aW9uYWwnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3RpbWUnXG46Ok9iamVjdC5hdXRvbG9hZCA6U3RydWN0LCAnY29yZWxpYi9zdHJ1Y3QnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2Rpcidcbjo6T2JqZWN0LmF1dG9sb2FkIDpGaWxlLCAnY29yZWxpYi9maWxlJ1xuXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3Byb2Nlc3MvYmFzZSdcbjo6T2JqZWN0LmF1dG9sb2FkIDpQcm9jZXNzLCAnY29yZWxpYi9wcm9jZXNzJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlJhbmRvbSwgJ2NvcmVsaWIvcmFuZG9tJ1xuXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3Vuc3VwcG9ydGVkJ1xuIl0sIm5hbWVzIjpbIjxtYWluPiIsIk9iamVjdCIsInJlcXVpcmUiLCJhdXRvbG9hZCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLE9BQVFDLFNBQUFBLENBQVNGLFdBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLFdBQVRFO0VBRVJELE9BQVFDLFNBQUFBLENBQVNGLHVCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRix5QkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxNQUFsQixFQUF5QkgsY0FBakJHO0VBQ1JGLE9BQVFDLFNBQUFBLENBQVNGLHNCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFNBQWxCLEVBQTRCSCxpQkFBcEJHO0VBQ1JGLE9BQVFDLFNBQUFBLENBQVNGLHVCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFVBQWxCLEVBQTZCSCxrQkFBckJHO0VBQ1JGLE9BQVFDLFNBQUFBLENBQVNGLGNBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsUUFBbEIsRUFBMkJILGdCQUFuQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsYUFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxNQUFsQixFQUF5QkgsY0FBakJHO0VBRVJGLE9BQVFDLFNBQUFBLENBQVNGLHNCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFNBQWxCLEVBQTRCSCxpQkFBcEJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsUUFBbEIsRUFBMkJILGdCQUFuQkc7RUFFUkgsT0FBQUMsT0FBUUMsU0FBQUEsQ0FBU0YscUJBQVRFO0FBbkJSRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ3OTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3BhY2tfdW5wYWNrL2Zvcm1hdF9zdHJpbmdfcGFyc2VyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSA6OlBhY2tVbnBhY2tcbiAgJXh7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSBbXG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICAnQycsXG4gICAgICAnUycsXG4gICAgICAnTCcsXG4gICAgICAnUScsXG4gICAgICAnSicsXG5cbiAgICAgICdjJyxcbiAgICAgICdzJyxcbiAgICAgICdsJyxcbiAgICAgICdxJyxcbiAgICAgICdqJyxcblxuICAgICAgJ24nLFxuICAgICAgJ04nLFxuICAgICAgJ3YnLFxuICAgICAgJ1YnLFxuXG4gICAgICAnVScsXG4gICAgICAndycsXG5cbiAgICAgIC8vIEZsb2F0XG4gICAgICAnRCcsXG4gICAgICAnZCcsXG4gICAgICAnRicsXG4gICAgICAnZicsXG4gICAgICAnRScsXG4gICAgICAnZScsXG4gICAgICAnRycsXG4gICAgICAnZycsXG5cbiAgICAgIC8vIFN0cmluZ1xuICAgICAgJ0EnLFxuICAgICAgJ2EnLFxuICAgICAgJ1onLFxuICAgICAgJ0InLFxuICAgICAgJ2InLFxuICAgICAgJ0gnLFxuICAgICAgJ2gnLFxuICAgICAgJ3UnLFxuICAgICAgJ00nLFxuICAgICAgJ20nLFxuXG4gICAgICAnUCcsXG4gICAgICAncCcsXG5cbiAgICAgIC8vIE1pc2NcbiAgICAgICdAJyxcbiAgICAgICdYJyxcbiAgICAgICd4J1xuICAgIF07XG5cbiAgICB2YXIgbW9kaWZpZXJzID0gW1xuICAgICAgJyEnLCAvLyBpZ25vcmVkXG4gICAgICAnXycsIC8vIGlnbm9yZWRcbiAgICAgICc+JywgLy8gYmlnIGVuZGlhblxuICAgICAgJzwnICAvLyBsaXR0bGUgZW5kaWFuXG4gICAgXTtcblxuICAgIHNlbGYuZWFjaERpcmVjdGl2ZUFuZENvdW50ID0gZnVuY3Rpb24oZm9ybWF0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGN1cnJlbnREaXJlY3RpdmUsXG4gICAgICAgICAgY3VycmVudENvdW50LFxuICAgICAgICAgIGN1cnJlbnRNb2RpZmllcnMsXG4gICAgICAgICAgY291bnRTcGVjaWZpZWQ7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBjdXJyZW50RGlyZWN0aXZlID0gbnVsbDtcbiAgICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICAgICAgY3VycmVudE1vZGlmaWVycyA9IFtdO1xuICAgICAgICBjb3VudFNwZWNpZmllZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXNldCgpO1xuXG4gICAgICBmdW5jdGlvbiB5aWVsZEFuZFJlc2V0KCkge1xuICAgICAgICBpZiAoY3VycmVudERpcmVjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlyZWN0aXZlU3VwcG9ydHNNb2RpZmllcnMgPSAvW3NTaUlsTHFRakpdLy50ZXN0KGN1cnJlbnREaXJlY3RpdmUpO1xuXG4gICAgICAgIGlmICghZGlyZWN0aXZlU3VwcG9ydHNNb2RpZmllcnMgJiYgY3VycmVudE1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiJyN7YGN1cnJlbnRNb2RpZmllcnNbMF1gfScgYWxsb3dlZCBvbmx5IGFmdGVyIHR5cGVzIHNTaUlsTHFRakpcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50TW9kaWZpZXJzLmluZGV4T2YoJzwnKSAhPT0gLTEgJiYgY3VycmVudE1vZGlmaWVycy5pbmRleE9mKCc+JykgIT09IC0xKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiQ2FuJ3QgdXNlIGJvdGggJzwnIGFuZCAnPidcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY291bnRTcGVjaWZpZWQpIHtcbiAgICAgICAgICBjdXJyZW50Q291bnQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRNb2RpZmllcnMuaW5kZXhPZignPicpICE9PSAtMSkge1xuICAgICAgICAgIGN1cnJlbnREaXJlY3RpdmUgPSBjdXJyZW50RGlyZWN0aXZlICsgJz4nO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soY3VycmVudERpcmVjdGl2ZSwgY3VycmVudENvdW50KTtcblxuICAgICAgICByZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudENoYXIgPSBmb3JtYXRbaV07XG5cbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMuaW5kZXhPZihjdXJyZW50Q2hhcikgIT09IC0xKSB7XG4gICAgICAgICAgLy8gRGlyZWN0aXZlIGNoYXIgYWx3YXlzIHJlc2V0cyBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgeWllbGRBbmRSZXNldCgpO1xuICAgICAgICAgIGN1cnJlbnREaXJlY3RpdmUgPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50RGlyZWN0aXZlKSB7XG4gICAgICAgICAgaWYgKC9cXGQvLnRlc3QoY3VycmVudENoYXIpKSB7XG4gICAgICAgICAgICAvLyBDb3VudCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBzZXF1ZW5jZSBvZiBkaWdpdHNcbiAgICAgICAgICAgIGN1cnJlbnRDb3VudCA9IGN1cnJlbnRDb3VudCAqIDEwICsgcGFyc2VJbnQoY3VycmVudENoYXIsIDEwKTtcbiAgICAgICAgICAgIGNvdW50U3BlY2lmaWVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSAnKicgJiYgY291bnRTcGVjaWZpZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBDb3VudCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgYSBzdGFyIGNoYXJhY3RlclxuICAgICAgICAgICAgY3VycmVudENvdW50ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBjb3VudFNwZWNpZmllZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChtb2RpZmllcnMuaW5kZXhPZihjdXJyZW50Q2hhcikgIT09IC0xICYmIGNvdW50U3BlY2lmaWVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gRGlyZWN0aXZlcyBjYW4gYmUgc3BlY2lmaWVkIG9ubHkgYWZ0ZXIgZGlyZWN0aXZlIGFuZCBiZWZvcmUgY291bnRcbiAgICAgICAgICAgIGN1cnJlbnRNb2RpZmllcnMucHVzaChjdXJyZW50Q2hhcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkQW5kUmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeWllbGRBbmRSZXNldCgpO1xuICAgIH1cbiAgfVxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6UGFja1VucGFjaz4iLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJSYW5nZUVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkVBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7OztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLFVBQVlDLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDSCxHQUFELEdBQUEsQ0FBS0EsbUJBQUwsQ0FBQSxHQUEwQkEsdUNBQWxERTtBQUNwQkY7O0FBRUFBO0FBQ0FBLFVBQVlDLE9BQVFDLE9BQUFBLENBQU9FLGlCQUFmLEVBQTZCSiw0QkFBckJFO0FBQ3BCRjs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7RUFySUFBLEdBQU8sSUFBUEE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0OTM4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9hcnJheS9wYWNrLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogY29lcmNlX3RvXG5cbnJlcXVpcmUgJ2NvcmVsaWIvcGFja191bnBhY2svZm9ybWF0X3N0cmluZ19wYXJzZXInXG5cbmNsYXNzIDo6QXJyYXlcbiAgJXh7XG4gICAgLy8gRm9ybWF0IFBhcnNlclxuICAgIHZhciBlYWNoRGlyZWN0aXZlQW5kQ291bnQgPSBPcGFsLlBhY2tVbnBhY2suZWFjaERpcmVjdGl2ZUFuZENvdW50O1xuXG4gICAgZnVuY3Rpb24gaWRlbnRpdHlGdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH1cblxuICAgIGZ1bmN0aW9uIHV0ZjhCeXRlc1RvVXRmMTZMRVN0cmluZyhieXRlcykge1xuICAgICAgdmFyIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpLCBvdXQgPSBcIlwiLCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aCwgYywgY2hhcjIsIGNoYXIzO1xuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIHN3aXRjaCAoYyA+PiA0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgICAgICBvdXQgKz0gc3RyLmNoYXJBdChpIC0gMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAvLyAxMTB4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgICAgICBjaGFyMiA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFGKSA8PCA2KSB8IChjaGFyMiAmIDB4M0YpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHgxMHh4IHh4eHgxMHh4IHh4eHhcbiAgICAgICAgICAgIGNoYXIyID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgIGNoYXIzID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MEYpIDw8IDEyKSB8ICgoY2hhcjIgJiAweDNGKSA8PCA2KSB8ICgoY2hhcjMgJiAweDNGKSA8PCAwKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc2NpaUJ5dGVzVG9VdGYxNkxFU3RyaW5nKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNjaWlTdHJpbmdGcm9tVW5zaWduZWRJbnQoYnl0ZXMsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gY2FsbGJhY2soZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJpdCA9IGl0ZW0gJiAyNTU7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiaXQpO1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW0gPj4gODtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIGFzY2lpQnl0ZXNUb1V0ZjE2TEVTdHJpbmcocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNjaWlTdHJpbmdGcm9tU2lnbmVkSW50KGJ5dGVzLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGNhbGxiYWNrKGRhdGEpLFxuICAgICAgICAgICAgYml0cyA9IGJ5dGVzICogOCxcbiAgICAgICAgICAgIGxpbWl0ID0gTWF0aC5wb3coMiwgYml0cyk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIGlmIChpdGVtIDwgMCkge1xuICAgICAgICAgICAgaXRlbSArPSBsaW1pdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiaXQgPSBpdGVtICYgMjU1O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYml0KTtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtID4+IDg7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBhc2NpaUJ5dGVzVG9VdGYxNkxFU3RyaW5nKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gY2FsbGJhY2soZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiAkY29lcmNlX3RvKGl0ZW0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRvU3RyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gY2FsbGJhY2soZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiAkY29lcmNlX3RvKGl0ZW0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICByZXR1cm4gYnVmZmVyLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChpdGVtKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ3ZhbHVlIG91dCBvZiByYW5nZSd9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqb2luQ2hhcnMoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICAnQyc6IGpvaW5DaGFycyhhc2NpaVN0cmluZ0Zyb21VbnNpZ25lZEludCgxLCB0b0ludChpZGVudGl0eUZ1bmN0aW9uKSkpLFxuICAgICAgJ1MnOiBqb2luQ2hhcnMoYXNjaWlTdHJpbmdGcm9tVW5zaWduZWRJbnQoMiwgdG9JbnQoaWRlbnRpdHlGdW5jdGlvbikpKSxcbiAgICAgICdMJzogam9pbkNoYXJzKGFzY2lpU3RyaW5nRnJvbVVuc2lnbmVkSW50KDQsIHRvSW50KGlkZW50aXR5RnVuY3Rpb24pKSksXG4gICAgICAnUSc6IGpvaW5DaGFycyhhc2NpaVN0cmluZ0Zyb21VbnNpZ25lZEludCg4LCB0b0ludChpZGVudGl0eUZ1bmN0aW9uKSkpLFxuICAgICAgJ0onOiBudWxsLFxuXG4gICAgICAnUz4nOiBudWxsLFxuICAgICAgJ0w+JzogbnVsbCxcbiAgICAgICdRPic6IG51bGwsXG5cbiAgICAgICdjJzogam9pbkNoYXJzKGFzY2lpU3RyaW5nRnJvbVNpZ25lZEludCgxLCB0b0ludChpZGVudGl0eUZ1bmN0aW9uKSkpLFxuICAgICAgJ3MnOiBqb2luQ2hhcnMoYXNjaWlTdHJpbmdGcm9tU2lnbmVkSW50KDIsIHRvSW50KGlkZW50aXR5RnVuY3Rpb24pKSksXG4gICAgICAnbCc6IGpvaW5DaGFycyhhc2NpaVN0cmluZ0Zyb21TaWduZWRJbnQoNCwgdG9JbnQoaWRlbnRpdHlGdW5jdGlvbikpKSxcbiAgICAgICdxJzogam9pbkNoYXJzKGFzY2lpU3RyaW5nRnJvbVNpZ25lZEludCg4LCB0b0ludChpZGVudGl0eUZ1bmN0aW9uKSkpLFxuICAgICAgJ2onOiBudWxsLFxuXG4gICAgICAncz4nOiBudWxsLFxuICAgICAgJ2w+JzogbnVsbCxcbiAgICAgICdxPic6IG51bGwsXG5cbiAgICAgICduJzogbnVsbCxcbiAgICAgICdOJzogbnVsbCxcbiAgICAgICd2JzogbnVsbCxcbiAgICAgICdWJzogbnVsbCxcblxuICAgICAgJ1UnOiBqb2luQ2hhcnMoZnJvbUNvZGVQb2ludCh0b0ludChpZGVudGl0eUZ1bmN0aW9uKSkpLFxuICAgICAgJ3cnOiBudWxsLFxuXG4gICAgICAvLyBGbG9hdFxuICAgICAgJ0QnOiBudWxsLFxuICAgICAgJ2QnOiBudWxsLFxuICAgICAgJ0YnOiBudWxsLFxuICAgICAgJ2YnOiBudWxsLFxuICAgICAgJ0UnOiBudWxsLFxuICAgICAgJ2UnOiBudWxsLFxuICAgICAgJ0cnOiBudWxsLFxuICAgICAgJ2cnOiBudWxsLFxuXG4gICAgICAvLyBTdHJpbmdcbiAgICAgICdBJzogam9pbkNoYXJzKGlkZW50aXR5RnVuY3Rpb24pLFxuICAgICAgJ2EnOiBqb2luQ2hhcnMoaWRlbnRpdHlGdW5jdGlvbiksXG4gICAgICAnWic6IG51bGwsXG4gICAgICAnQic6IG51bGwsXG4gICAgICAnYic6IG51bGwsXG4gICAgICAnSCc6IG51bGwsXG4gICAgICAnaCc6IG51bGwsXG4gICAgICAndSc6IG51bGwsXG4gICAgICAnTSc6IG51bGwsXG4gICAgICAnbSc6IG51bGwsXG5cbiAgICAgICdQJzogbnVsbCxcbiAgICAgICdwJzogbnVsbFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWFkTlRpbWVzRnJvbUJ1ZmZlckFuZE1lcmdlKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYnVmZmVyLCBjb3VudCkge1xuICAgICAgICB2YXIgY2h1bmsgPSBbXSwgY2h1bmtEYXRhO1xuXG4gICAgICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNodW5rRGF0YSA9IGNhbGxiYWNrKGJ1ZmZlcik7XG4gICAgICAgICAgICBidWZmZXIgPSBjaHVua0RhdGEucmVzdDtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsuY29uY2F0KGNodW5rRGF0YS5jaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndG9vIGZldyBhcmd1bWVudHMnfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjaHVua0RhdGEgPSBjYWxsYmFjayhidWZmZXIpO1xuICAgICAgICAgICAgYnVmZmVyID0gY2h1bmtEYXRhLnJlc3Q7XG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLmNvbmNhdChjaHVua0RhdGEuY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGNodW5rOiBjaHVuaywgcmVzdDogYnVmZmVyIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZEl0ZW0oYnVmZmVyKSB7XG4gICAgICB2YXIgY2h1bmsgPSBidWZmZXIuc2xpY2UoMCwgMSk7XG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMSwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICByZXR1cm4geyBjaHVuazogY2h1bmssIHJlc3Q6IGJ1ZmZlciB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWROQ2hhcnNGcm9tVGhlRmlyc3RJdGVtQW5kTWVyZ2VXaXRoRmFsbGJhY2soZmFsbGJhY2ssIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYnVmZmVyLCBjb3VudCkge1xuICAgICAgICB2YXIgY2h1bmsgPSBbXSwgc291cmNlID0gYnVmZmVyWzBdO1xuXG4gICAgICAgIGlmIChzb3VyY2UgPT09IG5pbCkge1xuICAgICAgICAgIHNvdXJjZSA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0b28gZmV3IGFyZ3VtZW50cyd9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvdXJjZSA9ICRjb2VyY2VfdG8oc291cmNlLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDEsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluZmluaXRlUmVlZGVyKCkge1xuICAgICAgICAgIHZhciBjaHVua0RhdGEgPSBjYWxsYmFjayhzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IGNodW5rRGF0YS5yZXN0O1xuICAgICAgICAgIHZhciBzdWJDaHVuayA9IGNodW5rRGF0YS5jaHVuaztcblxuICAgICAgICAgIGlmIChzdWJDaHVuay5sZW5ndGggPT09IDEgJiYgc3ViQ2h1bmtbMF0gPT09IG5pbCkge1xuICAgICAgICAgICAgc3ViQ2h1bmsgPSBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNodW5rID0gY2h1bmsuY29uY2F0KHN1YkNodW5rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbml0ZVJlZWRlcigpIHtcbiAgICAgICAgICB2YXIgY2h1bmtEYXRhID0gY2FsbGJhY2soc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSBjaHVua0RhdGEucmVzdDtcbiAgICAgICAgICB2YXIgc3ViQ2h1bmsgPSBjaHVua0RhdGEuY2h1bms7XG5cbiAgICAgICAgICBpZiAoc3ViQ2h1bmsubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWJDaHVuayA9IFtmYWxsYmFja107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN1YkNodW5rLmxlbmd0aCA9PT0gMSAmJiBzdWJDaHVua1swXSA9PT0gbmlsKSB7XG4gICAgICAgICAgICBzdWJDaHVuayA9IFtmYWxsYmFja107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2h1bmsgPSBjaHVuay5jb25jYXQoc3ViQ2h1bmspO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHdoaWxlIChzb3VyY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5maW5pdGVSZWVkZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBmaW5pdGVSZWVkZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBjaHVuazogY2h1bmssIHJlc3Q6IGJ1ZmZlciB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWFkQ2h1bmsgPSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICAnQyc6IHJlYWROVGltZXNGcm9tQnVmZmVyQW5kTWVyZ2UocmVhZEl0ZW0pLFxuICAgICAgJ1MnOiByZWFkTlRpbWVzRnJvbUJ1ZmZlckFuZE1lcmdlKHJlYWRJdGVtKSxcbiAgICAgICdMJzogcmVhZE5UaW1lc0Zyb21CdWZmZXJBbmRNZXJnZShyZWFkSXRlbSksXG4gICAgICAnUSc6IHJlYWROVGltZXNGcm9tQnVmZmVyQW5kTWVyZ2UocmVhZEl0ZW0pLFxuICAgICAgJ0onOiBudWxsLFxuXG4gICAgICAnUz4nOiBudWxsLFxuICAgICAgJ0w+JzogbnVsbCxcbiAgICAgICdRPic6IG51bGwsXG5cbiAgICAgICdjJzogcmVhZE5UaW1lc0Zyb21CdWZmZXJBbmRNZXJnZShyZWFkSXRlbSksXG4gICAgICAncyc6IHJlYWROVGltZXNGcm9tQnVmZmVyQW5kTWVyZ2UocmVhZEl0ZW0pLFxuICAgICAgJ2wnOiByZWFkTlRpbWVzRnJvbUJ1ZmZlckFuZE1lcmdlKHJlYWRJdGVtKSxcbiAgICAgICdxJzogcmVhZE5UaW1lc0Zyb21CdWZmZXJBbmRNZXJnZShyZWFkSXRlbSksXG4gICAgICAnaic6IG51bGwsXG5cbiAgICAgICdzPic6IG51bGwsXG4gICAgICAnbD4nOiBudWxsLFxuICAgICAgJ3E+JzogbnVsbCxcblxuICAgICAgJ24nOiBudWxsLFxuICAgICAgJ04nOiBudWxsLFxuICAgICAgJ3YnOiBudWxsLFxuICAgICAgJ1YnOiBudWxsLFxuXG4gICAgICAnVSc6IHJlYWROVGltZXNGcm9tQnVmZmVyQW5kTWVyZ2UocmVhZEl0ZW0pLFxuICAgICAgJ3cnOiBudWxsLFxuXG4gICAgICAvLyBGbG9hdFxuICAgICAgJ0QnOiBudWxsLFxuICAgICAgJ2QnOiBudWxsLFxuICAgICAgJ0YnOiBudWxsLFxuICAgICAgJ2YnOiBudWxsLFxuICAgICAgJ0UnOiBudWxsLFxuICAgICAgJ2UnOiBudWxsLFxuICAgICAgJ0cnOiBudWxsLFxuICAgICAgJ2cnOiBudWxsLFxuXG4gICAgICAvLyBTdHJpbmdcbiAgICAgICdBJzogcmVhZE5DaGFyc0Zyb21UaGVGaXJzdEl0ZW1BbmRNZXJnZVdpdGhGYWxsYmFjayhcIiBcIiwgcmVhZEl0ZW0pLFxuICAgICAgJ2EnOiByZWFkTkNoYXJzRnJvbVRoZUZpcnN0SXRlbUFuZE1lcmdlV2l0aEZhbGxiYWNrKFwiXFx4MDBcIiwgcmVhZEl0ZW0pLFxuICAgICAgJ1onOiBudWxsLFxuICAgICAgJ0InOiBudWxsLFxuICAgICAgJ2InOiBudWxsLFxuICAgICAgJ0gnOiBudWxsLFxuICAgICAgJ2gnOiBudWxsLFxuICAgICAgJ3UnOiBudWxsLFxuICAgICAgJ00nOiBudWxsLFxuICAgICAgJ20nOiBudWxsLFxuXG4gICAgICAnUCc6IG51bGwsXG4gICAgICAncCc6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIGF1dG9jb21wbGV0aW9uID0ge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgJ0MnOiBmYWxzZSxcbiAgICAgICdTJzogZmFsc2UsXG4gICAgICAnTCc6IGZhbHNlLFxuICAgICAgJ1EnOiBmYWxzZSxcbiAgICAgICdKJzogbnVsbCxcblxuICAgICAgJ1M+JzogbnVsbCxcbiAgICAgICdMPic6IG51bGwsXG4gICAgICAnUT4nOiBudWxsLFxuXG4gICAgICAnYyc6IGZhbHNlLFxuICAgICAgJ3MnOiBmYWxzZSxcbiAgICAgICdsJzogZmFsc2UsXG4gICAgICAncSc6IGZhbHNlLFxuICAgICAgJ2onOiBudWxsLFxuXG4gICAgICAncz4nOiBudWxsLFxuICAgICAgJ2w+JzogbnVsbCxcbiAgICAgICdxPic6IG51bGwsXG5cbiAgICAgICduJzogbnVsbCxcbiAgICAgICdOJzogbnVsbCxcbiAgICAgICd2JzogbnVsbCxcbiAgICAgICdWJzogbnVsbCxcblxuICAgICAgJ1UnOiBmYWxzZSxcbiAgICAgICd3JzogbnVsbCxcblxuICAgICAgLy8gRmxvYXRcbiAgICAgICdEJzogbnVsbCxcbiAgICAgICdkJzogbnVsbCxcbiAgICAgICdGJzogbnVsbCxcbiAgICAgICdmJzogbnVsbCxcbiAgICAgICdFJzogbnVsbCxcbiAgICAgICdlJzogbnVsbCxcbiAgICAgICdHJzogbnVsbCxcbiAgICAgICdnJzogbnVsbCxcblxuICAgICAgLy8gU3RyaW5nXG4gICAgICAnQSc6IGZhbHNlLFxuICAgICAgJ2EnOiBmYWxzZSxcbiAgICAgICdaJzogbnVsbCxcbiAgICAgICdCJzogbnVsbCxcbiAgICAgICdiJzogbnVsbCxcbiAgICAgICdIJzogbnVsbCxcbiAgICAgICdoJzogbnVsbCxcbiAgICAgICd1JzogZmFsc2UsXG4gICAgICAnTSc6IG51bGwsXG4gICAgICAnbSc6IG51bGwsXG5cbiAgICAgICdQJzogbnVsbCxcbiAgICAgICdwJzogbnVsbFxuICAgIH07XG4gIH1cblxuICBkZWYgcGFjayhmb3JtYXQpXG4gICAgZm9ybWF0ID0gOjpPcGFsLmNvZXJjZV90byEoZm9ybWF0LCA6OlN0cmluZywgOnRvX3N0cikuZ3N1YigvXFxzLywgJycpLmRlbGV0ZShcIlxcMDAwXCIpXG5cbiAgICAleHtcbiAgICAgIHZhciBvdXRwdXQgPSAnJztcblxuICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuc2xpY2UoKTtcblxuICAgICAgZnVuY3Rpb24gYXV0b2NvbXBsZXRlKGFycmF5LCBzaXplKSB7XG4gICAgICAgIHdoaWxlIChhcnJheS5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgICAgYXJyYXkucHVzaChuaWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzQ2h1bmsoZGlyZWN0aXZlLCBjb3VudCkge1xuICAgICAgICB2YXIgY2h1bmssXG4gICAgICAgICAgICBjaHVua1JlYWRlciA9IHJlYWRDaHVua1tkaXJlY3RpdmVdO1xuXG4gICAgICAgIGlmIChjaHVua1JlYWRlciA9PSBudWxsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBcIlVuc3VwcG9ydGVkIHBhY2sgZGlyZWN0aXZlICN7YGRpcmVjdGl2ZWAuaW5zcGVjdH0gKG5vIGNodW5rIHJlYWRlciBkZWZpbmVkKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNodW5rRGF0YSA9IGNodW5rUmVhZGVyKGJ1ZmZlciwgY291bnQpO1xuICAgICAgICBjaHVuayA9IGNodW5rRGF0YS5jaHVuaztcbiAgICAgICAgYnVmZmVyID0gY2h1bmtEYXRhLnJlc3Q7XG5cbiAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tkaXJlY3RpdmVdO1xuXG4gICAgICAgIGlmIChoYW5kbGVyID09IG51bGwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIFwiVW5zdXBwb3J0ZWQgcGFjayBkaXJlY3RpdmUgI3tgZGlyZWN0aXZlYC5pbnNwZWN0fSAobm8gaGFuZGxlciBkZWZpbmVkKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBlYWNoRGlyZWN0aXZlQW5kQ291bnQoZm9ybWF0LCBmdW5jdGlvbihkaXJlY3RpdmUsIGNvdW50KSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcHJvY2Vzc0NodW5rKGRpcmVjdGl2ZSwgY291bnQpO1xuXG4gICAgICAgIGlmIChjb3VudCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICB2YXIgc2hvdWxkQXV0b2NvbXBsZXRlID0gYXV0b2NvbXBsZXRpb25bZGlyZWN0aXZlXVxuXG4gICAgICAgICAgaWYgKHNob3VsZEF1dG9jb21wbGV0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIFwiVW5zdXBwb3J0ZWQgcGFjayBkaXJlY3RpdmUgI3tgZGlyZWN0aXZlYC5pbnNwZWN0fSAobm8gYXV0b2NvbXBsZXRpb24gcnVsZSBkZWZpbmVkKVwifVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvY29tcGxldGUpIHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZShwYXJ0LCBjb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmNvbmNhdChwYXJ0KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZm9ybWF0Lm1hdGNoKC9eKFVcXCo/KSskLykpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5lbmMob3V0cHV0LCBcImJpbmFyeVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkFycmF5PiIsIkludGVnZXIiLCJTdHJpbmciLCJLZXJuZWwiLCJyYWlzZSIsIlJhbmdlRXJyb3IiLCJBcmd1bWVudEVycm9yIiwicGFjayIsImZvcm1hdCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiZ3N1YiIsImRlbGV0ZSIsImluc3BlY3QiXSwibWFwcGluZ3MiOiJBQUFBQSxxREFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRiwwQ0FBUkU7RUFFQUYsT0FBQUc7RUFBQUE7Ozs7O0FBRUFBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsa0NBQW9DQyxjQUFVRDtBQUM5Q0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxrQ0FBb0NFLGFBQVNGO0FBQzdDQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsY0FBZ0JHLE9BQVFDLE9BQUFBLENBQU9DLGlCQUFmLEVBQTZCTCxvQkFBckJJLENBQTBDSjtBQUNsRUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsWUFBY0csT0FBUUMsT0FBQUEsQ0FBT0Usb0JBQWYsRUFBZ0NOLG1CQUF4QkksQ0FBNENKO0FBQ2xFQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUEsVUFBWUcsT0FBUUMsT0FBQUEsQ0FBT0Usb0JBQWYsRUFBZ0NOLG1CQUF4QkksQ0FBNENKO0FBQ2hFQTtBQUNBQSxzQ0FBd0NFLGFBQVNGO0FBQ2pEQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFFRUEsT0FBQU8sb0JBQUFBLGdCQUFTQyxNQUFURDtBQUFBQSxNQUFBQTs7O01BQ0VDLFNBQVNDLEtBQU1DLGVBQUFBLENBQVlGLE1BQWxCLEVBQTBCTixhQUExQixFQUFvQyxRQUE5QlEsQ0FBc0NDLE1BQUFBLENBQU0sSUFBbEQsRUFBd0RKLEVBQVpJLENBQWVDLFFBQUFBLENBQVFMLFFBQVJLOztBQUd4RUw7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxVQUFZSixPQUFRQyxPQUFBQSxDQUFRRyw2QkFBRCxHQUFBLENBQThCQSxDQUFDQSxTQUFEQSxDQUFXTSxTQUFBQSxDQUFBQSxDQUF6QyxDQUFBLEdBQWtETiw0QkFBekRIO0FBQ3BCRzs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQSxVQUFZSixPQUFRQyxPQUFBQSxDQUFRRyw2QkFBRCxHQUFBLENBQThCQSxDQUFDQSxTQUFEQSxDQUFXTSxTQUFBQSxDQUFBQSxDQUF6QyxDQUFBLEdBQWtETix1QkFBekRIO0FBQ3BCRzs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUEsWUFBY0osT0FBUUMsT0FBQUEsQ0FBUUcsNkJBQUQsR0FBQSxDQUE4QkEsQ0FBQ0EsU0FBREEsQ0FBV00sU0FBQUEsQ0FBQUEsQ0FBekMsQ0FBQSxHQUFrRE4sbUNBQXpESDtBQUN0Qkc7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUE3REVBLENBQUFBLEdBQUFBO0VBallGUCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTQwMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vYmFzZTY0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCYXNlNjRcbiAgIyBGUk9NIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGNoYW1iZXJzL0Jhc2U2NC5qcy9ibG9iLzY5MjYyZWM3ZTFmYTQ1NDFkZTU3MDBhMWIwYjAzYjBkZTBlM2Y1YWEvYmFzZTY0LmpzXG4gICV4e1xuICAgIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG4gICAgdmFyIGVuY29kZSwgZGVjb2RlO1xuXG4gICAgLy8gZW5jb2RlclxuICAgIC8vIFtodHRwczovL2dpc3QuZ2l0aHViLmNvbS85OTkxNjZdIGJ5IFtodHRwczovL2dpdGh1Yi5jb20vbmlnbmFnXVxuICAgIGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCk7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgZm9yIChcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcbiAgICAgICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnMsIG91dHB1dCA9ICcnO1xuICAgICAgICAvLyBpZiB0aGUgbmV4dCBzdHIgaW5kZXggZG9lcyBub3QgZXhpc3Q6XG4gICAgICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICAgICAgc3RyLmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgICAgICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICAgICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICAgICApIHtcbiAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMy80KTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID4gMHhGRikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2ludmFsaWQgY2hhcmFjdGVyIChmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZW5jb2RlZCBjb250YWlucyBjaGFyYWN0ZXJzIG91dHNpZGUgb2YgdGhlIExhdGluMSByYW5nZS4pJ307XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2sgPSBibG9jayA8PCA4IHwgY2hhckNvZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIH07XG5cbiAgICAvLyBkZWNvZGVyXG4gICAgLy8gW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwMjAzOTZdIGJ5IFtodHRwczovL2dpdGh1Yi5jb20vYXRrXVxuICAgIGRlY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCkucmVwbGFjZSgvPSskLywgJycpO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSA0ID09IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnaW52YWxpZCBiYXNlNjQgKGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC4pJ307XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgZm9yIChcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJzXG4gICAgICAgIHZhciBiYyA9IDAsIGJzLCBidWZmZXIsIGlkeCA9IDAsIG91dHB1dCA9ICcnO1xuICAgICAgICAvLyBnZXQgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgYnVmZmVyID0gc3RyLmNoYXJBdChpZHgrKyk7XG4gICAgICAgIC8vIGNoYXJhY3RlciBmb3VuZCBpbiB0YWJsZT8gaW5pdGlhbGl6ZSBiaXQgc3RvcmFnZSBhbmQgYWRkIGl0cyBhc2NpaSB2YWx1ZTtcbiAgICAgICAgfmJ1ZmZlciAmJiAoYnMgPSBiYyAlIDQgPyBicyAqIDY0ICsgYnVmZmVyIDogYnVmZmVyLFxuICAgICAgICAgIC8vIGFuZCBpZiBub3QgZmlyc3Qgb2YgZWFjaCA0IGNoYXJhY3RlcnMsXG4gICAgICAgICAgLy8gY29udmVydCB0aGUgZmlyc3QgOCBiaXRzIHRvIG9uZSBhc2NpaSBjaGFyYWN0ZXJcbiAgICAgICAgICBiYysrICUgNCkgPyBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiBicyA+PiAoLTIgKiBiYyAmIDYpKSA6IDBcbiAgICAgICkge1xuICAgICAgICAvLyB0cnkgdG8gZmluZCBjaGFyYWN0ZXIgaW4gdGFibGUgKDAtNjMsIG5vdCBmb3VuZCA9PiAtMSlcbiAgICAgICAgYnVmZmVyID0gY2hhcnMuaW5kZXhPZihidWZmZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB9O1xuICB9XG5cbiAgZGVmIHNlbGYuZGVjb2RlNjQoc3RyaW5nKVxuICAgIGBkZWNvZGUoc3RyaW5nLnJlcGxhY2UoL1xccj9cXG4vZywgJycpKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZW5jb2RlNjQoc3RyaW5nKVxuICAgIGBlbmNvZGUoc3RyaW5nKS5yZXBsYWNlKC8oLns2MH0pL2csIFwiJDFcXG5cIikucmVwbGFjZSgvKFteXFxuXSkkL2csIFwiJDFcXG5cIilgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnN0cmljdF9kZWNvZGU2NChzdHJpbmcpXG4gICAgYGRlY29kZShzdHJpbmcpYFxuICBlbmRcblxuICBkZWYgc2VsZi5zdHJpY3RfZW5jb2RlNjQoc3RyaW5nKVxuICAgIGBlbmNvZGUoc3RyaW5nKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYudXJsc2FmZV9kZWNvZGU2NChzdHJpbmcpXG4gICAgYGRlY29kZShzdHJpbmcucmVwbGFjZSgvXFwtL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYudXJsc2FmZV9lbmNvZGU2NChzdHJpbmcsIHBhZGRpbmc6IHRydWUpXG4gICAgc3RyID0gYGVuY29kZShzdHJpbmcpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpYFxuICAgIHN0ciA9IHN0ci5kZWxldGUoJz0nKSB1bmxlc3MgcGFkZGluZ1xuICAgIHN0clxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJhc2U2ND4iLCJzZWxmIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiZGVjb2RlNjQiLCJzdHJpbmciLCJlbmNvZGU2NCIsInN0cmljdF9kZWNvZGU2NCIsInN0cmljdF9lbmNvZGU2NCIsInVybHNhZmVfZGVjb2RlNjQiLCJ1cmxzYWZlX2VuY29kZTY0IiwiJGt3YXJncyIsInN0ciIsInBhZGRpbmciLCJkZWxldGUiXSwibWFwcGluZ3MiOiJBQUFBQSx5Q0FBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7OztBQUdBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsVUFBWUMsSUFBQUMsT0FBQUEsQ0FBTUMsbUJBQU4sRUFBcUJILHVHQUFyQkUsQ0FBNkhGO0FBQ3pJQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsUUFBVUMsSUFBQUMsT0FBQUEsQ0FBTUMsbUJBQU4sRUFBcUJILDZFQUFyQkUsQ0FBbUdGO0FBQzdHQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUVFSSxNQUFJSCxJQUFKRyxlQUFBQSxvQkFBa0JDLE1BQWxCRDtBQUFBQTtNQUNFQSxPQUFDQSxvQ0FBREE7SUFERkEsQ0FBQUEsR0FBQUE7SUFJQUUsTUFBSUwsSUFBSkssZUFBQUEsb0JBQWtCRCxNQUFsQkM7QUFBQUE7TUFDRUEsT0FBQ0EsdUVBQURBO0lBREZBLENBQUFBLEdBQUFBO0lBSUFDLE1BQUlOLElBQUpNLHNCQUFBQSwyQkFBeUJGLE1BQXpCRTtBQUFBQTtNQUNFQSxPQUFDQSxjQUFEQTtJQURGQSxDQUFBQSxHQUFBQTtJQUlBQyxNQUFJUCxJQUFKTyxzQkFBQUEsMkJBQXlCSCxNQUF6Qkc7QUFBQUE7TUFDRUEsT0FBQ0EsY0FBREE7SUFERkEsQ0FBQUEsR0FBQUE7SUFJQUMsTUFBSVIsSUFBSlEsdUJBQUFBLDRCQUEwQkosTUFBMUJJO0FBQUFBO01BQ0VBLE9BQUNBLHFEQUFEQTtJQURGQSxDQUFBQSxHQUFBQTtJQUlBVCxPQUFBVSxNQUFJVCxJQUFKUyx1QkFBQUEsNEJBQTBCTCxNQUFELEVBOUUzQk0sT0E4RUVEO0FBQUFBLE1BQUFBOzs7O01BOUVGO01BQUE7TUFBQTtNQUFBO01BQUE7O01BOEVvQztNQUFBLCtCQUFTO01BQ3pDRSxNQUFPRjtNQUNQLEtBQUEsUUFBNkJHLE9BQTdCLENBQUE7UUFBQUQsTUFBTUEsR0FBR0UsUUFBQUEsQ0FBUUosR0FBUkk7TUFBVDtNQUNBSixPQUFBRTtJQUhGRixDQUFBQSxJQUFBQTtFQTlFRlYsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1NTA3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcvdW5wYWNrLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2Jhc2U2NCdcbnJlcXVpcmUgJ2NvcmVsaWIvcGFja191bnBhY2svZm9ybWF0X3N0cmluZ19wYXJzZXInXG5cbmNsYXNzIDo6U3RyaW5nXG4gICV4e1xuICAgIC8vIEZvcm1hdCBQYXJzZXJcbiAgICB2YXIgZWFjaERpcmVjdGl2ZUFuZENvdW50ID0gT3BhbC5QYWNrVW5wYWNrLmVhY2hEaXJlY3RpdmVBbmRDb3VudDtcblxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5BcnJheShjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIHJldHVybiAje2BhcnJheWAuZmxhdHRlbn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwQ2h1bmtzVG9Xb3JkcyhjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGNodW5rcyA9IGNhbGxiYWNrKGRhdGEpO1xuXG4gICAgICAgIHJldHVybiBjaHVua3MubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgcmV0dXJuIGNodW5rLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0LCBzaW5nbGVCeXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogMjU2ICsgc2luZ2xlQnl0ZTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2h1bmtCeShjaHVua1NpemUsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBjYWxsYmFjayhkYXRhKSxcbiAgICAgICAgICAgIGNodW5rcyA9IFtdLFxuICAgICAgICAgICAgY2h1bmtzQ291bnQgPSAoYXJyYXkubGVuZ3RoIC8gY2h1bmtTaXplKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rc0NvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgY2h1bmsgPSBhcnJheS5zcGxpY2UoMCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID09PSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2h1bmtzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTkJ5dGVTaWduZWQoYnl0ZXNDb3VudCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB1bnNpZ25lZEJpdHMgPSBjYWxsYmFjayhkYXRhKSxcbiAgICAgICAgICAgIGJpdHNDb3VudCA9IGJ5dGVzQ291bnQgKiA4LFxuICAgICAgICAgICAgbGltaXQgPSBNYXRoLnBvdygyLCBiaXRzQ291bnQpO1xuXG4gICAgICAgIHJldHVybiB1bnNpZ25lZEJpdHMubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICBpZiAobiA+PSBsaW1pdCAvIDIpIHtcbiAgICAgICAgICAgIG4gLT0gbGltaXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ5dGVzVG9Bc2NpaUNoYXJzKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgYnl0ZXMgPSBjYWxsYmFjayhkYXRhKTtcblxuICAgICAgICByZXR1cm4gYnl0ZXMubWFwKGZ1bmN0aW9uKHNpbmdsZUJ5dGUpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzaW5nbGVCeXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gam9pbkNoYXJzKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgY2hhcnMgPSBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBJbnRvQXJyYXkoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgcmV0dXJuIFtvYmplY3RdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlclRyYWlsaW5nQ2hhcnMoY2hhcnMpIHtcbiAgICAgIHZhciBjaGFyQ29kZXNUb0ZpbHRlciA9IGNoYXJzLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiBzLmNoYXJDb2RlQXQoMCk7IH0pO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICB2YXIgY2hhckNvZGVzID0gY2FsbGJhY2soZGF0YSk7XG5cbiAgICAgICAgICB3aGlsZSAoY2hhckNvZGVzVG9GaWx0ZXIuaW5kZXhPZihjaGFyQ29kZXNbY2hhckNvZGVzLmxlbmd0aCAtIDFdKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IGNoYXJDb2Rlcy5zbGljZSgwLCBjaGFyQ29kZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNoYXJDb2RlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaWx0ZXJUcmFpbGluZ1plcm9zQW5kU3BhY2VzID0gZmlsdGVyVHJhaWxpbmdDaGFycyhbXCJcXHUwMDAwXCIsIFwiIFwiXSk7XG5cbiAgICBmdW5jdGlvbiBpbnZlcnRDaHVua3MoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBjaHVua3MgPSBjYWxsYmFjayhkYXRhKTtcblxuICAgICAgICByZXR1cm4gY2h1bmtzLm1hcChmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgIHJldHVybiBjaHVuay5yZXZlcnNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV1ZGVjb2RlKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgYnl0ZXMgPSBjYWxsYmFjayhkYXRhKTtcblxuICAgICAgICB2YXIgc3RvcCA9IGZhbHNlO1xuICAgICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG4gPSBieXRlc1tpXSAtIDMyICYgMHgzRjtcblxuICAgICAgICAgICAgKytpO1xuXG4gICAgICAgICAgICBpZiAoYnl0ZXNbaV0gPT09IDEwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobiA+IDQ1KSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuZ3RoICs9IG47XG5cbiAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgICB2YXIgYzEgPSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGMyID0gYnl0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICB2YXIgYzMgPSBieXRlc1tpICsgMl07XG4gICAgICAgICAgICAgIHZhciBjNCA9IGJ5dGVzW2kgKyAzXTtcblxuICAgICAgICAgICAgICB2YXIgYjEgPSAoYzEgLSAzMiAmIDB4M0YpIDw8IDIgfCAoYzIgLSAzMiAmIDB4M0YpID4+IDQ7XG4gICAgICAgICAgICAgIHZhciBiMiA9IChjMiAtIDMyICYgMHgzRikgPDwgNCB8IChjMyAtIDMyICYgMHgzRikgPj4gMjtcbiAgICAgICAgICAgICAgdmFyIGIzID0gKGMzIC0gMzIgJiAweDNGKSA8PCA2IHwgYzQgLSAzMiAmIDB4M0Y7XG5cbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYjEgJiAweEZGKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYjIgJiAweEZGKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYjMgJiAweEZGKTtcblxuICAgICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICAgIG4gLT0gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKytpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0JpdHMoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBieXRlcyA9IGNhbGxiYWNrKGRhdGEpO1xuXG4gICAgICAgIHZhciBiaXRzID0gYnl0ZXMubWFwKGZ1bmN0aW9uKHNpbmdsZUJ5dGUpIHtcbiAgICAgICAgICByZXR1cm4gc2luZ2xlQnl0ZS50b1N0cmluZygyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlQkVSQ29tcHJlc3NlZEludGVnZXJzKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgYnl0ZXMgPSBjYWxsYmFjayhkYXRhKSwgcmVzdWx0ID0gW10sIGJ1ZmZlciA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2luZ2xlQnl0ZSA9IGJ5dGVzW2ldLFxuICAgICAgICAgICAgICBiaXRzID0gc2luZ2xlQnl0ZS50b1N0cmluZygyKTtcblxuICAgICAgICAgIGJpdHMgPSBBcnJheSg4IC0gYml0cy5sZW5ndGggKyAxKS5qb2luKCcwJykuY29uY2F0KGJpdHMpO1xuXG4gICAgICAgICAgdmFyIGZpcnN0Qml0ID0gYml0c1swXTtcbiAgICAgICAgICBiaXRzID0gYml0cy5zbGljZSgxLCBiaXRzLmxlbmd0aCk7XG5cbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuY29uY2F0KGJpdHMpO1xuXG4gICAgICAgICAgaWYgKGZpcnN0Qml0ID09PSAnMCcpIHtcbiAgICAgICAgICAgIHZhciBkZWNvZGVkID0gcGFyc2VJbnQoYnVmZmVyLCAyKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWQpO1xuICAgICAgICAgICAgYnVmZmVyID0gJydcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhc2U2NERlY29kZShjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuICN7QmFzZTY0LmRlY29kZTY0KGBjYWxsYmFjayhkYXRhKWApfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBxdW90ZWQtcHJpbnRhYmxlIGRlY29kZVxuICAgIGZ1bmN0aW9uIHFwZGVjb2RlKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gY2FsbGJhY2soZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZ1xuICAgICAgICAgIC5yZXBsYWNlKC9bXFx0XFx4MjBdJC9nbSwgJycpXG4gICAgICAgICAgLnJlcGxhY2UoLz0oPzpcXHJcXG4/fFxcbnwkKS9nLCAnJylcbiAgICAgICAgICAucmVwbGFjZSgvPShbYS1mQS1GMC05XXsyfSkvZywgZnVuY3Rpb24oJDAsICQxKSB7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gcGFyc2VJbnQoJDEsIDE2KTtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWRlbnRpdHlGdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH1cblxuICAgIHZhciBoYW5kbGVycyA9IHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgICdDJzogaWRlbnRpdHlGdW5jdGlvbixcbiAgICAgICdTJzogbWFwQ2h1bmtzVG9Xb3JkcyhjaHVua0J5KDIsIGlkZW50aXR5RnVuY3Rpb24pKSxcbiAgICAgICdMJzogbWFwQ2h1bmtzVG9Xb3JkcyhjaHVua0J5KDQsIGlkZW50aXR5RnVuY3Rpb24pKSxcbiAgICAgICdRJzogbWFwQ2h1bmtzVG9Xb3JkcyhjaHVua0J5KDgsIGlkZW50aXR5RnVuY3Rpb24pKSxcbiAgICAgICdKJzogbnVsbCxcblxuICAgICAgJ1M+JzogbWFwQ2h1bmtzVG9Xb3JkcyhpbnZlcnRDaHVua3MoY2h1bmtCeSgyLCBpZGVudGl0eUZ1bmN0aW9uKSkpLFxuICAgICAgJ0w+JzogbWFwQ2h1bmtzVG9Xb3JkcyhpbnZlcnRDaHVua3MoY2h1bmtCeSg0LCBpZGVudGl0eUZ1bmN0aW9uKSkpLFxuICAgICAgJ1E+JzogbWFwQ2h1bmtzVG9Xb3JkcyhpbnZlcnRDaHVua3MoY2h1bmtCeSg4LCBpZGVudGl0eUZ1bmN0aW9uKSkpLFxuXG4gICAgICAnYyc6IHRvTkJ5dGVTaWduZWQoMSwgaWRlbnRpdHlGdW5jdGlvbiksXG4gICAgICAncyc6IHRvTkJ5dGVTaWduZWQoMiwgbWFwQ2h1bmtzVG9Xb3JkcyhjaHVua0J5KDIsIGlkZW50aXR5RnVuY3Rpb24pKSksXG4gICAgICAnbCc6IHRvTkJ5dGVTaWduZWQoNCwgbWFwQ2h1bmtzVG9Xb3JkcyhjaHVua0J5KDQsIGlkZW50aXR5RnVuY3Rpb24pKSksXG4gICAgICAncSc6IHRvTkJ5dGVTaWduZWQoOCwgbWFwQ2h1bmtzVG9Xb3JkcyhjaHVua0J5KDgsIGlkZW50aXR5RnVuY3Rpb24pKSksXG4gICAgICAnaic6IG51bGwsXG5cbiAgICAgICdzPic6IHRvTkJ5dGVTaWduZWQoMiwgbWFwQ2h1bmtzVG9Xb3JkcyhpbnZlcnRDaHVua3MoY2h1bmtCeSgyLCBpZGVudGl0eUZ1bmN0aW9uKSkpKSxcbiAgICAgICdsPic6IHRvTkJ5dGVTaWduZWQoNCwgbWFwQ2h1bmtzVG9Xb3JkcyhpbnZlcnRDaHVua3MoY2h1bmtCeSg0LCBpZGVudGl0eUZ1bmN0aW9uKSkpKSxcbiAgICAgICdxPic6IHRvTkJ5dGVTaWduZWQoOCwgbWFwQ2h1bmtzVG9Xb3JkcyhpbnZlcnRDaHVua3MoY2h1bmtCeSg4LCBpZGVudGl0eUZ1bmN0aW9uKSkpKSxcblxuICAgICAgJ24nOiBudWxsLCAvLyBhbGlhc2VkIGxhdGVyXG4gICAgICAnTic6IG51bGwsIC8vIGFsaWFzZWQgbGF0ZXJcbiAgICAgICd2JzogbnVsbCwgLy8gYWxpYXNlZCBsYXRlclxuICAgICAgJ1YnOiBudWxsLCAvLyBhbGlhc2VkIGxhdGVyXG5cbiAgICAgICdVJzogaWRlbnRpdHlGdW5jdGlvbixcbiAgICAgICd3JzogZGVjb2RlQkVSQ29tcHJlc3NlZEludGVnZXJzKGlkZW50aXR5RnVuY3Rpb24pLFxuXG4gICAgICAvLyBGbG9hdFxuICAgICAgJ0QnOiBudWxsLFxuICAgICAgJ2QnOiBudWxsLFxuICAgICAgJ0YnOiBudWxsLFxuICAgICAgJ2YnOiBudWxsLFxuICAgICAgJ0UnOiBudWxsLFxuICAgICAgJ2UnOiBudWxsLFxuICAgICAgJ0cnOiBudWxsLFxuICAgICAgJ2cnOiBudWxsLFxuXG4gICAgICAvLyBTdHJpbmdcbiAgICAgICdBJzogd3JhcEludG9BcnJheShqb2luQ2hhcnMoYnl0ZXNUb0FzY2lpQ2hhcnMoZmlsdGVyVHJhaWxpbmdaZXJvc0FuZFNwYWNlcyhpZGVudGl0eUZ1bmN0aW9uKSkpKSxcbiAgICAgICdhJzogd3JhcEludG9BcnJheShqb2luQ2hhcnMoYnl0ZXNUb0FzY2lpQ2hhcnMoaWRlbnRpdHlGdW5jdGlvbikpKSxcbiAgICAgICdaJzogam9pbkNoYXJzKGJ5dGVzVG9Bc2NpaUNoYXJzKGlkZW50aXR5RnVuY3Rpb24pKSxcbiAgICAgICdCJzogam9pbkNoYXJzKGlkZW50aXR5RnVuY3Rpb24pLFxuICAgICAgJ2InOiBqb2luQ2hhcnMoaWRlbnRpdHlGdW5jdGlvbiksXG4gICAgICAnSCc6IGpvaW5DaGFycyhpZGVudGl0eUZ1bmN0aW9uKSxcbiAgICAgICdoJzogam9pbkNoYXJzKGlkZW50aXR5RnVuY3Rpb24pLFxuICAgICAgJ3UnOiBqb2luQ2hhcnMoYnl0ZXNUb0FzY2lpQ2hhcnModXVkZWNvZGUoaWRlbnRpdHlGdW5jdGlvbikpKSxcbiAgICAgICdNJzogcXBkZWNvZGUoam9pbkNoYXJzKGJ5dGVzVG9Bc2NpaUNoYXJzKGlkZW50aXR5RnVuY3Rpb24pKSksXG4gICAgICAnbSc6IGJhc2U2NERlY29kZShqb2luQ2hhcnMoYnl0ZXNUb0FzY2lpQ2hhcnMoaWRlbnRpdHlGdW5jdGlvbikpKSxcblxuICAgICAgJ1AnOiBudWxsLFxuICAgICAgJ3AnOiBudWxsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlYWRCeXRlcyhuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgdmFyIGNodW5rID0gYnl0ZXMuc2xpY2UoMCwgbik7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UobiwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHsgY2h1bms6IGNodW5rLCByZXN0OiBieXRlcyB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRVbmljb2RlQ2hhckNodW5rKGJ5dGVzKSB7XG4gICAgICB2YXIgY3VycmVudEJ5dGVJbmRleCA9IDA7XG4gICAgICB2YXIgYnl0ZXNMZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICBmdW5jdGlvbiByZWFkQnl0ZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJ5dGVzW2N1cnJlbnRCeXRlSW5kZXgrK107XG4gICAgICAgIGJ5dGVzTGVuZ3RoID0gYnl0ZXMubGVuZ3RoIC0gY3VycmVudEJ5dGVJbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGMgPSByZWFkQnl0ZSgpLCBleHRyYUxlbmd0aDtcblxuICAgICAgaWYgKGMgPj4gNyA9PSAwKSB7XG4gICAgICAgIC8vIDB4eHggeHh4eFxuICAgICAgICByZXR1cm4geyBjaHVuazogW2NdLCByZXN0OiBieXRlcy5zbGljZShjdXJyZW50Qnl0ZUluZGV4KSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoYyA+PiA2ID09IDB4MDIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgVVRGLTggY2hhcmFjdGVyJ31cbiAgICAgIH1cblxuICAgICAgaWYgKGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICAgIC8vIDExMHggeHh4eCAodHdvIGJ5dGVzKVxuICAgICAgICBleHRyYUxlbmd0aCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGMgPj4gNCA9PSAweDBlKSB7XG4gICAgICAgIC8vIDExMTAgeHh4eCAodGhyZWUgYnl0ZXMpXG4gICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgIH0gZWxzZSBpZiAoYyA+PiAzID09IDB4MWUpIHtcbiAgICAgICAgLy8gMTExMSAweHh4IChmb3VyIGJ5dGVzKVxuICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICB9IGVsc2UgaWYgKGMgPj4gMiA9PSAweDNlKSB7XG4gICAgICAgIC8vIDExMTEgMTB4eCAoZml2ZSBieXRlcylcbiAgICAgICAgZXh0cmFMZW5ndGggPSA0O1xuICAgICAgfSBlbHNlIGlmIChjID4+IDEgPT0gMHg3ZSkge1xuICAgICAgICAvLyAxMTExIDExMHggKHNpeCBieXRlcylcbiAgICAgICAgZXh0cmFMZW5ndGggPSA1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSAnbWFsZm9ybWVkIFVURi04IGNoYXJhY3Rlcid9XG4gICAgICB9XG5cbiAgICAgIGlmIChleHRyYUxlbmd0aCA+IGJ5dGVzTGVuZ3RoKSB7XG4gICAgICAgICN7XG4gICAgICAgICAgZXhwZWN0ZWQgPSBgZXh0cmFMZW5ndGggKyAxYFxuICAgICAgICAgIGdpdmVuID0gYGJ5dGVzTGVuZ3RoICsgMWBcbiAgICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibWFsZm9ybWVkIFVURi04IGNoYXJhY3RlciAoZXhwZWN0ZWQgI3tleHBlY3RlZH0gYnl0ZXMsIGdpdmVuICN7Z2l2ZW59IGJ5dGVzKVwiXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBVVEYtOCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgdmFyIG1hc2sgPSAoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSxcbiAgICAgICAgICByZXN1bHQgPSBjICYgbWFzaztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRyYUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGMgPSByZWFkQnl0ZSgpO1xuXG4gICAgICAgIGlmIChjID4+IDYgIT0gMHgwMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgJ0ludmFsaWQgbXVsdGlieXRlIHNlcXVlbmNlJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgNikgfCAoYyAmIDB4M2YpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0IDw9IDB4ZmZmZikge1xuICAgICAgICByZXR1cm4geyBjaHVuazogW3Jlc3VsdF0sIHJlc3Q6IGJ5dGVzLnNsaWNlKGN1cnJlbnRCeXRlSW5kZXgpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgLT0gMHgxMDAwMDtcbiAgICAgICAgdmFyIGhpZ2ggPSAoKHJlc3VsdCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDAsXG4gICAgICAgICAgICBsb3cgPSAocmVzdWx0ICYgMHgzZmYpICsgMHhkYzAwO1xuICAgICAgICByZXR1cm4geyBjaHVuazogW2hpZ2gsIGxvd10sIHJlc3Q6IGJ5dGVzLnNsaWNlKGN1cnJlbnRCeXRlSW5kZXgpIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFV1ZW5jb2RpbmdDaHVuayhidWZmZXIpIHtcbiAgICAgIHZhciBsZW5ndGggPSBidWZmZXIuaW5kZXhPZigzMik7IC8vIDMyID0gc3BhY2VcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHsgY2h1bms6IGJ1ZmZlciwgcmVzdDogW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGNodW5rOiBidWZmZXIuc2xpY2UoMCwgbGVuZ3RoKSwgcmVzdDogYnVmZmVyLnNsaWNlKGxlbmd0aCwgYnVmZmVyLmxlbmd0aCkgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkTkJpdHNMU0JGaXJzdChidWZmZXIsIGNvdW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgIHdoaWxlIChjb3VudCA+IDAgJiYgYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHNpbmdsZUJ5dGUgPSBidWZmZXJbMF0sXG4gICAgICAgICAgICBiaXRzVG9UYWtlID0gTWF0aC5taW4oY291bnQsIDgpLFxuICAgICAgICAgICAgYnl0ZXNUb1Rha2UgPSBNYXRoLmNlaWwoYml0c1RvVGFrZSAvIDgpO1xuXG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgxLCBidWZmZXIubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc2luZ2xlQnl0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGJpdHMgPSBzaW5nbGVCeXRlLnRvU3RyaW5nKDIpO1xuICAgICAgICAgIGJpdHMgPSBBcnJheSg4IC0gYml0cy5sZW5ndGggKyAxKS5qb2luKCcwJykuY29uY2F0KGJpdHMpLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJpdHNUb1Rha2U7IGorKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGJpdHNbal0gfHwgJzAnO1xuICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgY2h1bms6IFtyZXN1bHRdLCByZXN0OiBidWZmZXIgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkTkJpdHNNU0JGaXJzdChidWZmZXIsIGNvdW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgIHdoaWxlIChjb3VudCA+IDAgJiYgYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHNpbmdsZUJ5dGUgPSBidWZmZXJbMF0sXG4gICAgICAgICAgICBiaXRzVG9UYWtlID0gTWF0aC5taW4oY291bnQsIDgpLFxuICAgICAgICAgICAgYnl0ZXNUb1Rha2UgPSBNYXRoLmNlaWwoYml0c1RvVGFrZSAvIDgpO1xuXG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgxLCBidWZmZXIubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc2luZ2xlQnl0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGJpdHMgPSBzaW5nbGVCeXRlLnRvU3RyaW5nKDIpO1xuICAgICAgICAgIGJpdHMgPSBBcnJheSg4IC0gYml0cy5sZW5ndGggKyAxKS5qb2luKCcwJykuY29uY2F0KGJpdHMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiaXRzVG9UYWtlOyBqKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBiaXRzW2pdIHx8ICcwJztcbiAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGNodW5rOiBbcmVzdWx0XSwgcmVzdDogYnVmZmVyIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFdoaWxlRmlyc3RCaXRJc09uZShidWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNpbmdsZUJ5dGUgPSBidWZmZXJbaV07XG5cbiAgICAgICAgcmVzdWx0LnB1c2goc2luZ2xlQnl0ZSk7XG5cbiAgICAgICAgaWYgKChzaW5nbGVCeXRlICYgMTI4KSA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGNodW5rOiByZXN1bHQsIHJlc3Q6IGJ1ZmZlci5zbGljZShyZXN1bHQubGVuZ3RoLCBidWZmZXIubGVuZ3RoKSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRUaWxsTnVsbENoYXJhY3RlcihidWZmZXIsIGNvdW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2luZ2xlQnl0ZSA9IGJ1ZmZlcltpXTtcblxuICAgICAgICBpZiAoc2luZ2xlQnl0ZSA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHNpbmdsZUJ5dGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY291bnQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVmZmVyW2NvdW50XSA9PT0gMCkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuXG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoY291bnQsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgICByZXR1cm4geyBjaHVuazogcmVzdWx0LCByZXN0OiBidWZmZXIgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkSGV4Q2hhcnNIaWdoTmliYmxlRmlyc3QoYnVmZmVyLCBjb3VudCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoY291bnQgPiAwICYmIGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzaW5nbGVCeXRlID0gYnVmZmVyWzBdLFxuICAgICAgICAgICAgaGV4ID0gc2luZ2xlQnl0ZS50b1N0cmluZygxNik7XG5cbiAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDEsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICBoZXggPSBBcnJheSgyIC0gaGV4Lmxlbmd0aCArIDEpLmpvaW4oJzAnKS5jb25jYXQoaGV4KTtcblxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChoZXhbMF0pO1xuICAgICAgICAgIGNvdW50LS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaGV4WzBdLCBoZXhbMV0pO1xuICAgICAgICAgIGNvdW50IC09IDI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgY2h1bms6IHJlc3VsdCwgcmVzdDogYnVmZmVyIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZEhleENoYXJzTG93TmliYmxlRmlyc3QoYnVmZmVyLCBjb3VudCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoY291bnQgPiAwICYmIGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzaW5nbGVCeXRlID0gYnVmZmVyWzBdLFxuICAgICAgICAgICAgaGV4ID0gc2luZ2xlQnl0ZS50b1N0cmluZygxNik7XG5cbiAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDEsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICBoZXggPSBBcnJheSgyIC0gaGV4Lmxlbmd0aCArIDEpLmpvaW4oJzAnKS5jb25jYXQoaGV4KTtcblxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChoZXhbMV0pO1xuICAgICAgICAgIGNvdW50LS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaGV4WzFdLCBoZXhbMF0pO1xuICAgICAgICAgIGNvdW50IC09IDI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgY2h1bms6IHJlc3VsdCwgcmVzdDogYnVmZmVyIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZE5UaW1lc0FuZE1lcmdlKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYnVmZmVyLCBjb3VudCkge1xuICAgICAgICB2YXIgY2h1bmsgPSBbXSwgY2h1bmtEYXRhO1xuXG4gICAgICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNodW5rRGF0YSA9IGNhbGxiYWNrKGJ1ZmZlcik7XG4gICAgICAgICAgICBidWZmZXIgPSBjaHVua0RhdGEucmVzdDtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsuY29uY2F0KGNodW5rRGF0YS5jaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY2h1bmtEYXRhID0gY2FsbGJhY2soYnVmZmVyKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGNodW5rRGF0YS5yZXN0O1xuICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5jb25jYXQoY2h1bmtEYXRhLmNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBjaHVuazogY2h1bmssIHJlc3Q6IGJ1ZmZlciB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRBbGwoYnVmZmVyLCBjb3VudCkge1xuICAgICAgcmV0dXJuIHsgY2h1bms6IGJ1ZmZlciwgcmVzdDogW10gfTtcbiAgICB9XG5cbiAgICB2YXIgcmVhZENodW5rID0ge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgJ0MnOiByZWFkTlRpbWVzQW5kTWVyZ2UocmVhZEJ5dGVzKDEpKSxcbiAgICAgICdTJzogcmVhZE5UaW1lc0FuZE1lcmdlKHJlYWRCeXRlcygyKSksXG4gICAgICAnTCc6IHJlYWROVGltZXNBbmRNZXJnZShyZWFkQnl0ZXMoNCkpLFxuICAgICAgJ1EnOiByZWFkTlRpbWVzQW5kTWVyZ2UocmVhZEJ5dGVzKDgpKSxcbiAgICAgICdKJzogbnVsbCxcblxuICAgICAgJ1M+JzogcmVhZE5UaW1lc0FuZE1lcmdlKHJlYWRCeXRlcygyKSksXG4gICAgICAnTD4nOiByZWFkTlRpbWVzQW5kTWVyZ2UocmVhZEJ5dGVzKDQpKSxcbiAgICAgICdRPic6IHJlYWROVGltZXNBbmRNZXJnZShyZWFkQnl0ZXMoOCkpLFxuXG4gICAgICAnYyc6IHJlYWROVGltZXNBbmRNZXJnZShyZWFkQnl0ZXMoMSkpLFxuICAgICAgJ3MnOiByZWFkTlRpbWVzQW5kTWVyZ2UocmVhZEJ5dGVzKDIpKSxcbiAgICAgICdsJzogcmVhZE5UaW1lc0FuZE1lcmdlKHJlYWRCeXRlcyg0KSksXG4gICAgICAncSc6IHJlYWROVGltZXNBbmRNZXJnZShyZWFkQnl0ZXMoOCkpLFxuICAgICAgJ2onOiBudWxsLFxuXG4gICAgICAncz4nOiByZWFkTlRpbWVzQW5kTWVyZ2UocmVhZEJ5dGVzKDIpKSxcbiAgICAgICdsPic6IHJlYWROVGltZXNBbmRNZXJnZShyZWFkQnl0ZXMoNCkpLFxuICAgICAgJ3E+JzogcmVhZE5UaW1lc0FuZE1lcmdlKHJlYWRCeXRlcyg4KSksXG5cbiAgICAgICduJzogbnVsbCwgLy8gYWxpYXNlZCBsYXRlclxuICAgICAgJ04nOiBudWxsLCAvLyBhbGlhc2VkIGxhdGVyXG4gICAgICAndic6IG51bGwsIC8vIGFsaWFzZWQgbGF0ZXJcbiAgICAgICdWJzogbnVsbCwgLy8gYWxpYXNlZCBsYXRlclxuXG4gICAgICAnVSc6IHJlYWROVGltZXNBbmRNZXJnZShyZWFkVW5pY29kZUNoYXJDaHVuayksXG4gICAgICAndyc6IHJlYWROVGltZXNBbmRNZXJnZShyZWFkV2hpbGVGaXJzdEJpdElzT25lKSxcblxuICAgICAgLy8gRmxvYXRcbiAgICAgICdEJzogbnVsbCxcbiAgICAgICdkJzogbnVsbCxcbiAgICAgICdGJzogbnVsbCxcbiAgICAgICdmJzogbnVsbCxcbiAgICAgICdFJzogbnVsbCxcbiAgICAgICdlJzogbnVsbCxcbiAgICAgICdHJzogbnVsbCxcbiAgICAgICdnJzogbnVsbCxcblxuICAgICAgLy8gU3RyaW5nXG4gICAgICAnQSc6IHJlYWROVGltZXNBbmRNZXJnZShyZWFkQnl0ZXMoMSkpLFxuICAgICAgJ2EnOiByZWFkTlRpbWVzQW5kTWVyZ2UocmVhZEJ5dGVzKDEpKSxcbiAgICAgICdaJzogcmVhZFRpbGxOdWxsQ2hhcmFjdGVyLFxuICAgICAgJ0InOiByZWFkTkJpdHNNU0JGaXJzdCxcbiAgICAgICdiJzogcmVhZE5CaXRzTFNCRmlyc3QsXG4gICAgICAnSCc6IHJlYWRIZXhDaGFyc0hpZ2hOaWJibGVGaXJzdCxcbiAgICAgICdoJzogcmVhZEhleENoYXJzTG93TmliYmxlRmlyc3QsXG4gICAgICAndSc6IHJlYWROVGltZXNBbmRNZXJnZShyZWFkVXVlbmNvZGluZ0NodW5rKSxcbiAgICAgICdNJzogcmVhZEFsbCxcbiAgICAgICdtJzogcmVhZEFsbCxcblxuICAgICAgJ1AnOiBudWxsLFxuICAgICAgJ3AnOiBudWxsXG4gICAgfVxuXG4gICAgdmFyIGF1dG9jb21wbGV0aW9uID0ge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgJ0MnOiB0cnVlLFxuICAgICAgJ1MnOiB0cnVlLFxuICAgICAgJ0wnOiB0cnVlLFxuICAgICAgJ1EnOiB0cnVlLFxuICAgICAgJ0onOiBudWxsLFxuXG4gICAgICAnUz4nOiB0cnVlLFxuICAgICAgJ0w+JzogdHJ1ZSxcbiAgICAgICdRPic6IHRydWUsXG5cbiAgICAgICdjJzogdHJ1ZSxcbiAgICAgICdzJzogdHJ1ZSxcbiAgICAgICdsJzogdHJ1ZSxcbiAgICAgICdxJzogdHJ1ZSxcbiAgICAgICdqJzogbnVsbCxcblxuICAgICAgJ3M+JzogdHJ1ZSxcbiAgICAgICdsPic6IHRydWUsXG4gICAgICAncT4nOiB0cnVlLFxuXG4gICAgICAnbic6IG51bGwsIC8vIGFsaWFzZWQgbGF0ZXJcbiAgICAgICdOJzogbnVsbCwgLy8gYWxpYXNlZCBsYXRlclxuICAgICAgJ3YnOiBudWxsLCAvLyBhbGlhc2VkIGxhdGVyXG4gICAgICAnVic6IG51bGwsIC8vIGFsaWFzZWQgbGF0ZXJcblxuICAgICAgJ1UnOiBmYWxzZSxcbiAgICAgICd3JzogZmFsc2UsXG5cbiAgICAgIC8vIEZsb2F0XG4gICAgICAnRCc6IG51bGwsXG4gICAgICAnZCc6IG51bGwsXG4gICAgICAnRic6IG51bGwsXG4gICAgICAnZic6IG51bGwsXG4gICAgICAnRSc6IG51bGwsXG4gICAgICAnZSc6IG51bGwsXG4gICAgICAnRyc6IG51bGwsXG4gICAgICAnZyc6IG51bGwsXG5cbiAgICAgIC8vIFN0cmluZ1xuICAgICAgJ0EnOiBmYWxzZSxcbiAgICAgICdhJzogZmFsc2UsXG4gICAgICAnWic6IGZhbHNlLFxuICAgICAgJ0InOiBmYWxzZSxcbiAgICAgICdiJzogZmFsc2UsXG4gICAgICAnSCc6IGZhbHNlLFxuICAgICAgJ2gnOiBmYWxzZSxcbiAgICAgICd1JzogZmFsc2UsXG4gICAgICAnTSc6IGZhbHNlLFxuICAgICAgJ20nOiBmYWxzZSxcblxuICAgICAgJ1AnOiBudWxsLFxuICAgICAgJ3AnOiBudWxsXG4gICAgfVxuXG4gICAgdmFyIG9wdGltaXplZCA9IHtcbiAgICAgICdDKic6IGhhbmRsZXJzWydDJ10sXG4gICAgICAnYyonOiBoYW5kbGVyc1snYyddLFxuICAgICAgJ0EqJzogaGFuZGxlcnNbJ0EnXSxcbiAgICAgICdhKic6IGhhbmRsZXJzWydhJ10sXG4gICAgICAnTSonOiB3cmFwSW50b0FycmF5KGhhbmRsZXJzWydNJ10pLFxuICAgICAgJ20qJzogd3JhcEludG9BcnJheShoYW5kbGVyc1snbSddKSxcbiAgICAgICdTKic6IGhhbmRsZXJzWydTJ10sXG4gICAgICAncyonOiBoYW5kbGVyc1sncyddLFxuICAgICAgJ0wqJzogaGFuZGxlcnNbJ0wnXSxcbiAgICAgICdsKic6IGhhbmRsZXJzWydsJ10sXG4gICAgICAnUSonOiBoYW5kbGVyc1snUSddLFxuICAgICAgJ3EqJzogaGFuZGxlcnNbJ3EnXSxcbiAgICAgICdTPionOiBoYW5kbGVyc1snUz4nXSxcbiAgICAgICdzPionOiBoYW5kbGVyc1sncz4nXSxcbiAgICAgICdMPionOiBoYW5kbGVyc1snTD4nXSxcbiAgICAgICdsPionOiBoYW5kbGVyc1snbD4nXSxcbiAgICAgICdRPionOiBoYW5kbGVyc1snUT4nXSxcbiAgICAgICdxPionOiBoYW5kbGVyc1sncT4nXVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsaWFzKGV4aXN0aW5nRGlyZWN0aXZlLCBuZXdEaXJlY3RpdmUpIHtcbiAgICAgIHJlYWRDaHVua1tuZXdEaXJlY3RpdmVdID0gcmVhZENodW5rW2V4aXN0aW5nRGlyZWN0aXZlXTtcbiAgICAgIGhhbmRsZXJzW25ld0RpcmVjdGl2ZV0gPSBoYW5kbGVyc1tleGlzdGluZ0RpcmVjdGl2ZV07XG4gICAgICBhdXRvY29tcGxldGlvbltuZXdEaXJlY3RpdmVdID0gYXV0b2NvbXBsZXRpb25bZXhpc3RpbmdEaXJlY3RpdmVdO1xuICAgIH1cblxuICAgIGFsaWFzKCdTPicsICduJyk7XG4gICAgYWxpYXMoJ0w+JywgJ04nKTtcblxuICAgIGFsaWFzKCdTJywgJ3YnKTtcbiAgICBhbGlhcygnTCcsICdWJyk7XG4gIH1cblxuICBkZWYgdW5wYWNrKGZvcm1hdCwgb2Zmc2V0OiAwKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJvZmZzZXQgY2FuJ3QgYmUgbmVnYXRpdmVcIiBpZiBvZmZzZXQgPCAwXG4gICAgZm9ybWF0ID0gOjpPcGFsLmNvZXJjZV90byEoZm9ybWF0LCA6OlN0cmluZywgOnRvX3N0cikuZ3N1YigvXFxzLywgJycpLmRlbGV0ZShcIlxcMDAwXCIpXG5cbiAgICAleHtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgICAgLy8gQSB2ZXJ5IG9wdGltaXplZCBoYW5kbGVyIGZvciBVKi5cbiAgICAgIGlmIChmb3JtYXQgPT0gXCJVKlwiICYmXG4gICAgICAgICAgc2VsZi5pbnRlcm5hbF9lbmNvZGluZy5uYW1lID09PSBcIlVURi04XCIgJiZcbiAgICAgICAgICB0eXBlb2Ygc2VsZi5jb2RlUG9pbnRBdCA9PT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICAgICAgdmFyIGNwLCBqID0gMDtcblxuICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkoc2VsZi5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNwID0gb3V0cHV0W2orK10gPSBzZWxmLmNvZGVQb2ludEF0KGkpO1xuICAgICAgICAgIGlmIChjcCA+IDB4ZmZmZikgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuc2xpY2UoMCwgaik7XG4gICAgICB9XG5cbiAgICAgIHZhciBidWZmZXIgPSBzZWxmLiRieXRlcygpO1xuXG4gICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ29mZnNldCBvdXRzaWRlIG9mIHN0cmluZycgaWYgb2Zmc2V0ID4gYGJ1ZmZlcmAubGVuZ3RofVxuXG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2Uob2Zmc2V0KTtcblxuXG4gICAgICAvLyBvcHRpbWl6YXRpb25cbiAgICAgIHZhciBvcHRpbWl6ZWRIYW5kbGVyID0gb3B0aW1pemVkW2Zvcm1hdF07XG4gICAgICBpZiAob3B0aW1pemVkSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gb3B0aW1pemVkSGFuZGxlcihidWZmZXIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhdXRvY29tcGxldGUoYXJyYXksIHNpemUpIHtcbiAgICAgICAgd2hpbGUgKGFycmF5Lmxlbmd0aCA8IHNpemUpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKG5pbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NDaHVuayhkaXJlY3RpdmUsIGNvdW50KSB7XG4gICAgICAgIHZhciBjaHVuayxcbiAgICAgICAgICAgIGNodW5rUmVhZGVyID0gcmVhZENodW5rW2RpcmVjdGl2ZV07XG5cbiAgICAgICAgaWYgKGNodW5rUmVhZGVyID09IG51bGwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIFwiVW5zdXBwb3J0ZWQgdW5wYWNrIGRpcmVjdGl2ZSAje2BkaXJlY3RpdmVgLmluc3BlY3R9IChubyBjaHVuayByZWFkZXIgZGVmaW5lZClcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaHVua0RhdGEgPSBjaHVua1JlYWRlcihidWZmZXIsIGNvdW50KTtcbiAgICAgICAgY2h1bmsgPSBjaHVua0RhdGEuY2h1bms7XG4gICAgICAgIGJ1ZmZlciA9IGNodW5rRGF0YS5yZXN0O1xuXG4gICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbZGlyZWN0aXZlXTtcblxuICAgICAgICBpZiAoaGFuZGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBcIlVuc3VwcG9ydGVkIHVucGFjayBkaXJlY3RpdmUgI3tgZGlyZWN0aXZlYC5pbnNwZWN0fSAobm8gaGFuZGxlciBkZWZpbmVkKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBlYWNoRGlyZWN0aXZlQW5kQ291bnQoZm9ybWF0LCBmdW5jdGlvbihkaXJlY3RpdmUsIGNvdW50KSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcHJvY2Vzc0NodW5rKGRpcmVjdGl2ZSwgY291bnQpO1xuXG4gICAgICAgIGlmIChjb3VudCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICB2YXIgc2hvdWxkQXV0b2NvbXBsZXRlID0gYXV0b2NvbXBsZXRpb25bZGlyZWN0aXZlXTtcblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvY29tcGxldGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBcIlVuc3VwcG9ydGVkIHVucGFjayBkaXJlY3RpdmUgI3tgZGlyZWN0aXZlYC5pbnNwZWN0fSAobm8gYXV0b2NvbXBsZXRpb24gcnVsZSBkZWZpbmVkKVwifVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvY29tcGxldGUpIHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZShwYXJ0LCBjb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmNvbmNhdChwYXJ0KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVucGFjazEoZm9ybWF0LCBvZmZzZXQ6IDApXG4gICAgZm9ybWF0ID0gOjpPcGFsLmNvZXJjZV90byEoZm9ybWF0LCA6OlN0cmluZywgOnRvX3N0cikuZ3N1YigvXFxzLywgJycpLmRlbGV0ZShcIlxcMDAwXCIpXG5cbiAgICB1bnBhY2soZm9ybWF0WzBdLCBvZmZzZXQ6IG9mZnNldClbMF1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6U3RyaW5nPiIsImZsYXR0ZW4iLCJCYXNlNjQiLCJkZWNvZGU2NCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImV4cGVjdGVkIiwiZ2l2ZW4iLCJ1bnBhY2siLCJmb3JtYXQiLCIka3dhcmdzIiwiMCIsIjwiLCJvZmZzZXQiLCJPcGFsIiwiY29lcmNlX3RvISIsIlN0cmluZyIsImdzdWIiLCJkZWxldGUiLCI+IiwibGVuZ3RoIiwiaW5zcGVjdCIsInVucGFjazEiLCJbXSJdLCJtYXBwaW5ncyI6IkFBQUFBLHdEQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLFFBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDBDQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7Ozs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGVBQWlCQSxDQUFDQSxLQUFEQSxDQUFPQyxTQUFBQSxDQUFBQSxDQUFTRDtBQUNqQ0E7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7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Q0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUVTLElBQUFBLHNCQUFBQSxrQkFBV0MsTUFBRCxFQXJxQlpDLE9BcXFCRUY7QUFBQUEsTUFBQUE7Ozs7TUFycUJGO01BQUE7TUFBQTtNQUFBO01BQUE7O01BcXFCcUI7TUFBQSw2QkFBUUc7TUFDekIsSUFBQSxRQUFxRUMsT0FBUEMsTUFBT0QsRUFBRUQsQ0FBRkMsQ0FBckUsQ0FBQTtRQUFBVCxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ0csMEJBQXhCSjtNQUFSO01BQ0FLLFNBQVNLLEtBQU1DLGVBQUFBLENBQVlOLE1BQWxCLEVBQTBCTyxhQUExQixFQUFvQyxRQUE5QkQsQ0FBc0NFLE1BQUFBLENBQU0sSUFBbEQsRUFBd0RULEVBQVpTLENBQWVDLFFBQUFBLENBQVFWLFFBQVJVOztBQUd4RVY7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQSxNQUFRLENBQUEsUUFBcUVXLE9BQVBOLE1BQU9NLEVBQUVYLENBQUNBLE1BQURBLENBQVFZLFFBQUFBLENBQUFBLENBQVZELENBQXJFLENBQUEsR0FBQSxDQUFBaEIsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NHLDBCQUF4QkosQ0FBUixJQUFBLEdBQUE7O0FBRVJJOzs7QUFHQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVlMLE9BQVFDLE9BQUFBLENBQVFJLCtCQUFELEdBQUEsQ0FBZ0NBLENBQUNBLFNBQURBLENBQVdhLFNBQUFBLENBQUFBLENBQTNDLENBQUEsR0FBb0RiLDRCQUEzREo7QUFDcEJJOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLFVBQVlMLE9BQVFDLE9BQUFBLENBQVFJLCtCQUFELEdBQUEsQ0FBZ0NBLENBQUNBLFNBQURBLENBQVdhLFNBQUFBLENBQUFBLENBQTNDLENBQUEsR0FBb0RiLHVCQUEzREo7QUFDcEJJOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQSxZQUFjTCxPQUFRQyxPQUFBQSxDQUFRSSwrQkFBRCxHQUFBLENBQWdDQSxDQUFDQSxTQUFEQSxDQUFXYSxTQUFBQSxDQUFBQSxDQUEzQyxDQUFBLEdBQW9EYixtQ0FBM0RKO0FBQ3RCSTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQW5GRUEsQ0FBQUEsSUFBQUE7SUFzRkFULE9BQUF1Qix1QkFBQUEsbUJBQVliLE1BQUQsRUEzdkJiQyxPQTJ2QkVZO0FBQUFBLE1BQUFBOzs7O01BM3ZCRjtNQUFBO01BQUE7TUFBQTtNQUFBOztNQTJ2QnNCO01BQUEsNkJBQVFYO01BQzFCRixTQUFTSyxLQUFNQyxlQUFBQSxDQUFZTixNQUFsQixFQUEwQk8sYUFBMUIsRUFBb0MsUUFBOUJELENBQXNDRSxNQUFBQSxDQUFNLElBQWxELEVBQXdESyxFQUFaTCxDQUFlQyxRQUFBQSxDQUFRSSxRQUFSSjtNQUVwRUksT0FBQXpCLElBQUFXLFFBQUFBLENBQU9DLE1BQU1jLE9BQUFBLENBQUNaLENBQURZLENBQWIsRUFBa0Isb0JBQUEsVUFBUVYsTUFBUixFQUFsQkwsQ0FBaUNlLE9BQUFBLENBQUNaLENBQURZO0lBSG5DRCxDQUFBQSxJQUFBQTtFQXh2QkZ2QixHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjMwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vanNvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgSlNPTlxuICBjbGFzcyBKU09ORXJyb3IgPCBTdGFuZGFyZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIFBhcnNlckVycm9yIDwgSlNPTkVycm9yXG4gIGVuZFxuXG4gICV4e1xuICAgIHZhciAkaGFzT3duID0gT3BhbC5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uICRwYXJzZShzb3VyY2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHNvdXJjZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICN7cmFpc2UgSlNPTjo6UGFyc2VyRXJyb3IsIGBlLm1lc3NhZ2VgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdG9fb3BhbCh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGtsYXNzLCBhcnIsIGhhc2gsIGksIGlpLCBrO1xuXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcblxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgIHJldHVybiBuaWw7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gbmlsO1xuXG4gICAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIGFyciA9ICN7YG9wdGlvbnMuYXJyYXlfY2xhc3NgLm5ld307XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gdmFsdWUubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAje2BhcnJgLnB1c2goYHRvX29wYWwodmFsdWVbaV0sIG9wdGlvbnMpYCl9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhc2ggPSAje2BvcHRpb25zLm9iamVjdF9jbGFzc2AubmV3fTtcblxuICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmICgkaGFzT3duLmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgI3tgaGFzaGBbYGtgXSA9IGB0b19vcGFsKHZhbHVlW2tdLCBvcHRpb25zKWB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wYXJzZSAmJiAoa2xhc3MgPSAje2BoYXNoYFtKU09OLmNyZWF0ZV9pZF19KSAhPSBuaWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICN7OjpPYmplY3QuY29uc3RfZ2V0KGBrbGFzc2ApLmpzb25fY3JlYXRlKGBoYXNoYCl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjbGFzcyA8PCBzZWxmXG4gICAgYXR0cl9hY2Nlc3NvciA6Y3JlYXRlX2lkXG4gIGVuZFxuXG4gIHNlbGYuY3JlYXRlX2lkID0gOmpzb25fY2xhc3NcblxuICBkZWYgc2VsZi5bXSh2YWx1ZSwgb3B0aW9ucyA9IHt9KVxuICAgIGlmIFN0cmluZyA9PT0gdmFsdWVcbiAgICAgIHBhcnNlKHZhbHVlLCBvcHRpb25zKVxuICAgIGVsc2VcbiAgICAgIGdlbmVyYXRlKHZhbHVlLCBvcHRpb25zKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5wYXJzZShzb3VyY2UsIG9wdGlvbnMgPSB7fSlcbiAgICBmcm9tX29iamVjdChgJHBhcnNlKHNvdXJjZSlgLCBvcHRpb25zLm1lcmdlKHBhcnNlOiB0cnVlKSlcbiAgZW5kXG5cbiAgZGVmIHNlbGYucGFyc2UhKHNvdXJjZSwgb3B0aW9ucyA9IHt9KVxuICAgIHBhcnNlKHNvdXJjZSwgb3B0aW9ucylcbiAgZW5kXG5cbiAgZGVmIHNlbGYubG9hZChzb3VyY2UsIG9wdGlvbnMgPSB7fSlcbiAgICBmcm9tX29iamVjdChgJHBhcnNlKHNvdXJjZSlgLCBvcHRpb25zKVxuICBlbmRcblxuICAjIFJhdyBqcyBvYmplY3QgPT4gb3BhbCBvYmplY3RcbiAgZGVmIHNlbGYuZnJvbV9vYmplY3QoanNfb2JqZWN0LCBvcHRpb25zID0ge30pXG4gICAgb3B0aW9uc1s6b2JqZWN0X2NsYXNzXSB8fD0gSGFzaFxuICAgIG9wdGlvbnNbOmFycmF5X2NsYXNzXSAgfHw9IEFycmF5XG5cbiAgICBgdG9fb3BhbChqc19vYmplY3QsIG9wdGlvbnMuJCRzbWFwKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZ2VuZXJhdGUob2JqLCBvcHRpb25zID0ge30pXG4gICAgb2JqLnRvX2pzb24ob3B0aW9ucylcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZHVtcChvYmosIGlvID0gbmlsLCBsaW1pdCA9IG5pbClcbiAgICBzdHJpbmcgPSBnZW5lcmF0ZShvYmopXG5cbiAgICBpZiBpb1xuICAgICAgaW8gPSBpby50b19pbyBpZiBpby5yZXNwb25kc190bz8gOnRvX2lvXG4gICAgICBpby53cml0ZSBzdHJpbmdcblxuICAgICAgaW9cbiAgICBlbHNlXG4gICAgICBzdHJpbmdcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuY2xhc3MgT2JqZWN0XG4gIGRlZiB0b19qc29uXG4gICAgdG9fcy50b19qc29uXG4gIGVuZFxuZW5kXG5cbiMgQlVHOiBFbnVtZXJhYmxlIG11c3QgY29tZSBiZWZvcmUgQXJyYXksIG90aGVyd2lzZSBpdCBvdmVycmlkZXMgI3RvX2pzb25cbiMgICAgICB0aGlzIGlzIGR1ZSB0byBob3cgbW9kdWxlcyBhcmUgaW1wbGVtZW50ZWQuXG5tb2R1bGUgRW51bWVyYWJsZVxuICBkZWYgdG9fanNvblxuICAgIHRvX2EudG9fanNvblxuICBlbmRcbmVuZFxuXG5jbGFzcyBBcnJheVxuICBkZWYgdG9fanNvblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gI3tzZWxmfS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaCgje2BzZWxmW2ldYC50b19qc29ufSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnWycgKyByZXN1bHQuam9pbignLCcpICsgJ10nO1xuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgQm9vbGVhblxuICBkZWYgdG9fanNvblxuICAgIGAoc2VsZiA9PSB0cnVlKSA/ICd0cnVlJyA6ICdmYWxzZSdgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEhhc2hcbiAgZGVmIHRvX2pzb25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKCN7YGtleWAudG9fcy50b19qc29ufSArICc6JyArICN7YHZhbHVlYC50b19qc29ufSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAneycgKyByZXN1bHQuam9pbignLCcpICsgJ30nO1xuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgTmlsQ2xhc3NcbiAgZGVmIHRvX2pzb25cbiAgICAnbnVsbCdcbiAgZW5kXG5lbmRcblxuY2xhc3MgTnVtZXJpY1xuICBkZWYgdG9fanNvblxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICBkZWYgdG9fanNvblxuICAgIGBKU09OLnN0cmluZ2lmeShzZWxmKWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgVGltZVxuICBkZWYgdG9fanNvblxuICAgIHN0cmZ0aW1lKCclRlQlVCV6JykudG9fanNvblxuICBlbmRcbmVuZFxuXG5jbGFzcyBEYXRlXG4gIGRlZiB0b19qc29uXG4gICAgdG9fcy50b19qc29uXG4gIGVuZFxuXG4gIGRlZiBhc19qc29uXG4gICAgdG9fc1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkpTT04+IiwiPGNsYXNzOkpTT05FcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOlBhcnNlckVycm9yPiIsIkpTT05FcnJvciIsInNlbGYiLCJyYWlzZSIsIkpTT046OlBhcnNlckVycm9yIiwiSlNPTiIsIm5ldyIsInB1c2giLCIkd3JpdGVyIiwiW109IiwiLSIsIjEiLCJbXSIsImNyZWF0ZV9pZCIsIk9iamVjdCIsImNvbnN0X2dldCIsImpzb25fY3JlYXRlIiwiYXR0cl9hY2Nlc3NvciIsImNyZWF0ZV9pZD0iLCJ2YWx1ZSIsIm9wdGlvbnMiLCJTdHJpbmciLCJwYXJzZSIsImdlbmVyYXRlIiwic291cmNlIiwiZnJvbV9vYmplY3QiLCJtZXJnZSIsInBhcnNlISIsImxvYWQiLCJqc19vYmplY3QiLCIkcmV0X29yXzEiLCJIYXNoIiwiQXJyYXkiLCJvYmoiLCJ0b19qc29uIiwiZHVtcCIsImlvIiwibGltaXQiLCJzdHJpbmciLCJyZXNwb25kc190bz8iLCJ0b19pbyIsIndyaXRlIiwiPGNsYXNzOk9iamVjdD4iLCJ0b19zIiwiPG1vZHVsZTpFbnVtZXJhYmxlPiIsInRvX2EiLCI8Y2xhc3M6QXJyYXk+IiwiPGNsYXNzOkJvb2xlYW4+IiwiPGNsYXNzOkhhc2g+IiwiPGNsYXNzOk5pbENsYXNzPiIsIjxjbGFzczpOdW1lcmljPiIsIjxjbGFzczpTdHJpbmc+IiwiPGNsYXNzOlRpbWU+Iiwic3RyZnRpbWUiLCI8Y2xhc3M6RGF0ZT4iLCJhc19qc29uIl0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsT0FBQUEsV0FBQUEsRUFBa0JDLG1CQUFsQkQ7SUFHQUUsT0FBQUEsV0FBQUEsRUFBb0JDLGVBQXBCRDs7QUFJRkg7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFFBQVVLLElBQUFDLE9BQUFBLENBQU1DLElBQUFDLFVBQUFELGdCQUFOLEVBQTBCUCxTQUExQk0sQ0FBcUNOO0FBQy9DQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUEsa0JBQW9CQSxDQUFDQSxtQkFBREEsQ0FBcUJTLEtBQUFBLENBQUFBLENBQUtUOztBQUU5Q0E7QUFDQUEsY0FBZ0JBLENBQUNBLEdBQURBLENBQUtVLE1BQUFBLENBQU9WLDBCQUFQVSxDQUFvQ1Y7QUFDekRBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxtQkFBcUJBLENBQUNBLG9CQUFEQSxDQUFzQlMsS0FBQUEsQ0FBQUEsQ0FBS1Q7O0FBRWhEQTtBQUNBQTtBQUNBQSxnQkFuREFBLENBQUFXLENBQUFBLFVBQUEsQ0FtRDBCWCxDQW5EMUIsRUFtRGlDQSwwQkFuRGpDLENBQUFXLEdBbUR3QkMsTUFBTlosQ0FBQ0EsSUFBREEsQ0FBTVksT0FBQUEsRUFuRHhCLE1BQUFELE9BQUEsQ0FtRHdCQyxHQW5EeEJELE9BQUEsQ0FBQUUsVUFBQUYsT0FBQSxDQUFBWCxRQUFBLENBQUFhLEVBQUFDLENBQUFELENB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QUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWhDLElBQUFtRCxVQUFBQSxDQUFTbkIsU0FBVG1CLENBQW1CbkIsU0FBQUEsQ0FBQUE7SUFEckJBLENBQUFBLEdBQUFBO0VBREZrQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQU1BeEQsT0FBQTBEO0VBQUFBOzs7OztBQUNFcEIsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWhDLElBQUF5QyxNQUFBQSxDQUFBQSxDQUFJVCxTQUFBQSxDQUFBQTtJQUROQSxDQUFBQSxHQUFBQTtJQUlBb0IsT0FBQUMsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXJELElBQUF5QyxNQUFBQSxDQUFBQTtJQURGWSxDQUFBQSxHQUFBQTtFQUxGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQXZNQTFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjYwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxpYi9hX2xveC92ZXJzaW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbm1vZHVsZSBBTG94XG4gIFZFUlNJT04gPSBcIjAuMS4wXCJcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkFMb3g+Il0sIm1hcHBpbmdzIjoiQUFBQUEsb0RBQUFBO0VBQUFBOztFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUEsbUNBQVVBLE9BQVY7RUFERkEsR0FBQUEsV0FBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NjE4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibGliL2FfbG94L3ByaW50ZXJzL3ByZXR0eV9wcmludGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBBTG94XG4gIG1vZHVsZSBQcmV0dHlQcmludGVyXG4gICAgZXh0ZW5kIHNlbGZcblxuICAgIGRlZiBwcmludChleHByZXNzaW9uKVxuICAgICAgZXhwcmVzc2lvbi5hY2NlcHQoc2VsZilcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9iaW5hcnkoYmluYXJ5KVxuICAgICAgYmluYXJ5LmxlZnQuYWNjZXB0KHNlbGYpICsgYmluYXJ5Lm9wZXJhdG9yLmxleGVtZSArIGJpbmFyeS5yaWdodC5hY2NlcHQoc2VsZilcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9ncm91cGluZyhncm91cGluZylcbiAgICAgIFwiKFwiICsgZ3JvdXBpbmcuZXhwcmVzc2lvbi5hY2NlcHQoc2VsZikgKyBcIilcIlxuICAgIGVuZFxuXG4gICAgZGVmIHZpc2l0X2xpdGVyYWwobGl0ZXJhbClcbiAgICAgIGxpdGVyYWwudmFsdWUudG9fc1xuICAgIGVuZFxuXG4gICAgZGVmIHZpc2l0X3VuYXJ5KHVuYXJ5KVxuICAgICAgdW5hcnkub3BlcmF0b3IubGV4ZW1lICsgdW5hcnkucmlnaHQuYWNjZXB0KHNlbGYpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QUxveD4iLCI8bW9kdWxlOlByZXR0eVByaW50ZXI+Iiwic2VsZiIsImV4dGVuZCIsInByaW50IiwiZXhwcmVzc2lvbiIsImFjY2VwdCIsInZpc2l0X2JpbmFyeSIsImJpbmFyeSIsIisiLCJsZWZ0Iiwib3BlcmF0b3IiLCJsZXhlbWUiLCJyaWdodCIsInZpc2l0X2dyb3VwaW5nIiwiZ3JvdXBpbmciLCJ2aXNpdF9saXRlcmFsIiwibGl0ZXJhbCIsInZhbHVlIiwidG9fcyIsInZpc2l0X3VuYXJ5IiwidW5hcnkiXSwibWFwcGluZ3MiOiJBQUFBQSxvRUFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7Ozs7TUFDRUMsSUFBQUMsUUFBQUEsQ0FBT0QsSUFBUEM7O0FBRUFDLE1BQUFBLHFCQUFBQSxpQkFBVUMsVUFBVkQ7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLFVBQVVDLFFBQUFBLENBQVFKLElBQVJJO01BRFpGLENBQUFBLEdBQUFBOztBQUlBRyxNQUFBQSw0QkFBQUEsd0JBQWlCQyxNQUFqQkQ7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQWtERSxTQUF6QkEsU0FBekJELE1BQU1FLE1BQUFBLENBQUFBLENBQUtKLFFBQUFBLENBQVFKLElBQVJJLENBQWNHLEVBQUVELE1BQU1HLFVBQUFBLENBQUFBLENBQVNDLFFBQUFBLENBQUFBLENBQWpCSCxDQUF5QkEsRUFBRUQsTUFBTUssT0FBQUEsQ0FBQUEsQ0FBTVAsUUFBQUEsQ0FBUUosSUFBUkksQ0FBZEc7TUFEcERGLENBQUFBLEdBQUFBOztBQUlBTyxNQUFBQSw4QkFBQUEsMEJBQW1CQyxRQUFuQkQ7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQXVDTCxTQUFuQ0EsU0FBSkssR0FBSUwsRUFBRU0sUUFBUVYsWUFBQUEsQ0FBQUEsQ0FBV0MsUUFBQUEsQ0FBUUosSUFBUkksQ0FBckJHLENBQW1DQSxFQUFFSyxHQUFGTDtNQUR6Q0ssQ0FBQUEsR0FBQUE7O0FBSUFFLE1BQUFBLDZCQUFBQSx5QkFBa0JDLE9BQWxCRDtBQUFBQTtRQUNFQSxPQUFBQyxPQUFPQyxPQUFBQSxDQUFBQSxDQUFNQyxNQUFBQSxDQUFBQTtNQURmSCxDQUFBQSxHQUFBQTtNQUlBZixPQUFBbUIsMkJBQUFBLHVCQUFnQkMsS0FBaEJEO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFzQlgsU0FBdEJZLEtBQUtWLFVBQUFBLENBQUFBLENBQVNDLFFBQUFBLENBQUFBLENBQVFILEVBQUVZLEtBQUtSLE9BQUFBLENBQUFBLENBQU1QLFFBQUFBLENBQVFKLElBQVJJLENBQWJHO01BRHhCVyxDQUFBQSxHQUFBQTtJQW5CRm5CLEdBQUFBLFdBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjY2NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxpYi9hX2xveC9wcmludGVycy9yZWFjdF90cmVlX3ByaW50ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEFMb3hcbiAgbW9kdWxlIFByaW50ZXJzXG4gICAgY2xhc3MgUmVhY3RUcmVlUHJpbnRlclxuICAgICAgZGVmIGluaXRpYWxpemUoc3RhdGVtZW50cylcbiAgICAgICAgQHN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzXG4gICAgICBlbmRcblxuICAgICAgZGVmIHByaW50XG4gICAgICAgIHJlZ3VsYXJfdHJlZSA9XG4gICAgICAgICAgaWYgQHN0YXRlbWVudHMuaXNfYT8gQXJyYXlcbiAgICAgICAgICAgIEBzdGF0ZW1lbnRzLm1hcCB7IHxyZXNvbHZhYmxlX2VsZW1lbnR8IHJlc29sdmFibGVfZWxlbWVudC5hY2NlcHQoc2VsZikgfVxuICAgICAgICAgIGVsc2lmIEBzdGF0ZW1lbnRzLnN0YXRlbWVudD9cbiAgICAgICAgICAgIEBzdGF0ZW1lbnRzLmFjY2VwdChzZWxmKVxuICAgICAgICAgIGVsc2lmIEBzdGF0ZW1lbnRzLmV4cHJlc3Npb24/XG4gICAgICAgICAgICBAc3RhdGVtZW50cy5hY2NlcHQoc2VsZilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByYWlzZSBcIk1hbGZvcm1lZCB0cmVlXCJcbiAgICAgICAgICBlbmRcblxuICAgICAgICB7bmFtZTogXCJQUk9HUkFNXCIsIGNoaWxkcmVuOiByZWd1bGFyX3RyZWV9XG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X2V4cHJlc3Npb25fc3RhdGVtZW50KGV4cHJlc3Npb25fc3RhdGVtZW50KVxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJFWFAtU1RNVFwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgIGNoaWxkcmVuOiBbZXhwcmVzc2lvbl9zdGF0ZW1lbnQuZXhwcmVzc2lvbi5hY2NlcHQoc2VsZildXG4gICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICBkZWYgdmlzaXRfZnVuY3Rpb25fc3RhdGVtZW50KGZ1bmN0aW9uX3N0YXRlbWVudClcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiRlVOLURFRlwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiI3tmdW5jdGlvbl9zdGF0ZW1lbnQubmFtZS5sZXhlbWV9KCN7ZnVuY3Rpb25fc3RhdGVtZW50LnBhcmFtZXRlcnMubWFwKCY6bGV4ZW1lKS5qb2luKFwiLCBcIil9KVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb25fc3RhdGVtZW50LmJvZHkubWFwIHsgfHN0YXRlbWVudHwgc3RhdGVtZW50LmFjY2VwdChzZWxmKSB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICBkZWYgdmlzaXRfcmV0dXJuX3N0YXRlbWVudChyZXR1cm5fc3RhdGVtZW50KVxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJSRVRVUk5cIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICBjaGlsZHJlbjogW3JldHVybl9zdGF0ZW1lbnQudmFsdWUuYWNjZXB0KHNlbGYpXVxuICAgICAgICB9XG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X3ByaW50X3N0YXRlbWVudChwcmludF9zdGF0ZW1lbnQpXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIlBSSU5UIFBSSU5UIFBSSU5UIFBSSU5UIFBSSU5UXCIsXG4gICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgY2hpbGRyZW46IFtwcmludF9zdGF0ZW1lbnQuZXhwcmVzc2lvbi5hY2NlcHQoc2VsZildXG4gICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICBkZWYgdmlzaXRfdmFyX3N0YXRlbWVudCh2YXJpYWJsZV9zdGF0ZW1lbnQpXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIlZBUi1ERUZcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBuYW1lOiB2YXJpYWJsZV9zdGF0ZW1lbnQubmFtZS5sZXhlbWVcbiAgICAgICAgICB9Lm1lcmdlKHNjb3BlX2F0dHJpYnV0ZXModmFyaWFibGVfc3RhdGVtZW50KSksXG4gICAgICAgICAgY2hpbGRyZW46IFthZG9ybih2YXJpYWJsZV9zdGF0ZW1lbnQuaW5pdGlhbGl6ZXImLmFjY2VwdChzZWxmKSwgXCJJTklUSUFMSVpFUlwiKV0uY29tcGFjdFxuICAgICAgICB9XG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X2Jsb2NrX3N0YXRlbWVudChibG9ja19zdGF0ZW1lbnQpXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkJMT0NLXCIsXG4gICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgY2hpbGRyZW46IGJsb2NrX3N0YXRlbWVudC5zdGF0ZW1lbnRzLm1hcCB7IHxzdGF0ZW1lbnR8IHN0YXRlbWVudC5hY2NlcHQoc2VsZikgfVxuICAgICAgICB9XG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X2lmX3N0YXRlbWVudChpZl9zdGF0ZW1lbnQpXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIklGXCIsXG4gICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIGFkb3JuKGlmX3N0YXRlbWVudC5jb25kaXRpb24uYWNjZXB0KHNlbGYpLCBcIkNPTkRJVElPTlwiKSxcbiAgICAgICAgICAgIGFkb3JuKGlmX3N0YXRlbWVudC50aGVuX2JyYW5jaC5hY2NlcHQoc2VsZiksIFwiVEhFTlwiKSxcbiAgICAgICAgICAgIGFkb3JuKGlmX3N0YXRlbWVudC5lbHNlX2JyYW5jaCYuYWNjZXB0KHNlbGYpLCBcIkVMU0VcIilcbiAgICAgICAgICBdLmNvbXBhY3RcbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB2aXNpdF93aGlsZV9zdGF0ZW1lbnQod2hpbGVfc3RhdGVtZW50KVxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJXSElMRVwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBhZG9ybih3aGlsZV9zdGF0ZW1lbnQuY29uZGl0aW9uLmFjY2VwdChzZWxmKSwgXCJDT05ESVRJT05cIiksXG4gICAgICAgICAgICBhZG9ybih3aGlsZV9zdGF0ZW1lbnQuYm9keS5hY2NlcHQoc2VsZiksIFwiQk9EWVwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgICMgLS0tLS0tLS0tXG5cbiAgICAgIGRlZiB2aXNpdF9hc3NpZ24oYXNzaWduX2V4cHJlc3Npb24pXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkFTU0lHTlwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IGFzc2lnbl9leHByZXNzaW9uLm5hbWUubGV4ZW1lXG4gICAgICAgICAgfS5tZXJnZShzY29wZV9hdHRyaWJ1dGVzKGFzc2lnbl9leHByZXNzaW9uKSksXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIGFzc2lnbl9leHByZXNzaW9uLnZhbHVlLmFjY2VwdChzZWxmKVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB2aXNpdF9iaW5hcnkoYmluYXJ5X2V4cHJlc3Npb24pXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkJJTkFSWVwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBiaW5hcnlfZXhwcmVzc2lvbi5vcGVyYXRvci5sZXhlbWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBiaW5hcnlfZXhwcmVzc2lvbi5sZWZ0LmFjY2VwdChzZWxmKSxcbiAgICAgICAgICAgIGJpbmFyeV9leHByZXNzaW9uLnJpZ2h0LmFjY2VwdChzZWxmKVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB2aXNpdF9ncm91cGluZyhncm91cGluZ19leHByZXNzaW9uKVxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJHUk9VUFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBbZ3JvdXBpbmdfZXhwcmVzc2lvbi5leHByZXNzaW9uLmFjY2VwdChzZWxmKV1cbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB2aXNpdF9saXRlcmFsKGxpdGVyYWxfZXhwcmVzc2lvbilcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiTElURVJBTFwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsX2V4cHJlc3Npb24udmFsdWUuaW5zcGVjdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB2aXNpdF9sb2dpY2FsKGxvZ2ljYWxfZXhwcmVzc2lvbilcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiTE9HSUNBTFwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHt2YWx1ZTogbG9naWNhbF9leHByZXNzaW9uLm9wZXJhdG9yLmxleGVtZX0sXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIGxvZ2ljYWxfZXhwcmVzc2lvbi5sZWZ0LmFjY2VwdChzZWxmKSxcbiAgICAgICAgICAgIGxvZ2ljYWxfZXhwcmVzc2lvbi5yaWdodC5hY2NlcHQoc2VsZilcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICBkZWYgdmlzaXRfdW5hcnkodW5hcnlfZXhwcmVzc2lvbilcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiVU5BUllcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBvcGVyYXRvcjogdW5hcnlfZXhwcmVzc2lvbi5vcGVyYXRvci5sZXhlbWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBbdW5hcnlfZXhwcmVzc2lvbi5yaWdodC5hY2NlcHQoc2VsZildXG4gICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICBkZWYgdmlzaXRfdmFyaWFibGUodmFyaWFibGVfZXhwcmVzc2lvbilcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiVkFSLUxPT0tVUFwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHZhcmlhYmxlX2V4cHJlc3Npb24ubmFtZS5sZXhlbWVcbiAgICAgICAgICB9Lm1lcmdlKHNjb3BlX2F0dHJpYnV0ZXModmFyaWFibGVfZXhwcmVzc2lvbikpXG4gICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICBkZWYgdmlzaXRfY2FsbChjYWxsX2V4cHJlc3Npb24pXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkNBTExcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgYWRvcm4oY2FsbF9leHByZXNzaW9uLmNhbGxlZS5hY2NlcHQoc2VsZiksIFwiQ0FMTEVFXCIpXG4gICAgICAgICAgXSArIGNhbGxfZXhwcmVzc2lvbi5hcmd1bWVudHMubWFwIHsgfGFyZ3VtZW50fCBhZG9ybihhcmd1bWVudC5hY2NlcHQoc2VsZiksIFwiQVJHXCIpIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIHByaXZhdGVcblxuICAgICAgZGVmIGFkb3JuKG5vZGUsIHJvbGUpXG4gICAgICAgIHJldHVybiB1bmxlc3Mgbm9kZVxuXG4gICAgICAgIG5vZGUudGFwIGRvXG4gICAgICAgICAgbm9kZVs6YXR0cmlidXRlc11bOnJvbGVdID0gcm9sZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgc2NvcGVfYXR0cmlidXRlcyhub2RlKVxuICAgICAgICBpZiBub2RlLmFsbG9jYXRpb24uZ2xvYmFsP1xuICAgICAgICAgIHthbGxvY2F0aW9uOiBcIkdMT0JBTFwifVxuICAgICAgICBlbHNpZiBub2RlLmFsbG9jYXRpb24ubG9jYWw/XG4gICAgICAgICAge1xuICAgICAgICAgICAgYWxsb2NhdGlvbjogXCJTVEFDS1wiLFxuICAgICAgICAgICAgXCJzdGFjayBzbG90XCIgPT4gbm9kZS5hbGxvY2F0aW9uLnNsb3RcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2lmIG5vZGUuYWxsb2NhdGlvbi51cHZhbHVlP1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFsbG9jYXRpb246IFwiSEVBUFwiLFxuICAgICAgICAgICAgXCJoZWFwIHNsb3RcIiA9PiBub2RlLmFsbG9jYXRpb24uc2xvdFxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpBTG94PiIsIjxtb2R1bGU6UHJpbnRlcnM+IiwiPGNsYXNzOlJlYWN0VHJlZVByaW50ZXI+IiwiaW5pdGlhbGl6ZSIsInN0YXRlbWVudHMiLCJAc3RhdGVtZW50cyIsInByaW50IiwicmVndWxhcl90cmVlIiwiaXNfYT8iLCJBcnJheSIsIm1hcCIsImJsb2NrIGluIHByaW50IiwicmVzb2x2YWJsZV9lbGVtZW50IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcmludCIsImFjY2VwdCIsInNlbGYiLCJzdGF0ZW1lbnQ/IiwiZXhwcmVzc2lvbj8iLCJyYWlzZSIsInZpc2l0X2V4cHJlc3Npb25fc3RhdGVtZW50IiwiZXhwcmVzc2lvbl9zdGF0ZW1lbnQiLCJleHByZXNzaW9uIiwidmlzaXRfZnVuY3Rpb25fc3RhdGVtZW50IiwiZnVuY3Rpb25fc3RhdGVtZW50IiwibmFtZSIsImxleGVtZSIsInBhcmFtZXRlcnMiLCJ0b19wcm9jIiwiam9pbiIsImJvZHkiLCJibG9jayBpbiB2aXNpdF9mdW5jdGlvbl9zdGF0ZW1lbnQiLCJzdGF0ZW1lbnQiLCJibG9jayAoMiBsZXZlbHMpIGluIHZpc2l0X2Z1bmN0aW9uX3N0YXRlbWVudCIsInZpc2l0X3JldHVybl9zdGF0ZW1lbnQiLCJyZXR1cm5fc3RhdGVtZW50IiwidmFsdWUiLCJ2aXNpdF9wcmludF9zdGF0ZW1lbnQiLCJwcmludF9zdGF0ZW1lbnQiLCJ2aXNpdF92YXJfc3RhdGVtZW50IiwidmFyaWFibGVfc3RhdGVtZW50IiwibWVyZ2UiLCJzY29wZV9hdHRyaWJ1dGVzIiwiYWRvcm4iLCJpbml0aWFsaXplciIsImNvbXBhY3QiLCJ2aXNpdF9ibG9ja19zdGF0ZW1lbnQiLCJibG9ja19zdGF0ZW1lbnQiLCJibG9jayBpbiB2aXNpdF9ibG9ja19zdGF0ZW1lbnQiLCJibG9jayAoMiBsZXZlbHMpIGluIHZpc2l0X2Jsb2NrX3N0YXRlbWVudCIsInZpc2l0X2lmX3N0YXRlbWVudCIsImlmX3N0YXRlbWVudCIsImNvbmRpdGlvbiIsInRoZW5fYnJhbmNoIiwiZWxzZV9icmFuY2giLCJ2aXNpdF93aGlsZV9zdGF0ZW1lbnQiLCJ3aGlsZV9zdGF0ZW1lbnQiLCJ2aXNpdF9hc3NpZ24iLCJhc3NpZ25fZXhwcmVzc2lvbiIsInZpc2l0X2JpbmFyeSIsImJpbmFyeV9leHByZXNzaW9uIiwib3BlcmF0b3IiLCJsZWZ0IiwicmlnaHQiLCJ2aXNpdF9ncm91cGluZyIsImdyb3VwaW5nX2V4cHJlc3Npb24iLCJ2aXNpdF9saXRlcmFsIiwibGl0ZXJhbF9leHByZXNzaW9uIiwiaW5zcGVjdCIsInZpc2l0X2xvZ2ljYWwiLCJsb2dpY2FsX2V4cHJlc3Npb24iLCJ2aXNpdF91bmFyeSIsInVuYXJ5X2V4cHJlc3Npb24iLCJ2aXNpdF92YXJpYWJsZSIsInZhcmlhYmxlX2V4cHJlc3Npb24iLCJ2aXNpdF9jYWxsIiwiY2FsbF9leHByZXNzaW9uIiwiKyIsImNhbGxlZSIsImFyZ3VtZW50cyIsImJsb2NrIGluIHZpc2l0X2NhbGwiLCJhcmd1bWVudCIsImJsb2NrICgyIGxldmVscykgaW4gdmlzaXRfY2FsbCIsInByaXZhdGUiLCJub2RlIiwicm9sZSIsInRhcCIsImJsb2NrIGluIGFkb3JuIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhZG9ybiIsIiR3cml0ZXIiLCJbXT0iLCJbXSIsIi0iLCIxIiwiYWxsb2NhdGlvbiIsImdsb2JhbD8iLCJsb2NhbD8iLCJzbG90IiwidXB2YWx1ZT8iXSwibWFwcGluZ3MiOiJBQUFBQSx3RUFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUNFQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOzs7QUFDRUMsUUFBQUEsMEJBQUFBLHNCQUFlQyxVQUFmRDtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUUsQ0FBQUEsa0JBQWNELFVBQWRDO1FBREZGLENBQUFBLEdBQUFBOztBQUlBRyxRQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFVBQUFBOzs7VUFDRUMsZUFDRSxDQUFBLFFBQUdGLGVBQVdHLFVBQUFBLENBQU9DLFdBQVBELENBQWQsQ0FBQSxHQUFBLENBQ2FFLE1BQVhMLGVBQVdLLE9BQUFBLEVBQUFBLEVBQUFBLEVBQVhDLGFBQW1CQyxrQkFBbkJELEVBQUFFOzs7O1lBQW1CO1lBQW9CQSxPQUFBRCxrQkFBa0JFLFFBQUFBLENBQVFDLElBQVJELEVBQXpESCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBV0QsQ0FEYixJQUVBLENBQUEsUUFBTUwsZUFBV1csZUFBQUEsQ0FBQUEsQ0FBakIsQ0FBQSxHQUFBLENBQ0VYLGVBQVdTLFFBQUFBLENBQVFDLElBQVJELENBRGIsSUFFQSxDQUFBLFFBQU1ULGVBQVdZLGdCQUFBQSxDQUFBQSxDQUFqQixDQUFBLEdBQUEsQ0FDRVosZUFBV1MsUUFBQUEsQ0FBUUMsSUFBUkQsQ0FEYixJQUFBLENBR0VDLElBQUFHLE9BQUFBLENBQU1aLGdCQUFOWSxDQUhGLENBQUEsQ0FGQSxDQUZBO1VBVUZaLE9BQUEs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ZCxFQUFBLGNBRWtCMEMsSUFBSVUsWUFBQUEsQ0FBQUEsQ0FBV0csTUFBQUEsQ0FBQUEsQ0FGakM7VUFERixPQUtBLElBQUEsUUFBTWIsSUFBSVUsWUFBQUEsQ0FBQUEsQ0FBV0ksYUFBQUEsQ0FBQUEsQ0FBckIsQ0FBQTtZQUNFeEQsT0FBQSxxQ0FBQSxjQUNjQSxNQURkLEVBQUEsYUFFaUIwQyxJQUFJVSxZQUFBQSxDQUFBQSxDQUFXRyxNQUFBQSxDQUFBQSxDQUZoQztVQURGO1lBdE1SdkQsT0FBQTtVQXNNUTtRQVJGQSxDQUFBQSxHQUFBQTtNQTVMRnZDLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBREZELEdBQUFBLFdBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjg0NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxpYi9hX2xveC9zY2FubmVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBBTG94XG4gIG1vZHVsZSBUb2tlblR5cGVzXG4gICAgTEVGVF9QQVJFTiA9IFwiTEVGVF9QQVJFTlwiXG4gICAgUklHSFRfUEFSRU4gPSBcIlJJR0hUX1BBUkVOXCJcbiAgICBMRUZUX0JSQUNFID0gXCJMRUZUX0JSQUNFXCJcbiAgICBSSUdIVF9CUkFDRSA9IFwiUklHSFRfQlJBQ0VcIlxuICAgIENPTU1BID0gXCJDT01NQVwiXG4gICAgRE9UID0gXCJET1RcIlxuICAgIE1JTlVTID0gXCJNSU5VU1wiXG4gICAgUExVUyA9IFwiUExVU1wiXG4gICAgU0VNSUNPTE9OID0gXCJTRU1JQ09MT05cIlxuICAgIFNMQVNIID0gXCJTTEFTSFwiXG4gICAgU1RBUiA9IFwiU1RBUlwiXG5cbiAgICBCQU5HID0gXCJCQU5HXCJcbiAgICBCQU5HX0VRVUFMID0gXCJCQU5HX0VRVUFMXCJcbiAgICBFUVVBTCA9IFwiRVFVQUxcIlxuICAgIEVRVUFMX0VRVUFMID0gXCJFUVVBTF9FUVVBTFwiXG5cbiAgICBHUkVBVEVSID0gXCJHUkVBVEVSXCJcbiAgICBHUkVBVEVSX0VRVUFMID0gXCJHUkVBVEVSX0VRVUFMXCJcbiAgICBMRVNTID0gXCJMRVNTXCJcbiAgICBMRVNTX0VRVUFMID0gXCJMRVNTX0VRVUFMXCJcblxuICAgIElERU5USUZJRVIgPSBcIklERU5USUZJRVJcIlxuICAgIFNUUklORyA9IFwiU1RSSU5HXCJcbiAgICBOVU1CRVIgPSBcIk5VTUJFUlwiXG5cbiAgICBBTkQgPSBcIkFORFwiXG4gICAgT1IgPSBcIk9SXCJcbiAgICBJRiA9IFwiSUZcIlxuICAgIEVMU0UgPSBcIkVMU0VcIlxuICAgIFRSVUVfVE9LRU4gPSBcIlRSVUVcIlxuICAgIEZBTFNFX1RPS0VOID0gXCJGQUxTRVwiXG4gICAgV0hJTEUgPSBcIldISUxFXCJcbiAgICBGT1IgPSBcIkZPUlwiXG4gICAgTklMX1RPS0VOID0gXCJOSUxcIlxuICAgIEZVTiA9IFwiRlVOXCJcblxuICAgIFBSSU5UID0gXCJQUklOVFwiXG4gICAgUkVUVVJOID0gXCJSRVRVUk5cIlxuICAgIFZBUiA9IFwiVkFSXCJcblxuICAgIEVPRiA9IFwiRU9GXCJcbiAgZW5kXG5cbiAgVG9rZW4gPSBTdHJ1Y3QubmV3KDp0eXBlLCA6bGV4ZW1lLCA6bGl0ZXJhbCwgOmxpbmUpIGRvXG4gICAgZGVmIHNlcmlhbGl6ZVxuICAgICAgdG9faC5tZXJnZShuYW1lOiBcIlRPS0VOXCIpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIFNjYW5uZXJcbiAgICBpbmNsdWRlIFRva2VuVHlwZXNcblxuICAgIEtFWV9XT1JEUyA9IHtcbiAgICAgIFwiYW5kXCIgPT4gQU5ELFxuICAgICAgXCJlbHNlXCIgPT4gRUxTRSxcbiAgICAgIFwiZm9yXCIgPT4gRk9SLFxuICAgICAgXCJmdW5cIiA9PiBGVU4sXG4gICAgICBcImlmXCIgPT4gSUYsXG4gICAgICBcIm5pbFwiID0+IE5JTF9UT0tFTixcbiAgICAgIFwib3JcIiA9PiBPUixcbiAgICAgIFwicHJpbnRcIiA9PiBQUklOVCxcbiAgICAgIFwicmV0dXJuXCIgPT4gUkVUVVJOLFxuICAgICAgXCJ0cnVlXCIgPT4gVFJVRV9UT0tFTixcbiAgICAgIFwiZmFsc2VcIiA9PiBGQUxTRV9UT0tFTixcbiAgICAgIFwidmFyXCIgPT4gVkFSLFxuICAgICAgXCJ3aGlsZVwiID0+IFdISUxFXG4gICAgfVxuXG4gICAgZGVmIGluaXRpYWxpemUoc291cmNlLCBlcnJvcl9yZXBvcnRlcjogbmlsKVxuICAgICAgQHNvdXJjZSA9IHNvdXJjZVxuICAgICAgQHRva2VucyA9IFtdXG5cbiAgICAgIEBzdGFydCA9IDBcbiAgICAgIEBjdXJyZW50ID0gMFxuICAgICAgQGxpbmUgPSAxXG5cbiAgICAgIEBlcnJvcl9yZXBvcnRlciA9IGVycm9yX3JlcG9ydGVyXG4gICAgZW5kXG5cbiAgICBkZWYgc2NhblxuICAgICAgd2hpbGUgaGFzX21vcmU/XG4gICAgICAgIEBzdGFydCA9IEBjdXJyZW50XG4gICAgICAgIHNjYW5fdG9rZW5cbiAgICAgIGVuZFxuXG4gICAgICBAc3RhcnQgPSBAY3VycmVudFxuXG4gICAgICBhZGRfdG9rZW4oRU9GKVxuXG4gICAgICBAdG9rZW5zXG4gICAgZW5kXG5cbiAgICBkZWYgc2Nhbl90b2tlblxuICAgICAgY3VycmVudF9jaGFyID0gYWR2YW5jZVxuXG4gICAgICBjYXNlIGN1cnJlbnRfY2hhclxuICAgICAgd2hlbiBcIihcIiB0aGVuIGFkZF90b2tlbihMRUZUX1BBUkVOKVxuICAgICAgd2hlbiBcIilcIiB0aGVuIGFkZF90b2tlbihSSUdIVF9QQVJFTilcbiAgICAgIHdoZW4gXCJ7XCIgdGhlbiBhZGRfdG9rZW4oTEVGVF9CUkFDRSlcbiAgICAgIHdoZW4gXCJ9XCIgdGhlbiBhZGRfdG9rZW4oUklHSFRfQlJBQ0UpXG4gICAgICB3aGVuIFwiLFwiIHRoZW4gYWRkX3Rva2VuKENPTU1BKVxuICAgICAgd2hlbiBcIi5cIiB0aGVuIGFkZF90b2tlbihET1QpXG4gICAgICB3aGVuIFwiLVwiIHRoZW4gYWRkX3Rva2VuKE1JTlVTKVxuICAgICAgd2hlbiBcIitcIiB0aGVuIGFkZF90b2tlbihQTFVTKVxuICAgICAgd2hlbiBcIjtcIiB0aGVuIGFkZF90b2tlbihTRU1JQ09MT04pXG4gICAgICB3aGVuIFwiKlwiIHRoZW4gYWRkX3Rva2VuKFNUQVIpXG4gICAgICB3aGVuIFwiIVwiIHRoZW4gYWRkX3Rva2VuKG1hdGNoPyhcIj1cIikgPyBCQU5HX0VRVUFMIDogQkFORylcbiAgICAgIHdoZW4gXCI9XCIgdGhlbiBhZGRfdG9rZW4obWF0Y2g/KFwiPVwiKSA/IEVRVUFMX0VRVUFMIDogRVFVQUwpXG4gICAgICB3aGVuIFwiPFwiIHRoZW4gYWRkX3Rva2VuKG1hdGNoPyhcIj1cIikgPyBMRVNTX0VRVUFMIDogTEVTUylcbiAgICAgIHdoZW4gXCI+XCIgdGhlbiBhZGRfdG9rZW4obWF0Y2g/KFwiPVwiKSA/IEdSRUFURVJfRVFVQUwgOiBHUkVBVEVSKVxuICAgICAgd2hlbiBcIi9cIlxuICAgICAgICBpZiBtYXRjaD8oXCIvXCIpXG4gICAgICAgICAgd2hpbGUgcGVlayAhPSBcIlxcblwiICYmIGhhc19tb3JlP1xuICAgICAgICAgICAgYWR2YW5jZVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgYWRkX3Rva2VuKFNMQVNIKVxuICAgICAgICBlbmRcbiAgICAgIHdoZW4gXCJcXG5cIiB0aGVuIEBsaW5lICs9IDFcbiAgICAgIHdoZW4gL1xccy8gdGhlbiBub29wXG4gICAgICB3aGVuICdcIicgdGhlbiBjb25zdW1lX3N0cmluZ1xuICAgICAgd2hlbiAvXFxkLyB0aGVuIGNvbnN1bWVfbnVtYmVyXG4gICAgICB3aGVuIC9cXHcvIHRoZW4gY29uc3VtZV9pZGVudGlmaWVyXG4gICAgICBlbHNlXG4gICAgICAgIEBlcnJvcl9yZXBvcnRlci5yZXBvcnRfc2Nhbm5lcl9lcnJvcihAbGluZSwgXCJpbnZhbGlkIHRva2VuXCIpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBub29wXG4gICAgZW5kXG5cbiAgICBkZWYgYXRfZW5kP1xuICAgICAgQGN1cnJlbnQgPj0gQHNvdXJjZS5zaXplXG4gICAgZW5kXG5cbiAgICBkZWYgaGFzX21vcmU/XG4gICAgICAhYXRfZW5kP1xuICAgIGVuZFxuXG4gICAgZGVmIGFkdmFuY2VcbiAgICAgIGNoYXIgPSBAc291cmNlW0BjdXJyZW50XVxuICAgICAgQGN1cnJlbnQgKz0gMVxuICAgICAgY2hhclxuICAgIGVuZFxuXG4gICAgZGVmIHBlZWtcbiAgICAgIHJldHVybiBcIlxcMFwiIGlmIGF0X2VuZD9cbiAgICAgIEBzb3VyY2VbQGN1cnJlbnRdXG4gICAgZW5kXG5cbiAgICBkZWYgcGVla19uZXh0XG4gICAgICByZXR1cm4gXCJcXDBcIiBpZiBhdF9lbmQ/XG4gICAgICBAc291cmNlW0BjdXJyZW50ICsgMV1cbiAgICBlbmRcblxuICAgIGRlZiBtYXRjaD8oZXhwZWN0ZWQpXG4gICAgICByZXR1cm4gZmFsc2UgaWYgYXRfZW5kP1xuICAgICAgcmV0dXJuIGZhbHNlIGlmIEBzb3VyY2VbQGN1cnJlbnRdICE9IGV4cGVjdGVkXG5cbiAgICAgIEBjdXJyZW50ICs9IDFcblxuICAgICAgdHJ1ZVxuICAgIGVuZFxuXG4gICAgZGVmIGNvbnN1bWVfc3RyaW5nXG4gICAgICB3aGlsZSBwZWVrICE9ICdcIicgJiYgaGFzX21vcmU/XG4gICAgICAgIEBsaW5lICs9IDEgaWYgcGVlayA9PSBcIlxcblwiXG4gICAgICAgIGFkdmFuY2VcbiAgICAgIGVuZFxuXG4gICAgICBpZiBhdF9lbmQ/XG4gICAgICAgIEBlcnJvcl9yZXBvcnRlci5yZXBvcnRfc2Nhbm5lcl9lcnJvcihAbGluZSwgXCJ1bnRlcm1pbmF0ZWQgc3RyaW5nXCIpXG4gICAgICBlbmRcblxuICAgICAgYWR2YW5jZSAjIGNsb3NpbmcgXCJcblxuICAgICAgYWRkX3Rva2VuKFNUUklORywgQHNvdXJjZVtAc3RhcnQgKyAxLi4uQGN1cnJlbnQgLSAxXSlcbiAgICBlbmRcblxuICAgIGRlZiBjb25zdW1lX251bWJlclxuICAgICAgd2hpbGUgZGlnaXQ/KHBlZWspXG4gICAgICAgIGFkdmFuY2VcbiAgICAgIGVuZFxuXG4gICAgICBpZiBwZWVrID09IFwiLlwiICYmIGRpZ2l0PyhwZWVrX25leHQpXG4gICAgICAgIGFkdmFuY2VcblxuICAgICAgICB3aGlsZSBkaWdpdD8ocGVlaylcbiAgICAgICAgICBhZHZhbmNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIGFkZF90b2tlbihOVU1CRVIsIEBzb3VyY2VbQHN0YXJ0Li4uQGN1cnJlbnRdLnRvX2YpXG4gICAgZW5kXG5cbiAgICBkZWYgY29uc3VtZV9pZGVudGlmaWVyXG4gICAgICB3aGlsZSBwZWVrID1+IC9cXHcvXG4gICAgICAgIGFkdmFuY2VcbiAgICAgIGVuZFxuXG4gICAgICBsZXhlbWUgPSBAc291cmNlW0BzdGFydC4uLkBjdXJyZW50XVxuXG4gICAgICBhZGRfdG9rZW4oS0VZX1dPUkRTW2xleGVtZV0gfHwgSURFTlRJRklFUilcbiAgICBlbmRcblxuICAgIGRlZiBkaWdpdD8oY2hhcilcbiAgICAgIGNoYXIgPj0gXCIwXCIgJiYgY2hhciA8PSBcIjlcIlxuICAgIGVuZFxuXG4gICAgZGVmIGFkZF90b2tlbih0eXBlLCBsaXRlcmFsID0gbmlsKVxuICAgICAgbGV4ZW1lID0gQHNvdXJjZVtAc3RhcnQuLi5AY3VycmVudF1cbiAgICAgIEB0b2tlbnMgPDwgVG9rZW4ubmV3KHR5cGUsIGxleGVtZSwgbGl0ZXJhbCwgQGxpbmUpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QUxveD4iLCI8bW9kdWxlOlRva2VuVHlwZXM+IiwibmV3IiwiU3RydWN0IiwiYmxvY2sgaW4gPG1vZHVsZTpBTG94PiIsImJsb2NrICgyIGxldmVscykgaW4gPG1vZHVsZTpBTG94PiIsInNlcmlhbGl6ZSIsInNlbGYiLCJ0b19oIiwibWVyZ2UiLCI8Y2xhc3M6U2Nhbm5lcj4iLCJpbmNsdWRlIiwiVG9rZW5UeXBlcyIsIkFORCIsIkVMU0UiLCJGT1IiLCJGVU4iLCJJRiIsIk5JTF9UT0tFTiIsIk9SIiwiUFJJTlQiLCJSRVRVUk4iLCJUUlVFX1RPS0VOIiwiRkFMU0VfVE9LRU4iLCJWQVIiLCJXSElMRSIsImluaXRpYWxpemUiLCJzb3VyY2UiLCIka3dhcmdzIiwiQHNvdXJjZSIsIkB0b2tlbnMiLCJAc3RhcnQiLCIwIiwiQGN1cnJlbnQiLCJAbGluZSIsIjEiLCJAZXJyb3JfcmVwb3J0ZXIiLCJlcnJvcl9yZXBvcnRlciIsInNjYW4iLCJoYXNfbW9yZT8iLCJzY2FuX3Rva2VuIiwiYWRkX3Rva2VuIiwiRU9GIiwiY3VycmVudF9jaGFyIiwiYWR2YW5jZSIsIiRyZXRfb3JfMSIsIkxFRlRfUEFSRU4iLCJSSUdIVF9QQVJFTiIsIkxFRlRfQlJBQ0UiLCJSSUdIVF9CUkFDRSIsIkNPTU1BIiwiRE9UIiwiTUlOVVMiLCJQTFVTIiwiU0VNSUNPTE9OIiwiU1RBUiIsIm1hdGNoPyIsIkJBTkdfRVFVQUwiLCJCQU5HIiwiRVFVQUxfRVFVQUwiLCJFUVVBTCIsIkxFU1NfRVFVQUwiLCJMRVNTIiwiR1JFQVRFUl9FUVVBTCIsIkdSRUFURVIiLCIkcmV0X29yXzIiLCJwZWVrIiwiIT0iLCJTTEFTSCIsIisiLCJub29wIiwiY29uc3VtZV9zdHJpbmciLCJjb25zdW1lX251bWJlciIsImNvbnN1bWVfaWRlbnRpZmllciIsInJlcG9ydF9zY2FubmVyX2Vycm9yIiwiYXRfZW5kPyIsIj49Iiwic2l6ZSIsIiEiLCJjaGFyJCIsIltdIiwicGVla19uZXh0IiwiZXhwZWN0ZWQiLCJTVFJJTkciLCItIiwiZGlnaXQ/IiwiTlVNQkVSIiwidG9fZiIsIj1+IiwibGV4ZW1lIiwiS0VZX1dPUkRTIiwiSURFTlRJRklFUiIsIjw9IiwidHlwZSIsImxpdGVyYWwiLCI8PCIsIlRva2VuIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0RBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQztJQUFBQTs7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LElBQUFBO0VBcERGVixHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjcxMzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsaWIvYV9sb3gvYXN0X25vZGVfZHNsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBBTG94XG4gIG1vZHVsZSBBc3ROb2RlRFNMXG4gICAgZGVmIHNlbGYuaW5jbHVkZWQoYmFzZSlcbiAgICAgIGJhc2UuZXh0ZW5kIHNlbGZcbiAgICBlbmRcblxuICAgIGNsYXNzIERTTEVudmlyb25tZW50XG4gICAgICBhdHRyX3JlYWRlciA6cHJpbWFyeV9maWVsZHMsIDphZGRpdGlvbmFsX2ZpZWxkc1xuXG4gICAgICBkZWYgaW5pdGlhbGl6ZVxuICAgICAgICBAcHJpbWFyeV9maWVsZHMgPSBbXVxuICAgICAgICBAYWRkaXRpb25hbF9maWVsZHMgPSBbXVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCAqYXJncywgKiprd2FyZ3MpXG4gICAgICAgIGZhaWwgaWYgQHByaW1hcnlfZmllbGRzLmluY2x1ZGU/KG5hbWUpXG5cbiAgICAgICAgQHByaW1hcnlfZmllbGRzIDw8IG5hbWVcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgcmVzcG9uZF90b19taXNzaW5nPygqKSA9IHRydWVcblxuICAgICAgZGVmIGFkZGl0aW9uYWwoKm5hbWVzKVxuICAgICAgICBuYW1lcy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICAgIGZhaWwgaWYgQGFkZGl0aW9uYWxfZmllbGRzLmluY2x1ZGU/KG5hbWUpXG4gICAgICAgICAgQGFkZGl0aW9uYWxfZmllbGRzIDw8IG5hbWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBkZWZpbmVfbm9kZSgmYmxvY2spXG4gICAgICBlbnYgPSBEU0xFbnZpcm9ubWVudC5uZXdcbiAgICAgIGVudi5pbnN0YW5jZV9ldmFsKCZibG9jaylcblxuICAgICAgQ2xhc3MubmV3IGRvXG4gICAgICAgIGF0dHJfcmVhZGVyKCplbnYucHJpbWFyeV9maWVsZHMpXG4gICAgICAgIGF0dHJfYWNjZXNzb3IoKmVudi5hZGRpdGlvbmFsX2ZpZWxkcylcblxuICAgICAgICBkZWZpbmVfbWV0aG9kIDppbml0aWFsaXplIGRvIHwqYXJnc3xcbiAgICAgICAgICBpZiBhcmdzLnNpemUgIT0gZW52LnByaW1hcnlfZmllbGRzLnNpemVcbiAgICAgICAgICAgIGZhaWwgQXJndW1lbnRFcnJvcixcbiAgICAgICAgICAgICAgXCJleGFjdGx5ICN7cHJlc2VudF9maWVsZHNfbGlzdChlbnYucHJpbWFyeV9maWVsZHMpfSBuZWVkZWRcIlxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgZW52LnByaW1hcnlfZmllbGRzLmVhY2hfd2l0aF9pbmRleCBkbyB8cHJpbWFyeV9maWVsZF9uYW1lLCBpfFxuICAgICAgICAgICAgaW5zdGFuY2VfdmFyaWFibGVfc2V0KDpcIkAje3ByaW1hcnlfZmllbGRfbmFtZX1cIiwgYXJnc1tpXSlcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIGVudi5hZGRpdGlvbmFsX2ZpZWxkcy5lYWNoIHsgfGZ8IGluc3RhbmNlX3ZhcmlhYmxlX3NldCg6XCJAI3tmfVwiLCBuaWwpIH1cbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmaW5lX21ldGhvZCA6YWNjZXB0IGRvIHx2aXNpdG9yfFxuICAgICAgICAgIHZpc2l0b3IucHVibGljX3NlbmQoOlwidmlzaXRfI3t1bmRlcnNjb3JlKHNlbGYuY2xhc3MubmFtZSl9XCIsIHNlbGYpXG4gICAgICAgIGVuZFxuXG4gICAgICAgIHByaXZhdGVcblxuICAgICAgICBkZWYgcHJlc2VudF9maWVsZHNfbGlzdChmaWVsZHMpXG4gICAgICAgICAgcmV0dXJuIFwibm8gZmllbGRzXCIgaWYgZmllbGRzLmVtcHR5P1xuICAgICAgICAgIHJldHVybiBcImAje2ZpZWxkcy5maXJzdH1gXCIgaWYgZmllbGRzLnNpemUgPT0gMVxuXG4gICAgICAgICAgZmllbGRzWzAuLi0yXS5tYXAgeyB8ZnwgXCJgI3tmfWBcIiB9LmpvaW4oXCIsIFwiKSArIFwiIGFuZCBgI3tmaWVsZHNbLTFdfWBcIlxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgdW5kZXJzY29yZShjYW1lbF9jYXNlZF93b3JkKVxuICAgICAgICAgIHdvcmQgPSBjYW1lbF9jYXNlZF93b3JkLnNwbGl0KFwiOjpcIikubGFzdFxuICAgICAgICAgIHdvcmQgPSB3b3JkLmdzdWIoLyhbQS1aXSspKD89W0EtWl1bYS16XSl8KFthLXpcXGRdKSg/PVtBLVpdKS8pIHsgKCQxIHx8ICQyKSArIFwiX1wiIH1cbiAgICAgICAgICB3b3JkID0gd29yZC50cihcIi1cIiwgXCJfXCIpXG4gICAgICAgICAgd29yZCA9IHdvcmQuZG93bmNhc2VcbiAgICAgICAgICB3b3JkXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QUxveD4iLCI8bW9kdWxlOkFzdE5vZGVEU0w+IiwiaW5jbHVkZWQiLCJzZWxmIiwiYmFzZSIsImV4dGVuZCIsIjxjbGFzczpEU0xFbnZpcm9ubWVudD4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAcHJpbWFyeV9maWVsZHMiLCJAYWRkaXRpb25hbF9maWVsZHMiLCJtZXRob2RfbWlzc2luZyIsIm5hbWUiLCJpbmNsdWRlPyIsImZhaWwiLCI8PCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJhZGRpdGlvbmFsIiwiZWFjaCIsIm5hbWVzIiwiYmxvY2sgaW4gYWRkaXRpb25hbCIsImJsb2NrICgyIGxldmVscykgaW4gYWRkaXRpb25hbCIsImRlZmluZV9ub2RlIiwiZW52IiwiRFNMRW52aXJvbm1lbnQiLCJuZXciLCJpbnN0YW5jZV9ldmFsIiwiYmxvY2siLCJ0b19wcm9jIiwiQ2xhc3MiLCJibG9jayBpbiBkZWZpbmVfbm9kZSIsImJsb2NrICgyIGxldmVscykgaW4gZGVmaW5lX25vZGUiLCJwcmltYXJ5X2ZpZWxkcyIsImF0dHJfYWNjZXNzb3IiLCJhZGRpdGlvbmFsX2ZpZWxkcyIsImRlZmluZV9tZXRob2QiLCJibG9jayAoMyBsZXZlbHMpIGluIGRlZmluZV9ub2RlIiwiYXJncyIsInNpemUiLCJBcmd1bWVudEVycm9yIiwicHJlc2VudF9maWVsZHNfbGlzdCIsImVhY2hfd2l0aF9pbmRleCIsInByaW1hcnlfZmllbGRfbmFtZSIsImkiLCJibG9jayAoNCBsZXZlbHMpIGluIGRlZmluZV9ub2RlIiwiaW5zdGFuY2VfdmFyaWFibGVfc2V0IiwiW10iLCJmIiwidmlzaXRvciIsInB1YmxpY19zZW5kIiwidW5kZXJzY29yZSIsImNsYXNzIiwicHJpdmF0ZSIsImZpZWxkcyIsImVtcHR5PyIsIjEiLCJmaXJzdCIsIisiLCJtYXAiLCIwIiwiLTIiLCJibG9jayBpbiBwcmVzZW50X2ZpZWxkc19saXN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcmVzZW50X2ZpZWxkc19saXN0Iiwiam9pbiIsIi0xIiwiY2FtZWxfY2FzZWRfd29yZCIsIndvcmQiLCJzcGxpdCIsImxhc3QiLCJnc3ViIiwiYmxvY2sgaW4gdW5kZXJzY29yZSIsImJsb2NrICgyIGxldmVscykgaW4gdW5kZXJzY29yZSIsIiRyZXRfb3JfMSIsInRyIiwiZG93bmNhc2UiXSwibWFwcGluZ3MiOiJBQUFBQSx5REFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFDRUMsTUFBSUMsSUFBSkQsZUFBQUEsb0JBQWtCRSxJQUFsQkY7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFFLElBQUlDLFFBQUFBLENBQVFGLElBQVJFO01BRE5ILENBQUFBLEdBQUFBO01BSUFJO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VILElBQUFJLGFBQUFBLENBQVksZ0JBQVosRUFBNkIsbUJBQTdCQTs7QUFFQUMs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QixRQUFELEdBQUEsQ0FBU2EsTUFBTVAsT0FBQUEsQ0FBQ2tCLEVBQURsQixDQUFmLENBQUEsR0FBb0JOLEdBQXRCaUI7VUFKaERqQixDQUFBQSxHQUFBQTtVQU9BVCxPQUFBbUIsMEJBQUFBLHNCQUFlZSxnQkFBZmY7QUFBQUEsWUFBQUE7OztZQUNFZ0IsT0FBT0QsZ0JBQWdCRSxPQUFBQSxDQUFPakIsSUFBUGlCLENBQVlDLE1BQUFBLENBQUFBO1lBQ25DRixPQUFXRyxNQUFKSCxJQUFJRyxRQUFBQSxFQUFBQSxDQUFNLDJDQUFOQSxDQUFBQSxFQUFKQyxhQUFBQSxFQUFBQzs7Y0FBeURBLE9BQVdkLFNBQVYsQ0FBQSxRQUFBZSxDQUFBQSxZQUFBLGlEQUFBQSxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQUFNLGlEQUFOLENBQUEsQ0FBVWYsRUFBRWMsR0FBRmQsQ0FBcEVhLENBQUFBLEdBQUlEO1lBQ1hILE9BQU9BLElBQUlPLElBQUFBLENBQUl2QixHQUFSLEVBQWFBLEdBQVR1QjtZQUNYUCxPQUFPQSxJQUFJUSxVQUFBQSxDQUFBQTtZQUNYeEIsT0FBQWdCO1VBTEZoQixDQUFBQSxHQUFBQSxFQTlCRnBCLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFLTDtNQUpQSCxDQUFBQSxHQUFBQTtJQTdCRnJCLEdBQUFBLFdBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzMwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxpYi9hX2xveC9leHByZXNzaW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBBTG94XG4gIG1vZHVsZSBFeHByZXNzaW9uXG4gICAgaW5jbHVkZSBBc3ROb2RlRFNMXG5cbiAgICBBc3NpZ24gPSBkZWZpbmVfbm9kZSBkb1xuICAgICAgbmFtZVxuICAgICAgdmFsdWVcbiAgICAgIGFkZGl0aW9uYWwgOmFsbG9jYXRpb25cbiAgICBlbmRcblxuICAgIFZhcmlhYmxlID0gZGVmaW5lX25vZGUgZG9cbiAgICAgIG5hbWVcbiAgICAgIGFkZGl0aW9uYWwgOmFsbG9jYXRpb25cbiAgICBlbmRcblxuICAgIEJpbmFyeSA9IGRlZmluZV9ub2RlIGRvXG4gICAgICBsZWZ0XG4gICAgICBvcGVyYXRvclxuICAgICAgcmlnaHRcbiAgICBlbmRcblxuICAgIExvZ2ljYWwgPSBkZWZpbmVfbm9kZSBkb1xuICAgICAgbGVmdFxuICAgICAgb3BlcmF0b3JcbiAgICAgIHJpZ2h0XG4gICAgZW5kXG5cbiAgICBVbmFyeSA9IGRlZmluZV9ub2RlIGRvXG4gICAgICBvcGVyYXRvclxuICAgICAgcmlnaHRcbiAgICBlbmRcblxuICAgIEdyb3VwaW5nID0gZGVmaW5lX25vZGUgeyBleHByZXNzaW9uIH1cblxuICAgIExpdGVyYWwgPSBkZWZpbmVfbm9kZSB7IHZhbHVlIH1cblxuICAgIENhbGwgPSBkZWZpbmVfbm9kZSBkb1xuICAgICAgY2FsbGVlXG4gICAgICBwYXJlblxuICAgICAgYXJndW1lbnRzXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QUxveD4iLCI8bW9kdWxlOkV4cHJlc3Npb24+Iiwic2VsZiIsImluY2x1ZGUiLCJBc3ROb2RlRFNMIiwiZGVmaW5lX25vZGUiLCJibG9jayBpbiA8bW9kdWxlOkV4cHJlc3Npb24+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8bW9kdWxlOkV4cHJlc3Npb24+IiwibmFtZSIsInZhbHVlIiwiYWRkaXRpb25hbCIsImxlZnQiLCJvcGVyYXRvciIsInJpZ2h0IiwiZXhwcmVzc2lvbiIsImNhbGxlZSIsInBhcmVuIiwiYXJndW1lbnRzIl0sIm1hcHBpbmdzIjoiQUFBQUEsdURBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLGdCQUFSRDtNQUVBLGtDQUFTRSxNQUFBSCxJQUFBRyxlQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyx1QkFBQUEsRUFBQUM7OztRQUNQTCxJQUFBTSxNQUFBQSxDQUFBQTtRQUNBTixJQUFBTyxPQUFBQSxDQUFBQTtRQUNBRixPQUFBTCxJQUFBUSxZQUFBQSxDQUFXLFlBQVhBLEVBSE9KLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRCxDQUFUO01BTUEsb0NBQVdBLE1BQUFILElBQUFHLGVBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLHVCQUFBQSxFQUFBQzs7O1FBQ1RMLElBQUFNLE1BQUFBLENBQUFBO1FBQ0FELE9BQUFMLElBQUFRLFlBQUFBLENBQVcsWUFBWEEsRUFGU0osQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFELENBQVg7TUFLQSxrQ0FBU0EsTUFBQUgsSUFBQUcsZUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsdUJBQUFBLEVBQUFDOzs7UUFDUEwsSUFBQVMsTUFBQUEsQ0FBQUE7UUFDQVQsSUFBQVUsVUFBQUEsQ0FBQUE7UUFDQUwsT0FBQUwsSUFBQVcsT0FBQUEsQ0FBQUEsRUFIT1AsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFELENBQVQ7TUFNQSxtQ0FBVUEsTUFBQUgsSUFBQUcsZUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsdUJBQUFBLEVBQUFDOzs7UUFDUkwsSUFBQVMsTUFBQUEsQ0FBQUE7UUFDQVQsSUFBQVUsVUFBQUEsQ0FBQUE7UUFDQUwsT0FBQUwsSUFBQVcsT0FBQUEsQ0FBQUEsRUFIUVAsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFELENBQVY7TUFNQSxpQ0FBUUEsTUFBQUgsSUFBQUcsZUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsdUJBQUFBLEVBQUFDOzs7UUFDTkwsSUFBQVUsVUFBQUEsQ0FBQUE7UUFDQUwsT0FBQUwsSUFBQVcsT0FBQUEsQ0FBQUEsRUFGTVAsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFELENBQVI7TUFLQSxvQ0FBV0EsTUFBQUgsSUFBQUcsZUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsdUJBQUFBLEVBQUFDOztRQUFjQSxPQUFBTCxJQUFBWSxZQUFBQSxDQUFBQSxDQUFkUixDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQUQsQ0FBWDtNQUVBLG1DQUFVQSxNQUFBSCxJQUFBRyxlQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyx1QkFBQUEsRUFBQUM7O1FBQWNBLE9BQUFMLElBQUFPLE9BQUFBLENBQUFBLENBQWRILENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRCxDQUFWO01BRUFKLE9BQUEsZ0NBQU9JLE1BQUFILElBQUFHLGVBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLHVCQUFBQSxFQUFBQzs7O1FBQ0xMLElBQUFhLFFBQUFBLENBQUFBO1FBQ0FiLElBQUFjLE9BQUFBLENBQUFBO1FBQ0FULE9BQUFMLElBQUFlLFdBQUFBLENBQUFBLEVBSEtYLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRCxDQUFQO0lBbkNGSixHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjczNjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsaWIvYV9sb3gvc3RhdGVtZW50LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBBTG94XG4gIG1vZHVsZSBTdGF0ZW1lbnRcbiAgICBpbmNsdWRlIEFzdE5vZGVEU0xcblxuICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSBkZWZpbmVfbm9kZSBkb1xuICAgICAgZXhwcmVzc2lvblxuICAgIGVuZFxuXG4gICAgRnVuY3Rpb25TdGF0ZW1lbnQgPSBkZWZpbmVfbm9kZSBkb1xuICAgICAgbmFtZVxuICAgICAgcGFyYW1ldGVyc1xuICAgICAgYm9keVxuICAgICAgYWRkaXRpb25hbCA6YWxsb2NhdGlvbiwgOmZ1bGxfbmFtZSwgOnVwdmFsdWVzXG4gICAgZW5kXG5cbiAgICBSZXR1cm5TdGF0ZW1lbnQgPSBkZWZpbmVfbm9kZSBkb1xuICAgICAga2V5d29yZFxuICAgICAgdmFsdWVcbiAgICBlbmRcblxuICAgIFByaW50U3RhdGVtZW50ID0gZGVmaW5lX25vZGUgeyBleHByZXNzaW9uIH1cblxuICAgIFZhclN0YXRlbWVudCA9IGRlZmluZV9ub2RlIGRvXG4gICAgICBuYW1lXG4gICAgICBpbml0aWFsaXplclxuICAgICAgYWRkaXRpb25hbCA6YWxsb2NhdGlvblxuICAgIGVuZFxuXG4gICAgQmxvY2tTdGF0ZW1lbnQgPSBkZWZpbmVfbm9kZSBkb1xuICAgICAgc3RhdGVtZW50c1xuICAgICAgYWRkaXRpb25hbCA6bG9jYWxzXG4gICAgZW5kXG5cbiAgICBJZlN0YXRlbWVudCA9IGRlZmluZV9ub2RlIGRvXG4gICAgICBjb25kaXRpb25cbiAgICAgIHRoZW5fYnJhbmNoXG4gICAgICBlbHNlX2JyYW5jaFxuICAgIGVuZFxuXG4gICAgV2hpbGVTdGF0ZW1lbnQgPSBkZWZpbmVfbm9kZSBkb1xuICAgICAgY29uZGl0aW9uXG4gICAgICBib2R5XG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QUxveD4iLCI8bW9kdWxlOlN0YXRlbWVudD4iLCJzZWxmIiwiaW5jbHVkZSIsIkFzdE5vZGVEU0wiLCJkZWZpbmVfbm9kZSIsImJsb2NrIGluIDxtb2R1bGU6U3RhdGVtZW50PiIsImJsb2NrICgyIGxldmVscykgaW4gPG1vZHVsZTpTdGF0ZW1lbnQ+IiwiZXhwcmVzc2lvbiIsIm5hbWUiLCJwYXJhbWV0ZXJzIiwiYm9keSIsImFkZGl0aW9uYWwiLCJrZXl3b3JkIiwidmFsdWUiLCJpbml0aWFsaXplciIsInN0YXRlbWVudHMiLCJjb25kaXRpb24iLCJ0aGVuX2JyYW5jaCIsImVsc2VfYnJhbmNoIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0RBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLGdCQUFSRDtNQUVBLCtDQUFzQkUsTUFBQUgsSUFBQUcsZUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsc0JBQUFBLEVBQUFDOztRQUNwQkEsT0FBQUwsSUFBQU0sWUFBQUEsQ0FBQUEsQ0FEb0JGLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRCxDQUF0QjtNQUlBLDZDQUFvQkEsTUFBQUgsSUFBQUcsZUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsc0JBQUFBLEVBQUFDOzs7UUFDbEJMLElBQUFPLE1BQUFBLENBQUFBO1FBQ0FQLElBQUFRLFlBQUFBLENBQUFBO1FBQ0FSLElBQUFTLE1BQUFBLENBQUFBO1FBQ0FKLE9BQUFMLElBQUFVLFlBQUFBLENBQVcsWUFBWCxFQUF3QixXQUF4QixFQUFvQyxVQUFwQ0EsRUFKa0JOLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRCxDQUFwQjtNQU9BLDJDQUFrQkEsTUFBQUgsSUFBQUcsZUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsc0JBQUFBLEVBQUFDOzs7UUFDaEJMLElBQUFXLFNBQUFBLENBQUFBO1FBQ0FOLE9BQUFMLElBQUFZLE9BQUFBLENBQUFBLEVBRmdCUixDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQUQsQ0FBbEI7TUFLQSwwQ0FBaUJBLE1BQUFILElBQUFHLGVBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLHNCQUFBQSxFQUFBQzs7UUFBY0EsT0FBQUwsSUFBQU0sWUFBQUEsQ0FBQUEsQ0FBZEYsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFELENBQWpCO01BRUEsd0NBQWVBLE1BQUFILElBQUFHLGVBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLHNCQUFBQSxFQUFBQzs7O1FBQ2JMLElBQUFPLE1BQUFBLENBQUFBO1FBQ0FQLElBQUFhLGFBQUFBLENBQUFBO1FBQ0FSLE9BQUFMLElBQUFVLFlBQUFBLENBQVcsWUFBWEEsRUFIYU4sQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFELENBQWY7TUFNQSwwQ0FBaUJBLE1BQUFILElBQUFHLGVBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLHNCQUFBQSxFQUFBQzs7O1FBQ2ZMLElBQUFjLFlBQUFBLENBQUFBO1FBQ0FULE9BQUFMLElBQUFVLFlBQUFBLENBQVcsUUFBWEEsRUFGZU4sQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFELENBQWpCO01BS0EsdUNBQWNBLE1BQUFILElBQUFHLGVBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLHNCQUFBQSxFQUFBQzs7O1FBQ1pMLElBQUFlLFdBQUFBLENBQUFBO1FBQ0FmLElBQUFnQixhQUFBQSxDQUFBQTtRQUNBWCxPQUFBTCxJQUFBaUIsYUFBQUEsQ0FBQUEsRUFIWWIsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFELENBQWQ7TUFNQUosT0FBQSwwQ0FBaUJJLE1BQUFILElBQUFHLGVBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLHNCQUFBQSxFQUFBQzs7O1FBQ2ZMLElBQUFlLFdBQUFBLENBQUFBO1FBQ0FWLE9BQUFMLElBQUFTLE1BQUFBLENBQUFBLEVBRmVMLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRCxDQUFqQjtJQXRDRkosR0FBQUEsV0FBQUE7RUFERkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NDI0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibGliL2FfbG94L3BhcnNlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQUxveFxuICBjbGFzcyBQYXJzZXJcbiAgICBpbmNsdWRlIFRva2VuVHlwZXNcbiAgICBpbmNsdWRlIEV4cHJlc3Npb25cbiAgICBpbmNsdWRlIFN0YXRlbWVudFxuXG4gICAgY2xhc3MgUGFyc2VyRXJyb3IgPCBSdW50aW1lRXJyb3I7IGVuZFxuXG4gICAgZGVmIGluaXRpYWxpemUodG9rZW5zLCBlcnJvcl9yZXBvcnRlcjogbmlsKVxuICAgICAgQHRva2VucyA9IHRva2Vuc1xuICAgICAgQGN1cnJlbnQgPSAwXG4gICAgICBAZXJyb3JfcmVwb3J0ZXIgPSBlcnJvcl9yZXBvcnRlclxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlXG4gICAgICBzdGF0ZW1lbnRzID0gW11cbiAgICAgIHN0YXRlbWVudHMgPDwgcGFyc2VfdG9wbGV2ZWxfc3RhdGVtZW50IHdoaWxlIGhhc19tb3JlP1xuXG4gICAgICBzdGF0ZW1lbnRzXG4gICAgZW5kXG5cbiAgICBkZWYgcGFyc2VfdG9wbGV2ZWxfc3RhdGVtZW50XG4gICAgICBpZiBtYXRjaF9hbnk/KFZBUilcbiAgICAgICAgcGFyc2VfdmFyaWFibGVfZGVjbGFyYXRpb25cbiAgICAgIGVsc2lmIG1hdGNoX2FueT8oRlVOKVxuICAgICAgICBwYXJzZV9mdW5jdGlvbl9kZWNsYXJhdGlvbig6ZnVuY3Rpb24pXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnNlX3N0YXRlbWVudFxuICAgICAgZW5kXG4gICAgcmVzY3VlIFBhcnNlckVycm9yXG4gICAgICBzeW5jaHJvbml6ZVxuICAgICAgbmlsXG4gICAgZW5kXG5cbiAgICBkZWYgcGFyc2VfdmFyaWFibGVfZGVjbGFyYXRpb25cbiAgICAgIG5hbWUgPSBjb25zdW1lKElERU5USUZJRVIsIFwiRXhwZWN0ZWQgdmFyaWFibGUgbmFtZVwiKVxuXG4gICAgICBpZiBtYXRjaF9hbnk/KEVRVUFMKVxuICAgICAgICBpbml0aWFsaXplciA9IHBhcnNlX2V4cHJlc3Npb25cbiAgICAgIGVuZFxuXG4gICAgICBjb25zdW1lKFNFTUlDT0xPTiwgXCJFeHBlY3RlZCA7IGFmdGVyIHZhcmlhYmxlIGRlY2xhcmF0aW9uXCIpXG5cbiAgICAgIFZhclN0YXRlbWVudC5uZXcobmFtZSwgaW5pdGlhbGl6ZXIpXG4gICAgZW5kXG5cbiAgICBkZWYgcGFyc2VfZnVuY3Rpb25fZGVjbGFyYXRpb24oa2luZClcbiAgICAgIG5hbWUgPSBjb25zdW1lKElERU5USUZJRVIsIFwiRXhwZWN0ZWQgI3traW5kfSBuYW1lXCIpXG4gICAgICBjb25zdW1lKExFRlRfUEFSRU4sIFwiRXhwZWN0ZWQgKCBhZnRlciAje2tpbmR9IG5hbWVcIilcblxuICAgICAgcGFyYW1ldGVycyA9IFtdXG5cbiAgICAgIGlmICFjaGVjayhSSUdIVF9QQVJFTilcbiAgICAgICAgbG9vcCBkb1xuICAgICAgICAgIGlmIHBhcmFtZXRlcnMuc2l6ZSA+IDI1NVxuICAgICAgICAgICAgZXJyb3IocGVlaywgXCJFeHBlY3RlZCBmdW5jdGlvbiB0byBoYXZlIGZld2VyIHRoYW4gMjU1IHBhcmFtZXRlcnNcIilcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIHBhcmFtZXRlcnMgPDwgY29uc3VtZShJREVOVElGSUVSLCBcIkV4cGVjdGVkIHBhcmFtZXRlciBuYW1lXCIpXG4gICAgICAgICAgYnJlYWsgdW5sZXNzIG1hdGNoX2FueT8oQ09NTUEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIGNvbnN1bWUoUklHSFRfUEFSRU4sIFwiRXhwZWN0ZWQgKSBhZnRlciAje2tpbmR9IHBhcmFtZXRlciBsaXN0XCIpXG4gICAgICBjb25zdW1lKExFRlRfQlJBQ0UsIFwiRXhwZWN0ZWQgeyBiZWZvcmUgI3traW5kfSBib2R5XCIpXG5cbiAgICAgIGJvZHkgPSBwYXJzZV9ibG9ja19zdGF0ZW1lbnRcblxuICAgICAgRnVuY3Rpb25TdGF0ZW1lbnQubmV3KG5hbWUsIHBhcmFtZXRlcnMsIGJvZHkpXG4gICAgZW5kXG5cbiAgICBkZWYgcGFyc2Vfc3RhdGVtZW50XG4gICAgICBpZiBtYXRjaF9hbnk/KFBSSU5UKSB0aGVuIHBhcnNlX3ByaW50X3N0YXRlbWVudFxuICAgICAgZWxzaWYgbWF0Y2hfYW55PyhMRUZUX0JSQUNFKSB0aGVuIEJsb2NrU3RhdGVtZW50Lm5ldyhwYXJzZV9ibG9ja19zdGF0ZW1lbnQpXG4gICAgICBlbHNpZiBtYXRjaF9hbnk/KElGKSB0aGVuIHBhcnNlX2lmXG4gICAgICBlbHNpZiBtYXRjaF9hbnk/KFdISUxFKSB0aGVuIHBhcnNlX3doaWxlXG4gICAgICBlbHNpZiBtYXRjaF9hbnk/KEZPUikgdGhlbiBwYXJzZV9mb3JcbiAgICAgIGVsc2lmIG1hdGNoX2FueT8oUkVUVVJOKSB0aGVuIHBhcnNlX3JldHVyblxuICAgICAgZWxzZVxuICAgICAgICBwYXJzZV9leHByZXNzaW9uX3N0YXRlbWVudFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgcGFyc2VfaWZcbiAgICAgIGNvbnN1bWUoTEVGVF9QQVJFTiwgXCJFeHBlY3RlZCAoIGJlZm9yZSBpZiBjb25kaXRpb25cIilcbiAgICAgIGNvbmRpdGlvbiA9IHBhcnNlX2V4cHJlc3Npb25cbiAgICAgIGNvbnN1bWUoUklHSFRfUEFSRU4sIFwiRXhwZWN0ZWQgKSBhZnRlciBpZiBjb25kaXRpb25cIilcblxuICAgICAgdGhlbl9icmFuY2ggPSBwYXJzZV9zdGF0ZW1lbnRcblxuICAgICAgaWYgbWF0Y2hfYW55PyhFTFNFKVxuICAgICAgICBlbHNlX2JyYW5jaCA9IHBhcnNlX3N0YXRlbWVudFxuICAgICAgZW5kXG5cbiAgICAgIElmU3RhdGVtZW50Lm5ldyhjb25kaXRpb24sIHRoZW5fYnJhbmNoLCBlbHNlX2JyYW5jaClcbiAgICBlbmRcblxuICAgIGRlZiBwYXJzZV93aGlsZVxuICAgICAgY29uc3VtZShMRUZUX1BBUkVOLCBcIkV4cGVjdGVkICggYmVmb3JlIHdoaWxlIGNvbmRpdGlvblwiKVxuICAgICAgY29uZGl0aW9uID0gcGFyc2VfZXhwcmVzc2lvblxuICAgICAgY29uc3VtZShSSUdIVF9QQVJFTiwgXCJFeHBlY3RlZCApIGFmdGVyIHdoaWxlIGNvbmRpdGlvblwiKVxuXG4gICAgICBib2R5ID0gcGFyc2Vfc3RhdGVtZW50XG5cbiAgICAgIFdoaWxlU3RhdGVtZW50Lm5ldyhjb25kaXRpb24sIGJvZHkpXG4gICAgZW5kXG5cbiAgICBkZWYgcGFyc2VfZm9yXG4gICAgICBjb25zdW1lKExFRlRfUEFSRU4sIFwiRXhwZWN0ZWQgKCBhZnRlciBmb3JcIilcblxuICAgICAgaW5pdGlhbGl6ZXIgPSBpZiBtYXRjaF9hbnk/KFNFTUlDT0xPTilcbiAgICAgICAgbmlsXG4gICAgICBlbHNpZiBtYXRjaF9hbnk/KFZBUilcbiAgICAgICAgcGFyc2VfdmFyaWFibGVfZGVjbGFyYXRpb25cbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfZXhwcmVzc2lvbl9zdGF0ZW1lbnRcbiAgICAgIGVuZFxuXG4gICAgICBpZiAhY2hlY2soU0VNSUNPTE9OKVxuICAgICAgICBjb25kaXRpb24gPSBwYXJzZV9leHByZXNzaW9uXG4gICAgICBlbmRcblxuICAgICAgY29uc3VtZShTRU1JQ09MT04sIFwiRXhwZWN0ZWQgOyBhZnRlciBmb3IgY29uZGl0aW9uXCIpXG5cbiAgICAgIGlmICFjaGVjayhSSUdIVF9QQVJFTilcbiAgICAgICAgaW5jcmVtZW50ID0gRXhwcmVzc2lvblN0YXRlbWVudC5uZXcocGFyc2VfZXhwcmVzc2lvbilcbiAgICAgIGVuZFxuXG4gICAgICBjb25zdW1lKFJJR0hUX1BBUkVOLCBcIkV4cGVjdGVkICkgYWZ0ZXIgZm9yIGNsYXVzZXNcIilcblxuICAgICAgYm9keSA9IHBhcnNlX3N0YXRlbWVudFxuXG4gICAgICBpZiAhaW5jcmVtZW50Lm5pbD9cbiAgICAgICAgYm9keSA9IEJsb2NrU3RhdGVtZW50Lm5ldyhbYm9keSwgaW5jcmVtZW50XSlcbiAgICAgIGVuZFxuXG4gICAgICBib2R5ID0gV2hpbGVTdGF0ZW1lbnQubmV3KGNvbmRpdGlvbiB8fCBMaXRlcmFsLm5ldyh0cnVlKSwgYm9keSlcblxuICAgICAgaWYgaW5pdGlhbGl6ZXJcbiAgICAgICAgYm9keSA9IEJsb2NrU3RhdGVtZW50Lm5ldyhbaW5pdGlhbGl6ZXIsIGJvZHldKVxuICAgICAgZW5kXG5cbiAgICAgIGJvZHlcbiAgICBlbmRcblxuICAgIGRlZiBwYXJzZV9yZXR1cm5cbiAgICAgIGtleXdvcmQgPSBwcmV2aW91c1xuXG4gICAgICB2YWx1ZSA9XG4gICAgICAgIGlmICFjaGVjayhTRU1JQ09MT04pXG4gICAgICAgICAgcGFyc2VfZXhwcmVzc2lvblxuICAgICAgICBlbmRcblxuICAgICAgY29uc3VtZShTRU1JQ09MT04sIFwiRXhwZWN0ZWQgc2VtaWNvbG9uIGFmdGVyIHJldHVyblwiKVxuXG4gICAgICBSZXR1cm5TdGF0ZW1lbnQubmV3KGtleXdvcmQsIHZhbHVlKVxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX3ByaW50X3N0YXRlbWVudFxuICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlX2V4cHJlc3Npb25cbiAgICAgIGNvbnN1bWUoU0VNSUNPTE9OLCBcIkV4cGVjdGVkIDsgYWZ0ZXIgZXhwcmVzc2lvblwiKVxuXG4gICAgICBQcmludFN0YXRlbWVudC5uZXcoZXhwcmVzc2lvbilcbiAgICBlbmRcblxuICAgIGRlZiBwYXJzZV9ibG9ja19zdGF0ZW1lbnRcbiAgICAgIHN0YXRlbWVudHMgPSBbXVxuXG4gICAgICB3aGlsZSAhY2hlY2soUklHSFRfQlJBQ0UpICYmIGhhc19tb3JlP1xuICAgICAgICBzdGF0ZW1lbnRzIDw8IHBhcnNlX3RvcGxldmVsX3N0YXRlbWVudFxuICAgICAgZW5kXG5cbiAgICAgIGNvbnN1bWUoUklHSFRfQlJBQ0UsIFwiRXhwZWN0ZWQgfSBhdCBlbmQgb2YgYmxvY2tcIilcblxuICAgICAgc3RhdGVtZW50c1xuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX2V4cHJlc3Npb25fc3RhdGVtZW50XG4gICAgICBleHByZXNzaW9uID0gcGFyc2VfZXhwcmVzc2lvblxuICAgICAgY29uc3VtZShTRU1JQ09MT04sIFwiRXhwZWN0ZWQgOyBhZnRlciBleHByZXNzaW9uXCIpXG5cbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQubmV3KGV4cHJlc3Npb24pXG4gICAgZW5kXG5cbiAgICBkZWYgcGFyc2VfZXhwcmVzc2lvblxuICAgICAgcGFyc2VfYXNzaWdubWVudFxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX2Fzc2lnbm1lbnRcbiAgICAgIGV4cHJlc3Npb24gPSBwYXJzZV9vclxuXG4gICAgICBpZiBtYXRjaF9hbnk/KEVRVUFMKVxuICAgICAgICBlcXVhbCA9IHByZXZpb3VzXG5cbiAgICAgICAgaWYgZXhwcmVzc2lvbi5pc19hPyBWYXJpYWJsZVxuICAgICAgICAgIG5hbWUgPSBleHByZXNzaW9uLm5hbWVcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlX2V4cHJlc3Npb25cbiAgICAgICAgICByZXR1cm4gQXNzaWduLm5ldyhuYW1lLCB2YWx1ZSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVycm9yKGVxdWFsLCBcIkV4cGVjdGVkIHZhcmlhYmxlIG5hbWUgb24gbGVmdCBzaWRlIG9mIGFzc2lnbm1lbnRcIilcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgZXhwcmVzc2lvblxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX29yXG4gICAgICBleHByZXNzaW9uID0gcGFyc2VfYW5kXG5cbiAgICAgIHdoaWxlIG1hdGNoX2FueT8oT1IpXG4gICAgICAgIG9wZXJhdG9yID0gcHJldmlvdXNcbiAgICAgICAgcmlnaHQgPSBwYXJzZV9hbmRcbiAgICAgICAgZXhwcmVzc2lvbiA9IExvZ2ljYWwubmV3KGV4cHJlc3Npb24sIG9wZXJhdG9yLCByaWdodClcbiAgICAgIGVuZFxuXG4gICAgICBleHByZXNzaW9uXG4gICAgZW5kXG5cbiAgICBkZWYgcGFyc2VfYW5kXG4gICAgICBleHByZXNzaW9uID0gcGFyc2VfZXF1YWxpdHlcblxuICAgICAgd2hpbGUgbWF0Y2hfYW55PyhBTkQpXG4gICAgICAgIG9wZXJhdG9yID0gcHJldmlvdXNcbiAgICAgICAgcmlnaHQgPSBwYXJzZV9lcXVhbGl0eVxuICAgICAgICBleHByZXNzaW9uID0gTG9naWNhbC5uZXcoZXhwcmVzc2lvbiwgb3BlcmF0b3IsIHJpZ2h0KVxuICAgICAgZW5kXG5cbiAgICAgIGV4cHJlc3Npb25cbiAgICBlbmRcblxuICAgIGRlZiBwYXJzZV9lcXVhbGl0eVxuICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlX2NvbXBhcmlzb25cblxuICAgICAgd2hpbGUgbWF0Y2hfYW55PyhCQU5HX0VRVUFMLCBFUVVBTF9FUVVBTClcbiAgICAgICAgb3BlcmF0b3IgPSBwcmV2aW91c1xuICAgICAgICByaWdodF9leHByZXNzaW9uID0gcGFyc2VfY29tcGFyaXNvblxuXG4gICAgICAgIGV4cHJlc3Npb24gPSBCaW5hcnkubmV3KFxuICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgcmlnaHRfZXhwcmVzc2lvblxuICAgICAgICApXG4gICAgICBlbmRcblxuICAgICAgZXhwcmVzc2lvblxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX2NvbXBhcmlzb25cbiAgICAgIGV4cHJlc3Npb24gPSBwYXJzZV90ZXJtXG5cbiAgICAgIHdoaWxlIG1hdGNoX2FueT8oR1JFQVRFUiwgR1JFQVRFUl9FUVVBTCwgTEVTUywgTEVTU19FUVVBTClcbiAgICAgICAgb3BlcmF0b3IgPSBwcmV2aW91c1xuICAgICAgICByaWdodF9leHByZXNzaW9uID0gcGFyc2VfdGVybVxuXG4gICAgICAgIGV4cHJlc3Npb24gPSBCaW5hcnkubmV3KFxuICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgcmlnaHRfZXhwcmVzc2lvblxuICAgICAgICApXG4gICAgICBlbmRcblxuICAgICAgZXhwcmVzc2lvblxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX3Rlcm1cbiAgICAgIGV4cHJlc3Npb24gPSBwYXJzZV9mYWN0b3JcblxuICAgICAgd2hpbGUgbWF0Y2hfYW55PyhQTFVTLCBNSU5VUylcbiAgICAgICAgb3BlcmF0b3IgPSBwcmV2aW91c1xuICAgICAgICByaWdodF9leHByZXNzaW9uID0gcGFyc2VfZmFjdG9yXG5cbiAgICAgICAgZXhwcmVzc2lvbiA9IEJpbmFyeS5uZXcoXG4gICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICByaWdodF9leHByZXNzaW9uXG4gICAgICAgIClcbiAgICAgIGVuZFxuXG4gICAgICBleHByZXNzaW9uXG4gICAgZW5kXG5cbiAgICBkZWYgcGFyc2VfZmFjdG9yXG4gICAgICBleHByZXNzaW9uID0gcGFyc2VfdW5hcnlcblxuICAgICAgd2hpbGUgbWF0Y2hfYW55PyhTVEFSLCBTTEFTSClcbiAgICAgICAgb3BlcmF0b3IgPSBwcmV2aW91c1xuICAgICAgICByaWdodF9leHByZXNzaW9uID0gcGFyc2VfdW5hcnlcblxuICAgICAgICBleHByZXNzaW9uID0gQmluYXJ5Lm5ldyhcbiAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgIHJpZ2h0X2V4cHJlc3Npb25cbiAgICAgICAgKVxuICAgICAgZW5kXG5cbiAgICAgIGV4cHJlc3Npb25cbiAgICBlbmRcblxuICAgIGRlZiBwYXJzZV91bmFyeVxuICAgICAgaWYgbWF0Y2hfYW55PyhCQU5HLCBNSU5VUylcbiAgICAgICAgb3BlcmF0b3IgPSBwcmV2aW91c1xuICAgICAgICByaWdodCA9IHBhcnNlX3VuYXJ5XG5cbiAgICAgICAgcmV0dXJuIFVuYXJ5Lm5ldyhvcGVyYXRvciwgcmlnaHQpXG4gICAgICBlbmRcblxuICAgICAgcGFyc2VfY2FsbFxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX2NhbGxcbiAgICAgIGV4cHJlc3Npb24gPSBwYXJzZV9wcmltYXJ5XG5cbiAgICAgIGxvb3AgZG9cbiAgICAgICAgaWYgbWF0Y2hfYW55PyhMRUZUX1BBUkVOKVxuICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZV9maW5pc2hfY2FsbChleHByZXNzaW9uKVxuICAgICAgICBlbHNpZiBtYXRjaF9hbnk/KERPVClcbiAgICAgICAgICBuYW1lID0gY29uc3VtZShJREVOVElGSUVSLCBcIkV4cGVjdGVkIGlkZW50aWZpZXIgYWZ0ZXIgLlwiKVxuICAgICAgICAgIGV4cHJlc3Npb24gPSBHZXRFeHByZXNzaW9uLm5ldyhleHByZXNzaW9uLCBuYW1lKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgZXhwcmVzc2lvblxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX2ZpbmlzaF9jYWxsKGNhbGxlZSlcbiAgICAgIGFyZ3VtZW50cyA9IFtdXG5cbiAgICAgIGlmICFjaGVjayhSSUdIVF9QQVJFTilcbiAgICAgICAgbG9vcCBkb1xuICAgICAgICAgIGlmIGFyZ3VtZW50cy5jb3VudCA+IDI1NVxuICAgICAgICAgICAgZXJyb3IocGVlaywgXCJDYW4ndCBoYXZlIG1vcmUgdGhhbiAyNTUgYXJndW1lbnRzXCIpXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICBhcmd1bWVudHMgPDwgcGFyc2VfZXhwcmVzc2lvblxuXG4gICAgICAgICAgYnJlYWsgdW5sZXNzIG1hdGNoX2FueT8oQ09NTUEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIGNsb3NlX3BhcmVuID0gY29uc3VtZShSSUdIVF9QQVJFTiwgXCJFeHBlY3RlZCApIGFmdGVyIGFyZ3VtZW50IGxpc3RcIilcblxuICAgICAgQ2FsbC5uZXcoY2FsbGVlLCBjbG9zZV9wYXJlbiwgYXJndW1lbnRzKVxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX3ByaW1hcnlcbiAgICAgIGlmIG1hdGNoX2FueT8oTlVNQkVSLCBTVFJJTkcpIHRoZW4gcmV0dXJuIExpdGVyYWwubmV3KHByZXZpb3VzLmxpdGVyYWwpIGVuZFxuICAgICAgaWYgbWF0Y2hfYW55PyhGQUxTRV9UT0tFTikgdGhlbiByZXR1cm4gTGl0ZXJhbC5uZXcoZmFsc2UpIGVuZFxuICAgICAgaWYgbWF0Y2hfYW55PyhUUlVFX1RPS0VOKSB0aGVuIHJldHVybiBMaXRlcmFsLm5ldyh0cnVlKSBlbmRcbiAgICAgIGlmIG1hdGNoX2FueT8oTklMX1RPS0VOKSB0aGVuIHJldHVybiBMaXRlcmFsLm5ldyhuaWwpIGVuZFxuICAgICAgaWYgbWF0Y2hfYW55PyhJREVOVElGSUVSKSB0aGVuIHJldHVybiBWYXJpYWJsZS5uZXcocHJldmlvdXMpIGVuZFxuXG4gICAgICBpZiBtYXRjaF9hbnk/KExFRlRfUEFSRU4pXG4gICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZV9leHByZXNzaW9uXG4gICAgICAgIGNvbnN1bWUoUklHSFRfUEFSRU4sIFwiRXhwZWN0ZWQgJyknIGFmdGVyIGV4cHJlc3Npb25cIilcbiAgICAgICAgcmV0dXJuIEdyb3VwaW5nLm5ldyhleHByZXNzaW9uKVxuICAgICAgZW5kXG5cbiAgICAgIHJhaXNlIGVycm9yKHBlZWssIFwiRXhwZWN0ZWQgZXhwcmVzc2lvblwiKVxuICAgIGVuZFxuXG4gICAgZGVmIG1hdGNoX2FueT8oKnRva2VuX3R5cGVzKVxuICAgICAgdG9rZW5fdHlwZXMuZWFjaCBkbyB8dG9rZW5fdHlwZXxcbiAgICAgICAgaWYgY2hlY2sodG9rZW5fdHlwZSlcbiAgICAgICAgICBhZHZhbmNlXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgZmFsc2VcbiAgICBlbmRcblxuICAgIGRlZiBjaGVjayh0b2tlbl90eXBlKVxuICAgICAgcmV0dXJuIGZhbHNlIGlmIGF0X2VuZD9cbiAgICAgIHBlZWsudHlwZSA9PSB0b2tlbl90eXBlXG4gICAgZW5kXG5cbiAgICBkZWYgcGVla1xuICAgICAgQHRva2Vuc1tAY3VycmVudF1cbiAgICBlbmRcblxuICAgIGRlZiBwcmV2aW91c1xuICAgICAgQHRva2Vuc1tAY3VycmVudCAtIDFdXG4gICAgZW5kXG5cbiAgICBkZWYgYWR2YW5jZVxuICAgICAgQGN1cnJlbnQgKz0gMSBpZiBoYXNfbW9yZT9cbiAgICAgIHByZXZpb3VzXG4gICAgZW5kXG5cbiAgICBkZWYgY29uc3VtZSh0b2tlbl90eXBlLCBtZXNzYWdlKVxuICAgICAgaWYgY2hlY2sodG9rZW5fdHlwZSlcbiAgICAgICAgYWR2YW5jZVxuICAgICAgZWxzZVxuICAgICAgICByYWlzZSBlcnJvcihwZWVrLCBtZXNzYWdlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZXJyb3IodG9rZW4sIG1lc3NhZ2UpXG4gICAgICBAZXJyb3JfcmVwb3J0ZXImLnJlcG9ydF9wYXJzZXJfZXJyb3IodG9rZW4sIG1lc3NhZ2UpXG4gICAgICBQYXJzZXJFcnJvci5uZXdcbiAgICBlbmRcblxuICAgIGRlZiBzeW5jaHJvbml6ZVxuICAgICAgYWR2YW5jZVxuICAgICAgd2hpbGUgaGFzX21vcmU/XG4gICAgICAgIHJldHVybiBpZiBwcmV2aW91cy50eXBlID09IFNFTUlDT0xPTlxuICAgICAgICByZXR1cm4gaWYgW0ZPUiwgRlVOLCBJRiwgUFJJTlQsIFJFVFVSTiwgVkFSLCBXSElMRV0uaW5jbHVkZT8gcGVlay50eXBlXG5cbiAgICAgICAgYWR2YW5jZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgYXRfZW5kP1xuICAgICAgcGVlay50eXBlID09IEVPRlxuICAgIGVuZFxuXG4gICAgZGVmIGhhc19tb3JlP1xuICAgICAgIWF0X2VuZD9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpBTG94PiIsIjxjbGFzczpQYXJzZXI+Iiwic2VsZiIsImluY2x1ZGUiLCJUb2tlblR5cGVzIiwiRXhwcmVzc2lvbiIsIlN0YXRlbWVudCIsIjxjbGFzczpQYXJzZXJFcnJvcj4iLCJSdW50aW1lRXJyb3IiLCJpbml0aWFsaXplIiwidG9rZW5zIiwiJGt3YXJncyIsIkB0b2tlbnMiLCJAY3VycmVudCIsIjAiLCJAZXJyb3JfcmVwb3J0ZXIiLCJlcnJvcl9yZXBvcnRlciIsInBhcnNlIiwic3RhdGVtZW50cyIsImhhc19tb3JlPyIsIjw8IiwicGFyc2VfdG9wbGV2ZWxfc3RhdGVtZW50IiwibWF0Y2hfYW55PyIsIlZBUiIsInBhcnNlX3ZhcmlhYmxlX2RlY2xhcmF0aW9uIiwiRlVOIiwicGFyc2VfZnVuY3Rpb25fZGVjbGFyYXRpb24iLCJwYXJzZV9zdGF0ZW1lbnQiLCJQYXJzZXJFcnJvciIsInN5bmNocm9uaXplIiwibmFtZSIsImNvbnN1bWUiLCJJREVOVElGSUVSIiwiRVFVQUwiLCJpbml0aWFsaXplciIsInBhcnNlX2V4cHJlc3Npb24iLCJTRU1JQ09MT04iLCJWYXJTdGF0ZW1lbnQiLCJuZXciLCJraW5kIiwiTEVGVF9QQVJFTiIsInBhcmFtZXRlcnMiLCJjaGVjayIsIlJJR0hUX1BBUkVOIiwibG9vcCIsImJsb2NrIGluIHBhcnNlX2Z1bmN0aW9uX2RlY2xhcmF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwYXJzZV9mdW5jdGlvbl9kZWNsYXJhdGlvbiIsIj4iLCJzaXplIiwiMjU1IiwiZXJyb3IiLCJwZWVrIiwiQ09NTUEiLCJMRUZUX0JSQUNFIiwiYm9keSIsInBhcnNlX2Jsb2NrX3N0YXRlbWVudCIsIkZ1bmN0aW9uU3RhdGVtZW50IiwiUFJJTlQiLCJwYXJzZV9wcmludF9zdGF0ZW1lbnQiLCJCbG9ja1N0YXRlbWVudCIsIklGIiwicGFyc2VfaWYiLCJXSElMRSIsInBhcnNlX3doaWxlIiwiRk9SIiwicGFyc2VfZm9yIiwiUkVUVVJOIiwicGFyc2VfcmV0dXJuIiwicGFyc2VfZXhwcmVzc2lvbl9zdGF0ZW1lbnQiLCJjb25kaXRpb24iLCJ0aGVuX2JyYW5jaCIsIkVMU0UiLCJlbHNlX2JyYW5jaCIsIklmU3RhdGVtZW50IiwiV2hpbGVTdGF0ZW1lbnQiLCJpbmNyZW1lbnQiLCJFeHByZXNzaW9uU3RhdGVtZW50IiwibmlsPyIsIiRyZXRfb3JfMSIsIkxpdGVyYWwiLCJrZXl3b3JkIiwicHJldmlvdXMiLCJ2YWx1ZSIsIlJldHVyblN0YXRlbWVudCIsImV4cHJlc3Npb24iLCJQcmludFN0YXRlbWVudCIsIlJJR0hUX0JSQUNFIiwiISIsInBhcnNlX2Fzc2lnbm1lbnQiLCJwYXJzZV9vciIsImVxdWFsIiwiaXNfYT8iLCJWYXJpYWJsZSIsIkFzc2lnbiIsInBhcnNlX2FuZCIsIk9SIiwib3BlcmF0b3IiLCJyaWdodCIsIkxvZ2ljYWwiLCJwYXJzZV9lcXVhbGl0eSIsIkFORCIsInBhcnNlX2NvbXBhcmlzb24iLCJCQU5HX0VRVUFMIiwiRVFVQUxfRVFVQUwiLCJyaWdodF9leHByZXNzaW9uIiwiQmluYXJ5IiwicGFyc2VfdGVybSIsIkdSRUFURVIiLCJHUkVBVEVSX0VRVUFMIiwiTEVTUyIsIkxFU1NfRVFVQUwiLCJwYXJzZV9mYWN0b3IiLCJQTFVTIiwiTUlOVVMiLCJwYXJzZV91bmFyeSIsIlNUQVIiLCJTTEFTSCIsIkJBTkciLCJVbmFyeSIsInBhcnNlX2NhbGwiLCJwYXJzZV9wcmltYXJ5IiwiYmxvY2sgaW4gcGFyc2VfY2FsbCIsImJsb2NrICgyIGxldmVscykgaW4gcGFyc2VfY2FsbCIsInBhcnNlX2ZpbmlzaF9jYWxsIiwiRE9UIiwiR2V0RXhwcmVzc2lvbiIsImNhbGxlZSIsImFyZ3VtZW50cyQiLCJibG9jayBpbiBwYXJzZV9maW5pc2hfY2FsbCIsImJsb2NrICgyIGxldmVscykgaW4gcGFyc2VfZmluaXNoX2NhbGwiLCJjb3VudCIsImNsb3NlX3BhcmVuIiwiQ2FsbCIsIk5VTUJFUiIsIlNUUklORyIsImxpdGVyYWwiLCJGQUxTRV9UT0tFTiIsIlRSVUVfVE9LRU4iLCJOSUxfVE9LRU4iLCJHcm91cGluZyIsInJhaXNlIiwiZWFjaCIsInRva2VuX3R5cGVzIiwiYmxvY2sgaW4gbWF0Y2hfYW55PyIsInRva2VuX3R5cGUiLCJibG9jayAoMiBsZXZlbHMpIGluIG1hdGNoX2FueT8iLCJhZHZhbmNlIiwiYXRfZW5kPyIsInR5cGUiLCI9PSIsIltdIiwiLSIsIjEiLCIrIiwibWVzc2FnZSIsInRva2VuIiwiaW5jbHVkZT8iLCJFT0YiXSwibWFwcGluZ3MiOiJBQUFBQSxtREFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsZ0JBQVJEO01BQ0FELElBQUFDLFNBQUFBLENBQVFFLGdCQUFSRjtNQUNBRCxJQUFBQyxTQUFBQSxDQUFRRyxlQUFSSDtNQUVBSSxPQUFBQSxXQUFBQSxFQUFvQkMsa0JBQXBCRDs7QUFFQUUsTUFBQUEsMEJBQUFBLHNCQUFlQyxNQUFELEVB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dUJBQUFBO0FBQUFBLFFBQUFBOzs7UUFDRTNCLElBQUFnSixTQUFBQSxDQUFBQTtRQUNBLE9BQUEsUUFBTWhKLElBQUFpQixjQUFBQSxDQUFBQSxDQUFOLENBQUE7O1VBQ0UsSUFBQSxNQUFVakIsSUFBQStFLFVBQUFBLENBQUFBLENBQVFtRSxNQUFBQSxDQUFBQSxDQUFsQixFQUEyQmhILGVBQTNCLENBQUE7WUFBQSxPQUFBO1VBQUE7VUFDQSxJQUFBLFFBQVUsQ0FBQzRCLFNBQUQsRUFBTXZDLFNBQU4sRUFBV21DLFFBQVgsRUFBZUgsV0FBZixFQUFzQlMsWUFBdEIsRUFBOEIzQyxTQUE5QixFQUFtQ3VDLFdBQW5DLENBQXlDOEYsYUFBQUEsQ0FBVTFKLElBQUFpRCxNQUFBQSxDQUFBQSxDQUFJaUcsTUFBQUEsQ0FBQUEsQ0FBZFEsQ0FBbkQsQ0FBQTtZQUFBLE9BQUE7VUFBQTtVQUVBMUosSUFBQWdKLFNBQUFBLENBQUFBO1FBSkY7TUFGRnJILENBQUFBLEdBQUFBOztBQVVBc0gsTUFBQUEsdUJBQUFBLCtCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQWpKLElBQUFpRCxNQUFBQSxDQUFBQSxDQUFJaUcsTUFBQUEsQ0FBQUEsQ0FBTUMsT0FBQUEsQ0FBR1EsU0FBSFI7TUFEWkYsQ0FBQUEsR0FBQUE7TUFJQWxKLE9BQUFrQix5QkFBQUEsaUNBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFDakIsSUFBQWlKLFlBQUFBLENBQUFBLENBQUQ1RCxNQUFBQSxDQUFBQTtNQURGcEUsQ0FBQUEsR0FBQUE7SUFqYUZsQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc5NTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsaWIvYV9sb3gvc3RhdGljX3Jlc29sdmVyL3VwdmFsdWVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBBTG94XG4gIG1vZHVsZSBTdGF0aWNSZXNvbHZlclxuICAgIGNsYXNzIFVwdmFsdWVzXG4gICAgICBWYXJpYWJsZSA9IFN0cnVjdC5uZXcoOm5hbWUsIDpraW5kLCA6c2xvdCwgOmRlcHRoKSBkb1xuICAgICAgICBhdHRyX2FjY2Vzc29yIDpjYXB0dXJlZFxuICAgICAgICBkZWYgc2VsZi5nbG9iYWwgPSBuZXcobmlsLCA6Z2xvYmFsLCBuaWwpXG4gICAgICAgIGRlZiBzZWxmLmxvY2FsKG5hbWU6LCBzbG90OiwgZGVwdGg6KSA9IG5ldyhuYW1lLCA6bG9jYWwsIHNsb3QsIGRlcHRoKVxuICAgICAgICBkZWYgc2VsZi51cHZhbHVlKG5hbWU6LCBzbG90OikgPSBuZXcobmFtZSwgOnVwdmFsdWUsIHNsb3QsIG5pbClcblxuICAgICAgICBkZWYgZ2xvYmFsPyA9IGtpbmQgPT0gOmdsb2JhbFxuICAgICAgICBkZWYgbG9jYWw/ID0ga2luZCA9PSA6bG9jYWxcbiAgICAgICAgZGVmIHVwdmFsdWU/ID0ga2luZCA9PSA6dXB2YWx1ZVxuICAgICAgZW5kXG5cbiAgICAgIFVwdmFsdWUgPSBTdHJ1Y3QubmV3KDpzbG90LCA6bG9jYWwpXG5cbiAgICAgIGNsYXNzIEZ1bmN0aW9uU2NvcGVcbiAgICAgICAgYXR0cl9yZWFkZXIgOnVwdmFsdWVzLCA6bmFtZVxuXG4gICAgICAgIGRlZiBpbml0aWFsaXplKG5hbWUsIGVuY2xvc2luZzogbmlsKVxuICAgICAgICAgIEBuYW1lID0gbmFtZVxuICAgICAgICAgIEBlbmNsb3NpbmcgPSBlbmNsb3NpbmdcbiAgICAgICAgICBAbG9jYWxzID0gW11cbiAgICAgICAgICBAY3VycmVudF9kZXB0aCA9IDBcbiAgICAgICAgICBAdXB2YWx1ZXMgPSBbXVxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgdG9wX2xldmVsP1xuICAgICAgICAgIEBlbmNsb3NpbmcubmlsP1xuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgYmVnaW5fYmxvY2tcbiAgICAgICAgICBAY3VycmVudF9kZXB0aCArPSAxXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiBlbmRfYmxvY2tcbiAgICAgICAgICBAY3VycmVudF9kZXB0aCAtPSAxXG5cbiAgICAgICAgICBibG9ja192YXJpYWJsZXMgPSBAbG9jYWxzLnNlbGVjdCB7IF8xLmRlcHRoID4gQGN1cnJlbnRfZGVwdGggfVxuXG4gICAgICAgICAgQGxvY2Fscy5yZWplY3QhIHsgXzEuZGVwdGggPiBAY3VycmVudF9kZXB0aCB9XG5cbiAgICAgICAgICBibG9ja192YXJpYWJsZXNcbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmIGFkZF92YXJpYWJsZShuYW1lKVxuICAgICAgICAgIHJldHVybiBWYXJpYWJsZS5nbG9iYWwgaWYgdG9wX2xldmVsPyAmJiBAY3VycmVudF9kZXB0aCA9PSAwXG5cbiAgICAgICAgICB2YXJpYWJsZSA9IFZhcmlhYmxlLmxvY2FsKG5hbWU6IG5hbWUsIHNsb3Q6IEBsb2NhbHMuY291bnQsIGRlcHRoOiBAY3VycmVudF9kZXB0aClcblxuICAgICAgICAgIEBsb2NhbHMgPDwgdmFyaWFibGVcblxuICAgICAgICAgIHZhcmlhYmxlXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgZm4gb3V0ZXIoeCwgeSlcbiAgICAgICAgIyAgIGZuIG1pZGRsZSBbMSwgdHJ1ZV1cbiAgICAgICAgIyAgICAgZm4gaW5uZXIgWzAsIGZhbHNlXVxuICAgICAgICAjICAgICAgIHJldHVybiB5XG4gICAgICAgIGRlZiByZXNvbHZlX3ZhcmlhYmxlKG5hbWUpXG4gICAgICAgICAgbG9jYWwgPSBmaW5kX2xvY2FsKG5hbWUpXG5cbiAgICAgICAgICByZXR1cm4gbG9jYWwgaWYgbG9jYWxcblxuICAgICAgICAgIGlmIEBlbmNsb3NpbmdcbiAgICAgICAgICAgIHVwdmFsdWVfc2xvdCwgaXNfbG9jYWwgPSBAZW5jbG9zaW5nLmZpbmRfdXB2YWx1ZShuYW1lKVxuXG4gICAgICAgICAgICBpZiB1cHZhbHVlX3Nsb3RcbiAgICAgICAgICAgICAgdXB2YWx1ZV9pbmRleCA9IGFkZF91cHZhbHVlKHVwdmFsdWVfc2xvdCwgbG9jYWw6IGlzX2xvY2FsKVxuXG4gICAgICAgICAgICAgIHJldHVybiBWYXJpYWJsZS51cHZhbHVlKG5hbWU6IG5hbWUsIHNsb3Q6IHVwdmFsdWVfaW5kZXgpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIFZhcmlhYmxlLmdsb2JhbFxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgZmluZF9sb2NhbChuYW1lKVxuICAgICAgICAgIEBsb2NhbHMuZGV0ZWN0IHsgfGxvY2FsfCBsb2NhbC5uYW1lID09IG5hbWUgfVxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgZmluZF91cHZhbHVlKG5hbWUpXG4gICAgICAgICAgbG9jYWwgPSBmaW5kX2xvY2FsKG5hbWUpXG5cbiAgICAgICAgICBpZiBsb2NhbFxuICAgICAgICAgICAgbG9jYWwuY2FwdHVyZWQgPSB0cnVlXG4gICAgICAgICAgICByZXR1cm4gW2xvY2FsLnNsb3QsIHRydWVdXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICBpZiBAZW5jbG9zaW5nXG4gICAgICAgICAgICB1cF91cHZhbHVlX3Nsb3QsIGlzX2xvY2FsID0gQGVuY2xvc2luZy5maW5kX3VwdmFsdWUobmFtZSlcblxuICAgICAgICAgICAgaWYgdXBfdXB2YWx1ZV9zbG90XG4gICAgICAgICAgICAgIHh4eF9zbG90ID0gYWRkX3VwdmFsdWUodXBfdXB2YWx1ZV9zbG90LCBsb2NhbDogaXNfbG9jYWwpXG5cbiAgICAgICAgICAgICAgcmV0dXJuIFt4eHhfc2xvdCwgZmFsc2VdXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIFtuaWwsIGZhbHNlXVxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgYWRkX3VwdmFsdWUodXB2YWx1ZSwgbG9jYWw6KVxuICAgICAgICAgIG5ld191cHZhbHVlID0gVXB2YWx1ZS5uZXcodXB2YWx1ZSwgbG9jYWwpXG5cbiAgICAgICAgICBAdXB2YWx1ZXMuZWFjaF93aXRoX2luZGV4IGRvIHx1cHZhbHVlLCBpbmRleHxcbiAgICAgICAgICAgIHJldHVybiBpbmRleCBpZiB1cHZhbHVlID09IG5ld191cHZhbHVlXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICBAdXB2YWx1ZXMgPDwgbmV3X3VwdmFsdWVcblxuICAgICAgICAgIEB1cHZhbHVlcy5jb3VudCAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgZGVmIGluaXRpYWxpemUoZXJyb3JfcmVwb3J0ZXI6IG5pbClcbiAgICAgICAgQGZ1bmN0aW9uX3Njb3BlcyA9IFtGdW5jdGlvblNjb3BlLm5ldygnZ2xvYmFsJyldXG4gICAgICAgIEBlcnJvcl9yZXBvcnRlciA9IGVycm9yX3JlcG9ydGVyXG4gICAgICBlbmRcblxuICAgICAgZGVmIHJlc29sdmUocmVzb2x2YWJsZSlcbiAgICAgICAgaWYgcmVzb2x2YWJsZS5pc19hPyBBcnJheVxuICAgICAgICAgIHJlc29sdmFibGUuZWFjaCB7IHxyZXNvbHZhYmxlX2VsZW1lbnR8IHJlc29sdmUocmVzb2x2YWJsZV9lbGVtZW50KSB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXNvbHZhYmxlLmFjY2VwdChzZWxmKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgZXJyb3IodG9rZW4sIG1lc3NhZ2UpXG4gICAgICAgIEBlcnJvcl9yZXBvcnRlciYucmVwb3J0X3N0YXRpY19hbmFseXNpc19lcnJvcih0b2tlbiwgbWVzc2FnZSlcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgdmlzaXRfYmxvY2tfc3RhdGVtZW50KGJsb2NrX3N0YXRlbWVudClcbiAgICAgICAgQGZ1bmN0aW9uX3Njb3Blcy5sYXN0LmJlZ2luX2Jsb2NrXG4gICAgICAgIHJlc29sdmUoYmxvY2tfc3RhdGVtZW50LnN0YXRlbWVudHMpXG4gICAgICAgIGJsb2NrX3N0YXRlbWVudC5sb2NhbHMgPSBAZnVuY3Rpb25fc2NvcGVzLmxhc3QuZW5kX2Jsb2NrXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X3Zhcl9zdGF0ZW1lbnQodmFyX3N0YXRlbWVudClcbiAgICAgICAgdmFyX3N0YXRlbWVudC5hbGxvY2F0aW9uID0gQGZ1bmN0aW9uX3Njb3Blcy5sYXN0LmFkZF92YXJpYWJsZSh2YXJfc3RhdGVtZW50Lm5hbWUubGV4ZW1lKVxuXG4gICAgICAgIGlmIHZhcl9zdGF0ZW1lbnQuaW5pdGlhbGl6ZXJcbiAgICAgICAgICByZXNvbHZlKHZhcl9zdGF0ZW1lbnQuaW5pdGlhbGl6ZXIpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB2aXNpdF92YXJpYWJsZSh2YXJpYWJsZV9leHByZXNzaW9uKVxuICAgICAgICB2YXJpYWJsZV9leHByZXNzaW9uLmFsbG9jYXRpb24gPVxuICAgICAgICAgIEBmdW5jdGlvbl9zY29wZXMubGFzdC5yZXNvbHZlX3ZhcmlhYmxlKHZhcmlhYmxlX2V4cHJlc3Npb24ubmFtZS5sZXhlbWUpXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X2Fzc2lnbihhc3NpZ25fZXhwcmVzc2lvbilcbiAgICAgICAgcmVzb2x2ZShhc3NpZ25fZXhwcmVzc2lvbi52YWx1ZSlcbiAgICAgICAgYXNzaWduX2V4cHJlc3Npb24uYWxsb2NhdGlvbiA9XG4gICAgICAgICAgQGZ1bmN0aW9uX3Njb3Blcy5sYXN0LnJlc29sdmVfdmFyaWFibGUoYXNzaWduX2V4cHJlc3Npb24ubmFtZS5sZXhlbWUpXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X2Z1bmN0aW9uX3N0YXRlbWVudChmdW5jdGlvbl9zdGF0ZW1lbnQpXG4gICAgICAgIGZ1bmN0aW9uX3N0YXRlbWVudC5hbGxvY2F0aW9uID1cbiAgICAgICAgICBAZnVuY3Rpb25fc2NvcGVzLmxhc3QuYWRkX3ZhcmlhYmxlKGZ1bmN0aW9uX3N0YXRlbWVudC5uYW1lLmxleGVtZSlcblxuICAgICAgICBAZnVuY3Rpb25fc2NvcGVzIDw8IEZ1bmN0aW9uU2NvcGUubmV3KFxuICAgICAgICAgIGZ1bmN0aW9uX3N0YXRlbWVudC5uYW1lLmxleGVtZSxcbiAgICAgICAgICBlbmNsb3Npbmc6IEBmdW5jdGlvbl9zY29wZXMubGFzdFxuICAgICAgICApXG5cbiAgICAgICAgZnVuY3Rpb25fc3RhdGVtZW50LnBhcmFtZXRlcnMubWFwIGRvIHxwYXJhbWV0ZXJ8XG4gICAgICAgICAgQGZ1bmN0aW9uX3Njb3Blcy5sYXN0LmFkZF92YXJpYWJsZShwYXJhbWV0ZXIubGV4ZW1lKVxuICAgICAgICBlbmRcblxuICAgICAgICByZXNvbHZlKGZ1bmN0aW9uX3N0YXRlbWVudC5ib2R5KVxuXG4gICAgICAgIGZ1bmN0aW9uX3N0YXRlbWVudC51cHZhbHVlcyA9IEBmdW5jdGlvbl9zY29wZXMubGFzdC51cHZhbHVlc1xuICAgICAgICBmdW5jdGlvbl9zdGF0ZW1lbnQuZnVsbF9uYW1lID0gJ19fJyArIEBmdW5jdGlvbl9zY29wZXMubWFwKCY6bmFtZSkuam9pbignX18nKSArICdfXydcblxuICAgICAgICBAZnVuY3Rpb25fc2NvcGVzLnBvcFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB2aXNpdF9leHByZXNzaW9uX3N0YXRlbWVudChleHByZXNzaW9uX3N0YXRlbWVudClcbiAgICAgICAgcmVzb2x2ZShleHByZXNzaW9uX3N0YXRlbWVudC5leHByZXNzaW9uKVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB2aXNpdF9pZl9zdGF0ZW1lbnQoaWZfc3RhdGVtZW50KVxuICAgICAgICByZXNvbHZlKGlmX3N0YXRlbWVudC5jb25kaXRpb24pXG4gICAgICAgIHJlc29sdmUoaWZfc3RhdGVtZW50LnRoZW5fYnJhbmNoKVxuICAgICAgICByZXNvbHZlKGlmX3N0YXRlbWVudC5lbHNlX2JyYW5jaCkgaWYgaWZfc3RhdGVtZW50LmVsc2VfYnJhbmNoXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X3ByaW50X3N0YXRlbWVudChwcmludF9zdGF0ZW1lbnQpXG4gICAgICAgIHJlc29sdmUocHJpbnRfc3RhdGVtZW50LmV4cHJlc3Npb24pXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X3JldHVybl9zdGF0ZW1lbnQocmV0dXJuX3N0YXRlbWVudClcbiAgICAgICAgaWYgQGZ1bmN0aW9uX3Njb3Blcy5sYXN0LnRvcF9sZXZlbD9cbiAgICAgICAgICBlcnJvcihyZXR1cm5fc3RhdGVtZW50LmtleXdvcmQsIFwiQ2FuJ3QgcmV0dXJuIG91dHNpZGUgb2YgZnVuY3Rpb25cIilcbiAgICAgICAgZW5kXG5cbiAgICAgICAgaWYgcmV0dXJuX3N0YXRlbWVudC52YWx1ZVxuICAgICAgICAgIHJlc29sdmUocmV0dXJuX3N0YXRlbWVudC52YWx1ZSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X3doaWxlX3N0YXRlbWVudCh3aGlsZV9zdGF0ZW1lbnQpXG4gICAgICAgIHJlc29sdmUod2hpbGVfc3RhdGVtZW50LmNvbmRpdGlvbilcbiAgICAgICAgcmVzb2x2ZSh3aGlsZV9zdGF0ZW1lbnQuYm9keSlcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgdmlzaXRfYmluYXJ5KGJpbmFyeV9leHByZXNzaW9uKVxuICAgICAgICByZXNvbHZlKGJpbmFyeV9leHByZXNzaW9uLmxlZnQpXG4gICAgICAgIHJlc29sdmUoYmluYXJ5X2V4cHJlc3Npb24ucmlnaHQpXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X2NhbGwoY2FsbF9leHByZXNzaW9uKVxuICAgICAgICByZXNvbHZlKGNhbGxfZXhwcmVzc2lvbi5jYWxsZWUpXG4gICAgICAgIGNhbGxfZXhwcmVzc2lvbi5hcmd1bWVudHMuZWFjaCBkbyB8YXJndW1lbnR8XG4gICAgICAgICAgcmVzb2x2ZShhcmd1bWVudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X2dyb3VwaW5nKGdyb3VwaW5nX2V4cHJlc3Npb24pXG4gICAgICAgIHJlc29sdmUoZ3JvdXBpbmdfZXhwcmVzc2lvbi5leHByZXNzaW9uKVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB2aXNpdF9sb2dpY2FsKGxvZ2ljYWxfZXhwcmVzc2lvbilcbiAgICAgICAgcmVzb2x2ZShsb2dpY2FsX2V4cHJlc3Npb24ubGVmdClcbiAgICAgICAgcmVzb2x2ZShsb2dpY2FsX2V4cHJlc3Npb24ucmlnaHQpXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZpc2l0X3VuYXJ5KHVuYXJ5X2V4cHJlc3Npb24pXG4gICAgICAgIHJlc29sdmUodW5hcnlfZXhwcmVzc2lvbi5yaWdodClcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgdmlzaXRfbGl0ZXJhbChsaXRlcmFsX2V4cHJlc3Npb24pXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpBTG94PiIsIjxtb2R1bGU6U3RhdGljUmVzb2x2ZXI+IiwiPGNsYXNzOlVwdmFsdWVzPiIsIm5ldyIsIlN0cnVjdCIsImJsb2NrIGluIDxjbGFzczpVcHZhbHVlcz4iLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpVcHZhbHVlcz4iLCJzZWxmIiwiYXR0cl9hY2Nlc3NvciIsImdsb2JhbCIsImxvY2FsIiwiJGt3YXJncyIsIm5hbWUiLCJzbG90IiwiZGVwdGgiLCJ1cHZhbHVlIiwiZ2xvYmFsPyIsImtpbmQiLCI9PSIsImxvY2FsPyIsInVwdmFsdWU/IiwiPGNsYXNzOkZ1bmN0aW9uU2NvcGU+IiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQG5hbWUiLCJAZW5jbG9zaW5nIiwiZW5jbG9zaW5nIiwiQGxvY2FscyIsIkBjdXJyZW50X2RlcHRoIiwiMCIsIkB1cHZhbHVlcyIsInRvcF9sZXZlbD8iLCJuaWw/IiwiYmVnaW5fYmxvY2siLCIrIiwiMSIsImVuZF9ibG9jayIsIi0iLCJibG9ja192YXJpYWJsZXMiLCJzZWxlY3QiLCJibG9jayBpbiBlbmRfYmxvY2siLCJfMSIsImJsb2NrICgyIGxldmVscykgaW4gZW5kX2Jsb2NrIiwiPiIsInJlamVjdCEiLCJhZGRfdmFyaWFibGUiLCJWYXJpYWJsZSIsInZhcmlhYmxlIiwiY291bnQiLCI8PCIsInJlc29sdmVfdmFyaWFibGUiLCJmaW5kX2xvY2FsIiwiZmluZF91cHZhbHVlIiwidXB2YWx1ZV9zbG90IiwiaXNfbG9jYWwiLCJ1cHZhbHVlX2luZGV4IiwiYWRkX3VwdmFsdWUiLCJkZXRlY3QiLCJibG9jayBpbiBmaW5kX2xvY2FsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX2xvY2FsIiwiJHdyaXRlciIsImNhcHR1cmVkPSIsInVwX3VwdmFsdWVfc2xvdCIsInh4eF9zbG90IiwibmV3X3VwdmFsdWUiLCJVcHZhbHVlIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gYWRkX3VwdmFsdWUiLCJpbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gYWRkX3VwdmFsdWUiLCJAZnVuY3Rpb25fc2NvcGVzIiwiRnVuY3Rpb25TY29wZSIsIkBlcnJvcl9yZXBvcnRlciIsImVycm9yX3JlcG9ydGVyIiwicmVzb2x2ZSIsInJlc29sdmFibGUiLCJpc19hPyIsIkFycmF5IiwiZWFjaCIsImJsb2NrIGluIHJlc29sdmUiLCJyZXNvbHZhYmxlX2VsZW1lbnQiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlc29sdmUiLCJhY2NlcHQiLCJlcnJvciIsInRva2VuIiwibWVzc2FnZSIsInZpc2l0X2Jsb2NrX3N0YXRlbWVudCIsImJsb2NrX3N0YXRlbWVudCIsImxhc3QiLCJzdGF0ZW1lbnRzIiwibG9jYWxzPSIsInZpc2l0X3Zhcl9zdGF0ZW1lbnQiLCJ2YXJfc3RhdGVtZW50IiwibGV4ZW1lIiwiYWxsb2NhdGlvbj0iLCJpbml0aWFsaXplciIsInZpc2l0X3ZhcmlhYmxlIiwidmFyaWFibGVfZXhwcmVzc2lvbiIsInZpc2l0X2Fzc2lnbiIsImFzc2lnbl9leHByZXNzaW9uIiwidmFsdWUiLCJ2aXNpdF9mdW5jdGlvbl9zdGF0ZW1lbnQiLCJmdW5jdGlvbl9zdGF0ZW1lbnQiLCJtYXAiLCJwYXJhbWV0ZXJzIiwiYmxvY2sgaW4gdmlzaXRfZnVuY3Rpb25fc3RhdGVtZW50IiwicGFyYW1ldGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB2aXNpdF9mdW5jdGlvbl9zdGF0ZW1lbnQiLCJib2R5IiwidXB2YWx1ZXMiLCJ1cHZhbHVlcz0iLCJ0b19wcm9jIiwiam9pbiIsImZ1bGxfbmFtZT0iLCJwb3AiLCJ2aXNpdF9leHByZXNzaW9uX3N0YXRlbWVudCIsImV4cHJlc3Npb25fc3RhdGVtZW50IiwiZXhwcmVzc2lvbiIsInZpc2l0X2lmX3N0YXRlbWVudCIsImlmX3N0YXRlbWVudCIsImNvbmRpdGlvbiIsInRoZW5fYnJhbmNoIiwiZWxzZV9icmFuY2giLCJ2aXNpdF9wcmludF9zdGF0ZW1lbnQiLCJwcmludF9zdGF0ZW1lbnQiLCJ2aXNpdF9yZXR1cm5fc3RhdGVtZW50IiwicmV0dXJuX3N0YXRlbWVudCIsImtleXdvcmQiLCJ2aXNpdF93aGlsZV9zdGF0ZW1lbnQiLCJ3aGlsZV9zdGF0ZW1lbnQiLCJ2aXNpdF9iaW5hcnkiLCJiaW5hcnlfZXhwcmVzc2lvbiIsImxlZnQiLCJyaWdodCIsInZpc2l0X2NhbGwiLCJjYWxsX2V4cHJlc3Npb24iLCJjYWxsZWUiLCJhcmd1bWVudHMiLCJibG9jayBpbiB2aXNpdF9jYWxsIiwiYXJndW1lbnQiLCJibG9jayAoMiBsZXZlbHMpIGluIHZpc2l0X2NhbGwiLCJ2aXNpdF9ncm91cGluZyIsImdyb3VwaW5nX2V4cHJlc3Npb24iLCJ2aXNpdF9sb2dpY2FsIiwibG9naWNhbF9leHByZXNzaW9uIiwidmlzaXRfdW5hcnkiLCJ1bmFyeV9leHByZXNzaW9uIiwidmlzaXRfbGl0ZXJhbCIsImxpdGVyYWxfZXhwcmVzc2lvbiJdLCJtYXBwaW5ncyI6IkFBQUFBLHFFQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQ0VBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0Usb0NBQWlCQyxNQUFOQyxZQUFNRCxPQUFBQSxFQUFBQSxDQUFLLE1BQVgsRUFBa0IsTUFBbEIsRUFBeUIsTUFBekIsRUFBZ0MsT0FBMUJBLENBQUFBLEVBQU5FLHFCQUFBQSxFQUFBQzs7O1VBQ1RDLElBQUFDLGVBQUFBLENBQWMsVUFBZEE7VUFDQUMsTUFBSUYsSUFBSkUsYUFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUFrQkEsT0FBQUYsSUFBQUosS0FBQUEsQ0FBSSxHQUFKLEVBQVMsUUFBVCxFQUFrQixHQUFsQkE7VUFBbEJNLENBQUFBLEdBQUFBO1VBQ0FDLE1BQUlILElBQUpHLFlBQUFBLGlCQU5SQyxPQU1RRDtBQUFBQSxZQUFBQTs7OztZQU5SO1lBQUE7WUFBQTtZQUFBO1lBQUE7O1lBTXVCO1lBQUE7WUFBQTtZQUFBOztZQUFPO1lBQUE7WUFBQTtZQUFBOztZQUFPO1lBQUE7WUFBQTtZQUFBO1lBQVVBLE9BQUFILElBQUFKLEtBQUFBLENBQUlTLElBQUosRUFBVSxPQUFWLEVBQWtCQyxJQUFsQixFQUF3QkMsS0FBeEJYO1VBQXZDTyxDQUFBQSxHQUFBQTtVQUNBSyxNQUFJUixJQUFKUSxjQUFBQSxtQkFQUkosT0FPUUk7QUFBQUEsWUFBQUE7Ozs7WUFQUjtZQUFBO1lBQUE7WUFBQTtZQUFBOztZQU95QjtZQUFBO1lBQUE7WUFBQTs7WUFBTztZQUFBO1lBQUE7WUFBQTtZQUFTQSxPQUFBUixJQUFBSixLQUFBQSxDQUFJUyxJQUFKLEVBQVUsU0FBVixFQUFvQkMsSUFBcEIsRUFBMEIsR0FBMUJWO1VBQWpDWSxDQUFBQSxHQUFBQTs7QUFFQUMsVUFBQUEsdUJBQUFBLHdCQUFBQTtBQUFBQSxZQUFBQTs7WUFBY0EsT0FBQVQsSUFBQVUsTUFBQUEsQ0FBQUEsQ0FBS0MsT0FBQUEsQ0FBRyxRQUFIQTtVQUFuQkYsQ0FBQUEsR0FBQUE7O0FBQ0FHLFVBQUFBLHNCQUFBQSx1QkFBQUE7QUFBQUEsWUFBQUE7O1lBQWFBLE9BQUFaLElBQUFVLE1BQUFBLENBQUFBLENBQUtDLE9BQUFBLENBQUcsT0FBSEE7VUFBbEJDLENBQUFBLEdBQUFBO1VBQ0FiLE9BQUFjLHdCQUFBQSx5QkFBQUE7QUFBQUEsWUFBQUE7O1lBQWVBLE9BQUFiLElBQUFVLE1BQUFBLENBQUFBLENBQUtDLE9BQUFBLENBQUcsU0FBSEE7VUFBcEJFLENBQUFBLEdBQUFBLEVBUlNmLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFNRixDQUFqQjtRQVdBLG1DQUFVQyxZQUFNRCxLQUFBQSxDQUFLLE1BQVgsRUFBa0IsT0FBWkEsQ0FBaEI7UUFFQWtCO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VkLElBQUFlLGFBQUFBLENBQVksVUFBWixFQUF1QixNQUF2QkE7O0FBRUFDLFVBQUFBLDBCQUFBQSxzQkFBZVgsSUFBRCxFQW5CdEJELE9BbUJRWTtBQUFBQSxZQUFBQTs7OztZQW5CUjtZQUFBO1lBQUE7WUFBQTtZQUFBOztZQW1CNkI7WUFBQSxtQ0FBVztZQUM5QkMsWUFBUVo7WUFDUmEsaUJBQWFDO1lBQ2JDLGNBQVU7WUFDVkMscUJBQWlCQztZQUNqQk4sT0FBQU8sQ0FBQUEsZ0JBQVksRUFBWkE7VUFMRlAsQ0FBQUEsSUFBQUE7O0FBUUFRLFVBQUFBLDBCQUFBQSx5Q0FBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFOLGNBQVVPLFNBQUFBLENBQUFBO1VBRFpELENBQUFBLEdBQUFBOztBQUlBRSxVQUFBQSwyQkFBQUEsdUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBTCxDQUFBQSxxQkFBZU0sU0FBZk4sa0JBQWVNLEVBQUdDLENBQUhELENBQWZOO1VBREZLLENBQUFBLEdBQUFBOztBQUlBRyxVQUFBQSx5QkFBQUEscUJBQUFBO0FBQUFBLFlBQUFBOzs7WUFDRVIscUJBQWVTLFVBQWZULGtCQUFlUyxFQUFHRixDQUFIRTtZQUVmQyxrQkFBeUJDLE1BQVBaLFdBQU9ZLFVBQUFBLEVBQUFBLEVBQUFBLEVBQVBDLGFBQUFDLEVBQUFELEVBQUFFO0FBQUFBOzs7O2NBQUE7Y0FBaUJBLE9BQVNDLE9BQVRGLEVBQUUzQixPQUFBQSxDQUFBQSxDQUFPNkIsRUFBRWYsa0JBQUZlLEVBQTFCSCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBT0Q7WUFFbEJLLE1BQVBqQixXQUFPaUIsV0FBQUEsRUFBQUEsRUFBQUEsRUFBUEosYUFBQUMsRUFBQUQsRUFBQUU7QUFBQUE7Ozs7Y0FBQTtjQUFrQkEsT0FBU0MsT0FBVEYsRUFBRTNCLE9BQUFBLENBQUFBLENBQU82QixFQUFFZixrQkFBRmUsRUFBM0JILENBQUFBLEdBQUFBLHFCQUFBQSxDQUFPSTtZQUVQUixPQUFBRTtVQVBGRixDQUFBQSxHQUFBQTs7QUFVQVMsVUFBQUEsNEJBQUFBLHdCQUFpQmpDLElBQWpCaUM7QUFBQUEsWUFBQUE7OztZQUNFLElBQTBCLENBQUEsUUFBQXRDLElBQUF3QixlQUFBQSxDQUFBQSxDQUFBLENBQUEsSUFBQSxDQUFBLE1BQWNILGtCQUFkLEVBQWdDQyxDQUFoQyxDQUFBLENBQUEsQ0FBMUI7Y0FBQSxPQUFPaUIsY0FBUXJDLFFBQUFBLENBQUFBO1lBQWY7WUFFQXNDLFdBQVdELGNBQVFwQyxPQUFBQSxDQUFPLG1DQUFBLFFBQU1FLElBQU4sRUFBQSxRQUFrQmUsV0FBT3FCLE9BQUFBLENBQUFBLENBQXpCLEVBQUEsU0FBd0NwQixrQkFBeEMsRUFBUGxCO1lBRW5CaUIsV0FBUXNCLE9BQUFBLENBQUdGLFFBQUhFO1lBRVJKLE9BQUFFO1VBUEZGLENBQUFBLEdBQUFBOztBQWNBSyxVQUFBQSxnQ0FBQUEsNEJBQXFCdEMsSUFBckJzQztBQUFBQSxZQUFBQTs7O1lBQ0V4QyxRQUFRSCxJQUFBNEMsWUFBQUEsQ0FBV3ZDLElBQVh1QztZQUVSLElBQUEsUUFBZ0J6QyxLQUFoQixDQUFBO2NBQUEsT0FBT0E7WUFBUDtZQUVBLElBQUEsUUFBR2UsY0FBSCxDQUFBOztjQUNFLEtBQXlCQSxjQUFVMkIsY0FBQUEsQ0FBY3hDLElBQWR3QyxDQUFuQyxrQkFBQSxFQUFBQyxDQUFBQSxlQUFBLDZCQUFBQSxDQUFBLEVBQWNDLENBQUFBLFdBQWQsNkJBQWNBLENBQWQ7Y0FFQSxJQUFBLFFBQUdELFlBQUgsQ0FBQTs7Z0JBQ0VFLGdCQUFnQmhELElBQUFpRCxhQUFBQSxDQUFZSCxZQUFaLEVBQTBCLG1CQUFBLFNBQU9DLFFBQVAsRUFBMUJFO2dCQUVoQixPQUFPVixjQUFRL0IsU0FBQUEsQ0FBUywwQkFBQSxRQUFNSCxJQUFOLEVBQUEsUUFBa0IyQyxhQUFsQixFQUFUeEM7Y0FIakI7WUFIRjtZQVVBbUMsT0FBQUosY0FBUXJDLFFBQUFBLENBQUFBO1VBZlZ5QyxDQUFBQSxHQUFBQTs7QUFrQkFDLFVBQUFBLDBCQUFBQSxzQkFBZXZDLElBQWZ1QztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBT00sTUFBUDlCLFdBQU84QixVQUFBQSxFQUFBQSxFQUFBQSxFQUFQQyxhQUFrQmhELEtBQWxCZ0Q7OztjQUFrQjtjQUFPQyxPQUFBakQsS0FBS0UsTUFBQUEsQ0FBQUEsQ0FBTU0sT0FBQUEsQ0FBR04sSUFBSE0sRUFBcEN3QyxDQUFBQSxHQUFPRDtVQURUTixDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEsNEJBQUFBLHdCQUFpQnhDLElBQWpCd0M7QUFBQUEsWUFBQUE7OztZQUNFMUMsUUFBUUgsSUFBQTRDLFlBQUFBLENBQVd2QyxJQUFYdUM7WUFFUixJQUFBLFFBQUd6QyxLQUFILENBQUE7OztjQXBGVmtELFVBQUEsQ0FxRjZCLElBckY3QjtjQXFGaUJDLE1BQUxuRCxLQUFLbUQsYUFBQUEsRUFyRmpCLE1BQUFELE9BQUEsQ0FxRmlCQztjQXJGakJELE9BQUEsQ0FBQXZCLFVBQUF1QixPQUFBLENBQUFSLFFBQUEsQ0FBQWYsRUFBQUYsQ0FBQUUsQ0FBQTtjQXNGWSxPQUFPLENBQUMzQixLQUFLRyxNQUFBQSxDQUFBQSxDQUFOLEVBQWEsSUFBYjtZQUZUO1lBS0EsSUFBQSxRQUFHWSxjQUFILENBQUE7O2NBQ0UsS0FBNEJBLGNBQVUyQixjQUFBQSxDQUFjeEMsSUFBZHdDLENBQXRDLGtCQUFBLEVBQUFVLENBQUFBLGtCQUFBLDZCQUFBQSxDQUFBLEVBQWlCUixDQUFBQSxXQUFqQiw2QkFBaUJBLENBQWpCO2NBRUEsSUFBQSxRQUFHUSxlQUFILENBQUE7O2dCQUNFQyxXQUFXeEQsSUFBQWlELGFBQUFBLENBQVlNLGVBQVosRUFBNkIsbUJBQUEsU0FBT1IsUUFBUCxFQUE3QkU7Z0JBRVgsT0FBTyxDQUFDTyxRQUFELEVBQVcsS0FBWDtjQUhUO1lBSEY7WUFVQVgsT0FBQSxDQUFDLEdBQUQsRUFBTSxLQUFOO1VBbEJGQSxDQUFBQSxHQUFBQTtVQXFCQS9CLE9BQUFtQywyQkFBQUEsdUJBQWdCekMsT0FBRCxFQXRHdkJKLE9Bc0dRNkMsR0FBQUE7O0FBQUFBLFlBQUFBOzs7O1lBdEdSO1lBQUE7WUFBQTtZQUFBO1lBQUE7O1lBc0dpQztZQUFBO1lBQUE7WUFBQTtZQUN2QlEsY0FBY0MsYUFBTzlELEtBQUFBLENBQUtZLE9BQVosRUFBcUJMLEtBQWRQO1lBRVorRCxNQUFUcEMsYUFBU29DLG1CQUFBQSxFQUFBQSxFQUFBQSxFQUFUQyxhQUE4QnBELE9BQUQsRUFBVXFELEtBQXZDRDs7O2NBQThCOztjQUFTO2NBQ3JDLElBQUEsTUFBZ0JwRCxPQUFoQixFQUEyQmlELFdBQTNCLENBQUE7Z0JBQUEsU0FBT0ksS0FBUDtjQUFBO2dCQTFHWkMsT0FBQTtjQTBHWSxFQURGRixDQUFBQSxHQUFTRDtZQUlUcEMsYUFBVW1CLE9BQUFBLENBQUdlLFdBQUhmO1lBRVZPLE9BQWdCbkIsVUFBaEJQLGFBQVNrQixPQUFBQSxDQUFBQSxDQUFPWCxFQUFFRixDQUFGRTtZQVRsQm1CLDhFQUFBQTtVQUFBQSxDQUFBQSxHQUFBQTtRQXRGRm5DLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOztBQW1HQUUsUUFBQUEsMEJBQUFBLHNCQW5ITlosT0FtSE1ZO0FBQUFBLFVBQUFBOzs7O1VBbkhOO1VBQUE7VUFBQTtVQUFBO1VBQUE7O1VBbUhxQjtVQUFBLDZDQUFnQjtVQUM3QitDLHVCQUFtQixDQUFDQyxtQkFBYXBFLEtBQUFBLENBQUtvQixRQUFMcEIsQ0FBZDtVQUNuQm9CLE9BQUFpRCxDQUFBQSxzQkFBa0JDLGNBQWxCRDtRQUZGakQsQ0FBQUEsSUFBQUE7O0FBS0FtRCxRQUFBQSx1QkFBQUEsbUJBQVlDLFVBQVpEO0FBQUFBLFVBQUFBOztVQUNFLElBQUEsUUFBR0MsVUFBVUMsVUFBQUEsQ0FBT0MsV0FBUEQsQ0FBYixDQUFBO1lBQ0VGLE9BQVVJLE1BQVZILFVBQVVHLFFBQUFBLEVBQUFBLEVBQUFBLEVBQVZDLGNBQW1CQyxrQkFBbkJELEVBQUFFOzs7O2NBQW1CO2NBQW9CQSxPQUFBMUUsSUFBQW1FLFNBQUFBLENBQVFNLGtCQUFSTixFQUF2Q0ssQ0FBQUEsR0FBQUEscUJBQUFBLENBQVVEO1VBRFo7WUFHRUosT0FBQUMsVUFBVU8sUUFBQUEsQ0FBUTNFLElBQVIyRTtVQUhaO1FBREZSLENBQUFBLEdBQUFBOztBQVFBUyxRQUFBQSxxQkFBQUEsaUJBQVVDLEtBQUQsRUFBUUMsT0FBakJGO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBLENBQUEsS0FBQVgsbUJBQUEscUNBQUEsTUFBQSxFQUFBLGdDQUFBLEVBQUEsQ0FBOENZLEtBQTlDLEVBQXFEQyxPQUFyRCxDQUFBLENBQUE7UUFERkYsQ0FBQUEsR0FBQUE7O0FBSUFHLFFBQUFBLHFDQUFBQSxpQ0FBMEJDLGVBQTFCRDtBQUFBQSxVQUFBQTs7O1VBQ0VoQixvQkFBZ0JrQixNQUFBQSxDQUFBQSxDQUFLdkQsYUFBQUEsQ0FBQUE7VUFDckIxQixJQUFBbUUsU0FBQUEsQ0FBUWEsZUFBZUUsWUFBQUEsQ0FBQUEsQ0FBdkJmOztVQXRJUmQsVUFBQSxDQXVJaUNVLG9CQUFnQmtCLE1BQUFBLENBQUFBLENBQUtwRCxXQUFBQSxDQUFBQSxDQXZJdEQ7VUF1SXVCc0QsTUFBZkgsZUFBZUcsV0FBQUEsRUF2SXZCLE1BQUE5QixPQUFBLENBdUl1QjhCO1VBdkl2QkosT0FBQTFCLE9BQUEsQ0FBQXZCLFVBQUF1QixPQUFBLENBQUEwQixRQUFBLENBQUFqRCxFQUFBRixDQUFBRSxDQUFBO1FBb0lNaUQsQ0FBQUEsR0FBQUE7O0FBTUFLLFFBQUFBLG1DQUFBQSwrQkFBd0JDLGFBQXhCRDtBQUFBQSxVQUFBQTs7OztVQTFJTi9CLFVBQUEsQ0EySW1DVSxvQkFBZ0JrQixNQUFBQSxDQUFBQSxDQUFLM0MsY0FBQUEsQ0FBYytDLGFBQWFoRixNQUFBQSxDQUFBQSxDQUFLaUYsUUFBQUEsQ0FBQUEsQ0FBaENoRCxDQTNJeEQ7VUEySXFCaUQsTUFBYkYsYUFBYUUsZUFBQUEsRUEzSXJCLE1BQUFsQyxPQUFBLENBMklxQmtDO1VBM0lyQmxDLE9BQUEsQ0FBQXZCLFVBQUF1QixPQUFBLENBQUErQixRQUFBLENBQUF0RCxFQUFBRixDQUFBRSxDQUFBO1VBNklRLElBQUEsUUFBR3VELGFBQWFHLGFBQUFBLENBQUFBLENBQWhCLENBQUE7WUFDRUosT0FBQXBGLElBQUFtRSxTQUFBQSxDQUFRa0IsYUFBYUcsYUFBQUEsQ0FBQUEsQ0FBckJyQjtVQURGO1lBN0lSaUIsT0FBQTtVQTZJUTtRQUhGQSxDQUFBQSxHQUFBQTs7QUFRQUssUUFBQUEsOEJBQUFBLDBCQUFtQkMsbUJBQW5CRDtBQUFBQSxVQUFBQTs7O1VBbEpOcEMsVUFBQSxDQW9KVVUsb0JBQWdCa0IsTUFBQUEsQ0FBQUEsQ0FBS3RDLGtCQUFBQSxDQUFrQitDLG1CQUFtQnJGLE1BQUFBLENBQUFBLENBQUtpRixRQUFBQSxDQUFBQSxDQUExQzNDLENBcEovQjtVQW1KMkI0QyxNQUFuQkcsbUJBQW1CSCxlQUFBQSxFQW5KM0IsTUFBQWxDLE9BQUEsQ0FtSjJCa0M7VUFuSjNCRSxPQUFBcEMsT0FBQSxDQUFBdkIsVUFBQXVCLE9BQUEsQ0FBQW9DLFFBQUEsQ0FBQTNELEVBQUFGLENBQUFFLENBQUE7UUFrSk0yRCxDQUFBQSxHQUFBQTs7QUFLQUUsUUFBQUEsNEJBQUFBLHdCQUFpQkMsaUJBQWpCRDtBQUFBQSxVQUFBQTs7O1VBQ0UzRixJQUFBbUUsU0FBQUEsQ0FBUXlCLGlCQUFpQkMsT0FBQUEsQ0FBQUEsQ0FBekIxQjs7VUF4SlJkLFVBQUEsQ0EwSlVVLG9CQUFnQmtCLE1BQUFBLENBQUFBLENBQUt0QyxrQkFBQUEsQ0FBa0JpRCxpQkFBaUJ2RixNQUFBQSxDQUFBQSxDQUFLaUYsUUFBQUEsQ0FBQUEsQ0FBeEMzQyxDQTFKL0I7VUF5SnlCNEMsTUFBakJLLGlCQUFpQkwsZUFBQUEsRUF6SnpCLE1BQUFsQyxPQUFBLENBeUp5QmtDO1VBekp6QkksT0FBQXRDLE9BQUEsQ0FBQXZCLFVBQUF1QixPQUFBLENBQUFzQyxRQUFBLENBQUE3RCxFQUFBRixDQUFBRSxDQUFBO1FBdUpNNkQsQ0FBQUEsR0FBQUE7O0FBTUFHLFFBQUFBLHdDQUFBQSxvQ0FBNkJDLGtCQUE3QkQ7QUFBQUEsVUFBQUE7Ozs7VUE3Sk56QyxVQUFBLENBK0pVVSxvQkFBZ0JrQixNQUFBQSxDQUFBQSxDQUFLM0MsY0FBQUEsQ0FBY3lELGtCQUFrQjFGLE1BQUFBLENBQUFBLENBQUtpRixRQUFBQSxDQUFBQSxDQUFyQ2hELENBL0ovQjtVQThKMEJpRCxNQUFsQlEsa0JBQWtCUixlQUFBQSxFQTlKMUIsTUFBQWxDLE9BQUEsQ0E4SjBCa0M7VUE5SjFCbEMsT0FBQSxDQUFBdkIsVUFBQXVCLE9BQUEsQ0FBQXlDLFFBQUEsQ0FBQWhFLEVBQUFGLENBQUFFLENBQUE7VUFpS1FpQyxvQkFBaUJyQixPQUFBQSxDQUFHc0IsbUJBQWFwRSxLQUFBQSxDQUMvQm1HLGtCQUFrQjFGLE1BQUFBLENBQUFBLENBQUtpRixRQUFBQSxDQUFBQSxDQURMLEVBRWxCLHVCQUFBLGFBQVd2QixvQkFBZ0JrQixNQUFBQSxDQUFBQSxDQUEzQixFQUYrQnJGLENBQWhCOEM7VUFLWXNELE1BQTdCRCxrQkFBa0JFLFlBQUFBLENBQUFBLENBQVdELE9BQUFBLEVBQUFBLEVBQUFBLEVBQTdCRSxjQUFzQ0MsU0FBdENELEVBQUFFO0FBQUFBOzs7O1lBQXNDO1lBQ3BDQSxPQUFBckMsb0JBQWdCa0IsTUFBQUEsQ0FBQUEsQ0FBSzNDLGNBQUFBLENBQWM2RCxTQUFTYixRQUFBQSxDQUFBQSxDQUF2QmhELEVBRHZCNEQsQ0FBQUEsR0FBQUEscUJBQUFBLENBQTZCRjtVQUk3QmhHLElBQUFtRSxTQUFBQSxDQUFRNEIsa0JBQWtCTSxNQUFBQSxDQUFBQSxDQUExQmxDOztVQTFLUmQsVUFBQSxDQTRLc0NVLG9CQUFnQmtCLE1BQUFBLENBQUFBLENBQUtxQixVQUFBQSxDQUFBQSxDQTVLM0Q7VUE0SzBCQyxNQUFsQlIsa0JBQWtCUSxhQUFBQSxFQTVLMUIsTUFBQWxELE9BQUEsQ0E0SzBCa0Q7VUE1SzFCbEQsT0FBQSxDQUFBdkIsVUFBQXVCLE9BQUEsQ0FBQXlDLFFBQUEsQ0FBQWhFLEVBQUFGLENBQUFFLENBQUE7O1VBQUF1QixVQUFBLENBNktzRjFCLFNBQTFDQSxTQUFMbUUsSUFBS25FLEVBQWtCcUUsTUFBaEJqQyxvQkFBZ0JpQyxPQUFBQSxFQUFBQSxFQUFBQSxFQUFNLE1BQURRLFNBQUFBLENBQUFBLENBQUxSLENBQVlTLE1BQUFBLENBQU1YLElBQU5XLENBQTlCOUUsQ0FBMENBLEVBQUVtRSxJQUFGbkUsQ0E3S3RGO1VBNkswQitFLE1BQWxCWCxrQkFBa0JXLGNBQUFBLEVBN0sxQixNQUFBckQsT0FBQSxDQTZLMEJxRDtVQTdLMUJyRCxPQUFBLENBQUF2QixVQUFBdUIsT0FBQSxDQUFBeUMsUUFBQSxDQUFBaEUsRUFBQUYsQ0FBQUUsQ0FBQTtVQStLUWdFLE9BQUEvQixvQkFBZ0I0QyxLQUFBQSxDQUFBQTtRQWxCbEJiLENBQUFBLEdBQUFBOztBQXFCQWMsUUFBQUEsMENBQUFBLHNDQUErQkMsb0JBQS9CRDtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQTVHLElBQUFtRSxTQUFBQSxDQUFRMEMsb0JBQW9CQyxZQUFBQSxDQUFBQSxDQUE1QjNDO1FBREZ5QyxDQUFBQSxHQUFBQTs7QUFJQUcsUUFBQUEsa0NBQUFBLDhCQUF1QkMsWUFBdkJEO0FBQUFBLFVBQUFBOzs7VUFDRS9HLElBQUFtRSxTQUFBQSxDQUFRNkMsWUFBWUMsV0FBQUEsQ0FBQUEsQ0FBcEI5QztVQUNBbkUsSUFBQW1FLFNBQUFBLENBQVE2QyxZQUFZRSxhQUFBQSxDQUFBQSxDQUFwQi9DO1VBQ0EsSUFBQSxRQUFxQzZDLFlBQVlHLGFBQUFBLENBQUFBLENBQWpELENBQUE7WUFBQUosT0FBQS9HLElBQUFtRSxTQUFBQSxDQUFRNkMsWUFBWUcsYUFBQUEsQ0FBQUEsQ0FBcEJoRDtVQUFBO1lBekxSNEMsT0FBQTtVQXlMUTtRQUhGQSxDQUFBQSxHQUFBQTs7QUFNQUssUUFBQUEscUNBQUFBLGlDQUEwQkMsZUFBMUJEO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBcEgsSUFBQW1FLFNBQUFBLENBQVFrRCxlQUFlUCxZQUFBQSxDQUFBQSxDQUF2QjNDO1FBREZpRCxDQUFBQSxHQUFBQTs7QUFJQUUsUUFBQUEsc0NBQUFBLGtDQUEyQkMsZ0JBQTNCRDtBQUFBQSxVQUFBQTs7O1VBQ0UsSUFBQSxRQUFHdkQsb0JBQWdCa0IsTUFBQUEsQ0FBQUEsQ0FBS3pELGVBQUFBLENBQUFBLENBQXhCLENBQUE7WUFDRXhCLElBQUE0RSxPQUFBQSxDQUFNMkMsZ0JBQWdCQyxTQUFBQSxDQUFBQSxDQUF0QixFQUFnQ0Ysa0NBQWhDMUM7VUFERjtVQUlBLElBQUEsUUFBRzJDLGdCQUFnQjFCLE9BQUFBLENBQUFBLENBQW5CLENBQUE7WUFDRXlCLE9BQUF0SCxJQUFBbUUsU0FBQUEsQ0FBUW9ELGdCQUFnQjFCLE9BQUFBLENBQUFBLENBQXhCMUI7VUFERjtZQXJNUm1ELE9BQUE7VUFxTVE7UUFMRkEsQ0FBQUEsR0FBQUE7O0FBVUFHLFFBQUFBLHFDQUFBQSxpQ0FBMEJDLGVBQTFCRDtBQUFBQSxVQUFBQTs7O1VBQ0V6SCxJQUFBbUUsU0FBQUEsQ0FBUXVELGVBQWVULFdBQUFBLENBQUFBLENBQXZCOUM7VUFDQXNELE9BQUF6SCxJQUFBbUUsU0FBQUEsQ0FBUXVELGVBQWVyQixNQUFBQSxDQUFBQSxDQUF2QmxDO1FBRkZzRCxDQUFBQSxHQUFBQTs7QUFLQUUsUUFBQUEsNEJBQUFBLHdCQUFpQkMsaUJBQWpCRDtBQUFBQSxVQUFBQTs7O1VBQ0UzSCxJQUFBbUUsU0FBQUEsQ0FBUXlELGlCQUFpQkMsTUFBQUEsQ0FBQUEsQ0FBekIxRDtVQUNBd0QsT0FBQTNILElBQUFtRSxTQUFBQSxDQUFReUQsaUJBQWlCRSxPQUFBQSxDQUFBQSxDQUF6QjNEO1FBRkZ3RCxDQUFBQSxHQUFBQTs7QUFLQUksUUFBQUEsMEJBQUFBLHNCQUFlQyxlQUFmRDtBQUFBQSxVQUFBQTs7O1VBQ0UvSCxJQUFBbUUsU0FBQUEsQ0FBUTZELGVBQWVDLFFBQUFBLENBQUFBLENBQXZCOUQ7VUFDQTRELE9BQXlCeEQsTUFBekJ5RCxlQUFlRSxXQUFBQSxDQUFBQSxDQUFVM0QsUUFBQUEsRUFBQUEsRUFBQUEsRUFBekI0RCxjQUFtQ0MsUUFBbkNELEVBQUFFOzs7O1lBQW1DO1lBQ2pDQSxPQUFBckksSUFBQW1FLFNBQUFBLENBQVFpRSxRQUFSakUsRUFERmdFLENBQUFBLEdBQUFBLHFCQUFBQSxDQUF5QjVEO1FBRjNCd0QsQ0FBQUEsR0FBQUE7O0FBT0FPLFFBQUFBLDhCQUFBQSwwQkFBbUJDLG1CQUFuQkQ7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUF0SSxJQUFBbUUsU0FBQUEsQ0FBUW9FLG1CQUFtQnpCLFlBQUFBLENBQUFBLENBQTNCM0M7UUFERm1FLENBQUFBLEdBQUFBOztBQUlBRSxRQUFBQSw2QkFBQUEseUJBQWtCQyxrQkFBbEJEO0FBQUFBLFVBQUFBOzs7VUFDRXhJLElBQUFtRSxTQUFBQSxDQUFRc0Usa0JBQWtCWixNQUFBQSxDQUFBQSxDQUExQjFEO1VBQ0FxRSxPQUFBeEksSUFBQW1FLFNBQUFBLENBQVFzRSxrQkFBa0JYLE9BQUFBLENBQUFBLENBQTFCM0Q7UUFGRnFFLENBQUFBLEdBQUFBOztBQUtBRSxRQUFBQSwyQkFBQUEsdUJBQWdCQyxnQkFBaEJEO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBMUksSUFBQW1FLFNBQUFBLENBQVF3RSxnQkFBZ0JiLE9BQUFBLENBQUFBLENBQXhCM0Q7UUFERnVFLENBQUFBLEdBQUFBO1FBSUEvSSxPQUFBaUosNkJBQUFBLHlCQUFrQkMsa0JBQWxCRDtBQUFBQTtVQXhPTkEsT0FBQTtRQXdPTUEsQ0FBQUEsR0FBQUE7TUF0T0ZqSixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQURGRCxHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg0MTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsaWIvYV9sb3gvZXhlY3V0YWJsZV9jb250YWluZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEFMb3hcbiAgY2xhc3MgRXhlY3V0YWJsZUNvbnRhaW5lclxuICAgIFBMQUNFSE9MREVSID0gXCJQTEFDRUhPTERFUlwiXG5cbiAgICBhdHRyX3JlYWRlciA6ZnVuY3Rpb25zLCA6Y29uc3RhbnRzXG5cbiAgICBkZWYgaW5pdGlhbGl6ZVxuICAgICAgQGZ1bmN0aW9ucyA9IHt9XG4gICAgICBAY29uc3RhbnRzID0gW11cbiAgICBlbmRcblxuICAgIGRlZiByZXNldF9mdW5jdGlvbihmdW5jdGlvbilcbiAgICAgIEBmdW5jdGlvbnNbZnVuY3Rpb25dID0gW11cbiAgICBlbmRcblxuICAgIGRlZiB3cml0ZShmdW5jdGlvbiwgb3Bjb2RlKVxuICAgICAgQGZ1bmN0aW9uc1tmdW5jdGlvbl0gPDwgb3Bjb2RlXG4gICAgICBAZnVuY3Rpb25zW2Z1bmN0aW9uXS5zaXplXG4gICAgZW5kXG5cbiAgICBkZWYgcGF0Y2hfanVtcChmdW5jdGlvbiwganVtcF9vZmZzZXQpXG4gICAgICBqdW1wID0gQGZ1bmN0aW9uc1tmdW5jdGlvbl0uc2l6ZSAtIGp1bXBfb2Zmc2V0IC0gMlxuXG4gICAgICBmaXJzdF9ieXRlLCBzZWNvbmRfYnl0ZSA9IEJpbmFyeVV0aWxzLnBhY2tfc2hvcnQoanVtcClcblxuICAgICAgQGZ1bmN0aW9uc1tmdW5jdGlvbl1banVtcF9vZmZzZXRdID0gZmlyc3RfYnl0ZVxuICAgICAgQGZ1bmN0aW9uc1tmdW5jdGlvbl1banVtcF9vZmZzZXQgKyAxXSA9IHNlY29uZF9ieXRlXG4gICAgZW5kXG5cbiAgICBkZWYgYWRkX2NvbnN0YW50KGNvbnN0YW50KVxuICAgICAgaWYgQGNvbnN0YW50cy5pbmNsdWRlPyhjb25zdGFudClcbiAgICAgICAgQGNvbnN0YW50cy5pbmRleChjb25zdGFudClcbiAgICAgIGVsc2VcbiAgICAgICAgQGNvbnN0YW50cyA8PCBjb25zdGFudFxuICAgICAgICBAY29uc3RhbnRzLnNpemUgLSAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBzaXplKGZ1bmN0aW9uKVxuICAgICAgQGZ1bmN0aW9uc1tmdW5jdGlvbl0uc2l6ZVxuICAgIGVuZFxuXG4gICAgZGVmIHNlcmlhbGl6ZVxuICAgICAge1xuICAgICAgICBmdW5jdGlvbnM6IEBmdW5jdGlvbnMsXG4gICAgICAgIGNvbnN0YW50czogQGNvbnN0YW50cy5tYXAgeyB8Y29uc3RhbnR8IGNvbnN0YW50LnJlc3BvbmRfdG8/KDpzZXJpYWxpemUpID8gY29uc3RhbnQuc2VyaWFsaXplIDogY29uc3RhbnQgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkFMb3g+IiwiPGNsYXNzOkV4ZWN1dGFibGVDb250YWluZXI+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkBmdW5jdGlvbnMiLCJAY29uc3RhbnRzIiwicmVzZXRfZnVuY3Rpb24iLCJmdW5jdGlvbiQiLCIkd3JpdGVyIiwiW109IiwiLSIsIjEiLCJ3cml0ZSIsIm9wY29kZSIsIltdIiwiPDwiLCJzaXplIiwicGF0Y2hfanVtcCIsImp1bXBfb2Zmc2V0IiwianVtcCIsIjIiLCJCaW5hcnlVdGlscyIsInBhY2tfc2hvcnQiLCJmaXJzdF9ieXRlIiwic2Vjb25kX2J5dGUiLCIrIiwiYWRkX2NvbnN0YW50IiwiY29uc3RhbnQiLCJpbmNsdWRlPyIsImluZGV4Iiwic2VyaWFsaXplIiwibWFwIiwiYmxvY2sgaW4gc2VyaWFsaXplIiwicmVzcG9uZF90bz8iLCJibG9jayAoMiBsZXZlbHMpIGluIHNlcmlhbGl6ZSJdLCJtYXBwaW5ncyI6IkFBQUFBLGlFQUFBQTtFQUFB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QixPQUFBQSxFQUFBQSxFQUFBQSxFQUFWQyxhQUFrQkwsUUFBbEJLOzs7VUFBa0I7VUFBVSxJQUFBLFFBQUFMLFFBQVFNLGdCQUFBQSxDQUFhLFdBQWJBLENBQVIsQ0FBQTtZQUFtQ0MsT0FBQVAsUUFBUUcsV0FBQUEsQ0FBQUE7VUFBM0M7WUFBd0RJLE9BQUFQO1VBQXhELEVBQTVCSyxDQUFBQSxHQUFVRCxDQUZ2QjtNQURGRCxDQUFBQSxHQUFBQTtJQXpDRjlCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODUxMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxpYi9hX2xveC9jb21waWxlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQUxveFxuICBjbGFzcyBDb21waWxlclxuICAgIGNsYXNzIEZ1bmN0aW9uRGVzY3JpcHRvclxuICAgICAgYXR0cl9yZWFkZXIgOmFyaXR5LCA6bmFtZVxuXG4gICAgICBkZWYgaW5pdGlhbGl6ZShuYW1lLCBhcml0eSwgdXB2YWx1ZXMpXG4gICAgICAgIEBhcml0eSA9IGFyaXR5XG4gICAgICAgIEBuYW1lID0gbmFtZVxuICAgICAgICBAdXB2YWx1ZXMgPSB1cHZhbHVlc1xuICAgICAgZW5kXG5cbiAgICAgIGRlZiB1cHZhbHVlX2NvdW50XG4gICAgICAgIEB1cHZhbHVlcy5jb3VudFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBzZXJpYWxpemVcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDpmdW5jdGlvbixcbiAgICAgICAgICBhcml0eTogQGFyaXR5LFxuICAgICAgICAgIG5hbWU6IEBuYW1lLFxuICAgICAgICAgIHVwdmFsdWVfY291bnQ6IHVwdmFsdWVfY291bnQsXG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGluaXRpYWxpemUoc3RhdGVtZW50cywgZXhlY3V0YWJsZSwgbmFtZSA9IFwiX190b3BsZXZlbF9fXCIsIGFyaXR5ID0gMCwgdXB2YWx1ZXMgPSBbXSwgZXJyb3JfcmVwb3J0ZXI6IG5pbClcbiAgICAgIEBzdGF0ZW1lbnRzID0gc3RhdGVtZW50c1xuICAgICAgQGV4ZWN1dGFibGUgPSBleGVjdXRhYmxlXG4gICAgICBAbmFtZSA9IG5hbWVcbiAgICAgIEBmdW5jdGlvbiA9IEZ1bmN0aW9uRGVzY3JpcHRvci5uZXcobmFtZSwgYXJpdHksIHVwdmFsdWVzKVxuICAgICAgQGVycm9yX3JlcG9ydGVyID0gZXJyb3JfcmVwb3J0ZXJcblxuICAgICAgZXhlY3V0YWJsZS5yZXNldF9mdW5jdGlvbihuYW1lKVxuICAgIGVuZFxuXG4gICAgZGVmIGNvbXBpbGVcbiAgICAgIEBzdGF0ZW1lbnRzLmVhY2ggZG8gfHN0YXRlbWVudHxcbiAgICAgICAgc3RhdGVtZW50LmFjY2VwdChzZWxmKVxuICAgICAgZW5kXG5cbiAgICAgIGVtaXRfcmV0dXJuXG5cbiAgICAgIEBmdW5jdGlvblxuICAgIGVuZFxuXG4gICAgZGVmIGFkZF9jb25zdGFudChjb25zdGFudClcbiAgICAgIEBleGVjdXRhYmxlLmFkZF9jb25zdGFudChjb25zdGFudClcbiAgICBlbmRcblxuICAgICMgc3RhdGVtZW50c1xuICAgIGRlZiB2aXNpdF9leHByZXNzaW9uX3N0YXRlbWVudChleHByZXNzaW9uX3N0YXRlbWVudClcbiAgICAgIGV4cHJlc3Npb25fc3RhdGVtZW50LmV4cHJlc3Npb24uYWNjZXB0KHNlbGYpXG4gICAgICBlbWl0KE9wY29kZXM6OlBPUClcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9mdW5jdGlvbl9zdGF0ZW1lbnQoZnVuY3Rpb25fc3RhdGVtZW50KVxuICAgICAgZnVuY3Rpb24gPSBDb21waWxlci5uZXcoXG4gICAgICAgIGZ1bmN0aW9uX3N0YXRlbWVudC5ib2R5LFxuICAgICAgICBAZXhlY3V0YWJsZSxcbiAgICAgICAgZnVuY3Rpb25fc3RhdGVtZW50LmZ1bGxfbmFtZSxcbiAgICAgICAgZnVuY3Rpb25fc3RhdGVtZW50LnBhcmFtZXRlcnMuY291bnQsXG4gICAgICAgIGZ1bmN0aW9uX3N0YXRlbWVudC51cHZhbHVlcyxcbiAgICAgICkuY29tcGlsZVxuXG4gICAgICBlbWl0X3R3byhPcGNvZGVzOjpMT0FEX0NMT1NVUkUsIGFkZF9jb25zdGFudChmdW5jdGlvbikpXG5cbiAgICAgIGZ1bmN0aW9uX3N0YXRlbWVudC51cHZhbHVlcy5lYWNoIGRvIHx1cHZhbHVlfFxuICAgICAgICBlbWl0X3R3byh1cHZhbHVlLmxvY2FsID8gMSA6IDAsIHVwdmFsdWUuc2xvdClcbiAgICAgIGVuZFxuXG4gICAgICBpZiBmdW5jdGlvbl9zdGF0ZW1lbnQuYWxsb2NhdGlvbi5nbG9iYWw/XG4gICAgICAgIGNvbnN0YW50X2luZGV4ID0gYWRkX2NvbnN0YW50KGZ1bmN0aW9uX3N0YXRlbWVudC5uYW1lLmxleGVtZSlcbiAgICAgICAgZW1pdF90d28oT3Bjb2Rlczo6REVGSU5FX0dMT0JBTCwgY29uc3RhbnRfaW5kZXgpXG4gICAgICBlbHNpZiBmdW5jdGlvbl9zdGF0ZW1lbnQuYWxsb2NhdGlvbi5sb2NhbD9cbiAgICAgICAgIyBub29wLCBpdCdzIG9uIHRoZSBzdGFja1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdmlzaXRfcmV0dXJuX3N0YXRlbWVudChyZXR1cm5fc3RhdGVtZW50KVxuICAgICAgaWYgcmV0dXJuX3N0YXRlbWVudC52YWx1ZVxuICAgICAgICByZXR1cm5fc3RhdGVtZW50LnZhbHVlLmFjY2VwdChzZWxmKVxuICAgICAgZWxzZVxuICAgICAgICBlbWl0KE9wY29kZXM6Ok5JTF9PUClcbiAgICAgIGVuZFxuXG4gICAgICBlbWl0KE9wY29kZXM6OlJFVFVSTilcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9wcmludF9zdGF0ZW1lbnQocHJpbnRfc3RhdGVtZW50KVxuICAgICAgcHJpbnRfc3RhdGVtZW50LmV4cHJlc3Npb24uYWNjZXB0KHNlbGYpXG4gICAgICBlbWl0KE9wY29kZXM6OlBSSU5UKVxuICAgIGVuZFxuXG4gICAgZGVmIHZpc2l0X3Zhcl9zdGF0ZW1lbnQodmFyX3N0YXRlbWVudClcbiAgICAgIGlmIHZhcl9zdGF0ZW1lbnQuaW5pdGlhbGl6ZXJcbiAgICAgICAgdmFyX3N0YXRlbWVudC5pbml0aWFsaXplci5hY2NlcHQoc2VsZilcbiAgICAgIGVsc2VcbiAgICAgICAgZW1pdChPcGNvZGVzOjpOSUxfT1ApXG4gICAgICBlbmRcblxuICAgICAgaWYgdmFyX3N0YXRlbWVudC5hbGxvY2F0aW9uLmdsb2JhbD9cbiAgICAgICAgZW1pdF90d28oT3Bjb2Rlczo6REVGSU5FX0dMT0JBTCwgYWRkX2NvbnN0YW50KHZhcl9zdGF0ZW1lbnQubmFtZS5sZXhlbWUpKVxuICAgICAgZWxzaWYgdmFyX3N0YXRlbWVudC5hbGxvY2F0aW9uLmxvY2FsP1xuICAgICAgICAjIG5vLW9wLCBzdGFjayBzbG90IHNob3VsZCBtYXRjaCA6ZmluZ2Vycy1jcm9zc2VkOlxuICAgICAgZWxzZVxuICAgICAgICBmYWlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9ibG9ja19zdGF0ZW1lbnQoYmxvY2tfc3RhdGVtZW50KVxuICAgICAgYmxvY2tfc3RhdGVtZW50LnN0YXRlbWVudHMuZWFjaCBkbyB8c3RhdGVtZW50fFxuICAgICAgICBzdGF0ZW1lbnQuYWNjZXB0KHNlbGYpXG4gICAgICBlbmRcblxuICAgICAgYmxvY2tfc3RhdGVtZW50LmxvY2Fscy5lYWNoIGRvIHxsb2NhbHxcbiAgICAgICAgaWYgbG9jYWwuY2FwdHVyZWRcbiAgICAgICAgICBlbWl0KE9wY29kZXM6OkNMT1NFX1VQVkFMVUUpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbWl0KE9wY29kZXM6OlBPUClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9pZl9zdGF0ZW1lbnQoaWZfc3RhdGVtZW50KVxuICAgICAgaWZfc3RhdGVtZW50LmNvbmRpdGlvbi5hY2NlcHQoc2VsZilcbiAgICAgIGVsc2VfanVtcF9vZmZzZXQgPSBlbWl0X2p1bXAoT3Bjb2Rlczo6SlVNUF9PTl9GQUxTRSlcblxuICAgICAgZW1pdChPcGNvZGVzOjpQT1ApICMgcG9wIGNvbmRpdGlvbiB3aGVuIGNvbmRpdGlvbiBpcyB0cnV0aHlcbiAgICAgIGlmX3N0YXRlbWVudC50aGVuX2JyYW5jaC5hY2NlcHQoc2VsZilcblxuICAgICAgZXhpdF9qdW1wID0gZW1pdF9qdW1wKE9wY29kZXM6OkpVTVApXG5cbiAgICAgIEBleGVjdXRhYmxlLnBhdGNoX2p1bXAoQG5hbWUsIGVsc2VfanVtcF9vZmZzZXQpXG5cbiAgICAgIGVtaXQoT3Bjb2Rlczo6UE9QKSAjIHBvcCBjb25kaXRpb24gd2hlbiBjb25kaXRpb24gaXMgZmFsc3lcbiAgICAgIGlmX3N0YXRlbWVudC5lbHNlX2JyYW5jaCYuYWNjZXB0KHNlbGYpXG5cbiAgICAgIEBleGVjdXRhYmxlLnBhdGNoX2p1bXAoQG5hbWUsIGV4aXRfanVtcClcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF93aGlsZV9zdGF0ZW1lbnQod2hpbGVfc3RhdGVtZW50KVxuICAgICAgYmVnaW5fbG9vcF9vZmZzZXQgPSBAZXhlY3V0YWJsZS5mdW5jdGlvbnNbQG5hbWVdLnNpemVcbiAgICAgIHdoaWxlX3N0YXRlbWVudC5jb25kaXRpb24uYWNjZXB0KHNlbGYpXG4gICAgICBleGl0X2xvb3Bfb2Zmc2V0ID0gZW1pdF9qdW1wKE9wY29kZXM6OkpVTVBfT05fRkFMU0UpXG4gICAgICBlbWl0KE9wY29kZXM6OlBPUClcbiAgICAgIHdoaWxlX3N0YXRlbWVudC5ib2R5LmFjY2VwdChzZWxmKVxuICAgICAgZW1pdChPcGNvZGVzOjpKVU1QKVxuICAgICAgZW1pdF90d28oKkJpbmFyeVV0aWxzLnBhY2tfc2hvcnQoYmVnaW5fbG9vcF9vZmZzZXQgLSAyIC0gQGV4ZWN1dGFibGUuZnVuY3Rpb25zW0BuYW1lXS5zaXplKSlcbiAgICAgIEBleGVjdXRhYmxlLnBhdGNoX2p1bXAoQG5hbWUsIGV4aXRfbG9vcF9vZmZzZXQpXG4gICAgICBlbWl0KE9wY29kZXM6OlBPUClcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9jbGFzc19zdGF0ZW1lbnRcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9hc3NpZ24oYXNzaWduX2V4cHJlc3Npb24pXG4gICAgICBhc3NpZ25fZXhwcmVzc2lvbi52YWx1ZS5hY2NlcHQoc2VsZilcblxuICAgICAgaWYgYXNzaWduX2V4cHJlc3Npb24uYWxsb2NhdGlvbi5nbG9iYWw/XG4gICAgICAgIGNvbnN0YW50X2luZGV4ID0gYWRkX2NvbnN0YW50KGFzc2lnbl9leHByZXNzaW9uLm5hbWUubGV4ZW1lKVxuICAgICAgICBlbWl0X3R3byhPcGNvZGVzOjpTRVRfR0xPQkFMLCBjb25zdGFudF9pbmRleClcbiAgICAgIGVsc2lmIGFzc2lnbl9leHByZXNzaW9uLmFsbG9jYXRpb24ubG9jYWw/XG4gICAgICAgIGVtaXRfdHdvKE9wY29kZXM6OlNFVF9MT0NBTCwgYXNzaWduX2V4cHJlc3Npb24uYWxsb2NhdGlvbi5zbG90KVxuICAgICAgZWxzaWYgYXNzaWduX2V4cHJlc3Npb24uYWxsb2NhdGlvbi51cHZhbHVlP1xuICAgICAgICBlbWl0X3R3byhPcGNvZGVzOjpTRVRfVVBWQUxVRSwgYXNzaWduX2V4cHJlc3Npb24uYWxsb2NhdGlvbi5zbG90KVxuICAgICAgZWxzZVxuICAgICAgICBmYWlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF92YXJpYWJsZSh2YXJpYWJsZV9leHByZXNzaW9uKVxuICAgICAgaWYgdmFyaWFibGVfZXhwcmVzc2lvbi5hbGxvY2F0aW9uLmdsb2JhbD9cbiAgICAgICAgY29uc3RhbnRfaW5kZXggPSBhZGRfY29uc3RhbnQodmFyaWFibGVfZXhwcmVzc2lvbi5uYW1lLmxleGVtZSlcbiAgICAgICAgZW1pdF90d28oT3Bjb2Rlczo6R0VUX0dMT0JBTCwgY29uc3RhbnRfaW5kZXgpXG4gICAgICBlbHNpZiB2YXJpYWJsZV9leHByZXNzaW9uLmFsbG9jYXRpb24ubG9jYWw/XG4gICAgICAgIGVtaXRfdHdvKE9wY29kZXM6OkdFVF9MT0NBTCwgdmFyaWFibGVfZXhwcmVzc2lvbi5hbGxvY2F0aW9uLnNsb3QpXG4gICAgICBlbHNpZiB2YXJpYWJsZV9leHByZXNzaW9uLmFsbG9jYXRpb24udXB2YWx1ZT9cbiAgICAgICAgZW1pdF90d28oT3Bjb2Rlczo6R0VUX1VQVkFMVUUsIHZhcmlhYmxlX2V4cHJlc3Npb24uYWxsb2NhdGlvbi5zbG90KVxuICAgICAgZWxzZVxuICAgICAgICBmYWlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9iaW5hcnkoYmluYXJ5X2V4cHJlc3Npb24pXG4gICAgICBiaW5hcnlfZXhwcmVzc2lvbi5sZWZ0LmFjY2VwdChzZWxmKVxuICAgICAgYmluYXJ5X2V4cHJlc3Npb24ucmlnaHQuYWNjZXB0KHNlbGYpXG5cbiAgICAgIHtcbiAgICAgICAgXCIrXCIgPT4gW09wY29kZXM6OkFERF0sXG4gICAgICAgIFwiLVwiID0+IFtPcGNvZGVzOjpTVUJUUkFDVF0sXG4gICAgICAgIFwiKlwiID0+IFtPcGNvZGVzOjpNVUxUSVBMWV0sXG4gICAgICAgIFwiL1wiID0+IFtPcGNvZGVzOjpESVZJREVdLFxuICAgICAgICBcIj09XCIgPT4gW09wY29kZXM6OkVRVUFMXSxcbiAgICAgICAgXCIhPVwiID0+IFtPcGNvZGVzOjpFUVVBTCwgT3Bjb2Rlczo6Tk9UXSxcbiAgICAgICAgXCI+XCIgPT4gW09wY29kZXM6OkdSRUFURVJdLFxuICAgICAgICBcIjxcIiA9PiBbT3Bjb2Rlczo6TEVTU0VSXSxcbiAgICAgICAgXCI+PVwiID0+IFtPcGNvZGVzOjpMRVNTRVIsIE9wY29kZXM6Ok5PVF0sXG4gICAgICAgIFwiPD1cIiA9PiBbT3Bjb2Rlczo6R1JFQVRFUiwgT3Bjb2Rlczo6Tk9UXVxuICAgICAgfS5mZXRjaChiaW5hcnlfZXhwcmVzc2lvbi5vcGVyYXRvci5sZXhlbWUpLmVhY2ggeyB8b3B8IGVtaXQob3ApIH1cbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9ncm91cGluZyhncm91cGluZ19leHByZXNzaW9uKVxuICAgICAgZ3JvdXBpbmdfZXhwcmVzc2lvbi5leHByZXNzaW9uLmFjY2VwdChzZWxmKVxuICAgIGVuZFxuXG4gICAgZGVmIHZpc2l0X2xpdGVyYWwobGl0ZXJhbF9leHByZXNzaW9uKVxuICAgICAgaWYgbGl0ZXJhbF9leHByZXNzaW9uLnZhbHVlID09IHRydWVcbiAgICAgICAgZW1pdChPcGNvZGVzOjpUUlVFX09QKVxuICAgICAgZWxzaWYgbGl0ZXJhbF9leHByZXNzaW9uLnZhbHVlID09IGZhbHNlXG4gICAgICAgIGVtaXQoT3Bjb2Rlczo6RkFMU0VfT1ApXG4gICAgICBlbHNpZiBsaXRlcmFsX2V4cHJlc3Npb24udmFsdWUubmlsP1xuICAgICAgICBlbWl0KE9wY29kZXM6Ok5JTF9PUClcbiAgICAgIGVsc2VcbiAgICAgICAgY29uc3RhbnRfaW5kZXggPSBhZGRfY29uc3RhbnQobGl0ZXJhbF9leHByZXNzaW9uLnZhbHVlKVxuICAgICAgICBlbWl0X3R3byhPcGNvZGVzOjpMT0FEX0NPTlNUQU5ULCBjb25zdGFudF9pbmRleClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHZpc2l0X2xvZ2ljYWwobG9naWNhbF9leHByZXNzaW9uKVxuICAgICAgaWYgbG9naWNhbF9leHByZXNzaW9uLm9wZXJhdG9yLnR5cGUgPT0gVG9rZW5UeXBlczo6QU5EXG4gICAgICAgIGxvZ2ljYWxfZXhwcmVzc2lvbi5sZWZ0LmFjY2VwdChzZWxmKVxuICAgICAgICBzaG9ydF9jaXJjdWl0X2V4aXQgPSBlbWl0X2p1bXAoT3Bjb2Rlczo6SlVNUF9PTl9GQUxTRSlcbiAgICAgICAgZW1pdChPcGNvZGVzOjpQT1ApICMgY2xlYW4gdXAgdGhlIGxlZnQgc2luY2UgdGhlcmUncyBubyBzaG9ydCBjaXJjdWl0XG4gICAgICAgIGxvZ2ljYWxfZXhwcmVzc2lvbi5yaWdodC5hY2NlcHQoc2VsZilcbiAgICAgICAgQGV4ZWN1dGFibGUucGF0Y2hfanVtcChAbmFtZSwgc2hvcnRfY2lyY3VpdF9leGl0KVxuICAgICAgZWxzaWYgbG9naWNhbF9leHByZXNzaW9uLm9wZXJhdG9yLnR5cGUgPT0gVG9rZW5UeXBlczo6T1JcbiAgICAgICAgbG9naWNhbF9leHByZXNzaW9uLmxlZnQuYWNjZXB0KHNlbGYpXG4gICAgICAgIGVsc2VfanVtcCA9IGVtaXRfanVtcChPcGNvZGVzOjpKVU1QX09OX0ZBTFNFKVxuICAgICAgICBlbmRfanVtcCA9IGVtaXRfanVtcChPcGNvZGVzOjpKVU1QKVxuICAgICAgICBAZXhlY3V0YWJsZS5wYXRjaF9qdW1wKEBuYW1lLCBlbHNlX2p1bXApXG4gICAgICAgIGVtaXQoT3Bjb2Rlczo6UE9QKSAjIGNsZWFuIHVwIHRoZSBsZWZ0IHNpbmNlIHRoZXJlJ3Mgbm8gc2hvcnQgY2lyY3VpdFxuICAgICAgICBsb2dpY2FsX2V4cHJlc3Npb24ucmlnaHQuYWNjZXB0KHNlbGYpXG4gICAgICAgIEBleGVjdXRhYmxlLnBhdGNoX2p1bXAoQG5hbWUsIGVuZF9qdW1wKVxuICAgICAgZWxzZVxuICAgICAgICBmYWlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF91bmFyeSh1bmFyeV9leHByZXNzaW9uKVxuICAgICAgdW5hcnlfZXhwcmVzc2lvbi5yaWdodC5hY2NlcHQoc2VsZilcblxuICAgICAge1xuICAgICAgICBcIi1cIiA9PiBbT3Bjb2Rlczo6TkVHQVRFXSxcbiAgICAgICAgXCIhXCIgPT4gW09wY29kZXM6Ok5PVF1cbiAgICAgIH0uZmV0Y2godW5hcnlfZXhwcmVzc2lvbi5vcGVyYXRvci5sZXhlbWUpLmVhY2ggeyB8b3B8IGVtaXQob3ApIH1cbiAgICBlbmRcblxuICAgIGRlZiB2aXNpdF9jYWxsKGNhbGxfZXhwcmVzc2lvbilcbiAgICAgIGNhbGxfZXhwcmVzc2lvbi5jYWxsZWUuYWNjZXB0KHNlbGYpXG4gICAgICBjYWxsX2V4cHJlc3Npb24uYXJndW1lbnRzLmVhY2ggeyB8YXJnfCBhcmcuYWNjZXB0KHNlbGYpIH1cblxuICAgICAgZW1pdF90d28oT3Bjb2Rlczo6Q0FMTCwgY2FsbF9leHByZXNzaW9uLmFyZ3VtZW50cy5jb3VudClcbiAgICBlbmRcblxuICAgIGRlZiBlbWl0KG9wY29kZSlcbiAgICAgIEBleGVjdXRhYmxlLndyaXRlKEBuYW1lLCBvcGNvZGUpXG4gICAgZW5kXG5cbiAgICBkZWYgZW1pdF90d28ob3Bjb2RlLCBvcGVyYW5kKVxuICAgICAgZW1pdChvcGNvZGUpXG4gICAgICBlbWl0KG9wZXJhbmQpXG4gICAgZW5kXG5cbiAgICBkZWYgZW1pdF9qdW1wKGp1bXBfb3Bjb2RlKVxuICAgICAgZW1pdChqdW1wX29wY29kZSlcbiAgICAgIGVtaXQoXCJQTEFDRUhPTERFUlwiKVxuICAgICAgZW1pdChcIlBMQUNFSE9MREVSXCIpXG5cbiAgICAgIEBleGVjdXRhYmxlLnNpemUoQG5hbWUpIC0gMlxuICAgIGVuZFxuXG4gICAgZGVmIGVtaXRfcmV0dXJuXG4gICAgICBlbWl0KE9wY29kZXM6Ok5JTF9PUClcbiAgICAgIGVtaXQoT3Bjb2Rlczo6UkVUVVJOKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkFMb3g+IiwiPGNsYXNzOkNvbXBpbGVyPiIsIjxjbGFzczpGdW5jdGlvbkRlc2NyaXB0b3I+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIm5hbWUiLCJhcml0eSIsInVwdmFsdWVzIiwiQGFyaXR5IiwiQG5hbWUiLCJAdXB2YWx1ZXMiLCJ1cHZhbHVlX2NvdW50IiwiY291bnQiLCJzZXJpYWxpemUiLCJzdGF0ZW1lbnRzIiwiZXhlY3V0YWJsZSIsIjAiLCJAc3RhdGVtZW50cyIsIkBleGVjdXRhYmxlIiwiQGZ1bmN0aW9uIiwiRnVuY3Rpb25EZXNjcmlwdG9yIiwibmV3IiwiQGVycm9yX3JlcG9ydGVyIiwiZXJyb3JfcmVwb3J0ZXIiLCJyZXNldF9mdW5jdGlvbiIsImNvbXBpbGUiLCJlYWNoIiwiYmxvY2sgaW4gY29tcGlsZSIsInN0YXRlbWVudCIsImJsb2NrICgyIGxldmVscykgaW4gY29tcGlsZSIsImFjY2VwdCIsImVtaXRfcmV0dXJuIiwiYWRkX2NvbnN0YW50IiwiY29uc3RhbnQiLCJ2aXNpdF9leHByZXNzaW9uX3N0YXRlbWVudCIsImV4cHJlc3Npb25fc3RhdGVtZW50IiwiZXhwcmVzc2lvbiIsImVtaXQiLCJPcGNvZGVzOjpQT1AiLCJPcGNvZGVzIiwidmlzaXRfZnVuY3Rpb25fc3RhdGVtZW50IiwiZnVuY3Rpb25fc3RhdGVtZW50IiwiZnVuY3Rpb24kIiwiQ29tcGlsZXIiLCJib2R5IiwiZnVsbF9uYW1lIiwicGFyYW1ldGVycyIsImVtaXRfdHdvIiwiT3Bjb2Rlczo6TE9BRF9DTE9TVVJFIiwiYmxvY2sgaW4gdmlzaXRfZnVuY3Rpb25fc3RhdGVtZW50IiwidXB2YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gdmlzaXRfZnVuY3Rpb25fc3RhdGVtZW50IiwibG9jYWwiLCIxIiwic2xvdCIsImFsbG9jYXRpb24iLCJnbG9iYWw/IiwiY29uc3RhbnRfaW5kZXgiLCJsZXhlbWUiLCJPcGNvZGVzOjpERUZJTkVfR0xPQkFMIiwibG9jYWw/IiwidmlzaXRfcmV0dXJuX3N0YXRlbWVudCIsInJldHVybl9zdGF0ZW1lbnQiLCJ2YWx1ZSIsIk9wY29kZXM6Ok5JTF9PUCIsIk9wY29kZXM6OlJFVFVSTiIsInZpc2l0X3ByaW50X3N0YXRlbWVudCIsInByaW50X3N0YXRlbWVudCIsIk9wY29kZXM6OlBSSU5UIiwidmlzaXRfdmFyX3N0YXRlbWVudCIsInZhcl9zdGF0ZW1lbnQiLCJpbml0aWFsaXplciIsImZhaWwiLCJ2aXNpdF9ibG9ja19zdGF0ZW1lbnQiLCJibG9ja19zdGF0ZW1lbnQiLCJibG9jayBpbiB2aXNpdF9ibG9ja19zdGF0ZW1lbnQiLCJibG9jayAoMiBsZXZlbHMpIGluIHZpc2l0X2Jsb2NrX3N0YXRlbWVudCIsImxvY2FscyIsImNhcHR1cmVkIiwiT3Bjb2Rlczo6Q0xPU0VfVVBWQUxVRSIsInZpc2l0X2lmX3N0YXRlbWVudCIsImlmX3N0YXRlbWVudCIsImNvbmRpdGlvbiIsImVsc2VfanVtcF9vZmZzZXQiLCJlbWl0X2p1bXAiLCJPcGNvZGVzOjpKVU1QX09OX0ZBTFNFIiwidGhlbl9icmFuY2giLCJleGl0X2p1bXAiLCJPcGNvZGVzOjpKVU1QIiwicGF0Y2hfanVtcCIsImVsc2VfYnJhbmNoIiwidmlzaXRfd2hpbGVfc3RhdGVtZW50Iiwid2hpbGVfc3RhdGVtZW50IiwiYmVnaW5fbG9vcF9vZmZzZXQiLCJmdW5jdGlvbnMiLCJbXSIsInNpemUiLCJleGl0X2xvb3Bfb2Zmc2V0IiwiQmluYXJ5VXRpbHMiLCJwYWNrX3Nob3J0IiwiLSIsIjIiLCJ2aXNpdF9jbGFzc19zdGF0ZW1lbnQiLCJ2aXNpdF9hc3NpZ24iLCJhc3NpZ25fZXhwcmVzc2lvbiIsIk9wY29kZXM6OlNFVF9HTE9CQUwiLCJPcGNvZGVzOjpTRVRfTE9DQUwiLCJ1cHZhbHVlPyIsIk9wY29kZXM6OlNFVF9VUFZBTFVFIiwidmlzaXRfdmFyaWFibGUiLCJ2YXJpYWJsZV9leHByZXNzaW9uIiwiT3Bjb2Rlczo6R0VUX0dMT0JBTCIsIk9wY29kZXM6OkdFVF9MT0NBTCIsIk9wY29kZXM6OkdFVF9VUFZBTFVFIiwidmlzaXRfYmluYXJ5IiwiYmluYXJ5X2V4cHJlc3Npb24iLCJsZWZ0IiwicmlnaHQiLCJPcGNvZGVzOjpBREQiLCJPcGNvZGVzOjpTVUJUUkFDVCIsIk9wY29kZXM6Ok1VTFRJUExZIiwiT3Bjb2Rlczo6RElWSURFIiwiT3Bjb2Rlczo6RVFVQUwiLCJPcGNvZGVzOjpOT1QiLCJPcGNvZGVzOjpHUkVBVEVSIiwiT3Bjb2Rlczo6TEVTU0VSIiwiZmV0Y2giLCJvcGVyYXRvciIsImJsb2NrIGluIHZpc2l0X2JpbmFyeSIsIm9wIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB2aXNpdF9iaW5hcnkiLCJ2aXNpdF9ncm91cGluZyIsImdyb3VwaW5nX2V4cHJlc3Npb24iLCJ2aXNpdF9saXRlcmFsIiwibGl0ZXJhbF9leHByZXNzaW9uIiwiT3Bjb2Rlczo6VFJVRV9PUCIsIk9wY29kZXM6OkZBTFNFX09QIiwibmlsPyIsIk9wY29kZXM6OkxPQURfQ09OU1RBTlQiLCJ2aXNpdF9sb2dpY2FsIiwibG9naWNhbF9leHByZXNzaW9uIiwidHlwZSIsIlRva2VuVHlwZXM6OkFORCIsIlRva2VuVHlwZXMiLCJzaG9ydF9jaXJjdWl0X2V4aXQiLCJUb2tlblR5cGVzOjpPUiIsImVsc2VfanVtcCIsImVuZF9qdW1wIiwidmlzaXRfdW5hcnkiLCJ1bmFyeV9leHByZXNzaW9uIiwiT3Bjb2Rlczo6TkVHQVRFIiwiYmxvY2sgaW4gdmlzaXRfdW5hcnkiLCJibG9jayAoMiBsZXZlbHMpIGluIHZpc2l0X3VuYXJ5IiwidmlzaXRfY2FsbCIsImNhbGxfZXhwcmVzc2lvbiIsImNhbGxlZSIsImFyZ3VtZW50cyIsImJsb2NrIGluIHZpc2l0X2NhbGwiLCJhcmciLCJibG9jayAoMiBsZXZlbHMpIGluIHZpc2l0X2NhbGwiLCJPcGNvZGVzOjpDQUxMIiwib3Bjb2RlIiwid3JpdGUiLCJvcGVyYW5kIiwianVtcF9vcGNvZGUiXSwibWFwcGluZ3MiOiJBQUFBQSxxREFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDRUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsYUFBQUEsQ0FBWSxPQUFaLEVBQW9CLE1BQXBCQTs7QUFFQUMsUUFBQUEsMEJBQUFBLHNCQUFlQyxJQUFELEVBQU9DLEtBQVAsRUFBY0MsUUFBNUJIO0FBQUFBLFVBQUFBOzs7VUFDRUksYUFBU0Y7VUFDVEcsWUFBUUo7VUFDUkQsT0FBQU0sQ0FBQUEsZ0JBQVlILFFBQVpHO1FBSEZOLENBQUFBLEdBQUFBOztBQU1BTyxRQUFBQSw2QkFBQUEseUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBRCxhQUFTRSxPQUFBQSxD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d0JBQUFBLG9CQUFha0gsTUFBRCxFQUFTRSxPQUFyQnBIO0FBQUFBLFFBQUFBOzs7UUFDRTdDLElBQUFtQyxNQUFBQSxDQUFLNEgsTUFBTDVIO1FBQ0FVLE9BQUE3QyxJQUFBbUMsTUFBQUEsQ0FBSzhILE9BQUw5SDtNQUZGVSxDQUFBQSxHQUFBQTs7QUFLQXFDLE1BQUFBLHlCQUFBQSxxQkFBY2dGLFdBQWRoRjtBQUFBQSxRQUFBQTs7O1FBQ0VsRixJQUFBbUMsTUFBQUEsQ0FBSytILFdBQUwvSDtRQUNBbkMsSUFBQW1DLE1BQUFBLENBQUsrQyxhQUFML0M7UUFDQW5DLElBQUFtQyxNQUFBQSxDQUFLK0MsYUFBTC9DO1FBRUErQyxPQUF3QmdCLFVBQXhCbEYsZUFBVzhFLE1BQUFBLENBQU12RixTQUFOdUYsQ0FBYUksRUFBRUMsQ0FBRkQ7TUFMMUJoQixDQUFBQSxHQUFBQTtNQVFBcEYsT0FBQStCLDJCQUFBQSx1QkFBQUE7QUFBQUEsUUFBQUE7OztRQUNFN0IsSUFBQW1DLE1BQUFBLENBQUsyQixJQUFBekIsYUFBQXlCLFdBQUwzQjtRQUNBTixPQUFBN0IsSUFBQW1DLE1BQUFBLENBQUs0QixJQUFBMUIsYUFBQTBCLFdBQUw1QjtNQUZGTixDQUFBQSxHQUFBQTtJQTlRRi9CLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODg5NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxpYi9hX2xveC9vcGNvZGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBBTG94XG4gIG1vZHVsZSBPcGNvZGVzXG4gICAgTE9BRF9DT05TVEFOVCA9IFwiTE9BRC1DT05TVEFOVFwiXG4gICAgTE9BRF9DTE9TVVJFID0gXCJMT0FELUNMT1NVUkVcIlxuICAgIFJFVFVSTiA9IFwiUkVUVVJOXCJcblxuICAgIEFERCA9IFwiQUREXCJcbiAgICBTVUJUUkFDVCA9IFwiU1VCVFJBQ1RcIlxuICAgIE1VTFRJUExZID0gXCJNVUxUSVBMWVwiXG4gICAgRElWSURFID0gXCJESVZJREVcIlxuXG4gICAgRVFVQUwgPSBcIkVRVUFMXCJcbiAgICBHUkVBVEVSID0gXCJHUkVBVEVSXCJcbiAgICBMRVNTRVIgPSBcIkxFU1NFUlwiXG5cbiAgICBOT1QgPSBcIk5PVFwiXG4gICAgTkVHQVRFID0gXCJORUdBVEVcIlxuXG4gICAgUE9QID0gXCJQT1BcIlxuICAgIFRSVUVfT1AgPSBcIlRSVUVcIlxuICAgIEZBTFNFX09QID0gXCJGQUxTRVwiXG4gICAgTklMX09QID0gXCJOSUxcIlxuXG4gICAgUFJJTlQgPSBcIlBSSU5UXCJcblxuICAgIERFRklORV9HTE9CQUwgPSBcIkRFRklORS1HTE9CQUxcIlxuICAgIEdFVF9HTE9CQUwgPSBcIkdFVC1HTE9CQUxcIlxuICAgIFNFVF9HTE9CQUwgPSBcIlNFVC1HTE9CQUxcIlxuXG4gICAgR0VUX0xPQ0FMID0gXCJHRVQtTE9DQUxcIlxuICAgIFNFVF9MT0NBTCA9IFwiU0VULUxPQ0FMXCJcblxuICAgIEdFVF9VUFZBTFVFID0gXCJHRVQtVVBWQUxVRVwiXG4gICAgU0VUX1VQVkFMVUUgPSBcIlNFVC1VUFZBTFVFXCJcblxuICAgIENMT1NFX1VQVkFMVUUgPSBcIkNMT1NFLVVQVkFMVUVcIlxuXG4gICAgSlVNUF9PTl9GQUxTRSA9IFwiSlVNUC1PTi1GQUxTRVwiXG4gICAgSlVNUCA9IFwiSlVNUFwiXG5cbiAgICBDQUxMID0gXCJDQUxMXCJcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpBTG94PiIsIjxtb2R1bGU6T3Bjb2Rlcz4iXSwibWFwcGluZ3MiOiJBQUFBQSxvREFBQUE7RUFBQUE7O0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFDRSx5Q0FBZ0JBLGVBQWhCO01BQ0Esd0NBQWVBLGNBQWY7TUFDQSxrQ0FBU0EsUUFBVDtNQUVBLCtCQUFNQSxLQUFOO01BQ0Esb0NBQVdBLFVBQVg7TUFDQSxvQ0FBV0EsVUFBWDtNQUNBLGtDQUFTQSxRQUFUO01BRUEsaUNBQVFBLE9BQVI7TUFDQSxtQ0FBVUEsU0FBVjtNQUNBLGtDQUFTQSxRQUFUO01BRUEsK0JBQU1BLEtBQU47TUFDQSxrQ0FBU0EsUUFBVDtNQUVBLCtCQUFNQSxLQUFOO01BQ0EsbUNBQVVBLE1BQVY7TUFDQSxvQ0FBV0EsT0FBWDtNQUNBLGtDQUFTQSxLQUFUO01BRUEsaUNBQVFBLE9BQVI7TUFFQSx5Q0FBZ0JBLGVBQWhCO01BQ0Esc0NBQWFBLFlBQWI7TUFDQSxzQ0FBYUEsWUFBYjtNQUVBLHFDQUFZQSxXQUFaO01BQ0EscUNBQVlBLFdBQVo7TUFFQSx1Q0FBY0EsYUFBZDtNQUNBLHVDQUFjQSxhQUFkO01BRUEseUNBQWdCQSxlQUFoQjtNQUVBLHlDQUFnQkEsZUFBaEI7TUFDQSxnQ0FBT0EsTUFBUDtNQUVBQSxPQUFBLGdDQUFPQSxNQUFQO0lBdkNGQSxHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg5NDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL29zdHJ1Y3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgT3BlblN0cnVjdFxuICBkZWYgaW5pdGlhbGl6ZShoYXNoID0gbmlsKVxuICAgIEB0YWJsZSA9IHt9XG5cbiAgICBpZiBoYXNoXG4gICAgICBoYXNoLmVhY2hfcGFpciBkbyB8a2V5LCB2YWx1ZXxcbiAgICAgICAgQHRhYmxlW25ld19vc3RydWN0X21lbWJlcihrZXkpXSA9IHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIFtdKG5hbWUpXG4gICAgQHRhYmxlW25hbWUudG9fc3ltXVxuICBlbmRcblxuICBkZWYgW109KG5hbWUsIHZhbHVlKVxuICAgIEB0YWJsZVtuZXdfb3N0cnVjdF9tZW1iZXIobmFtZSldID0gdmFsdWVcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsICphcmdzKVxuICAgIGlmIGFyZ3MubGVuZ3RoID4gMlxuICAgICAgcmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgIzxPcGVuU3RydWN0PlwiLCBuYW1lKVxuICAgIGVuZFxuICAgIGlmIG5hbWUuZW5kX3dpdGg/ICc9J1xuICAgICAgaWYgYXJncy5sZW5ndGggIT0gMVxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSknXG4gICAgICBlbmRcbiAgICAgIEB0YWJsZVtuZXdfb3N0cnVjdF9tZW1iZXIobmFtZVswLi4tMl0pXSA9IGFyZ3NbMF1cbiAgICBlbHNlXG4gICAgICBAdGFibGVbbmFtZS50b19zeW1dXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1pZCwgaW5jbHVkZV9wcml2YXRlID0gZmFsc2UpICMgOm5vZG9jOlxuICAgIG1uYW1lID0gbWlkLnRvX3MuY2hvbXAoJz0nKS50b19zeW1cbiAgICBAdGFibGUmLmtleT8obW5hbWUpIHx8IHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3BhaXJcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfcGFpciB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAdGFibGUuZWFjaF9wYWlyIGRvIHxwYWlyfFxuICAgICAgeWllbGQgcGFpclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pc19hPyhPcGVuU3RydWN0KVxuXG4gICAgQHRhYmxlID09IG90aGVyLmluc3RhbmNlX3ZhcmlhYmxlX2dldCg6QHRhYmxlKVxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaXNfYT8oT3BlblN0cnVjdClcblxuICAgIEB0YWJsZSA9PT0gb3RoZXIuaW5zdGFuY2VfdmFyaWFibGVfZ2V0KDpAdGFibGUpXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaXNfYT8oT3BlblN0cnVjdClcblxuICAgIEB0YWJsZS5lcWw/IG90aGVyLmluc3RhbmNlX3ZhcmlhYmxlX2dldCg6QHRhYmxlKVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIEB0YWJsZS5kdXBcbiAgZW5kXG5cbiAgZGVmIHRvX25cbiAgICBAdGFibGUudG9fblxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIEB0YWJsZS5oYXNoXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDp0YWJsZVxuXG4gIGRlZiBkZWxldGVfZmllbGQobmFtZSlcbiAgICBzeW0gPSBuYW1lLnRvX3N5bVxuICAgIGJlZ2luXG4gICAgICBzaW5nbGV0b25fY2xhc3MuX19zZW5kX18oOnJlbW92ZV9tZXRob2QsIHN5bSwgXCIje3N5bX09XCIpXG4gICAgcmVzY3VlIE5hbWVFcnJvclxuICAgIGVuZFxuICAgIEB0YWJsZS5kZWxldGUgc3ltXG4gIGVuZFxuXG4gIGRlZiBuZXdfb3N0cnVjdF9tZW1iZXIobmFtZSlcbiAgICBuYW1lID0gbmFtZS50b19zeW1cbiAgICB1bmxlc3MgcmVzcG9uZF90bz8obmFtZSlcbiAgICAgIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUpIHsgQHRhYmxlW25hbWVdIH1cbiAgICAgIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKFwiI3tuYW1lfT1cIikgeyB8eHwgQHRhYmxlW25hbWVdID0geCB9XG4gICAgZW5kXG4gICAgbmFtZVxuICBlbmRcblxuICBgdmFyIG9zdHJ1Y3RfaWRzO2BcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9IChvc3RydWN0X2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICBvc3RydWN0X2lkID0gI3tfX2lkX199O1xuICAgIH1cbiAgICBiZWdpblxuICAgICAgcmVzdWx0ID0gXCIjPCN7c2VsZi5jbGFzc31cIlxuICAgICAgJXh7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBvc3RydWN0X2lkcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvc3RydWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShvc3RydWN0X2lkKSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnIC4uLj4nO1xuICAgICAgICB9XG4gICAgICAgIG9zdHJ1Y3RfaWRzW29zdHJ1Y3RfaWRdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICcgJyBpZiBAdGFibGUuYW55P1xuXG4gICAgICByZXN1bHQgKz0gZWFjaF9wYWlyLm1hcCBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICAgIFwiI3tuYW1lfT0je3ZhbHVlLmluc3BlY3R9XCJcbiAgICAgIGVuZC5qb2luICcsICdcblxuICAgICAgcmVzdWx0ICs9ICc+J1xuXG4gICAgICByZXN1bHRcbiAgICBlbnN1cmVcbiAgICAgICV4e1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgb3N0cnVjdF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk9wZW5TdHJ1Y3Q+IiwiaW5pdGlhbGl6ZSIsImhhc2giLCJAdGFibGUiLCJlYWNoX3BhaXIiLCJibG9jayBpbiBpbml0aWFsaXplIiwia2V5IiwidmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCIkd3JpdGVyIiwic2VsZiIsIm5ld19vc3RydWN0X21lbWJlciIsIltdPSIsIi0iLCIxIiwiW10iLCJuYW1lIiwidG9fc3ltIiwibWV0aG9kX21pc3NpbmciLCI+IiwiYXJncyIsImxlbmd0aCIsIjIiLCJyYWlzZSIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJlbmRfd2l0aD8iLCJBcmd1bWVudEVycm9yIiwiMCIsIi0yIiwicmVzcG9uZF90b19taXNzaW5nPyIsIm1pZCIsImluY2x1ZGVfcHJpdmF0ZSIsIm1uYW1lIiwidG9fcyIsImNob21wIiwiJHJldF9vcl8xIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJibG9jayBpbiBlYWNoX3BhaXIiLCJwYWlyIiwiPT0iLCJvdGhlciIsImlzX2E/IiwiT3BlblN0cnVjdCIsImluc3RhbmNlX3ZhcmlhYmxlX2dldCIsIj09PSIsImVxbD8iLCJ0b19oIiwiZHVwIiwidG9fbiIsImF0dHJfcmVhZGVyIiwiZGVsZXRlX2ZpZWxkIiwic3ltIiwic2luZ2xldG9uX2NsYXNzIiwiX19zZW5kX18iLCJOYW1lRXJyb3IiLCJkZWxldGUiLCJyZXNwb25kX3RvPyIsImRlZmluZV9zaW5nbGV0b25fbWV0aG9kIiwiYmxvY2sgaW4gbmV3X29zdHJ1Y3RfbWVtYmVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuZXdfb3N0cnVjdF9tZW1iZXIiLCJ4IiwiaW5zcGVjdCIsIl9faWRfXyIsInJlc3VsdCIsImNsYXNzIiwiYW55PyIsIisiLCJtYXAiLCJibG9jayBpbiBpbnNwZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnNwZWN0Iiwiam9pbiJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7O0FBQ0VDLElBQUFBLDBCQUFBQSxzQkFBZUMsSUFBZkQ7QUFBQUEsTUFBQUE7Ozs7TUFBZSx5QkFBTyxHQUFQO01BQ2JFLGFBQVMsWUFBQTtNQUVULElBQUEsUUFBR0QsSUFBSCxDQUFBO1FBQ0VELE9BQUlHLE1BQUpGLElBQUlFLGFBQUFBLEVBQUFBLEVBQUFBLEVBQUpDLGFBQW1CQyxHQUFELEVBQU1DLEtBQXhCRixFQUFBRztBQUFBQTs7OztVQUFtQjs7VUFBSztVQUw5QkMsVUFBQSxDQU1lQyxJQUFBQyxvQkFBQUEsQ0FBbUJMLEdBQW5CSyxD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QSxDQUFBQSxHQUFBQTtJQW1DQS9ELE9BQUEsYUFBTSxNQUFOLEVBQVcsU0FBWDtFQXJJRkEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5MTgzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibGliL2FfbG94L3ZtLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgXCJvc3RydWN0XCJcblxubW9kdWxlIEFMb3hcbiAgY2xhc3MgVk1cbiAgICBjbGFzcyBDYWxsYWJsZVxuICAgICAgZGVmIHNlbGYudG9wX2xldmVsX3NjcmlwdFxuICAgICAgICBPcGVuU3RydWN0Lm5ldyhcbiAgICAgICAgICBmdW5jdGlvbl9uYW1lOiBcIl9fdG9wbGV2ZWxfX1wiLFxuICAgICAgICAgIHVwdmFsdWVzOiBbXVxuICAgICAgICApXG4gICAgICBlbmRcblxuICAgICAgYXR0cl9yZWFkZXIgOnVwdmFsdWVzXG5cbiAgICAgIGRlZiBpbml0aWFsaXplKGZ1bmN0aW9uX2Rlc2NyaXB0b3IsIHVwdmFsdWVzKVxuICAgICAgICBAZnVuY3Rpb25fZGVzY3JpcHRvciA9IGZ1bmN0aW9uX2Rlc2NyaXB0b3JcbiAgICAgICAgQHVwdmFsdWVzID0gdXB2YWx1ZXNcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgZnVuY3Rpb25fbmFtZVxuICAgICAgICBAZnVuY3Rpb25fZGVzY3JpcHRvci5uYW1lXG4gICAgICBlbmRcblxuICAgICAgZGVmIGFyaXR5XG4gICAgICAgIEBmdW5jdGlvbl9kZXNjcmlwdG9yLmFyaXR5XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGNsYXNzIENhbGxGcmFtZVxuICAgICAgYXR0cl9yZWFkZXIgOmNhbGxhYmxlLCA6c3RhY2tfdG9wXG5cbiAgICAgIGRlZiBpbml0aWFsaXplKGV4ZWN1dGFibGUsIHN0YWNrLCBjYWxsYWJsZSwgc3RhY2tfdG9wID0gMClcbiAgICAgICAgQGV4ZWN1dGFibGUgPSBleGVjdXRhYmxlXG4gICAgICAgIEBzdGFjayA9IHN0YWNrXG4gICAgICAgIEBjYWxsYWJsZSA9IGNhbGxhYmxlXG4gICAgICAgIEBpcCA9IDBcbiAgICAgICAgQHN0YWNrX3RvcCA9IHN0YWNrX3RvcFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiByZWFkX2NvZGVcbiAgICAgICAgQGlwICs9IDFcbiAgICAgICAgQGV4ZWN1dGFibGUuZnVuY3Rpb25zW0BjYWxsYWJsZS5mdW5jdGlvbl9uYW1lXVtAaXAgLSAxXVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiByZWFkX3Nob3J0XG4gICAgICAgIEJpbmFyeVV0aWxzLnVucGFja19zaG9ydChyZWFkX2NvZGUsIHJlYWRfY29kZSlcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgcmVhZF9jb25zdGFudChjb25zdGFudF9pbmRleClcbiAgICAgICAgQGV4ZWN1dGFibGUuY29uc3RhbnRzW2NvbnN0YW50X2luZGV4XVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBnZXRfc3RhY2tfc2xvdChvZmZzZXQpXG4gICAgICAgIEBzdGFja1tAc3RhY2tfdG9wICsgb2Zmc2V0XVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBzZXRfc3RhY2tfc2xvdChvZmZzZXQsIHZhbHVlKVxuICAgICAgICBAc3RhY2tbQHN0YWNrX3RvcCArIG9mZnNldF0gPSB2YWx1ZVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBqdW1wKGxvY2F0aW9uKVxuICAgICAgICBAaXAgKz0gbG9jYXRpb25cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY2xhc3MgVXB2YWx1ZVxuICAgICAgYXR0cl9yZWFkZXIgOnBvaW50ZXJcblxuICAgICAgZGVmIGluaXRpYWxpemUocG9pbnRlciwgc3RhY2spXG4gICAgICAgIEBwb2ludGVyID0gcG9pbnRlclxuICAgICAgICBAc3RhY2sgPSBzdGFja1xuICAgICAgZW5kXG5cbiAgICAgIGRlZiBjbG9zZSFcbiAgICAgICAgQHZhbHVlID0gQHN0YWNrW3BvaW50ZXJdXG4gICAgICBlbmRcblxuICAgICAgZGVmIHZhbHVlXG4gICAgICAgIEB2YWx1ZSB8fCBAc3RhY2tbcG9pbnRlcl1cbiAgICAgIGVuZFxuXG4gICAgICBkZWYgc2V0X3ZhbHVlKG5ld192YWx1ZSlcbiAgICAgICAgaWYgZGVmaW5lZD8gQHZhbHVlXG4gICAgICAgICAgQHZhbHVlID0gbmV3X3ZhbHVlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBAc3RhY2tbcG9pbnRlcl0gPSBuZXdfdmFsdWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmV4ZWN1dGUoZXhlY3V0YWJsZSwgb3V0OiAkc3Rkb3V0LCBkZWJ1ZzogZmFsc2UpXG4gICAgICBuZXcuZXhlY3V0ZShleGVjdXRhYmxlLCBvdXQ6IG91dCwgZGVidWc6IGRlYnVnKVxuICAgIGVuZFxuXG4gICAgZGVmIGluaXRpYWxpemUoZXJyb3JfcmVwb3J0ZXI6IG5pbClcbiAgICAgIEBzdGFjayA9IFtdXG4gICAgICBAZ2xvYmFscyA9IHt9XG4gICAgICBAZXJyb3JfcmVwb3J0ZXIgPSBlcnJvcl9yZXBvcnRlclxuICAgIGVuZFxuXG4gICAgZGVmIGV4ZWN1dGUoZXhlY3V0YWJsZSwgb3V0OiAkc3Rkb3V0LCBkZWJ1ZzogZmFsc2UpXG4gICAgICBjYWxsX2ZyYW1lcyA9IFtcbiAgICAgICAgQ2FsbEZyYW1lLm5ldyhleGVjdXRhYmxlLCBAc3RhY2ssIENhbGxhYmxlLnRvcF9sZXZlbF9zY3JpcHQpXG4gICAgICBdXG5cbiAgICAgIG9wZW5fdXB2YWx1ZXMgPSBbXVxuXG4gICAgICBAaGFkX2Vycm9yID0gZmFsc2VcblxuXG4gICAgICBsb29wIGRvXG4gICAgICAgIGNhbGxfZnJhbWUgPSBjYWxsX2ZyYW1lcy5sYXN0XG5cbiAgICAgICAgYnJlYWsgaWYgY2FsbF9mcmFtZS5uaWw/XG4gICAgICAgIGJyZWFrIGlmIEBoYWRfZXJyb3JcblxuICAgICAgICBvcCA9IGNhbGxfZnJhbWUucmVhZF9jb2RlXG5cbiAgICAgICAgY2FzZSBvcFxuICAgICAgICB3aGVuIE9wY29kZXM6OkxPQURfQ09OU1RBTlRcbiAgICAgICAgICBAc3RhY2sucHVzaChjYWxsX2ZyYW1lLnJlYWRfY29uc3RhbnQoY2FsbF9mcmFtZS5yZWFkX2NvZGUpKVxuICAgICAgICB3aGVuIE9wY29kZXM6OkxPQURfQ0xPU1VSRVxuICAgICAgICAgIGZ1bmN0aW9uX2Rlc2NyaXB0b3IgPSBjYWxsX2ZyYW1lLnJlYWRfY29uc3RhbnQoY2FsbF9mcmFtZS5yZWFkX2NvZGUpXG5cbiAgICAgICAgICB1cHZhbHVlcyA9XG4gICAgICAgICAgICBmdW5jdGlvbl9kZXNjcmlwdG9yLnVwdmFsdWVfY291bnQudGltZXMubWFwIGRvIHx1cHZhbHVlX2Rlc2NyaXB0aW9ufFxuICAgICAgICAgICAgICBpc19sb2NhbCwgc2xvdCA9IGNhbGxfZnJhbWUucmVhZF9jb2RlLCBjYWxsX2ZyYW1lLnJlYWRfY29kZVxuXG4gICAgICAgICAgICAgIGlmIGlzX2xvY2FsID09IDFcbiAgICAgICAgICAgICAgICBuZXdfdXB2YWx1ZSA9XG4gICAgICAgICAgICAgICAgICBvcGVuX3VwdmFsdWVzLmRldGVjdCB7IF8xLnBvaW50ZXIgPT0gY2FsbF9mcmFtZS5zdGFja190b3AgKyBzbG90IH0gfHxcbiAgICAgICAgICAgICAgICAgICAgVXB2YWx1ZS5uZXcoY2FsbF9mcmFtZS5zdGFja190b3AgKyBzbG90LCBAc3RhY2spXG5cbiAgICAgICAgICAgICAgICBvcGVuX3VwdmFsdWVzIDw8IG5ld191cHZhbHVlXG4gICAgICAgICAgICAgICAgb3Blbl91cHZhbHVlcy5zb3J0X2J5ISB7IC0oXzEucG9pbnRlcikgfVxuXG4gICAgICAgICAgICAgICAgbmV3X3VwdmFsdWVcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGxfZnJhbWUuY2FsbGFibGUudXB2YWx1ZXNbc2xvdF1cbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbmRcblxuICAgICAgICAgIEBzdGFjay5wdXNoKFxuICAgICAgICAgICAgQ2FsbGFibGUubmV3KGZ1bmN0aW9uX2Rlc2NyaXB0b3IsIHVwdmFsdWVzKVxuICAgICAgICAgIClcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpTRVRfR0xPQkFMXG4gICAgICAgICAgQGdsb2JhbHNbY2FsbF9mcmFtZS5yZWFkX2NvbnN0YW50KGNhbGxfZnJhbWUucmVhZF9jb2RlKV0gPSBAc3RhY2subGFzdFxuICAgICAgICB3aGVuIE9wY29kZXM6OkRFRklORV9HTE9CQUxcbiAgICAgICAgICBAZ2xvYmFsc1tjYWxsX2ZyYW1lLnJlYWRfY29uc3RhbnQoY2FsbF9mcmFtZS5yZWFkX2NvZGUpXSA9IEBzdGFjay5wb3BcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpHRVRfR0xPQkFMXG4gICAgICAgICAgZ2xvYmFsX25hbWUgPSBjYWxsX2ZyYW1lLnJlYWRfY29uc3RhbnQoY2FsbF9mcmFtZS5yZWFkX2NvZGUpXG4gICAgICAgICAgZXJyb3IoXCJVbmRlZmluZWQgZ2xvYmFsICN7Z2xvYmFsX25hbWV9XCIpIHVubGVzcyBAZ2xvYmFscy5oYXNfa2V5PyhnbG9iYWxfbmFtZSlcbiAgICAgICAgICBAc3RhY2sucHVzaChAZ2xvYmFsc1tnbG9iYWxfbmFtZV0pXG4gICAgICAgIHdoZW4gT3Bjb2Rlczo6U0VUX0xPQ0FMXG4gICAgICAgICAgY2FsbF9mcmFtZS5zZXRfc3RhY2tfc2xvdChjYWxsX2ZyYW1lLnJlYWRfY29kZSwgQHN0YWNrLmxhc3QpXG4gICAgICAgIHdoZW4gT3Bjb2Rlczo6R0VUX0xPQ0FMXG4gICAgICAgICAgQHN0YWNrLnB1c2goY2FsbF9mcmFtZS5nZXRfc3RhY2tfc2xvdChjYWxsX2ZyYW1lLnJlYWRfY29kZSkpXG4gICAgICAgIHdoZW4gT3Bjb2Rlczo6R0VUX1VQVkFMVUVcbiAgICAgICAgICBAc3RhY2sucHVzaChjYWxsX2ZyYW1lLmNhbGxhYmxlLnVwdmFsdWVzW2NhbGxfZnJhbWUucmVhZF9jb2RlXS52YWx1ZSlcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpTRVRfVVBWQUxVRVxuICAgICAgICAgIGNhbGxfZnJhbWUuY2FsbGFibGUudXB2YWx1ZXNbY2FsbF9mcmFtZS5yZWFkX2NvZGVdLnNldF92YWx1ZShAc3RhY2subGFzdClcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpOSUxfT1BcbiAgICAgICAgICBAc3RhY2sucHVzaChuaWwpXG4gICAgICAgIHdoZW4gT3Bjb2Rlczo6VFJVRV9PUFxuICAgICAgICAgIEBzdGFjay5wdXNoKHRydWUpXG4gICAgICAgIHdoZW4gT3Bjb2Rlczo6RkFMU0VfT1BcbiAgICAgICAgICBAc3RhY2sucHVzaChmYWxzZSlcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpOT1RcbiAgICAgICAgICBAc3RhY2sucHVzaChmYWxzZXk/KEBzdGFjay5wb3ApKVxuICAgICAgICB3aGVuIE9wY29kZXM6Ok5FR0FURVxuICAgICAgICAgIEBzdGFjay5wdXNoKC1Ac3RhY2sucG9wKVxuICAgICAgICB3aGVuIE9wY29kZXM6OlBPUFxuICAgICAgICAgIGZhaWwgJ2NvcnJ1cHRlZCBzdGFjaycgaWYgQHN0YWNrLmVtcHR5P1xuICAgICAgICAgIEBzdGFjay5wb3BcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpBRERcbiAgICAgICAgICBiLCBhID0gQHN0YWNrLnBvcCwgQHN0YWNrLnBvcFxuICAgICAgICAgIEBzdGFjay5wdXNoKGEgKyBiKVxuICAgICAgICB3aGVuIE9wY29kZXM6OlNVQlRSQUNUXG4gICAgICAgICAgYiwgYSA9IEBzdGFjay5wb3AsIEBzdGFjay5wb3BcbiAgICAgICAgICBAc3RhY2sucHVzaChhIC0gYilcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpESVZJREVcbiAgICAgICAgICBiLCBhID0gQHN0YWNrLnBvcCwgQHN0YWNrLnBvcFxuICAgICAgICAgIEBzdGFjay5wdXNoKGEgLyBiKVxuICAgICAgICB3aGVuIE9wY29kZXM6Ok1VTFRJUExZXG4gICAgICAgICAgYiwgYSA9IEBzdGFjay5wb3AsIEBzdGFjay5wb3BcbiAgICAgICAgICBAc3RhY2sucHVzaChhICogYilcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpFUVVBTFxuICAgICAgICAgIEBzdGFjay5wdXNoKGVxdWFsPyhAc3RhY2sucG9wLCBAc3RhY2sucG9wKSlcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpHUkVBVEVSXG4gICAgICAgICAgYiwgYSA9IEBzdGFjay5wb3AsIEBzdGFjay5wb3BcbiAgICAgICAgICBAc3RhY2sucHVzaChhID4gYilcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpMRVNTRVJcbiAgICAgICAgICBiLCBhID0gQHN0YWNrLnBvcCwgQHN0YWNrLnBvcFxuICAgICAgICAgIEBzdGFjay5wdXNoKGEgPCBiKVxuICAgICAgICB3aGVuIE9wY29kZXM6OkNBTExcbiAgICAgICAgICBhcmd1bWVudF9jb3VudCA9IGNhbGxfZnJhbWUucmVhZF9jb2RlXG4gICAgICAgICAgY2FsbGFibGUgPSBAc3RhY2tbLWFyZ3VtZW50X2NvdW50IC0gMV1cblxuICAgICAgICAgIGlmIGNhbGxhYmxlLmlzX2E/IENhbGxhYmxlXG4gICAgICAgICAgICBpZiBjYWxsYWJsZS5hcml0eSA9PSBhcmd1bWVudF9jb3VudFxuICAgICAgICAgICAgICBjYWxsX2ZyYW1lcyA8PCBDYWxsRnJhbWUubmV3KFxuICAgICAgICAgICAgICAgIGV4ZWN1dGFibGUsXG4gICAgICAgICAgICAgICAgQHN0YWNrLFxuICAgICAgICAgICAgICAgIGNhbGxhYmxlLFxuICAgICAgICAgICAgICAgIEBzdGFjay5zaXplIC0gYXJndW1lbnRfY291bnRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBlcnJvcihcImZ1bmN0aW9uICN7Y2FsbGFibGUuZnVuY3Rpb25fbmFtZX0gdGFrZXMgI3tjYWxsYWJsZS5hcml0eX0gYXJndW1lbnRzIGJ1dCAje2FyZ3VtZW50X2NvdW50fSBwcm92aWRlZFwiKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXJyb3IoXCIje2xveF9vYmplY3RfdG9fc3RyaW5nKGNhbGxhYmxlKX0gaXMgbm90IGNhbGxhYmxlXCIpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHdoZW4gT3Bjb2Rlczo6UkVUVVJOXG4gICAgICAgICAgcmVzdWx0ID0gQHN0YWNrLnBvcFxuXG4gICAgICAgICAgd2hpbGUgb3Blbl91cHZhbHVlcy5jb3VudCA+IDAgJiYgb3Blbl91cHZhbHVlcy5maXJzdC5wb2ludGVyID49IGNhbGxfZnJhbWUuc3RhY2tfdG9wXG4gICAgICAgICAgICB1cHZhbHVlID0gb3Blbl91cHZhbHVlcy5zaGlmdFxuICAgICAgICAgICAgdXB2YWx1ZS5jbG9zZSFcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIGNhbGxfZnJhbWVzLnBvcFxuXG4gICAgICAgICAgQHN0YWNrWzAuLi0xXSA9IEBzdGFja1swLi4uY2FsbF9mcmFtZS5zdGFja190b3AgLSAxXVxuXG4gICAgICAgICAgQHN0YWNrLnB1c2gocmVzdWx0KVxuICAgICAgICB3aGVuIE9wY29kZXM6OkNMT1NFX1VQVkFMVUVcbiAgICAgICAgICBmYWlsICdjb3JydXB0ZWQgdXB2YWx1ZXMnIGlmIG9wZW5fdXB2YWx1ZXMuZW1wdHk/XG4gICAgICAgICAgb3Blbl91cHZhbHVlcy5zaGlmdC5jbG9zZSFcblxuICAgICAgICAgIGZhaWwgJ2NvcnJ1cHRlZCBzdGFjaycgaWYgQHN0YWNrLmVtcHR5P1xuICAgICAgICAgIEBzdGFjay5wb3BcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpQUklOVFxuICAgICAgICAgIG91dC5wdXRzKGxveF9vYmplY3RfdG9fc3RyaW5nKEBzdGFjay5wb3ApKVxuICAgICAgICB3aGVuIE9wY29kZXM6OkpVTVBfT05fRkFMU0VcbiAgICAgICAgICBsb2NhdGlvbiA9IGNhbGxfZnJhbWUucmVhZF9zaG9ydFxuICAgICAgICAgIGNhbGxfZnJhbWUuanVtcChsb2NhdGlvbikgaWYgZmFsc2V5PyhAc3RhY2subGFzdClcbiAgICAgICAgd2hlbiBPcGNvZGVzOjpKVU1QXG4gICAgICAgICAgY2FsbF9mcmFtZS5qdW1wKGNhbGxfZnJhbWUucmVhZF9zaG9ydClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZhaWwgb3AuaW5zcGVjdFxuICAgICAgICBlbmRcblxuICAgICAgICBwcmludF9kZWJ1Z19pbmZvKGJpbmRpbmcpIGlmIGRlYnVnXG4gICAgICBlbmRcblxuICAgICAgQHN0YWNrLnBvcFxuXG4gICAgICBmYWlsICdjb3JydXB0ZWQgb3BlbiB1cHZhbHVlcycgaWYgb3Blbl91cHZhbHVlcy5hbnk/XG4gICAgZW5kXG5cbiAgICBwcml2YXRlXG5cbiAgICBkZWYgZmFsc2V5Pyh2YWx1ZSlcbiAgICAgICF2YWx1ZVxuICAgIGVuZFxuXG4gICAgZGVmIGVxdWFsPyhhLCBiKVxuICAgICAgYSA9PSBiICMgVE9ET1xuICAgIGVuZFxuXG4gICAgZGVmIGxveF9vYmplY3RfdG9fc3RyaW5nKGxveF9vYmplY3QpXG4gICAgICBpZiBsb3hfb2JqZWN0LmlzX2E/IENhbGxhYmxlXG4gICAgICAgIFwiZnVuICN7bG94X29iamVjdC5mdW5jdGlvbl9uYW1lfS8je2xveF9vYmplY3QuYXJpdHl9XCJcbiAgICAgIGVsc2lmIGxveF9vYmplY3QubmlsP1xuICAgICAgICBcIm5pbFwiXG4gICAgICBlbHNlXG4gICAgICAgIGxveF9vYmplY3QudG9fc1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZXJyb3IobWVzc2FnZSlcbiAgICAgIEBoYWRfZXJyb3IgPSB0cnVlXG4gICAgICBAZXJyb3JfcmVwb3J0ZXImLnJlcG9ydF9ydW50aW1lX2Vycm9yKG1lc3NhZ2UpXG4gICAgZW5kXG5cbiAgICBkZWYgcHJpbnRfZGVidWdfaW5mbyhiKVxuICAgICAgcHV0cyBiLmxvY2FsX3ZhcmlhYmxlX2dldCg6b3ApXG4gICAgICBwcmludF9zdGFja1xuICAgICAgcHV0c1xuICAgIGVuZFxuXG4gICAgZGVmIHByaW50X3N0YWNrXG4gICAgICBwdXRzIFtcbiAgICAgICAgXCJbXCIsXG4gICAgICAgICpAc3RhY2subWFwIHsgfHZhbHVlfCB2YWx1ZS5pc19hPyhDYWxsYWJsZSkgPyBcIjwje3ZhbHVlLmZ1bmN0aW9uX25hbWV9PlwiIDogdmFsdWUgfSxcbiAgICAgICAgXCJdXCJcbiAgICAgIF0uam9pbihcIiBcIilcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8bW9kdWxlOkFMb3g+IiwiPGNsYXNzOlZNPiIsIjxjbGFzczpDYWxsYWJsZT4iLCJ0b3BfbGV2ZWxfc2NyaXB0IiwiT3BlblN0cnVjdCIsIm5ldyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImZ1bmN0aW9uX2Rlc2NyaXB0b3IiLCJ1cHZhbHVlcyIsIkBmdW5jdGlvbl9kZXNjcmlwdG9yIiwiQHVwdmFsdWVzIiwiZnVuY3Rpb25fbmFtZSIsIm5hbWUiLCJhcml0eSIsIjxjbGFzczpDYWxsRnJhbWU+IiwiZXhlY3V0YWJsZSIsInN0YWNrIiwiY2FsbGFibGUiLCJzdGFja190b3AiLCIwIiwiQGV4ZWN1dGFibGUiLCJAc3RhY2siLCJAY2FsbGFibGUiLCJAaXAiLCJAc3RhY2tfdG9wIiwicmVhZF9jb2RlIiwiKyIsIjEiLCJmdW5jdGlvbnMiLCJbXSIsIi0iLCJyZWFkX3Nob3J0IiwiQmluYXJ5VXRpbHMiLCJ1bnBhY2tfc2hvcnQiLCJyZWFkX2NvbnN0YW50IiwiY29uc3RhbnRfaW5kZXgiLCJjb25zdGFudHMiLCJnZXRfc3RhY2tfc2xvdCIsIm9mZnNldCIsInNldF9zdGFja19zbG90IiwidmFsdWUiLCIkd3JpdGVyIiwiW109IiwianVtcCIsImxvY2F0aW9uIiwiPGNsYXNzOlVwdmFsdWU+IiwicG9pbnRlciIsIkBwb2ludGVyIiwiY2xvc2UhIiwiQHZhbHVlIiwiJHJldF9vcl8xIiwic2V0X3ZhbHVlIiwibmV3X3ZhbHVlIiwiZXhlY3V0ZSIsIiRrd2FyZ3MiLCIkc3Rkb3V0Iiwib3V0IiwiZGVidWciLCJAZ2xvYmFscyIsIkBlcnJvcl9yZXBvcnRlciIsImVycm9yX3JlcG9ydGVyIiwiY2FsbF9mcmFtZXMiLCJDYWxsRnJhbWUiLCJDYWxsYWJsZSIsIm9wZW5fdXB2YWx1ZXMiLCJAaGFkX2Vycm9yIiwibG9vcCIsImJsb2NrIGluIGV4ZWN1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGV4ZWN1dGUiLCJjYWxsX2ZyYW1lIiwibGFzdCIsIm5pbD8iLCJvcCIsIk9wY29kZXM6OkxPQURfQ09OU1RBTlQiLCJPcGNvZGVzIiwicHVzaCIsIk9wY29kZXM6OkxPQURfQ0xPU1VSRSIsIm1hcCIsInVwdmFsdWVfY291bnQiLCJ0aW1lcyIsInVwdmFsdWVfZGVzY3JpcHRpb24iLCJibG9jayAoMyBsZXZlbHMpIGluIGV4ZWN1dGUiLCJpc19sb2NhbCIsInNsb3QiLCJuZXdfdXB2YWx1ZSIsIiRyZXRfb3JfMiIsImRldGVjdCIsIl8xIiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiBleGVjdXRlIiwiPT0iLCJVcHZhbHVlIiwiPDwiLCJzb3J0X2J5ISIsIi1AIiwiT3Bjb2Rlczo6U0VUX0dMT0JBTCIsIk9wY29kZXM6OkRFRklORV9HTE9CQUwiLCJwb3AiLCJPcGNvZGVzOjpHRVRfR0xPQkFMIiwiZ2xvYmFsX25hbWUiLCJoYXNfa2V5PyIsImVycm9yIiwiT3Bjb2Rlczo6U0VUX0xPQ0FMIiwiT3Bjb2Rlczo6R0VUX0xPQ0FMIiwiT3Bjb2Rlczo6R0VUX1VQVkFMVUUiLCJPcGNvZGVzOjpTRVRfVVBWQUxVRSIsIk9wY29kZXM6Ok5JTF9PUCIsIk9wY29kZXM6OlRSVUVfT1AiLCJPcGNvZGVzOjpGQUxTRV9PUCIsIk9wY29kZXM6Ok5PVCIsImZhbHNleT8iLCJPcGNvZGVzOjpORUdBVEUiLCJPcGNvZGVzOjpQT1AiLCJlbXB0eT8iLCJmYWlsIiwiT3Bjb2Rlczo6QUREIiwiYiIsImEiLCJPcGNvZGVzOjpTVUJUUkFDVCIsIk9wY29kZXM6OkRJVklERSIsIi8iLCJPcGNvZGVzOjpNVUxUSVBMWSIsIioiLCJPcGNvZGVzOjpFUVVBTCIsImVxdWFsPyIsIk9wY29kZXM6OkdSRUFURVIiLCI+IiwiT3Bjb2Rlczo6TEVTU0VSIiwiPCIsIk9wY29kZXM6OkNBTEwiLCJhcmd1bWVudF9jb3VudCIsImlzX2E/Iiwic2l6ZSIsImxveF9vYmplY3RfdG9fc3RyaW5nIiwiT3Bjb2Rlczo6UkVUVVJOIiwicmVzdWx0IiwiY291bnQiLCI+PSIsImZpcnN0IiwidXB2YWx1ZSIsInNoaWZ0IiwiLTEiLCJPcGNvZGVzOjpDTE9TRV9VUFZBTFVFIiwiT3Bjb2Rlczo6UFJJTlQiLCJwdXRzIiwiT3Bjb2Rlczo6SlVNUF9PTl9GQUxTRSIsIk9wY29kZXM6OkpVTVAiLCJpbnNwZWN0IiwicHJpbnRfZGVidWdfaW5mbyIsImJpbmRpbmciLCJhbnk/IiwicHJpdmF0ZSIsIiEiLCJsb3hfb2JqZWN0IiwidG9fcyIsIm1lc3NhZ2UiLCJsb2NhbF92YXJpYWJsZV9nZXQiLCJwcmludF9zdGFjayIsImJsb2NrIGluIHByaW50X3N0YWNrIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcmludF9zdGFjayIsImpvaW4iXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixTQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLE1BQUlMLElBQUpLLHVCQUFBQSw0QkFBQUE7QUFBQUE7VUFDRUEsT0FBQUMsZ0JBQVVDLEtBQUFBLENBQ1IsdUNBQUEsaUJBQWVGLGNBQWYsRUFBQSxZQUNVLEVBRFYsRUFEUUU7UUFEWkYsQ0FBQUEsR0FBQUE7UUFPQUwsSUFBQVEsYUFBQUEsQ0FBWSxVQUFaQTs7QUFFQUMsUUFBQUEsMEJBQUFBLHNCQUFlQyxtQkFBRCxFQUFzQkMsUUFBcENGO0FBQUFBLFVBQUFBOzs7VUFDRUcsMkJBQXVCRjtVQUN2QkQsT0FBQUksQ0FBQUEsZ0JBQVlGLFFBQVpFO1FB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LENBR0grRSxHQUhHLENBQUEsQ0FJSkcsTUFBQUEsQ0FBTUgsR0FBTkcsQ0FKRGhCO01BREZhLENBQUFBLEdBQUFBO0lBdFJGNUosR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFERkQsR0FBQUEsV0FBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NjMwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibGliL2FfbG94L2JpbmFyeV91dGlscy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQUxveFxuICBtb2R1bGUgQmluYXJ5VXRpbHNcbiAgICBleHRlbmQgc2VsZlxuXG4gICAgZGVmIHBhY2tfc2hvcnQoc2hvcnQpXG4gICAgICBbc2hvcnRdLnBhY2soXCJzXCIpLmJ5dGVzXG4gICAgZW5kXG5cbiAgICBkZWYgdW5wYWNrX3Nob3J0KGJ5dGUxLCBieXRlMilcbiAgICAgIFtieXRlMSwgYnl0ZTJdLm1hcCgmOmNocikucmVkdWNlIHsgfGEsIHN8IGEgKyBzIH0udW5wYWNrMShcInNcIilcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpBTG94PiIsIjxtb2R1bGU6QmluYXJ5VXRpbHM+Iiwic2VsZiIsImV4dGVuZCIsInBhY2tfc2hvcnQiLCJzaG9ydCQiLCJwYWNrIiwiYnl0ZXMiLCJ1bnBhY2tfc2hvcnQiLCJieXRlMSIsImJ5dGUyIiwicmVkdWNlIiwibWFwIiwidG9fcHJvYyIsImJsb2NrIGluIHVucGFja19zaG9ydCIsImEiLCJzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB1bnBhY2tfc2hvcnQiLCIrIiwidW5wYWNrMSJdLCJtYXBwaW5ncyI6IkFBQUFBLHlEQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7OztNQUNFQyxJQUFBQyxRQUFBQSxDQUFPRCxJQUFQQzs7QUFFQUMsTUFBQUEsMEJBQUFBLHNCQUFlQyxNQUFmRDtBQUFBQTtRQUNFQSxPQUFBLENBQUNDLE1BQUQsQ0FBT0MsTUFBQUEsQ0FBTUYsR0FBTkUsQ0FBVUMsT0FBQUEsQ0FBQUE7TUFEbkJILENBQUFBLEdBQUFBO01BSUFILE9BQUFPLDRCQUFBQSx3QkFBaUJDLEtBQUQsRUFBUUMsS0FBeEJGO0FBQUFBO1FBQ0VBLE9BQXlCRyxNQUFYQyxNQUFkLENBQUNILEtBQUQsRUFBUUMsS0FBUixDQUFjRSxPQUFBQSxFQUFBQSxFQUFBQSxFQUFNLEtBQURDLFNBQUFBLENBQUFBLENBQUxELENBQVdELFVBQUFBLEVBQUFBLEVBQUFBLEVBQXpCRyxhQUFvQ0MsQ0FBRCxFQUFJQyxDQUF2Q0Y7OztVQUFvQzs7VUFBRztVQUFHRyxPQUFFQyxTQUFGSCxDQUFFRyxFQUFFRixDQUFGRSxFQUE1Q0osQ0FBQUEsR0FBeUJILENBQXdCUSxTQUFBQSxDQUFTWCxHQUFUVztNQURuRFgsQ0FBQUEsR0FBQUE7SUFQRlAsR0FBQUEsV0FBQUE7RUFERkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NjY0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibGliL2FfbG94LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbnJlcXVpcmVfcmVsYXRpdmUgXCJhX2xveC92ZXJzaW9uXCJcbnJlcXVpcmVfcmVsYXRpdmUgXCJhX2xveC9wcmludGVycy9wcmV0dHlfcHJpbnRlclwiXG5yZXF1aXJlX3JlbGF0aXZlIFwiYV9sb3gvcHJpbnRlcnMvcmVhY3RfdHJlZV9wcmludGVyXCJcbnJlcXVpcmVfcmVsYXRpdmUgXCJhX2xveC9zY2FubmVyXCJcbnJlcXVpcmVfcmVsYXRpdmUgXCJhX2xveC9hc3Rfbm9kZV9kc2xcIlxucmVxdWlyZV9yZWxhdGl2ZSBcImFfbG94L2V4cHJlc3Npb25cIlxucmVxdWlyZV9yZWxhdGl2ZSBcImFfbG94L3N0YXRlbWVudFwiXG5yZXF1aXJlX3JlbGF0aXZlIFwiYV9sb3gvcGFyc2VyXCJcbnJlcXVpcmVfcmVsYXRpdmUgXCJhX2xveC9zdGF0aWNfcmVzb2x2ZXIvdXB2YWx1ZXNcIlxucmVxdWlyZV9yZWxhdGl2ZSBcImFfbG94L2V4ZWN1dGFibGVfY29udGFpbmVyXCJcbnJlcXVpcmVfcmVsYXRpdmUgXCJhX2xveC9jb21waWxlclwiXG5yZXF1aXJlX3JlbGF0aXZlIFwiYV9sb3gvb3Bjb2Rlc1wiXG5yZXF1aXJlX3JlbGF0aXZlIFwiYV9sb3gvdm1cIlxucmVxdWlyZV9yZWxhdGl2ZSBcImFfbG94L2JpbmFyeV91dGlsc1wiXG5cbm1vZHVsZSBBTG94XG4gIGNsYXNzIEVycm9yIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwicmVxdWlyZV9yZWxhdGl2ZSIsIjxtb2R1bGU6QUxveD4iLCI8Y2xhc3M6RXJyb3I+IiwiU3RhbmRhcmRFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBLDRDQUFBQTtFQUFBQTs7O0VBRUFDLHVDQUFpQkQsZUFBakJDO0VBQ0FBLHVDQUFpQkQsK0JBQWpCQztFQUNBQSx1Q0FBaUJELG1DQUFqQkM7RUFDQUEsdUNBQWlCRCxlQUFqQkM7RUFDQUEsdUNBQWlCRCxvQkFBakJDO0VBQ0FBLHVDQUFpQkQsa0JBQWpCQztFQUNBQSx1Q0FBaUJELGlCQUFqQkM7RUFDQUEsdUNBQWlCRCxjQUFqQkM7RUFDQUEsdUNBQWlCRCxnQ0FBakJDO0VBQ0FBLHVDQUFpQkQsNEJBQWpCQztFQUNBQSx1Q0FBaUJELGdCQUFqQkM7RUFDQUEsdUNBQWlCRCxlQUFqQkM7RUFDQUEsdUNBQWlCRCxVQUFqQkM7RUFDQUEsdUNBQWlCRCxvQkFBakJDO0VBRUFELE9BQUFFO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsUUFBQUEsV0FBQUEsRUFBY0MsbUJBQWREO0VBREZELEdBQUFBLFdBQUFBO0FBakJBRjsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk2OTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsaWIvb3BhbF9lbnRyeXBvaW50LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInVubGVzcyBSVUJZX1BMQVRGT1JNID09IFwib3BhbFwiXG4gIHB1dHMgXCJUaGlzIGZpbGUgaXMgb25seSBzdXBwb3NlZCB0byBiZSB1c2VkIHdpdGggdGhlIE9wYWwgUnVieSAtPiBKUyB0cmFuc3BpbGVyXCJcbiAgZXhpdCgxKVxuZW5kXG5cbnJlcXVpcmUgXCJjb3JlbGliL2FycmF5L3BhY2tcIlxucmVxdWlyZSBcImNvcmVsaWIvc3RyaW5nL3VucGFja1wiXG5yZXF1aXJlIFwianNvblwiXG5yZXF1aXJlX3JlbGF0aXZlIFwiYV9sb3hcIlxuXG5jbGFzcyBDb21waWxhdGlvbkVudmlyb25tZW50XG4gIGRlZiBzZWxmLmNvbXBpbGUoc291cmNlKVxuICAgIG5ldy5jb21waWxlKHNvdXJjZSlcbiAgZW5kXG5cbiAgZGVmIGNvbXBpbGUoc291cmNlKVxuICAgIEBlcnJvcnMgPSBbXVxuXG4gICAgdG9rZW5zLCBhc3QsIGV4ZWN1dGFibGVfY29udGFpbmVyID0gbmlsLCBuaWwsIG5pbFxuXG4gICAgY2F0Y2ggOmVycm9yIGRvXG4gICAgICBleGVjdXRhYmxlX2NvbnRhaW5lciA9IEFMb3g6OkV4ZWN1dGFibGVDb250YWluZXIubmV3XG5cbiAgICAgIHRva2VucyA9IEFMb3g6OlNjYW5uZXIubmV3KHNvdXJjZSwgZXJyb3JfcmVwb3J0ZXI6IHNlbGYpLnNjYW5cbiAgICAgIHRocm93IDplcnJvciBpZiBAZXJyb3JzLmFueT9cblxuICAgICAgYXN0ID0gQUxveDo6UGFyc2VyLm5ldyh0b2tlbnMsIGVycm9yX3JlcG9ydGVyOiBzZWxmKS5wYXJzZVxuXG4gICAgICB0aHJvdyA6ZXJyb3IgaWYgQGVycm9ycy5hbnk/XG5cbiAgICAgIEFMb3g6OlN0YXRpY1Jlc29sdmVyOjpVcHZhbHVlcy5uZXcoZXJyb3JfcmVwb3J0ZXI6IHNlbGYpLnJlc29sdmUoYXN0KVxuXG4gICAgICB0aHJvdyA6ZXJyb3IgaWYgQGVycm9ycy5hbnk/XG5cbiAgICAgIEFMb3g6OkNvbXBpbGVyLm5ldyhhc3QsIGV4ZWN1dGFibGVfY29udGFpbmVyKS5jb21waWxlXG4gICAgZW5kXG5cbiAgICBbdG9rZW5zLCBhc3QsIGV4ZWN1dGFibGVfY29udGFpbmVyLCBAZXJyb3JzXVxuICBlbmRcblxuICBkZWYgcmVwb3J0X3NjYW5uZXJfZXJyb3IobGluZSwgbWVzc2FnZSlcbiAgICBAZXJyb3JzIDw8IFwic2Nhbm5lciBlcnJvci4gbGluZTogI3tsaW5lfSAtIGVycm9yOiAje21lc3NhZ2V9XCJcbiAgZW5kXG5cbiAgZGVmIHJlcG9ydF9wYXJzZXJfZXJyb3IodG9rZW4sIG1lc3NhZ2UpXG4gICAgaWYgdG9rZW4udHlwZSA9PSBBTG94OjpUb2tlblR5cGVzOjpFT0ZcbiAgICAgIEBlcnJvcnMgPDwgXCJwYXJzZXIgZXJyb3IuIGxpbmU6ICN7dG9rZW4ubGluZX0gYXQgZW5kIC0gZXJyb3I6ICN7bWVzc2FnZX1cIlxuICAgIGVsc2VcbiAgICAgIEBlcnJvcnMgPDwgXCJwYXJzZXIgZXJyb3IuIGxpbmU6ICN7dG9rZW4ubGluZX0sIHRva2VuOiAje3Rva2VuLmxleGVtZX0gLSBlcnJvcjogI3ttZXNzYWdlfVwiXG4gICAgZW5kXG5cbiAgZW5kXG5cbiAgZGVmIHJlcG9ydF9zdGF0aWNfYW5hbHlzaXNfZXJyb3IodG9rZW4sIG1lc3NhZ2UpXG4gICAgQGVycm9ycyA8PCBcInN0YXRpYyBhbmFseXNpcyBlcnJvci4gbGluZTogI3t0b2tlbi5saW5lfSAtIGVycm9yOiAje21lc3NhZ2V9XCJcbiAgZW5kXG5cbiAgZGVmIHJlcG9ydF9ydW50aW1lX2Vycm9yKG1lc3NhZ2UpXG4gICAgQGVycm9ycyA8PCBcInJ1bnRpbWUgZXJyb3I6ICN7bWVzc2FnZX1cIlxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQUxveFxuICBkZWYgc2VsZi5hbmFseXplKHNvdXJjZSlcbiAgICB0b2tlbnMsIGFzdCwgZXhlY3V0YWJsZV9jb250YWluZXIsIGVycm9ycyA9IENvbXBpbGF0aW9uRW52aXJvbm1lbnQuY29tcGlsZShzb3VyY2UpXG5cbiAgICBpZiBlcnJvcnMuYW55P1xuICAgICAge1xuICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgdG9rZW5zOiB0b2tlbnMubWFwKCY6c2VyaWFsaXplKSxcbiAgICAgICAgdHJlZTogYXN0ID8gUHJpbnRlcnM6OlJlYWN0VHJlZVByaW50ZXIubmV3KGFzdCkucHJpbnQgOiBuaWwsXG4gICAgICAgIGV4ZWN1dGFibGU6IGV4ZWN1dGFibGVfY29udGFpbmVyJi5zZXJpYWxpemVcbiAgICB9XG4gICAgZW5kLnRvX2pzb25cbiAgZW5kXG5lbmRcblxuXG5cbiJdLCJuYW1lcyI6WyI8bWFpbj4iLCJzZWxmIiwicmVxdWlyZSIsInJlcXVpcmVfcmVsYXRpdmUiLCI8Y2xhc3M6Q29tcGlsYXRpb25FbnZpcm9ubWVudD4iLCJjb21waWxlIiwic291cmNlIiwibmV3IiwiQGVycm9ycyIsInRva2VucyIsImFzdCIsImV4ZWN1dGFibGVfY29udGFpbmVyIiwiY2F0Y2giLCJibG9jayBpbiBjb21waWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb21waWxlIiwiQUxveDo6RXhlY3V0YWJsZUNvbnRhaW5lciIsIkFMb3giLCJBTG94OjpTY2FubmVyIiwic2NhbiIsImFueT8iLCJ0aHJvdyIsIkFMb3g6OlBhcnNlciIsInBhcnNlIiwiQUxveDo6U3RhdGljUmVzb2x2ZXI6OlVwdmFsdWVzIiwiQUxveDo6U3RhdGljUmVzb2x2ZXIiLCJyZXNvbHZlIiwiQUxveDo6Q29tcGlsZXIiLCJyZXBvcnRfc2Nhbm5lcl9lcnJvciIsImxpbmUiLCJtZXNzYWdlIiwiPDwiLCJyZXBvcnRfcGFyc2VyX2Vycm9yIiwidG9rZW4iLCJ0eXBlIiwiQUxveDo6VG9rZW5UeXBlczo6RU9GIiwiQUxveDo6VG9rZW5UeXBlcyIsImxleGVtZSIsInJlcG9ydF9zdGF0aWNfYW5hbHlzaXNfZXJyb3IiLCJyZXBvcnRfcnVudGltZV9lcnJvciIsIjxtb2R1bGU6QUxveD4iLCJhbmFseXplIiwiQ29tcGlsYXRpb25FbnZpcm9ubWVudCIsImVycm9ycyIsIm1hcCIsInRvX3Byb2MiLCJQcmludGVyczo6UmVhY3RUcmVlUHJpbnRlciIsIlByaW50ZXJzIiwicHJpbnQiLCJ0b19qc29uIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkJBQUFBO0VBQUFBOztFQUFBQTs7RUFBQTtFQUtBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsdUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLE1BQVJFO0VBQ0FDLGlEQUFpQkgsT0FBakJHO0VBRUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlKLElBQUpJLGNBQUFBLG1CQUFpQkMsTUFBakJEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBSixJQUFBTSxLQUFBQSxDQUFBQSxDQUFHRixTQUFBQSxDQUFTQyxNQUFURDtJQURMQSxDQUFBQSxHQUFBQTs7QUFJQUEsSUFBQUEsdUJBQUFBLG1CQUFZQyxNQUFaRDtBQUFBQSxNQUFBQTs7O01BQ0VHLGNBQVU7TUFFVixLQUFvQyxDQUFBLEdBQUEsRUFBSyxHQUFMLEVBQVUsR0FBVixDQUFwQyxFQUFBQyxDQUFBQSxTQUFBLEtBQUFBLENBQUEsRUFBUUMsQ0FBQUEsTUFBUixLQUFRQSxDQUFSLEVBQWFDLENBQUFBLHVCQUFiLEtBQWFBLENBQWI7TUFFQUMsTUFBQVgsSUFBQVcsU0FBQUEsRUFBQUEsQ0FBTSxPQUFOQSxDQUFBQSxFQUFBQyxhQUFBQSxFQUFBQztBQUFBQTs7O1FBQ0VILHVCQUF1QkksSUFBQUMsVUFBQUQsd0JBQXlCUixLQUFBQSxDQUFBQTtRQUVoREUsU0FBU1EsSUFBQUQsVUFBQUMsWUFBYVYsS0FBQUEsQ0FBS0QsTUFBbEIsRUFBMEIsNEJBQUEsa0JBQWdCTCxJQUFoQixF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QUksQ0FBQUEsU0FBQSw2QkFBQUEsQ0FBQSxFQUFRQyxDQUFBQSxNQUFSLDZCQUFRQSxDQUFSLEVBQWFDLENBQUFBLHVCQUFiLDZCQUFhQSxDQUFiLEVBQW1DK0IsQ0FBQUEsU0FBbkMsNkJBQW1DQSxDQUFuQztNQUVBRixPQUFBLENBQUEsUUFBR0UsTUFBTXZCLFNBQUFBLENBQUFBLENBQVQsQ0FBQSxHQUFBLENBQ0Usb0JBQUEsVUFDVXVCLE1BRFYsRUFERixJQUFBLENBS0UsMENBQUEsVUFDZ0JDLE1BQU5sQyxNQUFNa0MsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTSxXQUFEQyxTQUFBQSxDQUFBQSxDQUFMRCxDQURoQixFQUFBLFFBRVEsQ0FBQSxRQUFBakMsR0FBQSxDQUFBLEdBQUEsQ0FBTW1DLElBQUFDLGNBQUFELHFCQUEwQnRDLEtBQUFBLENBQUtHLEdBQUxILENBQVN3QyxPQUFBQSxDQUFBQSxDQUF6QyxJQUFBLENBQWtELEdBQWxELENBQUEsQ0FGUixFQUFBLGNBR2MsQ0FBQSxLQUFBcEMsb0JBQUEscUNBQUEsTUFBQSxFQUFBLGFBQUEsRUFBQSxFQUFBLENBQUEsQ0FIZCxFQUxGLENBQUEsQ0FVR3FDLFNBQUFBLENBQUFBO0lBYkxSLENBQUFBLEdBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBOURBdkM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NzgzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiKGV4aXQpIl0sInNvdXJjZXNDb250ZW50IjpbIjo6S2VybmVsLmV4aXRcbiJdLCJuYW1lcyI6WyI8bWFpbj4iLCJLZXJuZWwiLCJleGl0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMkJBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQyxPQUFRQyxNQUFBQSxDQUFBQTtBQUFSRjsifX1dfQ==
